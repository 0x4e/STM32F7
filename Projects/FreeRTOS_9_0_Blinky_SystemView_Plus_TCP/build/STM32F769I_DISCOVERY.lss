
build/STM32F769I_DISCOVERY.elf:     file format elf32-littlearm


Disassembly of section .text:

08000200 <__do_global_dtors_aux>:
 8000200:	b510      	push	{r4, lr}
 8000202:	4c05      	ldr	r4, [pc, #20]	; (8000218 <__do_global_dtors_aux+0x18>)
 8000204:	7823      	ldrb	r3, [r4, #0]
 8000206:	b933      	cbnz	r3, 8000216 <__do_global_dtors_aux+0x16>
 8000208:	4b04      	ldr	r3, [pc, #16]	; (800021c <__do_global_dtors_aux+0x1c>)
 800020a:	b113      	cbz	r3, 8000212 <__do_global_dtors_aux+0x12>
 800020c:	4804      	ldr	r0, [pc, #16]	; (8000220 <__do_global_dtors_aux+0x20>)
 800020e:	f3af 8000 	nop.w
 8000212:	2301      	movs	r3, #1
 8000214:	7023      	strb	r3, [r4, #0]
 8000216:	bd10      	pop	{r4, pc}
 8000218:	2000bb70 	.word	0x2000bb70
 800021c:	00000000 	.word	0x00000000
 8000220:	08012430 	.word	0x08012430

08000224 <frame_dummy>:
 8000224:	4b08      	ldr	r3, [pc, #32]	; (8000248 <frame_dummy+0x24>)
 8000226:	b510      	push	{r4, lr}
 8000228:	b11b      	cbz	r3, 8000232 <frame_dummy+0xe>
 800022a:	4808      	ldr	r0, [pc, #32]	; (800024c <frame_dummy+0x28>)
 800022c:	4908      	ldr	r1, [pc, #32]	; (8000250 <frame_dummy+0x2c>)
 800022e:	f3af 8000 	nop.w
 8000232:	4808      	ldr	r0, [pc, #32]	; (8000254 <frame_dummy+0x30>)
 8000234:	6803      	ldr	r3, [r0, #0]
 8000236:	b903      	cbnz	r3, 800023a <frame_dummy+0x16>
 8000238:	bd10      	pop	{r4, pc}
 800023a:	4b07      	ldr	r3, [pc, #28]	; (8000258 <frame_dummy+0x34>)
 800023c:	2b00      	cmp	r3, #0
 800023e:	d0fb      	beq.n	8000238 <frame_dummy+0x14>
 8000240:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8000244:	4718      	bx	r3
 8000246:	bf00      	nop
 8000248:	00000000 	.word	0x00000000
 800024c:	08012430 	.word	0x08012430
 8000250:	2000bb74 	.word	0x2000bb74
 8000254:	2000bb70 	.word	0x2000bb70
 8000258:	00000000 	.word	0x00000000

0800025c <__aeabi_uldivmod>:
 800025c:	b953      	cbnz	r3, 8000274 <__aeabi_uldivmod+0x18>
 800025e:	b94a      	cbnz	r2, 8000274 <__aeabi_uldivmod+0x18>
 8000260:	2900      	cmp	r1, #0
 8000262:	bf08      	it	eq
 8000264:	2800      	cmpeq	r0, #0
 8000266:	bf1c      	itt	ne
 8000268:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 800026c:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 8000270:	f000 b83c 	b.w	80002ec <__aeabi_idiv0>
 8000274:	b082      	sub	sp, #8
 8000276:	46ec      	mov	ip, sp
 8000278:	e92d 5000 	stmdb	sp!, {ip, lr}
 800027c:	f000 f81e 	bl	80002bc <__gnu_uldivmod_helper>
 8000280:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000284:	b002      	add	sp, #8
 8000286:	bc0c      	pop	{r2, r3}
 8000288:	4770      	bx	lr
 800028a:	bf00      	nop

0800028c <__gnu_ldivmod_helper>:
 800028c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000290:	4690      	mov	r8, r2
 8000292:	4606      	mov	r6, r0
 8000294:	460f      	mov	r7, r1
 8000296:	461d      	mov	r5, r3
 8000298:	9c06      	ldr	r4, [sp, #24]
 800029a:	f000 f829 	bl	80002f0 <__divdi3>
 800029e:	fb08 fc01 	mul.w	ip, r8, r1
 80002a2:	4686      	mov	lr, r0
 80002a4:	fba8 2300 	umull	r2, r3, r8, r0
 80002a8:	fb00 c505 	mla	r5, r0, r5, ip
 80002ac:	1ab2      	subs	r2, r6, r2
 80002ae:	442b      	add	r3, r5
 80002b0:	eb67 0303 	sbc.w	r3, r7, r3
 80002b4:	e9c4 2300 	strd	r2, r3, [r4]
 80002b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080002bc <__gnu_uldivmod_helper>:
 80002bc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80002c0:	461d      	mov	r5, r3
 80002c2:	4617      	mov	r7, r2
 80002c4:	4680      	mov	r8, r0
 80002c6:	4689      	mov	r9, r1
 80002c8:	9e08      	ldr	r6, [sp, #32]
 80002ca:	f000 f953 	bl	8000574 <__udivdi3>
 80002ce:	fb00 f305 	mul.w	r3, r0, r5
 80002d2:	fba0 4507 	umull	r4, r5, r0, r7
 80002d6:	fb07 3701 	mla	r7, r7, r1, r3
 80002da:	ebb8 0404 	subs.w	r4, r8, r4
 80002de:	443d      	add	r5, r7
 80002e0:	eb69 0505 	sbc.w	r5, r9, r5
 80002e4:	e9c6 4500 	strd	r4, r5, [r6]
 80002e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080002ec <__aeabi_idiv0>:
 80002ec:	4770      	bx	lr
 80002ee:	bf00      	nop

080002f0 <__divdi3>:
 80002f0:	2900      	cmp	r1, #0
 80002f2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002f6:	f2c0 80a2 	blt.w	800043e <__divdi3+0x14e>
 80002fa:	2600      	movs	r6, #0
 80002fc:	2b00      	cmp	r3, #0
 80002fe:	f2c0 8098 	blt.w	8000432 <__divdi3+0x142>
 8000302:	468c      	mov	ip, r1
 8000304:	4690      	mov	r8, r2
 8000306:	469e      	mov	lr, r3
 8000308:	4615      	mov	r5, r2
 800030a:	4604      	mov	r4, r0
 800030c:	460f      	mov	r7, r1
 800030e:	bbcb      	cbnz	r3, 8000384 <__divdi3+0x94>
 8000310:	428a      	cmp	r2, r1
 8000312:	d956      	bls.n	80003c2 <__divdi3+0xd2>
 8000314:	fab2 f382 	clz	r3, r2
 8000318:	b13b      	cbz	r3, 800032a <__divdi3+0x3a>
 800031a:	f1c3 0220 	rsb	r2, r3, #32
 800031e:	409f      	lsls	r7, r3
 8000320:	409d      	lsls	r5, r3
 8000322:	409c      	lsls	r4, r3
 8000324:	fa20 f202 	lsr.w	r2, r0, r2
 8000328:	4317      	orrs	r7, r2
 800032a:	0c28      	lsrs	r0, r5, #16
 800032c:	0c22      	lsrs	r2, r4, #16
 800032e:	fa1f fe85 	uxth.w	lr, r5
 8000332:	fbb7 f1f0 	udiv	r1, r7, r0
 8000336:	fb00 7711 	mls	r7, r0, r1, r7
 800033a:	fb0e f301 	mul.w	r3, lr, r1
 800033e:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 8000342:	42bb      	cmp	r3, r7
 8000344:	d907      	bls.n	8000356 <__divdi3+0x66>
 8000346:	197f      	adds	r7, r7, r5
 8000348:	f080 8101 	bcs.w	800054e <__divdi3+0x25e>
 800034c:	42bb      	cmp	r3, r7
 800034e:	f240 80fe 	bls.w	800054e <__divdi3+0x25e>
 8000352:	3902      	subs	r1, #2
 8000354:	442f      	add	r7, r5
 8000356:	1aff      	subs	r7, r7, r3
 8000358:	b2a4      	uxth	r4, r4
 800035a:	fbb7 f3f0 	udiv	r3, r7, r0
 800035e:	fb00 7713 	mls	r7, r0, r3, r7
 8000362:	fb0e fe03 	mul.w	lr, lr, r3
 8000366:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 800036a:	45be      	cmp	lr, r7
 800036c:	d906      	bls.n	800037c <__divdi3+0x8c>
 800036e:	197f      	adds	r7, r7, r5
 8000370:	f080 80eb 	bcs.w	800054a <__divdi3+0x25a>
 8000374:	45be      	cmp	lr, r7
 8000376:	f240 80e8 	bls.w	800054a <__divdi3+0x25a>
 800037a:	3b02      	subs	r3, #2
 800037c:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 8000380:	2200      	movs	r2, #0
 8000382:	e003      	b.n	800038c <__divdi3+0x9c>
 8000384:	428b      	cmp	r3, r1
 8000386:	d90f      	bls.n	80003a8 <__divdi3+0xb8>
 8000388:	2200      	movs	r2, #0
 800038a:	4613      	mov	r3, r2
 800038c:	1c34      	adds	r4, r6, #0
 800038e:	f04f 0500 	mov.w	r5, #0
 8000392:	bf18      	it	ne
 8000394:	2401      	movne	r4, #1
 8000396:	4260      	negs	r0, r4
 8000398:	eb65 0145 	sbc.w	r1, r5, r5, lsl #1
 800039c:	4058      	eors	r0, r3
 800039e:	4051      	eors	r1, r2
 80003a0:	1900      	adds	r0, r0, r4
 80003a2:	4169      	adcs	r1, r5
 80003a4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80003a8:	fab3 f283 	clz	r2, r3
 80003ac:	2a00      	cmp	r2, #0
 80003ae:	f040 8083 	bne.w	80004b8 <__divdi3+0x1c8>
 80003b2:	4580      	cmp	r8, r0
 80003b4:	f240 80cd 	bls.w	8000552 <__divdi3+0x262>
 80003b8:	428b      	cmp	r3, r1
 80003ba:	f0c0 80ca 	bcc.w	8000552 <__divdi3+0x262>
 80003be:	4613      	mov	r3, r2
 80003c0:	e7e4      	b.n	800038c <__divdi3+0x9c>
 80003c2:	b912      	cbnz	r2, 80003ca <__divdi3+0xda>
 80003c4:	2301      	movs	r3, #1
 80003c6:	fbb3 f5f2 	udiv	r5, r3, r2
 80003ca:	fab5 f285 	clz	r2, r5
 80003ce:	2a00      	cmp	r2, #0
 80003d0:	d13b      	bne.n	800044a <__divdi3+0x15a>
 80003d2:	1b78      	subs	r0, r7, r5
 80003d4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80003d8:	fa1f fc85 	uxth.w	ip, r5
 80003dc:	2201      	movs	r2, #1
 80003de:	0c21      	lsrs	r1, r4, #16
 80003e0:	fbb0 f8fe 	udiv	r8, r0, lr
 80003e4:	fb0e 0018 	mls	r0, lr, r8, r0
 80003e8:	fb0c f308 	mul.w	r3, ip, r8
 80003ec:	ea41 4700 	orr.w	r7, r1, r0, lsl #16
 80003f0:	42bb      	cmp	r3, r7
 80003f2:	d908      	bls.n	8000406 <__divdi3+0x116>
 80003f4:	197f      	adds	r7, r7, r5
 80003f6:	f080 80b0 	bcs.w	800055a <__divdi3+0x26a>
 80003fa:	42bb      	cmp	r3, r7
 80003fc:	f240 80ad 	bls.w	800055a <__divdi3+0x26a>
 8000400:	f1a8 0802 	sub.w	r8, r8, #2
 8000404:	442f      	add	r7, r5
 8000406:	1aff      	subs	r7, r7, r3
 8000408:	b2a4      	uxth	r4, r4
 800040a:	fbb7 f3fe 	udiv	r3, r7, lr
 800040e:	fb0e 7713 	mls	r7, lr, r3, r7
 8000412:	fb0c fc03 	mul.w	ip, ip, r3
 8000416:	ea44 4707 	orr.w	r7, r4, r7, lsl #16
 800041a:	45bc      	cmp	ip, r7
 800041c:	d906      	bls.n	800042c <__divdi3+0x13c>
 800041e:	197f      	adds	r7, r7, r5
 8000420:	f080 8099 	bcs.w	8000556 <__divdi3+0x266>
 8000424:	45bc      	cmp	ip, r7
 8000426:	f240 8096 	bls.w	8000556 <__divdi3+0x266>
 800042a:	3b02      	subs	r3, #2
 800042c:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000430:	e7ac      	b.n	800038c <__divdi3+0x9c>
 8000432:	4252      	negs	r2, r2
 8000434:	ea6f 0606 	mvn.w	r6, r6
 8000438:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800043c:	e761      	b.n	8000302 <__divdi3+0x12>
 800043e:	4240      	negs	r0, r0
 8000440:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
 8000444:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000448:	e758      	b.n	80002fc <__divdi3+0xc>
 800044a:	4095      	lsls	r5, r2
 800044c:	f1c2 0120 	rsb	r1, r2, #32
 8000450:	fa07 f302 	lsl.w	r3, r7, r2
 8000454:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000458:	40cf      	lsrs	r7, r1
 800045a:	fa24 f101 	lsr.w	r1, r4, r1
 800045e:	4094      	lsls	r4, r2
 8000460:	fa1f fc85 	uxth.w	ip, r5
 8000464:	4319      	orrs	r1, r3
 8000466:	fbb7 f2fe 	udiv	r2, r7, lr
 800046a:	ea4f 4811 	mov.w	r8, r1, lsr #16
 800046e:	fb0e 7712 	mls	r7, lr, r2, r7
 8000472:	fb0c f302 	mul.w	r3, ip, r2
 8000476:	ea48 4707 	orr.w	r7, r8, r7, lsl #16
 800047a:	42bb      	cmp	r3, r7
 800047c:	d905      	bls.n	800048a <__divdi3+0x19a>
 800047e:	197f      	adds	r7, r7, r5
 8000480:	d271      	bcs.n	8000566 <__divdi3+0x276>
 8000482:	42bb      	cmp	r3, r7
 8000484:	d96f      	bls.n	8000566 <__divdi3+0x276>
 8000486:	3a02      	subs	r2, #2
 8000488:	442f      	add	r7, r5
 800048a:	1aff      	subs	r7, r7, r3
 800048c:	b289      	uxth	r1, r1
 800048e:	fbb7 f8fe 	udiv	r8, r7, lr
 8000492:	fb0e 7718 	mls	r7, lr, r8, r7
 8000496:	fb0c f008 	mul.w	r0, ip, r8
 800049a:	ea41 4307 	orr.w	r3, r1, r7, lsl #16
 800049e:	4298      	cmp	r0, r3
 80004a0:	d906      	bls.n	80004b0 <__divdi3+0x1c0>
 80004a2:	195b      	adds	r3, r3, r5
 80004a4:	d261      	bcs.n	800056a <__divdi3+0x27a>
 80004a6:	4298      	cmp	r0, r3
 80004a8:	d95f      	bls.n	800056a <__divdi3+0x27a>
 80004aa:	f1a8 0802 	sub.w	r8, r8, #2
 80004ae:	442b      	add	r3, r5
 80004b0:	1a18      	subs	r0, r3, r0
 80004b2:	ea48 4202 	orr.w	r2, r8, r2, lsl #16
 80004b6:	e792      	b.n	80003de <__divdi3+0xee>
 80004b8:	f1c2 0720 	rsb	r7, r2, #32
 80004bc:	fa03 fe02 	lsl.w	lr, r3, r2
 80004c0:	fa08 f502 	lsl.w	r5, r8, r2
 80004c4:	4091      	lsls	r1, r2
 80004c6:	fa28 f307 	lsr.w	r3, r8, r7
 80004ca:	fa2c fc07 	lsr.w	ip, ip, r7
 80004ce:	40f8      	lsrs	r0, r7
 80004d0:	ea43 0e0e 	orr.w	lr, r3, lr
 80004d4:	4308      	orrs	r0, r1
 80004d6:	ea4f 481e 	mov.w	r8, lr, lsr #16
 80004da:	0c07      	lsrs	r7, r0, #16
 80004dc:	fa1f fa8e 	uxth.w	sl, lr
 80004e0:	fbbc f9f8 	udiv	r9, ip, r8
 80004e4:	fb08 cc19 	mls	ip, r8, r9, ip
 80004e8:	fb0a f109 	mul.w	r1, sl, r9
 80004ec:	ea47 4c0c 	orr.w	ip, r7, ip, lsl #16
 80004f0:	4561      	cmp	r1, ip
 80004f2:	d907      	bls.n	8000504 <__divdi3+0x214>
 80004f4:	eb1c 0c0e 	adds.w	ip, ip, lr
 80004f8:	d232      	bcs.n	8000560 <__divdi3+0x270>
 80004fa:	4561      	cmp	r1, ip
 80004fc:	d930      	bls.n	8000560 <__divdi3+0x270>
 80004fe:	f1a9 0902 	sub.w	r9, r9, #2
 8000502:	44f4      	add	ip, lr
 8000504:	ebc1 0c0c 	rsb	ip, r1, ip
 8000508:	b280      	uxth	r0, r0
 800050a:	fbbc f3f8 	udiv	r3, ip, r8
 800050e:	fb08 cc13 	mls	ip, r8, r3, ip
 8000512:	fb0a fa03 	mul.w	sl, sl, r3
 8000516:	ea40 410c 	orr.w	r1, r0, ip, lsl #16
 800051a:	458a      	cmp	sl, r1
 800051c:	d906      	bls.n	800052c <__divdi3+0x23c>
 800051e:	eb11 010e 	adds.w	r1, r1, lr
 8000522:	d225      	bcs.n	8000570 <__divdi3+0x280>
 8000524:	458a      	cmp	sl, r1
 8000526:	d923      	bls.n	8000570 <__divdi3+0x280>
 8000528:	3b02      	subs	r3, #2
 800052a:	4471      	add	r1, lr
 800052c:	ea43 4309 	orr.w	r3, r3, r9, lsl #16
 8000530:	ebca 0101 	rsb	r1, sl, r1
 8000534:	fba3 8905 	umull	r8, r9, r3, r5
 8000538:	4549      	cmp	r1, r9
 800053a:	d303      	bcc.n	8000544 <__divdi3+0x254>
 800053c:	d103      	bne.n	8000546 <__divdi3+0x256>
 800053e:	4094      	lsls	r4, r2
 8000540:	4544      	cmp	r4, r8
 8000542:	d200      	bcs.n	8000546 <__divdi3+0x256>
 8000544:	3b01      	subs	r3, #1
 8000546:	2200      	movs	r2, #0
 8000548:	e720      	b.n	800038c <__divdi3+0x9c>
 800054a:	3b01      	subs	r3, #1
 800054c:	e716      	b.n	800037c <__divdi3+0x8c>
 800054e:	3901      	subs	r1, #1
 8000550:	e701      	b.n	8000356 <__divdi3+0x66>
 8000552:	2301      	movs	r3, #1
 8000554:	e71a      	b.n	800038c <__divdi3+0x9c>
 8000556:	3b01      	subs	r3, #1
 8000558:	e768      	b.n	800042c <__divdi3+0x13c>
 800055a:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 800055e:	e752      	b.n	8000406 <__divdi3+0x116>
 8000560:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
 8000564:	e7ce      	b.n	8000504 <__divdi3+0x214>
 8000566:	3a01      	subs	r2, #1
 8000568:	e78f      	b.n	800048a <__divdi3+0x19a>
 800056a:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 800056e:	e79f      	b.n	80004b0 <__divdi3+0x1c0>
 8000570:	3b01      	subs	r3, #1
 8000572:	e7db      	b.n	800052c <__divdi3+0x23c>

08000574 <__udivdi3>:
 8000574:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000578:	2b00      	cmp	r3, #0
 800057a:	d140      	bne.n	80005fe <__udivdi3+0x8a>
 800057c:	428a      	cmp	r2, r1
 800057e:	4604      	mov	r4, r0
 8000580:	4615      	mov	r5, r2
 8000582:	d94a      	bls.n	800061a <__udivdi3+0xa6>
 8000584:	fab2 f382 	clz	r3, r2
 8000588:	460f      	mov	r7, r1
 800058a:	b14b      	cbz	r3, 80005a0 <__udivdi3+0x2c>
 800058c:	f1c3 0620 	rsb	r6, r3, #32
 8000590:	4099      	lsls	r1, r3
 8000592:	fa00 f403 	lsl.w	r4, r0, r3
 8000596:	fa02 f503 	lsl.w	r5, r2, r3
 800059a:	40f0      	lsrs	r0, r6
 800059c:	ea40 0701 	orr.w	r7, r0, r1
 80005a0:	0c29      	lsrs	r1, r5, #16
 80005a2:	0c26      	lsrs	r6, r4, #16
 80005a4:	fa1f fe85 	uxth.w	lr, r5
 80005a8:	fbb7 f0f1 	udiv	r0, r7, r1
 80005ac:	fb01 7710 	mls	r7, r1, r0, r7
 80005b0:	fb0e f200 	mul.w	r2, lr, r0
 80005b4:	ea46 4307 	orr.w	r3, r6, r7, lsl #16
 80005b8:	429a      	cmp	r2, r3
 80005ba:	d907      	bls.n	80005cc <__udivdi3+0x58>
 80005bc:	195b      	adds	r3, r3, r5
 80005be:	f080 80ea 	bcs.w	8000796 <__udivdi3+0x222>
 80005c2:	429a      	cmp	r2, r3
 80005c4:	f240 80e7 	bls.w	8000796 <__udivdi3+0x222>
 80005c8:	3802      	subs	r0, #2
 80005ca:	442b      	add	r3, r5
 80005cc:	1a9a      	subs	r2, r3, r2
 80005ce:	b2a4      	uxth	r4, r4
 80005d0:	fbb2 f3f1 	udiv	r3, r2, r1
 80005d4:	fb01 2213 	mls	r2, r1, r3, r2
 80005d8:	fb0e fe03 	mul.w	lr, lr, r3
 80005dc:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
 80005e0:	4596      	cmp	lr, r2
 80005e2:	d906      	bls.n	80005f2 <__udivdi3+0x7e>
 80005e4:	1952      	adds	r2, r2, r5
 80005e6:	f080 80da 	bcs.w	800079e <__udivdi3+0x22a>
 80005ea:	4596      	cmp	lr, r2
 80005ec:	f240 80d7 	bls.w	800079e <__udivdi3+0x22a>
 80005f0:	3b02      	subs	r3, #2
 80005f2:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80005f6:	2600      	movs	r6, #0
 80005f8:	4631      	mov	r1, r6
 80005fa:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80005fe:	428b      	cmp	r3, r1
 8000600:	d844      	bhi.n	800068c <__udivdi3+0x118>
 8000602:	fab3 f683 	clz	r6, r3
 8000606:	2e00      	cmp	r6, #0
 8000608:	d145      	bne.n	8000696 <__udivdi3+0x122>
 800060a:	4282      	cmp	r2, r0
 800060c:	f240 80bf 	bls.w	800078e <__udivdi3+0x21a>
 8000610:	428b      	cmp	r3, r1
 8000612:	f0c0 80bc 	bcc.w	800078e <__udivdi3+0x21a>
 8000616:	4630      	mov	r0, r6
 8000618:	e7ee      	b.n	80005f8 <__udivdi3+0x84>
 800061a:	b912      	cbnz	r2, 8000622 <__udivdi3+0xae>
 800061c:	2501      	movs	r5, #1
 800061e:	fbb5 f5f2 	udiv	r5, r5, r2
 8000622:	fab5 f285 	clz	r2, r5
 8000626:	2a00      	cmp	r2, #0
 8000628:	d17b      	bne.n	8000722 <__udivdi3+0x1ae>
 800062a:	1b4a      	subs	r2, r1, r5
 800062c:	0c2f      	lsrs	r7, r5, #16
 800062e:	fa1f fe85 	uxth.w	lr, r5
 8000632:	2601      	movs	r6, #1
 8000634:	0c23      	lsrs	r3, r4, #16
 8000636:	fbb2 f0f7 	udiv	r0, r2, r7
 800063a:	fb07 2210 	mls	r2, r7, r0, r2
 800063e:	fb0e fc00 	mul.w	ip, lr, r0
 8000642:	ea43 4102 	orr.w	r1, r3, r2, lsl #16
 8000646:	458c      	cmp	ip, r1
 8000648:	d907      	bls.n	800065a <__udivdi3+0xe6>
 800064a:	1949      	adds	r1, r1, r5
 800064c:	f080 80a1 	bcs.w	8000792 <__udivdi3+0x21e>
 8000650:	458c      	cmp	ip, r1
 8000652:	f240 809e 	bls.w	8000792 <__udivdi3+0x21e>
 8000656:	3802      	subs	r0, #2
 8000658:	4429      	add	r1, r5
 800065a:	ebcc 0101 	rsb	r1, ip, r1
 800065e:	b2a4      	uxth	r4, r4
 8000660:	fbb1 f3f7 	udiv	r3, r1, r7
 8000664:	fb07 1113 	mls	r1, r7, r3, r1
 8000668:	fb0e fe03 	mul.w	lr, lr, r3
 800066c:	ea44 4401 	orr.w	r4, r4, r1, lsl #16
 8000670:	45a6      	cmp	lr, r4
 8000672:	d906      	bls.n	8000682 <__udivdi3+0x10e>
 8000674:	1964      	adds	r4, r4, r5
 8000676:	f080 8090 	bcs.w	800079a <__udivdi3+0x226>
 800067a:	45a6      	cmp	lr, r4
 800067c:	f240 808d 	bls.w	800079a <__udivdi3+0x226>
 8000680:	3b02      	subs	r3, #2
 8000682:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 8000686:	4631      	mov	r1, r6
 8000688:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800068c:	2600      	movs	r6, #0
 800068e:	4630      	mov	r0, r6
 8000690:	4631      	mov	r1, r6
 8000692:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000696:	f1c6 0520 	rsb	r5, r6, #32
 800069a:	40b3      	lsls	r3, r6
 800069c:	fa02 f706 	lsl.w	r7, r2, r6
 80006a0:	fa01 f406 	lsl.w	r4, r1, r6
 80006a4:	40ea      	lsrs	r2, r5
 80006a6:	40e9      	lsrs	r1, r5
 80006a8:	fa20 f505 	lsr.w	r5, r0, r5
 80006ac:	431a      	orrs	r2, r3
 80006ae:	4325      	orrs	r5, r4
 80006b0:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 80006b4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80006b8:	b293      	uxth	r3, r2
 80006ba:	fbb1 f8fc 	udiv	r8, r1, ip
 80006be:	fb0c 1118 	mls	r1, ip, r8, r1
 80006c2:	fb03 f408 	mul.w	r4, r3, r8
 80006c6:	ea4e 4101 	orr.w	r1, lr, r1, lsl #16
 80006ca:	428c      	cmp	r4, r1
 80006cc:	d906      	bls.n	80006dc <__udivdi3+0x168>
 80006ce:	1889      	adds	r1, r1, r2
 80006d0:	d269      	bcs.n	80007a6 <__udivdi3+0x232>
 80006d2:	428c      	cmp	r4, r1
 80006d4:	d967      	bls.n	80007a6 <__udivdi3+0x232>
 80006d6:	f1a8 0802 	sub.w	r8, r8, #2
 80006da:	4411      	add	r1, r2
 80006dc:	1b09      	subs	r1, r1, r4
 80006de:	b2ad      	uxth	r5, r5
 80006e0:	fbb1 f4fc 	udiv	r4, r1, ip
 80006e4:	fb0c 1114 	mls	r1, ip, r4, r1
 80006e8:	fb03 fe04 	mul.w	lr, r3, r4
 80006ec:	ea45 4301 	orr.w	r3, r5, r1, lsl #16
 80006f0:	459e      	cmp	lr, r3
 80006f2:	d905      	bls.n	8000700 <__udivdi3+0x18c>
 80006f4:	189b      	adds	r3, r3, r2
 80006f6:	d254      	bcs.n	80007a2 <__udivdi3+0x22e>
 80006f8:	459e      	cmp	lr, r3
 80006fa:	d952      	bls.n	80007a2 <__udivdi3+0x22e>
 80006fc:	3c02      	subs	r4, #2
 80006fe:	4413      	add	r3, r2
 8000700:	ea44 4408 	orr.w	r4, r4, r8, lsl #16
 8000704:	ebce 0303 	rsb	r3, lr, r3
 8000708:	fba4 8907 	umull	r8, r9, r4, r7
 800070c:	454b      	cmp	r3, r9
 800070e:	d303      	bcc.n	8000718 <__udivdi3+0x1a4>
 8000710:	d151      	bne.n	80007b6 <__udivdi3+0x242>
 8000712:	40b0      	lsls	r0, r6
 8000714:	4540      	cmp	r0, r8
 8000716:	d24e      	bcs.n	80007b6 <__udivdi3+0x242>
 8000718:	2600      	movs	r6, #0
 800071a:	1e60      	subs	r0, r4, #1
 800071c:	4631      	mov	r1, r6
 800071e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000722:	f1c2 0620 	rsb	r6, r2, #32
 8000726:	4095      	lsls	r5, r2
 8000728:	fa01 f302 	lsl.w	r3, r1, r2
 800072c:	fa00 f402 	lsl.w	r4, r0, r2
 8000730:	0c2f      	lsrs	r7, r5, #16
 8000732:	40f1      	lsrs	r1, r6
 8000734:	40f0      	lsrs	r0, r6
 8000736:	fa1f fe85 	uxth.w	lr, r5
 800073a:	fbb1 f6f7 	udiv	r6, r1, r7
 800073e:	4318      	orrs	r0, r3
 8000740:	fb07 1116 	mls	r1, r7, r6, r1
 8000744:	fb0e f206 	mul.w	r2, lr, r6
 8000748:	ea4f 4c10 	mov.w	ip, r0, lsr #16
 800074c:	ea4c 4301 	orr.w	r3, ip, r1, lsl #16
 8000750:	429a      	cmp	r2, r3
 8000752:	d905      	bls.n	8000760 <__udivdi3+0x1ec>
 8000754:	195b      	adds	r3, r3, r5
 8000756:	d229      	bcs.n	80007ac <__udivdi3+0x238>
 8000758:	429a      	cmp	r2, r3
 800075a:	d927      	bls.n	80007ac <__udivdi3+0x238>
 800075c:	3e02      	subs	r6, #2
 800075e:	442b      	add	r3, r5
 8000760:	1a9b      	subs	r3, r3, r2
 8000762:	b280      	uxth	r0, r0
 8000764:	fbb3 fcf7 	udiv	ip, r3, r7
 8000768:	fb07 331c 	mls	r3, r7, ip, r3
 800076c:	fb0e f10c 	mul.w	r1, lr, ip
 8000770:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 8000774:	4299      	cmp	r1, r3
 8000776:	d906      	bls.n	8000786 <__udivdi3+0x212>
 8000778:	195b      	adds	r3, r3, r5
 800077a:	d219      	bcs.n	80007b0 <__udivdi3+0x23c>
 800077c:	4299      	cmp	r1, r3
 800077e:	d917      	bls.n	80007b0 <__udivdi3+0x23c>
 8000780:	f1ac 0c02 	sub.w	ip, ip, #2
 8000784:	442b      	add	r3, r5
 8000786:	1a5a      	subs	r2, r3, r1
 8000788:	ea4c 4606 	orr.w	r6, ip, r6, lsl #16
 800078c:	e752      	b.n	8000634 <__udivdi3+0xc0>
 800078e:	2001      	movs	r0, #1
 8000790:	e732      	b.n	80005f8 <__udivdi3+0x84>
 8000792:	3801      	subs	r0, #1
 8000794:	e761      	b.n	800065a <__udivdi3+0xe6>
 8000796:	3801      	subs	r0, #1
 8000798:	e718      	b.n	80005cc <__udivdi3+0x58>
 800079a:	3b01      	subs	r3, #1
 800079c:	e771      	b.n	8000682 <__udivdi3+0x10e>
 800079e:	3b01      	subs	r3, #1
 80007a0:	e727      	b.n	80005f2 <__udivdi3+0x7e>
 80007a2:	3c01      	subs	r4, #1
 80007a4:	e7ac      	b.n	8000700 <__udivdi3+0x18c>
 80007a6:	f108 38ff 	add.w	r8, r8, #4294967295	; 0xffffffff
 80007aa:	e797      	b.n	80006dc <__udivdi3+0x168>
 80007ac:	3e01      	subs	r6, #1
 80007ae:	e7d7      	b.n	8000760 <__udivdi3+0x1ec>
 80007b0:	f10c 3cff 	add.w	ip, ip, #4294967295	; 0xffffffff
 80007b4:	e7e7      	b.n	8000786 <__udivdi3+0x212>
 80007b6:	4620      	mov	r0, r4
 80007b8:	2600      	movs	r6, #0
 80007ba:	e71d      	b.n	80005f8 <__udivdi3+0x84>

080007bc <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 80007bc:	b580      	push	{r7, lr}
 80007be:	af00      	add	r7, sp, #0
  /* Configure Flash prefetch and Instruction cache through ART accelerator */ 
#if (ART_ACCLERATOR_ENABLE != 0)
   __HAL_FLASH_ART_ENABLE();
 80007c0:	4a08      	ldr	r2, [pc, #32]	; (80007e4 <HAL_Init+0x28>)
 80007c2:	4b08      	ldr	r3, [pc, #32]	; (80007e4 <HAL_Init+0x28>)
 80007c4:	681b      	ldr	r3, [r3, #0]
 80007c6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80007ca:	6013      	str	r3, [r2, #0]
#endif /* ART_ACCLERATOR_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80007cc:	2003      	movs	r0, #3
 80007ce:	f000 f903 	bl	80009d8 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80007d2:	2000      	movs	r0, #0
 80007d4:	f00f ff38 	bl	8010648 <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 80007d8:	f00f fec4 	bl	8010564 <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
 80007dc:	2300      	movs	r3, #0
}
 80007de:	4618      	mov	r0, r3
 80007e0:	bd80      	pop	{r7, pc}
 80007e2:	bf00      	nop
 80007e4:	40023c00 	.word	0x40023c00

080007e8 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other 
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 80007e8:	b480      	push	{r7}
 80007ea:	af00      	add	r7, sp, #0
  uwTick++;
 80007ec:	4b04      	ldr	r3, [pc, #16]	; (8000800 <HAL_IncTick+0x18>)
 80007ee:	681b      	ldr	r3, [r3, #0]
 80007f0:	3301      	adds	r3, #1
 80007f2:	4a03      	ldr	r2, [pc, #12]	; (8000800 <HAL_IncTick+0x18>)
 80007f4:	6013      	str	r3, [r2, #0]
}
 80007f6:	46bd      	mov	sp, r7
 80007f8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80007fc:	4770      	bx	lr
 80007fe:	bf00      	nop
 8000800:	2000cecc 	.word	0x2000cecc

08000804 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other 
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8000804:	b480      	push	{r7}
 8000806:	af00      	add	r7, sp, #0
  return uwTick;
 8000808:	4b03      	ldr	r3, [pc, #12]	; (8000818 <HAL_GetTick+0x14>)
 800080a:	681b      	ldr	r3, [r3, #0]
}
 800080c:	4618      	mov	r0, r3
 800080e:	46bd      	mov	sp, r7
 8000810:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000814:	4770      	bx	lr
 8000816:	bf00      	nop
 8000818:	2000cecc 	.word	0x2000cecc

0800081c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 800081c:	b580      	push	{r7, lr}
 800081e:	b084      	sub	sp, #16
 8000820:	af00      	add	r7, sp, #0
 8000822:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;
 8000824:	2300      	movs	r3, #0
 8000826:	60fb      	str	r3, [r7, #12]
  tickstart = HAL_GetTick();
 8000828:	f7ff ffec 	bl	8000804 <HAL_GetTick>
 800082c:	60f8      	str	r0, [r7, #12]
  while((HAL_GetTick() - tickstart) < Delay)
 800082e:	bf00      	nop
 8000830:	f7ff ffe8 	bl	8000804 <HAL_GetTick>
 8000834:	4602      	mov	r2, r0
 8000836:	68fb      	ldr	r3, [r7, #12]
 8000838:	1ad2      	subs	r2, r2, r3
 800083a:	687b      	ldr	r3, [r7, #4]
 800083c:	429a      	cmp	r2, r3
 800083e:	d3f7      	bcc.n	8000830 <HAL_Delay+0x14>
  {
  }
}
 8000840:	3710      	adds	r7, #16
 8000842:	46bd      	mov	sp, r7
 8000844:	bd80      	pop	{r7, pc}
 8000846:	bf00      	nop

08000848 <NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8000848:	b480      	push	{r7}
 800084a:	b085      	sub	sp, #20
 800084c:	af00      	add	r7, sp, #0
 800084e:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8000850:	687b      	ldr	r3, [r7, #4]
 8000852:	f003 0307 	and.w	r3, r3, #7
 8000856:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000858:	4b0b      	ldr	r3, [pc, #44]	; (8000888 <NVIC_SetPriorityGrouping+0x40>)
 800085a:	68db      	ldr	r3, [r3, #12]
 800085c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800085e:	68ba      	ldr	r2, [r7, #8]
 8000860:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8000864:	4013      	ands	r3, r2
 8000866:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8000868:	68fb      	ldr	r3, [r7, #12]
 800086a:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 800086c:	68bb      	ldr	r3, [r7, #8]
 800086e:	431a      	orrs	r2, r3
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000870:	4b06      	ldr	r3, [pc, #24]	; (800088c <NVIC_SetPriorityGrouping+0x44>)
 8000872:	4313      	orrs	r3, r2
 8000874:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000876:	4a04      	ldr	r2, [pc, #16]	; (8000888 <NVIC_SetPriorityGrouping+0x40>)
 8000878:	68bb      	ldr	r3, [r7, #8]
 800087a:	60d3      	str	r3, [r2, #12]
}
 800087c:	3714      	adds	r7, #20
 800087e:	46bd      	mov	sp, r7
 8000880:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000884:	4770      	bx	lr
 8000886:	bf00      	nop
 8000888:	e000ed00 	.word	0xe000ed00
 800088c:	05fa0000 	.word	0x05fa0000

08000890 <NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
 8000890:	b480      	push	{r7}
 8000892:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000894:	4b04      	ldr	r3, [pc, #16]	; (80008a8 <NVIC_GetPriorityGrouping+0x18>)
 8000896:	68db      	ldr	r3, [r3, #12]
 8000898:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 800089c:	0a1b      	lsrs	r3, r3, #8
}
 800089e:	4618      	mov	r0, r3
 80008a0:	46bd      	mov	sp, r7
 80008a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008a6:	4770      	bx	lr
 80008a8:	e000ed00 	.word	0xe000ed00

080008ac <NVIC_EnableIRQ>:
  \brief   Enable External Interrupt
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80008ac:	b480      	push	{r7}
 80008ae:	b083      	sub	sp, #12
 80008b0:	af00      	add	r7, sp, #0
 80008b2:	4603      	mov	r3, r0
 80008b4:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80008b6:	4908      	ldr	r1, [pc, #32]	; (80008d8 <NVIC_EnableIRQ+0x2c>)
 80008b8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80008bc:	095b      	lsrs	r3, r3, #5
 80008be:	79fa      	ldrb	r2, [r7, #7]
 80008c0:	f002 021f 	and.w	r2, r2, #31
 80008c4:	2001      	movs	r0, #1
 80008c6:	fa00 f202 	lsl.w	r2, r0, r2
 80008ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80008ce:	370c      	adds	r7, #12
 80008d0:	46bd      	mov	sp, r7
 80008d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80008d6:	4770      	bx	lr
 80008d8:	e000e100 	.word	0xe000e100

080008dc <NVIC_SetPriority>:
  \note    The priority cannot be set for every core interrupt.
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80008dc:	b480      	push	{r7}
 80008de:	b083      	sub	sp, #12
 80008e0:	af00      	add	r7, sp, #0
 80008e2:	4603      	mov	r3, r0
 80008e4:	6039      	str	r1, [r7, #0]
 80008e6:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) < 0)
 80008e8:	f997 3007 	ldrsb.w	r3, [r7, #7]
 80008ec:	2b00      	cmp	r3, #0
 80008ee:	da0b      	bge.n	8000908 <NVIC_SetPriority+0x2c>
  {
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80008f0:	490d      	ldr	r1, [pc, #52]	; (8000928 <NVIC_SetPriority+0x4c>)
 80008f2:	79fb      	ldrb	r3, [r7, #7]
 80008f4:	f003 030f 	and.w	r3, r3, #15
 80008f8:	3b04      	subs	r3, #4
 80008fa:	683a      	ldr	r2, [r7, #0]
 80008fc:	b2d2      	uxtb	r2, r2
 80008fe:	0112      	lsls	r2, r2, #4
 8000900:	b2d2      	uxtb	r2, r2
 8000902:	440b      	add	r3, r1
 8000904:	761a      	strb	r2, [r3, #24]
 8000906:	e009      	b.n	800091c <NVIC_SetPriority+0x40>
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000908:	4908      	ldr	r1, [pc, #32]	; (800092c <NVIC_SetPriority+0x50>)
 800090a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800090e:	683a      	ldr	r2, [r7, #0]
 8000910:	b2d2      	uxtb	r2, r2
 8000912:	0112      	lsls	r2, r2, #4
 8000914:	b2d2      	uxtb	r2, r2
 8000916:	440b      	add	r3, r1
 8000918:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 800091c:	370c      	adds	r7, #12
 800091e:	46bd      	mov	sp, r7
 8000920:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000924:	4770      	bx	lr
 8000926:	bf00      	nop
 8000928:	e000ed00 	.word	0xe000ed00
 800092c:	e000e100 	.word	0xe000e100

08000930 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000930:	b480      	push	{r7}
 8000932:	b089      	sub	sp, #36	; 0x24
 8000934:	af00      	add	r7, sp, #0
 8000936:	60f8      	str	r0, [r7, #12]
 8000938:	60b9      	str	r1, [r7, #8]
 800093a:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 800093c:	68fb      	ldr	r3, [r7, #12]
 800093e:	f003 0307 	and.w	r3, r3, #7
 8000942:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000944:	69fb      	ldr	r3, [r7, #28]
 8000946:	f1c3 0307 	rsb	r3, r3, #7
 800094a:	2b04      	cmp	r3, #4
 800094c:	bf28      	it	cs
 800094e:	2304      	movcs	r3, #4
 8000950:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000952:	69fb      	ldr	r3, [r7, #28]
 8000954:	3304      	adds	r3, #4
 8000956:	2b06      	cmp	r3, #6
 8000958:	d902      	bls.n	8000960 <NVIC_EncodePriority+0x30>
 800095a:	69fb      	ldr	r3, [r7, #28]
 800095c:	3b03      	subs	r3, #3
 800095e:	e000      	b.n	8000962 <NVIC_EncodePriority+0x32>
 8000960:	2300      	movs	r3, #0
 8000962:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000964:	69bb      	ldr	r3, [r7, #24]
 8000966:	2201      	movs	r2, #1
 8000968:	fa02 f303 	lsl.w	r3, r2, r3
 800096c:	1e5a      	subs	r2, r3, #1
 800096e:	68bb      	ldr	r3, [r7, #8]
 8000970:	401a      	ands	r2, r3
 8000972:	697b      	ldr	r3, [r7, #20]
 8000974:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000976:	697b      	ldr	r3, [r7, #20]
 8000978:	2101      	movs	r1, #1
 800097a:	fa01 f303 	lsl.w	r3, r1, r3
 800097e:	1e59      	subs	r1, r3, #1
 8000980:	687b      	ldr	r3, [r7, #4]
 8000982:	400b      	ands	r3, r1
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8000984:	4313      	orrs	r3, r2
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
}
 8000986:	4618      	mov	r0, r3
 8000988:	3724      	adds	r7, #36	; 0x24
 800098a:	46bd      	mov	sp, r7
 800098c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000990:	4770      	bx	lr
 8000992:	bf00      	nop

08000994 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8000994:	b580      	push	{r7, lr}
 8000996:	b082      	sub	sp, #8
 8000998:	af00      	add	r7, sp, #0
 800099a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 800099c:	687b      	ldr	r3, [r7, #4]
 800099e:	3b01      	subs	r3, #1
 80009a0:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 80009a4:	d301      	bcc.n	80009aa <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 80009a6:	2301      	movs	r3, #1
 80009a8:	e00f      	b.n	80009ca <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80009aa:	4a0a      	ldr	r2, [pc, #40]	; (80009d4 <SysTick_Config+0x40>)
 80009ac:	687b      	ldr	r3, [r7, #4]
 80009ae:	3b01      	subs	r3, #1
 80009b0:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 80009b2:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80009b6:	210f      	movs	r1, #15
 80009b8:	f7ff ff90 	bl	80008dc <NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80009bc:	4b05      	ldr	r3, [pc, #20]	; (80009d4 <SysTick_Config+0x40>)
 80009be:	2200      	movs	r2, #0
 80009c0:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80009c2:	4b04      	ldr	r3, [pc, #16]	; (80009d4 <SysTick_Config+0x40>)
 80009c4:	2207      	movs	r2, #7
 80009c6:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 80009c8:	2300      	movs	r3, #0
}
 80009ca:	4618      	mov	r0, r3
 80009cc:	3708      	adds	r7, #8
 80009ce:	46bd      	mov	sp, r7
 80009d0:	bd80      	pop	{r7, pc}
 80009d2:	bf00      	nop
 80009d4:	e000e010 	.word	0xe000e010

080009d8 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80009d8:	b580      	push	{r7, lr}
 80009da:	b082      	sub	sp, #8
 80009dc:	af00      	add	r7, sp, #0
 80009de:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 80009e0:	6878      	ldr	r0, [r7, #4]
 80009e2:	f7ff ff31 	bl	8000848 <NVIC_SetPriorityGrouping>
}
 80009e6:	3708      	adds	r7, #8
 80009e8:	46bd      	mov	sp, r7
 80009ea:	bd80      	pop	{r7, pc}

080009ec <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 80009ec:	b580      	push	{r7, lr}
 80009ee:	b086      	sub	sp, #24
 80009f0:	af00      	add	r7, sp, #0
 80009f2:	4603      	mov	r3, r0
 80009f4:	60b9      	str	r1, [r7, #8]
 80009f6:	607a      	str	r2, [r7, #4]
 80009f8:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00;
 80009fa:	2300      	movs	r3, #0
 80009fc:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 80009fe:	f7ff ff47 	bl	8000890 <NVIC_GetPriorityGrouping>
 8000a02:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8000a04:	6978      	ldr	r0, [r7, #20]
 8000a06:	68b9      	ldr	r1, [r7, #8]
 8000a08:	687a      	ldr	r2, [r7, #4]
 8000a0a:	f7ff ff91 	bl	8000930 <NVIC_EncodePriority>
 8000a0e:	4602      	mov	r2, r0
 8000a10:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8000a14:	4618      	mov	r0, r3
 8000a16:	4611      	mov	r1, r2
 8000a18:	f7ff ff60 	bl	80008dc <NVIC_SetPriority>
}
 8000a1c:	3718      	adds	r7, #24
 8000a1e:	46bd      	mov	sp, r7
 8000a20:	bd80      	pop	{r7, pc}
 8000a22:	bf00      	nop

08000a24 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8000a24:	b580      	push	{r7, lr}
 8000a26:	b082      	sub	sp, #8
 8000a28:	af00      	add	r7, sp, #0
 8000a2a:	4603      	mov	r3, r0
 8000a2c:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8000a2e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8000a32:	4618      	mov	r0, r3
 8000a34:	f7ff ff3a 	bl	80008ac <NVIC_EnableIRQ>
}
 8000a38:	3708      	adds	r7, #8
 8000a3a:	46bd      	mov	sp, r7
 8000a3c:	bd80      	pop	{r7, pc}
 8000a3e:	bf00      	nop

08000a40 <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8000a40:	b580      	push	{r7, lr}
 8000a42:	b082      	sub	sp, #8
 8000a44:	af00      	add	r7, sp, #0
 8000a46:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8000a48:	6878      	ldr	r0, [r7, #4]
 8000a4a:	f7ff ffa3 	bl	8000994 <SysTick_Config>
 8000a4e:	4603      	mov	r3, r0
}
 8000a50:	4618      	mov	r0, r3
 8000a52:	3708      	adds	r7, #8
 8000a54:	46bd      	mov	sp, r7
 8000a56:	bd80      	pop	{r7, pc}

08000a58 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8000a58:	b480      	push	{r7}
 8000a5a:	b083      	sub	sp, #12
 8000a5c:	af00      	add	r7, sp, #0
 8000a5e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8000a60:	687b      	ldr	r3, [r7, #4]
 8000a62:	2b04      	cmp	r3, #4
 8000a64:	d106      	bne.n	8000a74 <HAL_SYSTICK_CLKSourceConfig+0x1c>
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8000a66:	4a09      	ldr	r2, [pc, #36]	; (8000a8c <HAL_SYSTICK_CLKSourceConfig+0x34>)
 8000a68:	4b08      	ldr	r3, [pc, #32]	; (8000a8c <HAL_SYSTICK_CLKSourceConfig+0x34>)
 8000a6a:	681b      	ldr	r3, [r3, #0]
 8000a6c:	f043 0304 	orr.w	r3, r3, #4
 8000a70:	6013      	str	r3, [r2, #0]
 8000a72:	e005      	b.n	8000a80 <HAL_SYSTICK_CLKSourceConfig+0x28>
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000a74:	4a05      	ldr	r2, [pc, #20]	; (8000a8c <HAL_SYSTICK_CLKSourceConfig+0x34>)
 8000a76:	4b05      	ldr	r3, [pc, #20]	; (8000a8c <HAL_SYSTICK_CLKSourceConfig+0x34>)
 8000a78:	681b      	ldr	r3, [r3, #0]
 8000a7a:	f023 0304 	bic.w	r3, r3, #4
 8000a7e:	6013      	str	r3, [r2, #0]
  }
}
 8000a80:	370c      	adds	r7, #12
 8000a82:	46bd      	mov	sp, r7
 8000a84:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000a88:	4770      	bx	lr
 8000a8a:	bf00      	nop
 8000a8c:	e000e010 	.word	0xe000e010

08000a90 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000a90:	b480      	push	{r7}
 8000a92:	b089      	sub	sp, #36	; 0x24
 8000a94:	af00      	add	r7, sp, #0
 8000a96:	6078      	str	r0, [r7, #4]
 8000a98:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00;
 8000a9a:	2300      	movs	r3, #0
 8000a9c:	61fb      	str	r3, [r7, #28]
  uint32_t ioposition = 0x00;
 8000a9e:	2300      	movs	r3, #0
 8000aa0:	617b      	str	r3, [r7, #20]
  uint32_t iocurrent = 0x00;
 8000aa2:	2300      	movs	r3, #0
 8000aa4:	613b      	str	r3, [r7, #16]
  uint32_t temp = 0x00;
 8000aa6:	2300      	movs	r3, #0
 8000aa8:	61bb      	str	r3, [r7, #24]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 8000aaa:	2300      	movs	r3, #0
 8000aac:	61fb      	str	r3, [r7, #28]
 8000aae:	e171      	b.n	8000d94 <HAL_GPIO_Init+0x304>
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01) << position;
 8000ab0:	69fb      	ldr	r3, [r7, #28]
 8000ab2:	2201      	movs	r2, #1
 8000ab4:	fa02 f303 	lsl.w	r3, r2, r3
 8000ab8:	617b      	str	r3, [r7, #20]
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8000aba:	683b      	ldr	r3, [r7, #0]
 8000abc:	681a      	ldr	r2, [r3, #0]
 8000abe:	697b      	ldr	r3, [r7, #20]
 8000ac0:	4013      	ands	r3, r2
 8000ac2:	613b      	str	r3, [r7, #16]

    if(iocurrent == ioposition)
 8000ac4:	693a      	ldr	r2, [r7, #16]
 8000ac6:	697b      	ldr	r3, [r7, #20]
 8000ac8:	429a      	cmp	r2, r3
 8000aca:	f040 8160 	bne.w	8000d8e <HAL_GPIO_Init+0x2fe>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000ace:	683b      	ldr	r3, [r7, #0]
 8000ad0:	685b      	ldr	r3, [r3, #4]
 8000ad2:	2b02      	cmp	r3, #2
 8000ad4:	d003      	beq.n	8000ade <HAL_GPIO_Init+0x4e>
 8000ad6:	683b      	ldr	r3, [r7, #0]
 8000ad8:	685b      	ldr	r3, [r3, #4]
 8000ada:	2b12      	cmp	r3, #18
 8000adc:	d122      	bne.n	8000b24 <HAL_GPIO_Init+0x94>
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3];
 8000ade:	69fb      	ldr	r3, [r7, #28]
 8000ae0:	08da      	lsrs	r2, r3, #3
 8000ae2:	687b      	ldr	r3, [r7, #4]
 8000ae4:	3208      	adds	r2, #8
 8000ae6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8000aea:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8000aec:	69fb      	ldr	r3, [r7, #28]
 8000aee:	f003 0307 	and.w	r3, r3, #7
 8000af2:	009b      	lsls	r3, r3, #2
 8000af4:	461a      	mov	r2, r3
 8000af6:	230f      	movs	r3, #15
 8000af8:	4093      	lsls	r3, r2
 8000afa:	43db      	mvns	r3, r3
 8000afc:	69ba      	ldr	r2, [r7, #24]
 8000afe:	4013      	ands	r3, r2
 8000b00:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8000b02:	683b      	ldr	r3, [r7, #0]
 8000b04:	691b      	ldr	r3, [r3, #16]
 8000b06:	69fa      	ldr	r2, [r7, #28]
 8000b08:	f002 0207 	and.w	r2, r2, #7
 8000b0c:	0092      	lsls	r2, r2, #2
 8000b0e:	4093      	lsls	r3, r2
 8000b10:	69ba      	ldr	r2, [r7, #24]
 8000b12:	4313      	orrs	r3, r2
 8000b14:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3] = temp;
 8000b16:	69fb      	ldr	r3, [r7, #28]
 8000b18:	08da      	lsrs	r2, r3, #3
 8000b1a:	687b      	ldr	r3, [r7, #4]
 8000b1c:	3208      	adds	r2, #8
 8000b1e:	69b9      	ldr	r1, [r7, #24]
 8000b20:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8000b24:	687b      	ldr	r3, [r7, #4]
 8000b26:	681b      	ldr	r3, [r3, #0]
 8000b28:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
 8000b2a:	69fb      	ldr	r3, [r7, #28]
 8000b2c:	005b      	lsls	r3, r3, #1
 8000b2e:	461a      	mov	r2, r3
 8000b30:	2303      	movs	r3, #3
 8000b32:	4093      	lsls	r3, r2
 8000b34:	43db      	mvns	r3, r3
 8000b36:	69ba      	ldr	r2, [r7, #24]
 8000b38:	4013      	ands	r3, r2
 8000b3a:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8000b3c:	683b      	ldr	r3, [r7, #0]
 8000b3e:	685b      	ldr	r3, [r3, #4]
 8000b40:	f003 0303 	and.w	r3, r3, #3
 8000b44:	69fa      	ldr	r2, [r7, #28]
 8000b46:	0052      	lsls	r2, r2, #1
 8000b48:	4093      	lsls	r3, r2
 8000b4a:	69ba      	ldr	r2, [r7, #24]
 8000b4c:	4313      	orrs	r3, r2
 8000b4e:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8000b50:	687b      	ldr	r3, [r7, #4]
 8000b52:	69ba      	ldr	r2, [r7, #24]
 8000b54:	601a      	str	r2, [r3, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000b56:	683b      	ldr	r3, [r7, #0]
 8000b58:	685b      	ldr	r3, [r3, #4]
 8000b5a:	2b01      	cmp	r3, #1
 8000b5c:	d00b      	beq.n	8000b76 <HAL_GPIO_Init+0xe6>
 8000b5e:	683b      	ldr	r3, [r7, #0]
 8000b60:	685b      	ldr	r3, [r3, #4]
 8000b62:	2b02      	cmp	r3, #2
 8000b64:	d007      	beq.n	8000b76 <HAL_GPIO_Init+0xe6>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000b66:	683b      	ldr	r3, [r7, #0]
 8000b68:	685b      	ldr	r3, [r3, #4]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000b6a:	2b11      	cmp	r3, #17
 8000b6c:	d003      	beq.n	8000b76 <HAL_GPIO_Init+0xe6>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8000b6e:	683b      	ldr	r3, [r7, #0]
 8000b70:	685b      	ldr	r3, [r3, #4]
 8000b72:	2b12      	cmp	r3, #18
 8000b74:	d12f      	bne.n	8000bd6 <HAL_GPIO_Init+0x146>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8000b76:	687b      	ldr	r3, [r7, #4]
 8000b78:	689b      	ldr	r3, [r3, #8]
 8000b7a:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2));
 8000b7c:	69fb      	ldr	r3, [r7, #28]
 8000b7e:	005b      	lsls	r3, r3, #1
 8000b80:	461a      	mov	r2, r3
 8000b82:	2303      	movs	r3, #3
 8000b84:	4093      	lsls	r3, r2
 8000b86:	43db      	mvns	r3, r3
 8000b88:	69ba      	ldr	r2, [r7, #24]
 8000b8a:	4013      	ands	r3, r2
 8000b8c:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2));
 8000b8e:	683b      	ldr	r3, [r7, #0]
 8000b90:	68db      	ldr	r3, [r3, #12]
 8000b92:	69fa      	ldr	r2, [r7, #28]
 8000b94:	0052      	lsls	r2, r2, #1
 8000b96:	4093      	lsls	r3, r2
 8000b98:	69ba      	ldr	r2, [r7, #24]
 8000b9a:	4313      	orrs	r3, r2
 8000b9c:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8000b9e:	687b      	ldr	r3, [r7, #4]
 8000ba0:	69ba      	ldr	r2, [r7, #24]
 8000ba2:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8000ba4:	687b      	ldr	r3, [r7, #4]
 8000ba6:	685b      	ldr	r3, [r3, #4]
 8000ba8:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8000baa:	69fb      	ldr	r3, [r7, #28]
 8000bac:	2201      	movs	r2, #1
 8000bae:	fa02 f303 	lsl.w	r3, r2, r3
 8000bb2:	43db      	mvns	r3, r3
 8000bb4:	69ba      	ldr	r2, [r7, #24]
 8000bb6:	4013      	ands	r3, r2
 8000bb8:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8000bba:	683b      	ldr	r3, [r7, #0]
 8000bbc:	685b      	ldr	r3, [r3, #4]
 8000bbe:	f003 0310 	and.w	r3, r3, #16
 8000bc2:	091a      	lsrs	r2, r3, #4
 8000bc4:	69fb      	ldr	r3, [r7, #28]
 8000bc6:	fa02 f303 	lsl.w	r3, r2, r3
 8000bca:	69ba      	ldr	r2, [r7, #24]
 8000bcc:	4313      	orrs	r3, r2
 8000bce:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8000bd0:	687b      	ldr	r3, [r7, #4]
 8000bd2:	69ba      	ldr	r2, [r7, #24]
 8000bd4:	605a      	str	r2, [r3, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8000bd6:	687b      	ldr	r3, [r7, #4]
 8000bd8:	68db      	ldr	r3, [r3, #12]
 8000bda:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
 8000bdc:	69fb      	ldr	r3, [r7, #28]
 8000bde:	005b      	lsls	r3, r3, #1
 8000be0:	461a      	mov	r2, r3
 8000be2:	2303      	movs	r3, #3
 8000be4:	4093      	lsls	r3, r2
 8000be6:	43db      	mvns	r3, r3
 8000be8:	69ba      	ldr	r2, [r7, #24]
 8000bea:	4013      	ands	r3, r2
 8000bec:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8000bee:	683b      	ldr	r3, [r7, #0]
 8000bf0:	689b      	ldr	r3, [r3, #8]
 8000bf2:	69fa      	ldr	r2, [r7, #28]
 8000bf4:	0052      	lsls	r2, r2, #1
 8000bf6:	4093      	lsls	r3, r2
 8000bf8:	69ba      	ldr	r2, [r7, #24]
 8000bfa:	4313      	orrs	r3, r2
 8000bfc:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 8000bfe:	687b      	ldr	r3, [r7, #4]
 8000c00:	69ba      	ldr	r2, [r7, #24]
 8000c02:	60da      	str	r2, [r3, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8000c04:	683b      	ldr	r3, [r7, #0]
 8000c06:	685b      	ldr	r3, [r3, #4]
 8000c08:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000c0c:	2b00      	cmp	r3, #0
 8000c0e:	f000 80be 	beq.w	8000d8e <HAL_GPIO_Init+0x2fe>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000c12:	4a65      	ldr	r2, [pc, #404]	; (8000da8 <HAL_GPIO_Init+0x318>)
 8000c14:	4b64      	ldr	r3, [pc, #400]	; (8000da8 <HAL_GPIO_Init+0x318>)
 8000c16:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000c18:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000c1c:	6453      	str	r3, [r2, #68]	; 0x44
 8000c1e:	4b62      	ldr	r3, [pc, #392]	; (8000da8 <HAL_GPIO_Init+0x318>)
 8000c20:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000c22:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8000c26:	60fb      	str	r3, [r7, #12]
 8000c28:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2];
 8000c2a:	4a60      	ldr	r2, [pc, #384]	; (8000dac <HAL_GPIO_Init+0x31c>)
 8000c2c:	69fb      	ldr	r3, [r7, #28]
 8000c2e:	089b      	lsrs	r3, r3, #2
 8000c30:	3302      	adds	r3, #2
 8000c32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8000c36:	61bb      	str	r3, [r7, #24]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8000c38:	69fb      	ldr	r3, [r7, #28]
 8000c3a:	f003 0303 	and.w	r3, r3, #3
 8000c3e:	009b      	lsls	r3, r3, #2
 8000c40:	461a      	mov	r2, r3
 8000c42:	230f      	movs	r3, #15
 8000c44:	4093      	lsls	r3, r2
 8000c46:	43db      	mvns	r3, r3
 8000c48:	69ba      	ldr	r2, [r7, #24]
 8000c4a:	4013      	ands	r3, r2
 8000c4c:	61bb      	str	r3, [r7, #24]
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4 * (position & 0x03)));
 8000c4e:	687b      	ldr	r3, [r7, #4]
 8000c50:	4a57      	ldr	r2, [pc, #348]	; (8000db0 <HAL_GPIO_Init+0x320>)
 8000c52:	4293      	cmp	r3, r2
 8000c54:	d037      	beq.n	8000cc6 <HAL_GPIO_Init+0x236>
 8000c56:	687b      	ldr	r3, [r7, #4]
 8000c58:	4a56      	ldr	r2, [pc, #344]	; (8000db4 <HAL_GPIO_Init+0x324>)
 8000c5a:	4293      	cmp	r3, r2
 8000c5c:	d031      	beq.n	8000cc2 <HAL_GPIO_Init+0x232>
 8000c5e:	687b      	ldr	r3, [r7, #4]
 8000c60:	4a55      	ldr	r2, [pc, #340]	; (8000db8 <HAL_GPIO_Init+0x328>)
 8000c62:	4293      	cmp	r3, r2
 8000c64:	d02b      	beq.n	8000cbe <HAL_GPIO_Init+0x22e>
 8000c66:	687b      	ldr	r3, [r7, #4]
 8000c68:	4a54      	ldr	r2, [pc, #336]	; (8000dbc <HAL_GPIO_Init+0x32c>)
 8000c6a:	4293      	cmp	r3, r2
 8000c6c:	d025      	beq.n	8000cba <HAL_GPIO_Init+0x22a>
 8000c6e:	687b      	ldr	r3, [r7, #4]
 8000c70:	4a53      	ldr	r2, [pc, #332]	; (8000dc0 <HAL_GPIO_Init+0x330>)
 8000c72:	4293      	cmp	r3, r2
 8000c74:	d01f      	beq.n	8000cb6 <HAL_GPIO_Init+0x226>
 8000c76:	687b      	ldr	r3, [r7, #4]
 8000c78:	4a52      	ldr	r2, [pc, #328]	; (8000dc4 <HAL_GPIO_Init+0x334>)
 8000c7a:	4293      	cmp	r3, r2
 8000c7c:	d019      	beq.n	8000cb2 <HAL_GPIO_Init+0x222>
 8000c7e:	687b      	ldr	r3, [r7, #4]
 8000c80:	4a51      	ldr	r2, [pc, #324]	; (8000dc8 <HAL_GPIO_Init+0x338>)
 8000c82:	4293      	cmp	r3, r2
 8000c84:	d013      	beq.n	8000cae <HAL_GPIO_Init+0x21e>
 8000c86:	687b      	ldr	r3, [r7, #4]
 8000c88:	4a50      	ldr	r2, [pc, #320]	; (8000dcc <HAL_GPIO_Init+0x33c>)
 8000c8a:	4293      	cmp	r3, r2
 8000c8c:	d00d      	beq.n	8000caa <HAL_GPIO_Init+0x21a>
 8000c8e:	687b      	ldr	r3, [r7, #4]
 8000c90:	4a4f      	ldr	r2, [pc, #316]	; (8000dd0 <HAL_GPIO_Init+0x340>)
 8000c92:	4293      	cmp	r3, r2
 8000c94:	d007      	beq.n	8000ca6 <HAL_GPIO_Init+0x216>
 8000c96:	687b      	ldr	r3, [r7, #4]
 8000c98:	4a4e      	ldr	r2, [pc, #312]	; (8000dd4 <HAL_GPIO_Init+0x344>)
 8000c9a:	4293      	cmp	r3, r2
 8000c9c:	d101      	bne.n	8000ca2 <HAL_GPIO_Init+0x212>
 8000c9e:	2309      	movs	r3, #9
 8000ca0:	e012      	b.n	8000cc8 <HAL_GPIO_Init+0x238>
 8000ca2:	230a      	movs	r3, #10
 8000ca4:	e010      	b.n	8000cc8 <HAL_GPIO_Init+0x238>
 8000ca6:	2308      	movs	r3, #8
 8000ca8:	e00e      	b.n	8000cc8 <HAL_GPIO_Init+0x238>
 8000caa:	2307      	movs	r3, #7
 8000cac:	e00c      	b.n	8000cc8 <HAL_GPIO_Init+0x238>
 8000cae:	2306      	movs	r3, #6
 8000cb0:	e00a      	b.n	8000cc8 <HAL_GPIO_Init+0x238>
 8000cb2:	2305      	movs	r3, #5
 8000cb4:	e008      	b.n	8000cc8 <HAL_GPIO_Init+0x238>
 8000cb6:	2304      	movs	r3, #4
 8000cb8:	e006      	b.n	8000cc8 <HAL_GPIO_Init+0x238>
 8000cba:	2303      	movs	r3, #3
 8000cbc:	e004      	b.n	8000cc8 <HAL_GPIO_Init+0x238>
 8000cbe:	2302      	movs	r3, #2
 8000cc0:	e002      	b.n	8000cc8 <HAL_GPIO_Init+0x238>
 8000cc2:	2301      	movs	r3, #1
 8000cc4:	e000      	b.n	8000cc8 <HAL_GPIO_Init+0x238>
 8000cc6:	2300      	movs	r3, #0
 8000cc8:	69fa      	ldr	r2, [r7, #28]
 8000cca:	f002 0203 	and.w	r2, r2, #3
 8000cce:	0092      	lsls	r2, r2, #2
 8000cd0:	4093      	lsls	r3, r2
 8000cd2:	69ba      	ldr	r2, [r7, #24]
 8000cd4:	4313      	orrs	r3, r2
 8000cd6:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2] = temp;
 8000cd8:	4934      	ldr	r1, [pc, #208]	; (8000dac <HAL_GPIO_Init+0x31c>)
 8000cda:	69fb      	ldr	r3, [r7, #28]
 8000cdc:	089b      	lsrs	r3, r3, #2
 8000cde:	3302      	adds	r3, #2
 8000ce0:	69ba      	ldr	r2, [r7, #24]
 8000ce2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8000ce6:	4b3c      	ldr	r3, [pc, #240]	; (8000dd8 <HAL_GPIO_Init+0x348>)
 8000ce8:	681b      	ldr	r3, [r3, #0]
 8000cea:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8000cec:	693b      	ldr	r3, [r7, #16]
 8000cee:	43db      	mvns	r3, r3
 8000cf0:	69ba      	ldr	r2, [r7, #24]
 8000cf2:	4013      	ands	r3, r2
 8000cf4:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000cf6:	683b      	ldr	r3, [r7, #0]
 8000cf8:	685b      	ldr	r3, [r3, #4]
 8000cfa:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8000cfe:	2b00      	cmp	r3, #0
 8000d00:	d003      	beq.n	8000d0a <HAL_GPIO_Init+0x27a>
        {
          temp |= iocurrent;
 8000d02:	69ba      	ldr	r2, [r7, #24]
 8000d04:	693b      	ldr	r3, [r7, #16]
 8000d06:	4313      	orrs	r3, r2
 8000d08:	61bb      	str	r3, [r7, #24]
        }
        EXTI->IMR = temp;
 8000d0a:	4a33      	ldr	r2, [pc, #204]	; (8000dd8 <HAL_GPIO_Init+0x348>)
 8000d0c:	69bb      	ldr	r3, [r7, #24]
 8000d0e:	6013      	str	r3, [r2, #0]

        temp = EXTI->EMR;
 8000d10:	4b31      	ldr	r3, [pc, #196]	; (8000dd8 <HAL_GPIO_Init+0x348>)
 8000d12:	685b      	ldr	r3, [r3, #4]
 8000d14:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8000d16:	693b      	ldr	r3, [r7, #16]
 8000d18:	43db      	mvns	r3, r3
 8000d1a:	69ba      	ldr	r2, [r7, #24]
 8000d1c:	4013      	ands	r3, r2
 8000d1e:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000d20:	683b      	ldr	r3, [r7, #0]
 8000d22:	685b      	ldr	r3, [r3, #4]
 8000d24:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8000d28:	2b00      	cmp	r3, #0
 8000d2a:	d003      	beq.n	8000d34 <HAL_GPIO_Init+0x2a4>
        {
          temp |= iocurrent;
 8000d2c:	69ba      	ldr	r2, [r7, #24]
 8000d2e:	693b      	ldr	r3, [r7, #16]
 8000d30:	4313      	orrs	r3, r2
 8000d32:	61bb      	str	r3, [r7, #24]
        }
        EXTI->EMR = temp;
 8000d34:	4a28      	ldr	r2, [pc, #160]	; (8000dd8 <HAL_GPIO_Init+0x348>)
 8000d36:	69bb      	ldr	r3, [r7, #24]
 8000d38:	6053      	str	r3, [r2, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8000d3a:	4b27      	ldr	r3, [pc, #156]	; (8000dd8 <HAL_GPIO_Init+0x348>)
 8000d3c:	689b      	ldr	r3, [r3, #8]
 8000d3e:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8000d40:	693b      	ldr	r3, [r7, #16]
 8000d42:	43db      	mvns	r3, r3
 8000d44:	69ba      	ldr	r2, [r7, #24]
 8000d46:	4013      	ands	r3, r2
 8000d48:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000d4a:	683b      	ldr	r3, [r7, #0]
 8000d4c:	685b      	ldr	r3, [r3, #4]
 8000d4e:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8000d52:	2b00      	cmp	r3, #0
 8000d54:	d003      	beq.n	8000d5e <HAL_GPIO_Init+0x2ce>
        {
          temp |= iocurrent;
 8000d56:	69ba      	ldr	r2, [r7, #24]
 8000d58:	693b      	ldr	r3, [r7, #16]
 8000d5a:	4313      	orrs	r3, r2
 8000d5c:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR = temp;
 8000d5e:	4a1e      	ldr	r2, [pc, #120]	; (8000dd8 <HAL_GPIO_Init+0x348>)
 8000d60:	69bb      	ldr	r3, [r7, #24]
 8000d62:	6093      	str	r3, [r2, #8]

        temp = EXTI->FTSR;
 8000d64:	4b1c      	ldr	r3, [pc, #112]	; (8000dd8 <HAL_GPIO_Init+0x348>)
 8000d66:	68db      	ldr	r3, [r3, #12]
 8000d68:	61bb      	str	r3, [r7, #24]
        temp &= ~((uint32_t)iocurrent);
 8000d6a:	693b      	ldr	r3, [r7, #16]
 8000d6c:	43db      	mvns	r3, r3
 8000d6e:	69ba      	ldr	r2, [r7, #24]
 8000d70:	4013      	ands	r3, r2
 8000d72:	61bb      	str	r3, [r7, #24]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8000d74:	683b      	ldr	r3, [r7, #0]
 8000d76:	685b      	ldr	r3, [r3, #4]
 8000d78:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8000d7c:	2b00      	cmp	r3, #0
 8000d7e:	d003      	beq.n	8000d88 <HAL_GPIO_Init+0x2f8>
        {
          temp |= iocurrent;
 8000d80:	69ba      	ldr	r2, [r7, #24]
 8000d82:	693b      	ldr	r3, [r7, #16]
 8000d84:	4313      	orrs	r3, r2
 8000d86:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR = temp;
 8000d88:	4a13      	ldr	r2, [pc, #76]	; (8000dd8 <HAL_GPIO_Init+0x348>)
 8000d8a:	69bb      	ldr	r3, [r7, #24]
 8000d8c:	60d3      	str	r3, [r2, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0; position < GPIO_NUMBER; position++)
 8000d8e:	69fb      	ldr	r3, [r7, #28]
 8000d90:	3301      	adds	r3, #1
 8000d92:	61fb      	str	r3, [r7, #28]
 8000d94:	69fb      	ldr	r3, [r7, #28]
 8000d96:	2b0f      	cmp	r3, #15
 8000d98:	f67f ae8a 	bls.w	8000ab0 <HAL_GPIO_Init+0x20>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 8000d9c:	3724      	adds	r7, #36	; 0x24
 8000d9e:	46bd      	mov	sp, r7
 8000da0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000da4:	4770      	bx	lr
 8000da6:	bf00      	nop
 8000da8:	40023800 	.word	0x40023800
 8000dac:	40013800 	.word	0x40013800
 8000db0:	40020000 	.word	0x40020000
 8000db4:	40020400 	.word	0x40020400
 8000db8:	40020800 	.word	0x40020800
 8000dbc:	40020c00 	.word	0x40020c00
 8000dc0:	40021000 	.word	0x40021000
 8000dc4:	40021400 	.word	0x40021400
 8000dc8:	40021800 	.word	0x40021800
 8000dcc:	40021c00 	.word	0x40021c00
 8000dd0:	40022000 	.word	0x40022000
 8000dd4:	40022400 	.word	0x40022400
 8000dd8:	40013c00 	.word	0x40013c00

08000ddc <HAL_GPIO_TogglePin>:
  * @param  GPIOx: Where x can be (A..I) to select the GPIO peripheral.
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8000ddc:	b480      	push	{r7}
 8000dde:	b083      	sub	sp, #12
 8000de0:	af00      	add	r7, sp, #0
 8000de2:	6078      	str	r0, [r7, #4]
 8000de4:	460b      	mov	r3, r1
 8000de6:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 8000de8:	687b      	ldr	r3, [r7, #4]
 8000dea:	695a      	ldr	r2, [r3, #20]
 8000dec:	887b      	ldrh	r3, [r7, #2]
 8000dee:	405a      	eors	r2, r3
 8000df0:	687b      	ldr	r3, [r7, #4]
 8000df2:	615a      	str	r2, [r3, #20]
}
 8000df4:	370c      	adds	r7, #12
 8000df6:	46bd      	mov	sp, r7
 8000df8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8000dfc:	4770      	bx	lr
 8000dfe:	bf00      	nop

08000e00 <HAL_PWREx_EnableOverDrive>:
  *         During the Over-drive switch activation, no peripheral clocks should be enabled.   
  *         The peripheral clocks must be enabled once the Over-drive mode is activated.   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PWREx_EnableOverDrive(void)
{
 8000e00:	b580      	push	{r7, lr}
 8000e02:	b082      	sub	sp, #8
 8000e04:	af00      	add	r7, sp, #0
  uint32_t tickstart = 0;
 8000e06:	2300      	movs	r3, #0
 8000e08:	607b      	str	r3, [r7, #4]

  __HAL_RCC_PWR_CLK_ENABLE();
 8000e0a:	4a22      	ldr	r2, [pc, #136]	; (8000e94 <HAL_PWREx_EnableOverDrive+0x94>)
 8000e0c:	4b21      	ldr	r3, [pc, #132]	; (8000e94 <HAL_PWREx_EnableOverDrive+0x94>)
 8000e0e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000e10:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000e14:	6413      	str	r3, [r2, #64]	; 0x40
 8000e16:	4b1f      	ldr	r3, [pc, #124]	; (8000e94 <HAL_PWREx_EnableOverDrive+0x94>)
 8000e18:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000e1a:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000e1e:	603b      	str	r3, [r7, #0]
 8000e20:	683b      	ldr	r3, [r7, #0]
  
  /* Enable the Over-drive to extend the clock frequency to 216 MHz */
  __HAL_PWR_OVERDRIVE_ENABLE();
 8000e22:	4a1d      	ldr	r2, [pc, #116]	; (8000e98 <HAL_PWREx_EnableOverDrive+0x98>)
 8000e24:	4b1c      	ldr	r3, [pc, #112]	; (8000e98 <HAL_PWREx_EnableOverDrive+0x98>)
 8000e26:	681b      	ldr	r3, [r3, #0]
 8000e28:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000e2c:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8000e2e:	f7ff fce9 	bl	8000804 <HAL_GetTick>
 8000e32:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8000e34:	e009      	b.n	8000e4a <HAL_PWREx_EnableOverDrive+0x4a>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8000e36:	f7ff fce5 	bl	8000804 <HAL_GetTick>
 8000e3a:	4602      	mov	r2, r0
 8000e3c:	687b      	ldr	r3, [r7, #4]
 8000e3e:	1ad3      	subs	r3, r2, r3
 8000e40:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8000e44:	d901      	bls.n	8000e4a <HAL_PWREx_EnableOverDrive+0x4a>
    {
      return HAL_TIMEOUT;
 8000e46:	2303      	movs	r3, #3
 8000e48:	e020      	b.n	8000e8c <HAL_PWREx_EnableOverDrive+0x8c>
  __HAL_PWR_OVERDRIVE_ENABLE();

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODRDY))
 8000e4a:	4b13      	ldr	r3, [pc, #76]	; (8000e98 <HAL_PWREx_EnableOverDrive+0x98>)
 8000e4c:	685b      	ldr	r3, [r3, #4]
 8000e4e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8000e52:	2b00      	cmp	r3, #0
 8000e54:	d0ef      	beq.n	8000e36 <HAL_PWREx_EnableOverDrive+0x36>
      return HAL_TIMEOUT;
    }
  }
  
  /* Enable the Over-drive switch */
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();
 8000e56:	4a10      	ldr	r2, [pc, #64]	; (8000e98 <HAL_PWREx_EnableOverDrive+0x98>)
 8000e58:	4b0f      	ldr	r3, [pc, #60]	; (8000e98 <HAL_PWREx_EnableOverDrive+0x98>)
 8000e5a:	681b      	ldr	r3, [r3, #0]
 8000e5c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8000e60:	6013      	str	r3, [r2, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8000e62:	f7ff fccf 	bl	8000804 <HAL_GetTick>
 8000e66:	6078      	str	r0, [r7, #4]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8000e68:	e009      	b.n	8000e7e <HAL_PWREx_EnableOverDrive+0x7e>
  {
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
 8000e6a:	f7ff fccb 	bl	8000804 <HAL_GetTick>
 8000e6e:	4602      	mov	r2, r0
 8000e70:	687b      	ldr	r3, [r7, #4]
 8000e72:	1ad3      	subs	r3, r2, r3
 8000e74:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8000e78:	d901      	bls.n	8000e7e <HAL_PWREx_EnableOverDrive+0x7e>
    {
      return HAL_TIMEOUT;
 8000e7a:	2303      	movs	r3, #3
 8000e7c:	e006      	b.n	8000e8c <HAL_PWREx_EnableOverDrive+0x8c>
  __HAL_PWR_OVERDRIVESWITCHING_ENABLE();

  /* Get tick */
  tickstart = HAL_GetTick();

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_ODSWRDY))
 8000e7e:	4b06      	ldr	r3, [pc, #24]	; (8000e98 <HAL_PWREx_EnableOverDrive+0x98>)
 8000e80:	685b      	ldr	r3, [r3, #4]
 8000e82:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8000e86:	2b00      	cmp	r3, #0
 8000e88:	d0ef      	beq.n	8000e6a <HAL_PWREx_EnableOverDrive+0x6a>
    if((HAL_GetTick() - tickstart ) > PWR_OVERDRIVE_TIMEOUT_VALUE)
    {
      return HAL_TIMEOUT;
    }
  } 
  return HAL_OK;
 8000e8a:	2300      	movs	r3, #0
}
 8000e8c:	4618      	mov	r0, r3
 8000e8e:	3708      	adds	r7, #8
 8000e90:	46bd      	mov	sp, r7
 8000e92:	bd80      	pop	{r7, pc}
 8000e94:	40023800 	.word	0x40023800
 8000e98:	40007000 	.word	0x40007000

08000e9c <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8000e9c:	b580      	push	{r7, lr}
 8000e9e:	b090      	sub	sp, #64	; 0x40
 8000ea0:	af00      	add	r7, sp, #0
 8000ea2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0;  
 8000ea4:	2300      	movs	r3, #0
 8000ea6:	63fb      	str	r3, [r7, #60]	; 0x3c
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8000ea8:	687b      	ldr	r3, [r7, #4]
 8000eaa:	681b      	ldr	r3, [r3, #0]
 8000eac:	f003 0301 	and.w	r3, r3, #1
 8000eb0:	2b00      	cmp	r3, #0
 8000eb2:	f000 8085 	beq.w	8000fc0 <HAL_RCC_OscConfig+0x124>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8000eb6:	4ba0      	ldr	r3, [pc, #640]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000eb8:	689b      	ldr	r3, [r3, #8]
 8000eba:	f003 030c 	and.w	r3, r3, #12
 8000ebe:	2b04      	cmp	r3, #4
 8000ec0:	d00b      	beq.n	8000eda <HAL_RCC_OscConfig+0x3e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8000ec2:	4b9d      	ldr	r3, [pc, #628]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000ec4:	689b      	ldr	r3, [r3, #8]
 8000ec6:	f003 030c 	and.w	r3, r3, #12
 8000eca:	2b08      	cmp	r3, #8
 8000ecc:	d112      	bne.n	8000ef4 <HAL_RCC_OscConfig+0x58>
 8000ece:	4b9a      	ldr	r3, [pc, #616]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000ed0:	685b      	ldr	r3, [r3, #4]
 8000ed2:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8000ed6:	2b00      	cmp	r3, #0
 8000ed8:	d00c      	beq.n	8000ef4 <HAL_RCC_OscConfig+0x58>
    {
	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000eda:	4b97      	ldr	r3, [pc, #604]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000edc:	681b      	ldr	r3, [r3, #0]
 8000ede:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8000ee2:	2b00      	cmp	r3, #0
 8000ee4:	d005      	beq.n	8000ef2 <HAL_RCC_OscConfig+0x56>
 8000ee6:	687b      	ldr	r3, [r7, #4]
 8000ee8:	685b      	ldr	r3, [r3, #4]
 8000eea:	2b00      	cmp	r3, #0
 8000eec:	d101      	bne.n	8000ef2 <HAL_RCC_OscConfig+0x56>
      {
        return HAL_ERROR;
 8000eee:	2301      	movs	r3, #1
 8000ef0:	e263      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL, It can not be disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
    {
	  if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8000ef2:	e065      	b.n	8000fc0 <HAL_RCC_OscConfig+0x124>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8000ef4:	687b      	ldr	r3, [r7, #4]
 8000ef6:	685b      	ldr	r3, [r3, #4]
 8000ef8:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8000efc:	d106      	bne.n	8000f0c <HAL_RCC_OscConfig+0x70>
 8000efe:	4a8e      	ldr	r2, [pc, #568]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f00:	4b8d      	ldr	r3, [pc, #564]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f02:	681b      	ldr	r3, [r3, #0]
 8000f04:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000f08:	6013      	str	r3, [r2, #0]
 8000f0a:	e02e      	b.n	8000f6a <HAL_RCC_OscConfig+0xce>
 8000f0c:	687b      	ldr	r3, [r7, #4]
 8000f0e:	685b      	ldr	r3, [r3, #4]
 8000f10:	2b00      	cmp	r3, #0
 8000f12:	d10c      	bne.n	8000f2e <HAL_RCC_OscConfig+0x92>
 8000f14:	4a88      	ldr	r2, [pc, #544]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f16:	4b88      	ldr	r3, [pc, #544]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f18:	681b      	ldr	r3, [r3, #0]
 8000f1a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000f1e:	6013      	str	r3, [r2, #0]
 8000f20:	4a85      	ldr	r2, [pc, #532]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f22:	4b85      	ldr	r3, [pc, #532]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f24:	681b      	ldr	r3, [r3, #0]
 8000f26:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000f2a:	6013      	str	r3, [r2, #0]
 8000f2c:	e01d      	b.n	8000f6a <HAL_RCC_OscConfig+0xce>
 8000f2e:	687b      	ldr	r3, [r7, #4]
 8000f30:	685b      	ldr	r3, [r3, #4]
 8000f32:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8000f36:	d10c      	bne.n	8000f52 <HAL_RCC_OscConfig+0xb6>
 8000f38:	4a7f      	ldr	r2, [pc, #508]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f3a:	4b7f      	ldr	r3, [pc, #508]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f3c:	681b      	ldr	r3, [r3, #0]
 8000f3e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000f42:	6013      	str	r3, [r2, #0]
 8000f44:	4a7c      	ldr	r2, [pc, #496]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f46:	4b7c      	ldr	r3, [pc, #496]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f48:	681b      	ldr	r3, [r3, #0]
 8000f4a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8000f4e:	6013      	str	r3, [r2, #0]
 8000f50:	e00b      	b.n	8000f6a <HAL_RCC_OscConfig+0xce>
 8000f52:	4a79      	ldr	r2, [pc, #484]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f54:	4b78      	ldr	r3, [pc, #480]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f56:	681b      	ldr	r3, [r3, #0]
 8000f58:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8000f5c:	6013      	str	r3, [r2, #0]
 8000f5e:	4a76      	ldr	r2, [pc, #472]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f60:	4b75      	ldr	r3, [pc, #468]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f62:	681b      	ldr	r3, [r3, #0]
 8000f64:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8000f68:	6013      	str	r3, [r2, #0]
      
      /* Check the HSE State */
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8000f6a:	687b      	ldr	r3, [r7, #4]
 8000f6c:	685b      	ldr	r3, [r3, #4]
 8000f6e:	2b00      	cmp	r3, #0
 8000f70:	d013      	beq.n	8000f9a <HAL_RCC_OscConfig+0xfe>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000f72:	f7ff fc47 	bl	8000804 <HAL_GetTick>
 8000f76:	63f8      	str	r0, [r7, #60]	; 0x3c
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000f78:	e008      	b.n	8000f8c <HAL_RCC_OscConfig+0xf0>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000f7a:	f7ff fc43 	bl	8000804 <HAL_GetTick>
 8000f7e:	4602      	mov	r2, r0
 8000f80:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8000f82:	1ad3      	subs	r3, r2, r3
 8000f84:	2b64      	cmp	r3, #100	; 0x64
 8000f86:	d901      	bls.n	8000f8c <HAL_RCC_OscConfig+0xf0>
          {
            return HAL_TIMEOUT;
 8000f88:	2303      	movs	r3, #3
 8000f8a:	e216      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8000f8c:	4b6a      	ldr	r3, [pc, #424]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000f8e:	681b      	ldr	r3, [r3, #0]
 8000f90:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8000f94:	2b00      	cmp	r3, #0
 8000f96:	d0f0      	beq.n	8000f7a <HAL_RCC_OscConfig+0xde>
 8000f98:	e012      	b.n	8000fc0 <HAL_RCC_OscConfig+0x124>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8000f9a:	f7ff fc33 	bl	8000804 <HAL_GetTick>
 8000f9e:	63f8      	str	r0, [r7, #60]	; 0x3c
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000fa0:	e008      	b.n	8000fb4 <HAL_RCC_OscConfig+0x118>
        {
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8000fa2:	f7ff fc2f 	bl	8000804 <HAL_GetTick>
 8000fa6:	4602      	mov	r2, r0
 8000fa8:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8000faa:	1ad3      	subs	r3, r2, r3
 8000fac:	2b64      	cmp	r3, #100	; 0x64
 8000fae:	d901      	bls.n	8000fb4 <HAL_RCC_OscConfig+0x118>
          {
            return HAL_TIMEOUT;
 8000fb0:	2303      	movs	r3, #3
 8000fb2:	e202      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8000fb4:	4b60      	ldr	r3, [pc, #384]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000fb6:	681b      	ldr	r3, [r3, #0]
 8000fb8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8000fbc:	2b00      	cmp	r3, #0
 8000fbe:	d1f0      	bne.n	8000fa2 <HAL_RCC_OscConfig+0x106>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8000fc0:	687b      	ldr	r3, [r7, #4]
 8000fc2:	681b      	ldr	r3, [r3, #0]
 8000fc4:	f003 0302 	and.w	r3, r3, #2
 8000fc8:	2b00      	cmp	r3, #0
 8000fca:	d07d      	beq.n	80010c8 <HAL_RCC_OscConfig+0x22c>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 8000fcc:	4b5a      	ldr	r3, [pc, #360]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000fce:	689b      	ldr	r3, [r3, #8]
 8000fd0:	f003 030c 	and.w	r3, r3, #12
 8000fd4:	2b00      	cmp	r3, #0
 8000fd6:	d00b      	beq.n	8000ff0 <HAL_RCC_OscConfig+0x154>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8000fd8:	4b57      	ldr	r3, [pc, #348]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000fda:	689b      	ldr	r3, [r3, #8]
 8000fdc:	f003 030c 	and.w	r3, r3, #12
 8000fe0:	2b08      	cmp	r3, #8
 8000fe2:	d126      	bne.n	8001032 <HAL_RCC_OscConfig+0x196>
 8000fe4:	4b54      	ldr	r3, [pc, #336]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000fe6:	685b      	ldr	r3, [r3, #4]
 8000fe8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8000fec:	2b00      	cmp	r3, #0
 8000fee:	d120      	bne.n	8001032 <HAL_RCC_OscConfig+0x196>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8000ff0:	4b51      	ldr	r3, [pc, #324]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8000ff2:	681b      	ldr	r3, [r3, #0]
 8000ff4:	f003 0302 	and.w	r3, r3, #2
 8000ff8:	2b00      	cmp	r3, #0
 8000ffa:	d005      	beq.n	8001008 <HAL_RCC_OscConfig+0x16c>
 8000ffc:	687b      	ldr	r3, [r7, #4]
 8000ffe:	68db      	ldr	r3, [r3, #12]
 8001000:	2b01      	cmp	r3, #1
 8001002:	d001      	beq.n	8001008 <HAL_RCC_OscConfig+0x16c>
      {
        return HAL_ERROR;
 8001004:	2301      	movs	r3, #1
 8001006:	e1d8      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001008:	484b      	ldr	r0, [pc, #300]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 800100a:	4b4b      	ldr	r3, [pc, #300]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 800100c:	681b      	ldr	r3, [r3, #0]
 800100e:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 8001012:	687b      	ldr	r3, [r7, #4]
 8001014:	6919      	ldr	r1, [r3, #16]
 8001016:	23f8      	movs	r3, #248	; 0xf8
 8001018:	63bb      	str	r3, [r7, #56]	; 0x38
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800101a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800101c:	fa93 f3a3 	rbit	r3, r3
 8001020:	637b      	str	r3, [r7, #52]	; 0x34
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001022:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8001024:	fab3 f383 	clz	r3, r3
 8001028:	fa01 f303 	lsl.w	r3, r1, r3
 800102c:	4313      	orrs	r3, r2
 800102e:	6003      	str	r3, [r0, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */ 
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8001030:	e04a      	b.n	80010c8 <HAL_RCC_OscConfig+0x22c>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8001032:	687b      	ldr	r3, [r7, #4]
 8001034:	68db      	ldr	r3, [r3, #12]
 8001036:	2b00      	cmp	r3, #0
 8001038:	d02d      	beq.n	8001096 <HAL_RCC_OscConfig+0x1fa>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 800103a:	4a3f      	ldr	r2, [pc, #252]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 800103c:	4b3e      	ldr	r3, [pc, #248]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 800103e:	681b      	ldr	r3, [r3, #0]
 8001040:	f043 0301 	orr.w	r3, r3, #1
 8001044:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001046:	f7ff fbdd 	bl	8000804 <HAL_GetTick>
 800104a:	63f8      	str	r0, [r7, #60]	; 0x3c

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800104c:	e008      	b.n	8001060 <HAL_RCC_OscConfig+0x1c4>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800104e:	f7ff fbd9 	bl	8000804 <HAL_GetTick>
 8001052:	4602      	mov	r2, r0
 8001054:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8001056:	1ad3      	subs	r3, r2, r3
 8001058:	2b02      	cmp	r3, #2
 800105a:	d901      	bls.n	8001060 <HAL_RCC_OscConfig+0x1c4>
          {
            return HAL_TIMEOUT;
 800105c:	2303      	movs	r3, #3
 800105e:	e1ac      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001060:	4b35      	ldr	r3, [pc, #212]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8001062:	681b      	ldr	r3, [r3, #0]
 8001064:	f003 0302 	and.w	r3, r3, #2
 8001068:	2b00      	cmp	r3, #0
 800106a:	d0f0      	beq.n	800104e <HAL_RCC_OscConfig+0x1b2>
            return HAL_TIMEOUT;
          }
        }
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800106c:	4832      	ldr	r0, [pc, #200]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 800106e:	4b32      	ldr	r3, [pc, #200]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8001070:	681b      	ldr	r3, [r3, #0]
 8001072:	f023 02f8 	bic.w	r2, r3, #248	; 0xf8
 8001076:	687b      	ldr	r3, [r7, #4]
 8001078:	6919      	ldr	r1, [r3, #16]
 800107a:	23f8      	movs	r3, #248	; 0xf8
 800107c:	633b      	str	r3, [r7, #48]	; 0x30
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800107e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8001080:	fa93 f3a3 	rbit	r3, r3
 8001084:	62fb      	str	r3, [r7, #44]	; 0x2c
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001086:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8001088:	fab3 f383 	clz	r3, r3
 800108c:	fa01 f303 	lsl.w	r3, r1, r3
 8001090:	4313      	orrs	r3, r2
 8001092:	6003      	str	r3, [r0, #0]
 8001094:	e018      	b.n	80010c8 <HAL_RCC_OscConfig+0x22c>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8001096:	4a28      	ldr	r2, [pc, #160]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8001098:	4b27      	ldr	r3, [pc, #156]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 800109a:	681b      	ldr	r3, [r3, #0]
 800109c:	f023 0301 	bic.w	r3, r3, #1
 80010a0:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80010a2:	f7ff fbaf 	bl	8000804 <HAL_GetTick>
 80010a6:	63f8      	str	r0, [r7, #60]	; 0x3c
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80010a8:	e008      	b.n	80010bc <HAL_RCC_OscConfig+0x220>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80010aa:	f7ff fbab 	bl	8000804 <HAL_GetTick>
 80010ae:	4602      	mov	r2, r0
 80010b0:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80010b2:	1ad3      	subs	r3, r2, r3
 80010b4:	2b02      	cmp	r3, #2
 80010b6:	d901      	bls.n	80010bc <HAL_RCC_OscConfig+0x220>
          {
            return HAL_TIMEOUT;
 80010b8:	2303      	movs	r3, #3
 80010ba:	e17e      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80010bc:	4b1e      	ldr	r3, [pc, #120]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 80010be:	681b      	ldr	r3, [r3, #0]
 80010c0:	f003 0302 	and.w	r3, r3, #2
 80010c4:	2b00      	cmp	r3, #0
 80010c6:	d1f0      	bne.n	80010aa <HAL_RCC_OscConfig+0x20e>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80010c8:	687b      	ldr	r3, [r7, #4]
 80010ca:	681b      	ldr	r3, [r3, #0]
 80010cc:	f003 0308 	and.w	r3, r3, #8
 80010d0:	2b00      	cmp	r3, #0
 80010d2:	d039      	beq.n	8001148 <HAL_RCC_OscConfig+0x2ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 80010d4:	687b      	ldr	r3, [r7, #4]
 80010d6:	695b      	ldr	r3, [r3, #20]
 80010d8:	2b00      	cmp	r3, #0
 80010da:	d019      	beq.n	8001110 <HAL_RCC_OscConfig+0x274>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 80010dc:	4a16      	ldr	r2, [pc, #88]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 80010de:	4b16      	ldr	r3, [pc, #88]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 80010e0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80010e2:	f043 0301 	orr.w	r3, r3, #1
 80010e6:	6753      	str	r3, [r2, #116]	; 0x74
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 80010e8:	f7ff fb8c 	bl	8000804 <HAL_GetTick>
 80010ec:	63f8      	str	r0, [r7, #60]	; 0x3c
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 80010ee:	e008      	b.n	8001102 <HAL_RCC_OscConfig+0x266>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 80010f0:	f7ff fb88 	bl	8000804 <HAL_GetTick>
 80010f4:	4602      	mov	r2, r0
 80010f6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80010f8:	1ad3      	subs	r3, r2, r3
 80010fa:	2b02      	cmp	r3, #2
 80010fc:	d901      	bls.n	8001102 <HAL_RCC_OscConfig+0x266>
        {
          return HAL_TIMEOUT;
 80010fe:	2303      	movs	r3, #3
 8001100:	e15b      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001102:	4b0d      	ldr	r3, [pc, #52]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8001104:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001106:	f003 0302 	and.w	r3, r3, #2
 800110a:	2b00      	cmp	r3, #0
 800110c:	d0f0      	beq.n	80010f0 <HAL_RCC_OscConfig+0x254>
 800110e:	e01b      	b.n	8001148 <HAL_RCC_OscConfig+0x2ac>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8001110:	4a09      	ldr	r2, [pc, #36]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8001112:	4b09      	ldr	r3, [pc, #36]	; (8001138 <HAL_RCC_OscConfig+0x29c>)
 8001114:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001116:	f023 0301 	bic.w	r3, r3, #1
 800111a:	6753      	str	r3, [r2, #116]	; 0x74
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800111c:	f7ff fb72 	bl	8000804 <HAL_GetTick>
 8001120:	63f8      	str	r0, [r7, #60]	; 0x3c
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8001122:	e00b      	b.n	800113c <HAL_RCC_OscConfig+0x2a0>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001124:	f7ff fb6e 	bl	8000804 <HAL_GetTick>
 8001128:	4602      	mov	r2, r0
 800112a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800112c:	1ad3      	subs	r3, r2, r3
 800112e:	2b02      	cmp	r3, #2
 8001130:	d904      	bls.n	800113c <HAL_RCC_OscConfig+0x2a0>
        {
          return HAL_TIMEOUT;
 8001132:	2303      	movs	r3, #3
 8001134:	e141      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>
 8001136:	bf00      	nop
 8001138:	40023800 	.word	0x40023800
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800113c:	4ba1      	ldr	r3, [pc, #644]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 800113e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001140:	f003 0302 	and.w	r3, r3, #2
 8001144:	2b00      	cmp	r3, #0
 8001146:	d1ed      	bne.n	8001124 <HAL_RCC_OscConfig+0x288>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001148:	687b      	ldr	r3, [r7, #4]
 800114a:	681b      	ldr	r3, [r3, #0]
 800114c:	f003 0304 	and.w	r3, r3, #4
 8001150:	2b00      	cmp	r3, #0
 8001152:	f000 808d 	beq.w	8001270 <HAL_RCC_OscConfig+0x3d4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8001156:	4a9b      	ldr	r2, [pc, #620]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 8001158:	4b9a      	ldr	r3, [pc, #616]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 800115a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800115c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001160:	6413      	str	r3, [r2, #64]	; 0x40
 8001162:	4b98      	ldr	r3, [pc, #608]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 8001164:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001166:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800116a:	60bb      	str	r3, [r7, #8]
 800116c:	68bb      	ldr	r3, [r7, #8]
    
    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 800116e:	4a96      	ldr	r2, [pc, #600]	; (80013c8 <HAL_RCC_OscConfig+0x52c>)
 8001170:	4b95      	ldr	r3, [pc, #596]	; (80013c8 <HAL_RCC_OscConfig+0x52c>)
 8001172:	681b      	ldr	r3, [r3, #0]
 8001174:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001178:	6013      	str	r3, [r2, #0]
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 800117a:	f7ff fb43 	bl	8000804 <HAL_GetTick>
 800117e:	63f8      	str	r0, [r7, #60]	; 0x3c
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8001180:	e008      	b.n	8001194 <HAL_RCC_OscConfig+0x2f8>
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8001182:	f7ff fb3f 	bl	8000804 <HAL_GetTick>
 8001186:	4602      	mov	r2, r0
 8001188:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800118a:	1ad3      	subs	r3, r2, r3
 800118c:	2b64      	cmp	r3, #100	; 0x64
 800118e:	d901      	bls.n	8001194 <HAL_RCC_OscConfig+0x2f8>
      {
        return HAL_TIMEOUT;
 8001190:	2303      	movs	r3, #3
 8001192:	e112      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>
    PWR->CR1 |= PWR_CR1_DBP;
    
    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 8001194:	4b8c      	ldr	r3, [pc, #560]	; (80013c8 <HAL_RCC_OscConfig+0x52c>)
 8001196:	681b      	ldr	r3, [r3, #0]
 8001198:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800119c:	2b00      	cmp	r3, #0
 800119e:	d0f0      	beq.n	8001182 <HAL_RCC_OscConfig+0x2e6>
        return HAL_TIMEOUT;
      }      
    }
    
    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80011a0:	687b      	ldr	r3, [r7, #4]
 80011a2:	689b      	ldr	r3, [r3, #8]
 80011a4:	2b01      	cmp	r3, #1
 80011a6:	d106      	bne.n	80011b6 <HAL_RCC_OscConfig+0x31a>
 80011a8:	4a86      	ldr	r2, [pc, #536]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80011aa:	4b86      	ldr	r3, [pc, #536]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80011ac:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80011ae:	f043 0301 	orr.w	r3, r3, #1
 80011b2:	6713      	str	r3, [r2, #112]	; 0x70
 80011b4:	e02d      	b.n	8001212 <HAL_RCC_OscConfig+0x376>
 80011b6:	687b      	ldr	r3, [r7, #4]
 80011b8:	689b      	ldr	r3, [r3, #8]
 80011ba:	2b00      	cmp	r3, #0
 80011bc:	d10c      	bne.n	80011d8 <HAL_RCC_OscConfig+0x33c>
 80011be:	4a81      	ldr	r2, [pc, #516]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80011c0:	4b80      	ldr	r3, [pc, #512]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80011c2:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80011c4:	f023 0301 	bic.w	r3, r3, #1
 80011c8:	6713      	str	r3, [r2, #112]	; 0x70
 80011ca:	4a7e      	ldr	r2, [pc, #504]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80011cc:	4b7d      	ldr	r3, [pc, #500]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80011ce:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80011d0:	f023 0304 	bic.w	r3, r3, #4
 80011d4:	6713      	str	r3, [r2, #112]	; 0x70
 80011d6:	e01c      	b.n	8001212 <HAL_RCC_OscConfig+0x376>
 80011d8:	687b      	ldr	r3, [r7, #4]
 80011da:	689b      	ldr	r3, [r3, #8]
 80011dc:	2b05      	cmp	r3, #5
 80011de:	d10c      	bne.n	80011fa <HAL_RCC_OscConfig+0x35e>
 80011e0:	4a78      	ldr	r2, [pc, #480]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80011e2:	4b78      	ldr	r3, [pc, #480]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80011e4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80011e6:	f043 0304 	orr.w	r3, r3, #4
 80011ea:	6713      	str	r3, [r2, #112]	; 0x70
 80011ec:	4a75      	ldr	r2, [pc, #468]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80011ee:	4b75      	ldr	r3, [pc, #468]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80011f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80011f2:	f043 0301 	orr.w	r3, r3, #1
 80011f6:	6713      	str	r3, [r2, #112]	; 0x70
 80011f8:	e00b      	b.n	8001212 <HAL_RCC_OscConfig+0x376>
 80011fa:	4a72      	ldr	r2, [pc, #456]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80011fc:	4b71      	ldr	r3, [pc, #452]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80011fe:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001200:	f023 0301 	bic.w	r3, r3, #1
 8001204:	6713      	str	r3, [r2, #112]	; 0x70
 8001206:	4a6f      	ldr	r2, [pc, #444]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 8001208:	4b6e      	ldr	r3, [pc, #440]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 800120a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800120c:	f023 0304 	bic.w	r3, r3, #4
 8001210:	6713      	str	r3, [r2, #112]	; 0x70
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8001212:	687b      	ldr	r3, [r7, #4]
 8001214:	689b      	ldr	r3, [r3, #8]
 8001216:	2b00      	cmp	r3, #0
 8001218:	d015      	beq.n	8001246 <HAL_RCC_OscConfig+0x3aa>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800121a:	f7ff faf3 	bl	8000804 <HAL_GetTick>
 800121e:	63f8      	str	r0, [r7, #60]	; 0x3c
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001220:	e00a      	b.n	8001238 <HAL_RCC_OscConfig+0x39c>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001222:	f7ff faef 	bl	8000804 <HAL_GetTick>
 8001226:	4602      	mov	r2, r0
 8001228:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800122a:	1ad3      	subs	r3, r2, r3
 800122c:	f241 3288 	movw	r2, #5000	; 0x1388
 8001230:	4293      	cmp	r3, r2
 8001232:	d901      	bls.n	8001238 <HAL_RCC_OscConfig+0x39c>
        {
          return HAL_TIMEOUT;
 8001234:	2303      	movs	r3, #3
 8001236:	e0c0      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001238:	4b62      	ldr	r3, [pc, #392]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 800123a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800123c:	f003 0302 	and.w	r3, r3, #2
 8001240:	2b00      	cmp	r3, #0
 8001242:	d0ee      	beq.n	8001222 <HAL_RCC_OscConfig+0x386>
 8001244:	e014      	b.n	8001270 <HAL_RCC_OscConfig+0x3d4>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001246:	f7ff fadd 	bl	8000804 <HAL_GetTick>
 800124a:	63f8      	str	r0, [r7, #60]	; 0x3c
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 800124c:	e00a      	b.n	8001264 <HAL_RCC_OscConfig+0x3c8>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800124e:	f7ff fad9 	bl	8000804 <HAL_GetTick>
 8001252:	4602      	mov	r2, r0
 8001254:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8001256:	1ad3      	subs	r3, r2, r3
 8001258:	f241 3288 	movw	r2, #5000	; 0x1388
 800125c:	4293      	cmp	r3, r2
 800125e:	d901      	bls.n	8001264 <HAL_RCC_OscConfig+0x3c8>
        {
          return HAL_TIMEOUT;
 8001260:	2303      	movs	r3, #3
 8001262:	e0aa      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001264:	4b57      	ldr	r3, [pc, #348]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 8001266:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001268:	f003 0302 	and.w	r3, r3, #2
 800126c:	2b00      	cmp	r3, #0
 800126e:	d1ee      	bne.n	800124e <HAL_RCC_OscConfig+0x3b2>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8001270:	687b      	ldr	r3, [r7, #4]
 8001272:	699b      	ldr	r3, [r3, #24]
 8001274:	2b00      	cmp	r3, #0
 8001276:	f000 809f 	beq.w	80013b8 <HAL_RCC_OscConfig+0x51c>
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 800127a:	4b52      	ldr	r3, [pc, #328]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 800127c:	689b      	ldr	r3, [r3, #8]
 800127e:	f003 030c 	and.w	r3, r3, #12
 8001282:	2b08      	cmp	r3, #8
 8001284:	f000 8096 	beq.w	80013b4 <HAL_RCC_OscConfig+0x518>
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001288:	687b      	ldr	r3, [r7, #4]
 800128a:	699b      	ldr	r3, [r3, #24]
 800128c:	2b02      	cmp	r3, #2
 800128e:	d177      	bne.n	8001380 <HAL_RCC_OscConfig+0x4e4>
#if defined (RCC_PLLCFGR_PLLR)
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));
#endif
        
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001290:	4a4c      	ldr	r2, [pc, #304]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 8001292:	4b4c      	ldr	r3, [pc, #304]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 8001294:	681b      	ldr	r3, [r3, #0]
 8001296:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800129a:	6013      	str	r3, [r2, #0]
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800129c:	f7ff fab2 	bl	8000804 <HAL_GetTick>
 80012a0:	63f8      	str	r0, [r7, #60]	; 0x3c
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80012a2:	e008      	b.n	80012b6 <HAL_RCC_OscConfig+0x41a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80012a4:	f7ff faae 	bl	8000804 <HAL_GetTick>
 80012a8:	4602      	mov	r2, r0
 80012aa:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80012ac:	1ad3      	subs	r3, r2, r3
 80012ae:	2b02      	cmp	r3, #2
 80012b0:	d901      	bls.n	80012b6 <HAL_RCC_OscConfig+0x41a>
          {
            return HAL_TIMEOUT;
 80012b2:	2303      	movs	r3, #3
 80012b4:	e081      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80012b6:	4b43      	ldr	r3, [pc, #268]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80012b8:	681b      	ldr	r3, [r3, #0]
 80012ba:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80012be:	2b00      	cmp	r3, #0
 80012c0:	d1f0      	bne.n	80012a4 <HAL_RCC_OscConfig+0x408>
          }
        }
        
        /* Configure the main PLL clock source, multiplication and division factors. */
#if defined (RCC_PLLCFGR_PLLR)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 80012c2:	4840      	ldr	r0, [pc, #256]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80012c4:	687b      	ldr	r3, [r7, #4]
 80012c6:	69da      	ldr	r2, [r3, #28]
 80012c8:	687b      	ldr	r3, [r7, #4]
 80012ca:	6a1b      	ldr	r3, [r3, #32]
 80012cc:	431a      	orrs	r2, r3
 80012ce:	687b      	ldr	r3, [r7, #4]
 80012d0:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80012d2:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80012d6:	62bb      	str	r3, [r7, #40]	; 0x28
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80012d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80012da:	fa93 f3a3 	rbit	r3, r3
 80012de:	627b      	str	r3, [r7, #36]	; 0x24
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 80012e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80012e2:	fab3 f383 	clz	r3, r3
 80012e6:	fa01 f303 	lsl.w	r3, r1, r3
 80012ea:	431a      	orrs	r2, r3
 80012ec:	687b      	ldr	r3, [r7, #4]
 80012ee:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80012f0:	085b      	lsrs	r3, r3, #1
 80012f2:	1e59      	subs	r1, r3, #1
 80012f4:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 80012f8:	623b      	str	r3, [r7, #32]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80012fa:	6a3b      	ldr	r3, [r7, #32]
 80012fc:	fa93 f3a3 	rbit	r3, r3
 8001300:	61fb      	str	r3, [r7, #28]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001302:	69fb      	ldr	r3, [r7, #28]
 8001304:	fab3 f383 	clz	r3, r3
 8001308:	fa01 f303 	lsl.w	r3, r1, r3
 800130c:	431a      	orrs	r2, r3
 800130e:	687b      	ldr	r3, [r7, #4]
 8001310:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8001312:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 8001316:	61bb      	str	r3, [r7, #24]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001318:	69bb      	ldr	r3, [r7, #24]
 800131a:	fa93 f3a3 	rbit	r3, r3
 800131e:	617b      	str	r3, [r7, #20]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001320:	697b      	ldr	r3, [r7, #20]
 8001322:	fab3 f383 	clz	r3, r3
 8001326:	fa01 f303 	lsl.w	r3, r1, r3
 800132a:	431a      	orrs	r2, r3
 800132c:	687b      	ldr	r3, [r7, #4]
 800132e:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8001330:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 8001334:	613b      	str	r3, [r7, #16]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001336:	693b      	ldr	r3, [r7, #16]
 8001338:	fa93 f3a3 	rbit	r3, r3
 800133c:	60fb      	str	r3, [r7, #12]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 800133e:	68fb      	ldr	r3, [r7, #12]
 8001340:	fab3 f383 	clz	r3, r3
 8001344:	fa01 f303 	lsl.w	r3, r1, r3
 8001348:	4313      	orrs	r3, r2
 800134a:	6043      	str	r3, [r0, #4]
                             RCC_OscInitStruct->PLL.PLLP,
                             RCC_OscInitStruct->PLL.PLLQ);
#endif

        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800134c:	4a1d      	ldr	r2, [pc, #116]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 800134e:	4b1d      	ldr	r3, [pc, #116]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 8001350:	681b      	ldr	r3, [r3, #0]
 8001352:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001356:	6013      	str	r3, [r2, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001358:	f7ff fa54 	bl	8000804 <HAL_GetTick>
 800135c:	63f8      	str	r0, [r7, #60]	; 0x3c
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 800135e:	e008      	b.n	8001372 <HAL_RCC_OscConfig+0x4d6>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001360:	f7ff fa50 	bl	8000804 <HAL_GetTick>
 8001364:	4602      	mov	r2, r0
 8001366:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8001368:	1ad3      	subs	r3, r2, r3
 800136a:	2b02      	cmp	r3, #2
 800136c:	d901      	bls.n	8001372 <HAL_RCC_OscConfig+0x4d6>
          {
            return HAL_TIMEOUT;
 800136e:	2303      	movs	r3, #3
 8001370:	e023      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001372:	4b14      	ldr	r3, [pc, #80]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 8001374:	681b      	ldr	r3, [r3, #0]
 8001376:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800137a:	2b00      	cmp	r3, #0
 800137c:	d0f0      	beq.n	8001360 <HAL_RCC_OscConfig+0x4c4>
 800137e:	e01b      	b.n	80013b8 <HAL_RCC_OscConfig+0x51c>
        }
      }
      else
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001380:	4a10      	ldr	r2, [pc, #64]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 8001382:	4b10      	ldr	r3, [pc, #64]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 8001384:	681b      	ldr	r3, [r3, #0]
 8001386:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800138a:	6013      	str	r3, [r2, #0]
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 800138c:	f7ff fa3a 	bl	8000804 <HAL_GetTick>
 8001390:	63f8      	str	r0, [r7, #60]	; 0x3c
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 8001392:	e008      	b.n	80013a6 <HAL_RCC_OscConfig+0x50a>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001394:	f7ff fa36 	bl	8000804 <HAL_GetTick>
 8001398:	4602      	mov	r2, r0
 800139a:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800139c:	1ad3      	subs	r3, r2, r3
 800139e:	2b02      	cmp	r3, #2
 80013a0:	d901      	bls.n	80013a6 <HAL_RCC_OscConfig+0x50a>
          {
            return HAL_TIMEOUT;
 80013a2:	2303      	movs	r3, #3
 80013a4:	e009      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80013a6:	4b07      	ldr	r3, [pc, #28]	; (80013c4 <HAL_RCC_OscConfig+0x528>)
 80013a8:	681b      	ldr	r3, [r3, #0]
 80013aa:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80013ae:	2b00      	cmp	r3, #0
 80013b0:	d1f0      	bne.n	8001394 <HAL_RCC_OscConfig+0x4f8>
 80013b2:	e001      	b.n	80013b8 <HAL_RCC_OscConfig+0x51c>
        }
      }
    }
    else
    {
      return HAL_ERROR;
 80013b4:	2301      	movs	r3, #1
 80013b6:	e000      	b.n	80013ba <HAL_RCC_OscConfig+0x51e>
    }
  }
  return HAL_OK;
 80013b8:	2300      	movs	r3, #0
}
 80013ba:	4618      	mov	r0, r3
 80013bc:	3740      	adds	r7, #64	; 0x40
 80013be:	46bd      	mov	sp, r7
 80013c0:	bd80      	pop	{r7, pc}
 80013c2:	bf00      	nop
 80013c4:	40023800 	.word	0x40023800
 80013c8:	40007000 	.word	0x40007000

080013cc <HAL_RCC_ClockConfig>:
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 80013cc:	b580      	push	{r7, lr}
 80013ce:	b086      	sub	sp, #24
 80013d0:	af00      	add	r7, sp, #0
 80013d2:	6078      	str	r0, [r7, #4]
 80013d4:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;
 80013d6:	2300      	movs	r3, #0
 80013d8:	617b      	str	r3, [r7, #20]
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
  must be correctly programmed according to the frequency of the CPU clock 
  (HCLK) and the supply voltage of the device. */
  
  /* Increasing the CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 80013da:	4b78      	ldr	r3, [pc, #480]	; (80015bc <HAL_RCC_ClockConfig+0x1f0>)
 80013dc:	681b      	ldr	r3, [r3, #0]
 80013de:	f003 020f 	and.w	r2, r3, #15
 80013e2:	683b      	ldr	r3, [r7, #0]
 80013e4:	429a      	cmp	r2, r3
 80013e6:	d210      	bcs.n	800140a <HAL_RCC_ClockConfig+0x3e>
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 80013e8:	4974      	ldr	r1, [pc, #464]	; (80015bc <HAL_RCC_ClockConfig+0x1f0>)
 80013ea:	4b74      	ldr	r3, [pc, #464]	; (80015bc <HAL_RCC_ClockConfig+0x1f0>)
 80013ec:	681b      	ldr	r3, [r3, #0]
 80013ee:	f023 020f 	bic.w	r2, r3, #15
 80013f2:	683b      	ldr	r3, [r7, #0]
 80013f4:	4313      	orrs	r3, r2
 80013f6:	600b      	str	r3, [r1, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 80013f8:	4b70      	ldr	r3, [pc, #448]	; (80015bc <HAL_RCC_ClockConfig+0x1f0>)
 80013fa:	681b      	ldr	r3, [r3, #0]
 80013fc:	f003 020f 	and.w	r2, r3, #15
 8001400:	683b      	ldr	r3, [r7, #0]
 8001402:	429a      	cmp	r2, r3
 8001404:	d001      	beq.n	800140a <HAL_RCC_ClockConfig+0x3e>
    {
      return HAL_ERROR;
 8001406:	2301      	movs	r3, #1
 8001408:	e0d3      	b.n	80015b2 <HAL_RCC_ClockConfig+0x1e6>
    }
  }
  
  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800140a:	687b      	ldr	r3, [r7, #4]
 800140c:	681b      	ldr	r3, [r3, #0]
 800140e:	f003 0302 	and.w	r3, r3, #2
 8001412:	2b00      	cmp	r3, #0
 8001414:	d008      	beq.n	8001428 <HAL_RCC_ClockConfig+0x5c>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001416:	496a      	ldr	r1, [pc, #424]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 8001418:	4b69      	ldr	r3, [pc, #420]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 800141a:	689b      	ldr	r3, [r3, #8]
 800141c:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8001420:	687b      	ldr	r3, [r7, #4]
 8001422:	689b      	ldr	r3, [r3, #8]
 8001424:	4313      	orrs	r3, r2
 8001426:	608b      	str	r3, [r1, #8]
  }
  
  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001428:	687b      	ldr	r3, [r7, #4]
 800142a:	681b      	ldr	r3, [r3, #0]
 800142c:	f003 0301 	and.w	r3, r3, #1
 8001430:	2b00      	cmp	r3, #0
 8001432:	d06b      	beq.n	800150c <HAL_RCC_ClockConfig+0x140>
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001434:	687b      	ldr	r3, [r7, #4]
 8001436:	685b      	ldr	r3, [r3, #4]
 8001438:	2b01      	cmp	r3, #1
 800143a:	d107      	bne.n	800144c <HAL_RCC_ClockConfig+0x80>
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 800143c:	4b60      	ldr	r3, [pc, #384]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 800143e:	681b      	ldr	r3, [r3, #0]
 8001440:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001444:	2b00      	cmp	r3, #0
 8001446:	d115      	bne.n	8001474 <HAL_RCC_ClockConfig+0xa8>
      {
        return HAL_ERROR;
 8001448:	2301      	movs	r3, #1
 800144a:	e0b2      	b.n	80015b2 <HAL_RCC_ClockConfig+0x1e6>
      }
    }
    /* PLL is selected as System Clock Source */
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800144c:	687b      	ldr	r3, [r7, #4]
 800144e:	685b      	ldr	r3, [r3, #4]
 8001450:	2b02      	cmp	r3, #2
 8001452:	d107      	bne.n	8001464 <HAL_RCC_ClockConfig+0x98>
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8001454:	4b5a      	ldr	r3, [pc, #360]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 8001456:	681b      	ldr	r3, [r3, #0]
 8001458:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800145c:	2b00      	cmp	r3, #0
 800145e:	d109      	bne.n	8001474 <HAL_RCC_ClockConfig+0xa8>
      {
        return HAL_ERROR;
 8001460:	2301      	movs	r3, #1
 8001462:	e0a6      	b.n	80015b2 <HAL_RCC_ClockConfig+0x1e6>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001464:	4b56      	ldr	r3, [pc, #344]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 8001466:	681b      	ldr	r3, [r3, #0]
 8001468:	f003 0302 	and.w	r3, r3, #2
 800146c:	2b00      	cmp	r3, #0
 800146e:	d101      	bne.n	8001474 <HAL_RCC_ClockConfig+0xa8>
      {
        return HAL_ERROR;
 8001470:	2301      	movs	r3, #1
 8001472:	e09e      	b.n	80015b2 <HAL_RCC_ClockConfig+0x1e6>
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 8001474:	4952      	ldr	r1, [pc, #328]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 8001476:	4b52      	ldr	r3, [pc, #328]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 8001478:	689b      	ldr	r3, [r3, #8]
 800147a:	f023 0203 	bic.w	r2, r3, #3
 800147e:	687b      	ldr	r3, [r7, #4]
 8001480:	685b      	ldr	r3, [r3, #4]
 8001482:	4313      	orrs	r3, r2
 8001484:	608b      	str	r3, [r1, #8]
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001486:	f7ff f9bd 	bl	8000804 <HAL_GetTick>
 800148a:	6178      	str	r0, [r7, #20]
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800148c:	687b      	ldr	r3, [r7, #4]
 800148e:	685b      	ldr	r3, [r3, #4]
 8001490:	2b01      	cmp	r3, #1
 8001492:	d112      	bne.n	80014ba <HAL_RCC_ClockConfig+0xee>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 8001494:	e00a      	b.n	80014ac <HAL_RCC_ClockConfig+0xe0>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001496:	f7ff f9b5 	bl	8000804 <HAL_GetTick>
 800149a:	4602      	mov	r2, r0
 800149c:	697b      	ldr	r3, [r7, #20]
 800149e:	1ad3      	subs	r3, r2, r3
 80014a0:	f241 3288 	movw	r2, #5000	; 0x1388
 80014a4:	4293      	cmp	r3, r2
 80014a6:	d901      	bls.n	80014ac <HAL_RCC_ClockConfig+0xe0>
        {
          return HAL_TIMEOUT;
 80014a8:	2303      	movs	r3, #3
 80014aa:	e082      	b.n	80015b2 <HAL_RCC_ClockConfig+0x1e6>
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80014ac:	4b44      	ldr	r3, [pc, #272]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 80014ae:	689b      	ldr	r3, [r3, #8]
 80014b0:	f003 030c 	and.w	r3, r3, #12
 80014b4:	2b04      	cmp	r3, #4
 80014b6:	d1ee      	bne.n	8001496 <HAL_RCC_ClockConfig+0xca>
 80014b8:	e028      	b.n	800150c <HAL_RCC_ClockConfig+0x140>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80014ba:	687b      	ldr	r3, [r7, #4]
 80014bc:	685b      	ldr	r3, [r3, #4]
 80014be:	2b02      	cmp	r3, #2
 80014c0:	d112      	bne.n	80014e8 <HAL_RCC_ClockConfig+0x11c>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80014c2:	e00a      	b.n	80014da <HAL_RCC_ClockConfig+0x10e>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80014c4:	f7ff f99e 	bl	8000804 <HAL_GetTick>
 80014c8:	4602      	mov	r2, r0
 80014ca:	697b      	ldr	r3, [r7, #20]
 80014cc:	1ad3      	subs	r3, r2, r3
 80014ce:	f241 3288 	movw	r2, #5000	; 0x1388
 80014d2:	4293      	cmp	r3, r2
 80014d4:	d901      	bls.n	80014da <HAL_RCC_ClockConfig+0x10e>
        {
          return HAL_TIMEOUT;
 80014d6:	2303      	movs	r3, #3
 80014d8:	e06b      	b.n	80015b2 <HAL_RCC_ClockConfig+0x1e6>
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80014da:	4b39      	ldr	r3, [pc, #228]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 80014dc:	689b      	ldr	r3, [r3, #8]
 80014de:	f003 030c 	and.w	r3, r3, #12
 80014e2:	2b08      	cmp	r3, #8
 80014e4:	d1ee      	bne.n	80014c4 <HAL_RCC_ClockConfig+0xf8>
 80014e6:	e011      	b.n	800150c <HAL_RCC_ClockConfig+0x140>
        }
      }
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 80014e8:	e00a      	b.n	8001500 <HAL_RCC_ClockConfig+0x134>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80014ea:	f7ff f98b 	bl	8000804 <HAL_GetTick>
 80014ee:	4602      	mov	r2, r0
 80014f0:	697b      	ldr	r3, [r7, #20]
 80014f2:	1ad3      	subs	r3, r2, r3
 80014f4:	f241 3288 	movw	r2, #5000	; 0x1388
 80014f8:	4293      	cmp	r3, r2
 80014fa:	d901      	bls.n	8001500 <HAL_RCC_ClockConfig+0x134>
        {
          return HAL_TIMEOUT;
 80014fc:	2303      	movs	r3, #3
 80014fe:	e058      	b.n	80015b2 <HAL_RCC_ClockConfig+0x1e6>
        }
      }
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 8001500:	4b2f      	ldr	r3, [pc, #188]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 8001502:	689b      	ldr	r3, [r3, #8]
 8001504:	f003 030c 	and.w	r3, r3, #12
 8001508:	2b00      	cmp	r3, #0
 800150a:	d1ee      	bne.n	80014ea <HAL_RCC_ClockConfig+0x11e>
      }
    }
  }
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 800150c:	4b2b      	ldr	r3, [pc, #172]	; (80015bc <HAL_RCC_ClockConfig+0x1f0>)
 800150e:	681b      	ldr	r3, [r3, #0]
 8001510:	f003 020f 	and.w	r2, r3, #15
 8001514:	683b      	ldr	r3, [r7, #0]
 8001516:	429a      	cmp	r2, r3
 8001518:	d910      	bls.n	800153c <HAL_RCC_ClockConfig+0x170>
  {
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800151a:	4928      	ldr	r1, [pc, #160]	; (80015bc <HAL_RCC_ClockConfig+0x1f0>)
 800151c:	4b27      	ldr	r3, [pc, #156]	; (80015bc <HAL_RCC_ClockConfig+0x1f0>)
 800151e:	681b      	ldr	r3, [r3, #0]
 8001520:	f023 020f 	bic.w	r2, r3, #15
 8001524:	683b      	ldr	r3, [r7, #0]
 8001526:	4313      	orrs	r3, r2
 8001528:	600b      	str	r3, [r1, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800152a:	4b24      	ldr	r3, [pc, #144]	; (80015bc <HAL_RCC_ClockConfig+0x1f0>)
 800152c:	681b      	ldr	r3, [r3, #0]
 800152e:	f003 020f 	and.w	r2, r3, #15
 8001532:	683b      	ldr	r3, [r7, #0]
 8001534:	429a      	cmp	r2, r3
 8001536:	d001      	beq.n	800153c <HAL_RCC_ClockConfig+0x170>
    {
      return HAL_ERROR;
 8001538:	2301      	movs	r3, #1
 800153a:	e03a      	b.n	80015b2 <HAL_RCC_ClockConfig+0x1e6>
    }
  }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 800153c:	687b      	ldr	r3, [r7, #4]
 800153e:	681b      	ldr	r3, [r3, #0]
 8001540:	f003 0304 	and.w	r3, r3, #4
 8001544:	2b00      	cmp	r3, #0
 8001546:	d008      	beq.n	800155a <HAL_RCC_ClockConfig+0x18e>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8001548:	491d      	ldr	r1, [pc, #116]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 800154a:	4b1d      	ldr	r3, [pc, #116]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 800154c:	689b      	ldr	r3, [r3, #8]
 800154e:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8001552:	687b      	ldr	r3, [r7, #4]
 8001554:	68db      	ldr	r3, [r3, #12]
 8001556:	4313      	orrs	r3, r2
 8001558:	608b      	str	r3, [r1, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800155a:	687b      	ldr	r3, [r7, #4]
 800155c:	681b      	ldr	r3, [r3, #0]
 800155e:	f003 0308 	and.w	r3, r3, #8
 8001562:	2b00      	cmp	r3, #0
 8001564:	d009      	beq.n	800157a <HAL_RCC_ClockConfig+0x1ae>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3));
 8001566:	4916      	ldr	r1, [pc, #88]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 8001568:	4b15      	ldr	r3, [pc, #84]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 800156a:	689b      	ldr	r3, [r3, #8]
 800156c:	f423 4260 	bic.w	r2, r3, #57344	; 0xe000
 8001570:	687b      	ldr	r3, [r7, #4]
 8001572:	691b      	ldr	r3, [r3, #16]
 8001574:	00db      	lsls	r3, r3, #3
 8001576:	4313      	orrs	r3, r2
 8001578:	608b      	str	r3, [r1, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 800157a:	f000 f827 	bl	80015cc <HAL_RCC_GetSysClockFreq>
 800157e:	4601      	mov	r1, r0
 8001580:	4b0f      	ldr	r3, [pc, #60]	; (80015c0 <HAL_RCC_ClockConfig+0x1f4>)
 8001582:	689b      	ldr	r3, [r3, #8]
 8001584:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8001588:	23f0      	movs	r3, #240	; 0xf0
 800158a:	613b      	str	r3, [r7, #16]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800158c:	693b      	ldr	r3, [r7, #16]
 800158e:	fa93 f3a3 	rbit	r3, r3
 8001592:	60fb      	str	r3, [r7, #12]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001594:	68fb      	ldr	r3, [r7, #12]
 8001596:	fab3 f383 	clz	r3, r3
 800159a:	fa22 f303 	lsr.w	r3, r2, r3
 800159e:	4a09      	ldr	r2, [pc, #36]	; (80015c4 <HAL_RCC_ClockConfig+0x1f8>)
 80015a0:	5cd3      	ldrb	r3, [r2, r3]
 80015a2:	fa21 f303 	lsr.w	r3, r1, r3
 80015a6:	4a08      	ldr	r2, [pc, #32]	; (80015c8 <HAL_RCC_ClockConfig+0x1fc>)
 80015a8:	6013      	str	r3, [r2, #0]
  
  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 80015aa:	2000      	movs	r0, #0
 80015ac:	f00f f84c 	bl	8010648 <HAL_InitTick>
  
  return HAL_OK;
 80015b0:	2300      	movs	r3, #0
}
 80015b2:	4618      	mov	r0, r3
 80015b4:	3718      	adds	r7, #24
 80015b6:	46bd      	mov	sp, r7
 80015b8:	bd80      	pop	{r7, pc}
 80015ba:	bf00      	nop
 80015bc:	40023c00 	.word	0x40023c00
 80015c0:	40023800 	.word	0x40023800
 80015c4:	08012a64 	.word	0x08012a64
 80015c8:	2000bb58 	.word	0x2000bb58

080015cc <HAL_RCC_GetSysClockFreq>:
  *         
  *               
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 80015cc:	b480      	push	{r7}
 80015ce:	b08b      	sub	sp, #44	; 0x2c
 80015d0:	af00      	add	r7, sp, #0
  uint32_t pllm = 0, pllvco = 0, pllp = 0;
 80015d2:	2300      	movs	r3, #0
 80015d4:	61fb      	str	r3, [r7, #28]
 80015d6:	2300      	movs	r3, #0
 80015d8:	627b      	str	r3, [r7, #36]	; 0x24
 80015da:	2300      	movs	r3, #0
 80015dc:	61bb      	str	r3, [r7, #24]
  uint32_t sysclockfreq = 0;
 80015de:	2300      	movs	r3, #0
 80015e0:	623b      	str	r3, [r7, #32]

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80015e2:	4b36      	ldr	r3, [pc, #216]	; (80016bc <HAL_RCC_GetSysClockFreq+0xf0>)
 80015e4:	689b      	ldr	r3, [r3, #8]
 80015e6:	f003 030c 	and.w	r3, r3, #12
 80015ea:	2b04      	cmp	r3, #4
 80015ec:	d006      	beq.n	80015fc <HAL_RCC_GetSysClockFreq+0x30>
 80015ee:	2b08      	cmp	r3, #8
 80015f0:	d007      	beq.n	8001602 <HAL_RCC_GetSysClockFreq+0x36>
 80015f2:	2b00      	cmp	r3, #0
 80015f4:	d158      	bne.n	80016a8 <HAL_RCC_GetSysClockFreq+0xdc>
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 80015f6:	4b32      	ldr	r3, [pc, #200]	; (80016c0 <HAL_RCC_GetSysClockFreq+0xf4>)
 80015f8:	623b      	str	r3, [r7, #32]
       break;
 80015fa:	e058      	b.n	80016ae <HAL_RCC_GetSysClockFreq+0xe2>
    }
    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 80015fc:	4b31      	ldr	r3, [pc, #196]	; (80016c4 <HAL_RCC_GetSysClockFreq+0xf8>)
 80015fe:	623b      	str	r3, [r7, #32]
      break;
 8001600:	e055      	b.n	80016ae <HAL_RCC_GetSysClockFreq+0xe2>
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 8001602:	4b2e      	ldr	r3, [pc, #184]	; (80016bc <HAL_RCC_GetSysClockFreq+0xf0>)
 8001604:	685b      	ldr	r3, [r3, #4]
 8001606:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800160a:	61fb      	str	r3, [r7, #28]
      if (__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLCFGR_PLLSRC_HSI)
 800160c:	4b2b      	ldr	r3, [pc, #172]	; (80016bc <HAL_RCC_GetSysClockFreq+0xf0>)
 800160e:	685b      	ldr	r3, [r3, #4]
 8001610:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8001614:	2b00      	cmp	r3, #0
 8001616:	d017      	beq.n	8001648 <HAL_RCC_GetSysClockFreq+0x7c>
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8001618:	4a2a      	ldr	r2, [pc, #168]	; (80016c4 <HAL_RCC_GetSysClockFreq+0xf8>)
 800161a:	69fb      	ldr	r3, [r7, #28]
 800161c:	fbb2 f2f3 	udiv	r2, r2, r3
 8001620:	4b26      	ldr	r3, [pc, #152]	; (80016bc <HAL_RCC_GetSysClockFreq+0xf0>)
 8001622:	6859      	ldr	r1, [r3, #4]
 8001624:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8001628:	400b      	ands	r3, r1
 800162a:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 800162e:	6179      	str	r1, [r7, #20]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001630:	6979      	ldr	r1, [r7, #20]
 8001632:	fa91 f1a1 	rbit	r1, r1
 8001636:	6139      	str	r1, [r7, #16]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001638:	6939      	ldr	r1, [r7, #16]
 800163a:	fab1 f181 	clz	r1, r1
 800163e:	40cb      	lsrs	r3, r1
 8001640:	fb03 f302 	mul.w	r3, r3, r2
 8001644:	627b      	str	r3, [r7, #36]	; 0x24
 8001646:	e016      	b.n	8001676 <HAL_RCC_GetSysClockFreq+0xaa>
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8001648:	4a1d      	ldr	r2, [pc, #116]	; (80016c0 <HAL_RCC_GetSysClockFreq+0xf4>)
 800164a:	69fb      	ldr	r3, [r7, #28]
 800164c:	fbb2 f2f3 	udiv	r2, r2, r3
 8001650:	4b1a      	ldr	r3, [pc, #104]	; (80016bc <HAL_RCC_GetSysClockFreq+0xf0>)
 8001652:	6859      	ldr	r1, [r3, #4]
 8001654:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8001658:	400b      	ands	r3, r1
 800165a:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 800165e:	60f9      	str	r1, [r7, #12]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001660:	68f9      	ldr	r1, [r7, #12]
 8001662:	fa91 f1a1 	rbit	r1, r1
 8001666:	60b9      	str	r1, [r7, #8]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001668:	68b9      	ldr	r1, [r7, #8]
 800166a:	fab1 f181 	clz	r1, r1
 800166e:	40cb      	lsrs	r3, r1
 8001670:	fb03 f302 	mul.w	r3, r3, r2
 8001674:	627b      	str	r3, [r7, #36]	; 0x24
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1 ) *2);
 8001676:	4b11      	ldr	r3, [pc, #68]	; (80016bc <HAL_RCC_GetSysClockFreq+0xf0>)
 8001678:	685b      	ldr	r3, [r3, #4]
 800167a:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 800167e:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8001682:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001684:	687b      	ldr	r3, [r7, #4]
 8001686:	fa93 f3a3 	rbit	r3, r3
 800168a:	603b      	str	r3, [r7, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 800168c:	683b      	ldr	r3, [r7, #0]
 800168e:	fab3 f383 	clz	r3, r3
 8001692:	fa22 f303 	lsr.w	r3, r2, r3
 8001696:	3301      	adds	r3, #1
 8001698:	005b      	lsls	r3, r3, #1
 800169a:	61bb      	str	r3, [r7, #24]
      
      sysclockfreq = pllvco/pllp;
 800169c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800169e:	69bb      	ldr	r3, [r7, #24]
 80016a0:	fbb2 f3f3 	udiv	r3, r2, r3
 80016a4:	623b      	str	r3, [r7, #32]
      break;
 80016a6:	e002      	b.n	80016ae <HAL_RCC_GetSysClockFreq+0xe2>
    }
    default:
    {
      sysclockfreq = HSI_VALUE;
 80016a8:	4b05      	ldr	r3, [pc, #20]	; (80016c0 <HAL_RCC_GetSysClockFreq+0xf4>)
 80016aa:	623b      	str	r3, [r7, #32]
      break;
 80016ac:	bf00      	nop
    }
  }
  return sysclockfreq;
 80016ae:	6a3b      	ldr	r3, [r7, #32]
}
 80016b0:	4618      	mov	r0, r3
 80016b2:	372c      	adds	r7, #44	; 0x2c
 80016b4:	46bd      	mov	sp, r7
 80016b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016ba:	4770      	bx	lr
 80016bc:	40023800 	.word	0x40023800
 80016c0:	00f42400 	.word	0x00f42400
 80016c4:	017d7840 	.word	0x017d7840

080016c8 <HAL_RCC_GetHCLKFreq>:
  *         right HCLK value. Otherwise, any configuration based on this function will be incorrect. 
  * @note   The SystemCoreClock CMSIS variable is used to store System Clock Frequency.
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 80016c8:	b480      	push	{r7}
 80016ca:	af00      	add	r7, sp, #0
  return SystemCoreClock;
 80016cc:	4b03      	ldr	r3, [pc, #12]	; (80016dc <HAL_RCC_GetHCLKFreq+0x14>)
 80016ce:	681b      	ldr	r3, [r3, #0]
}
 80016d0:	4618      	mov	r0, r3
 80016d2:	46bd      	mov	sp, r7
 80016d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80016d8:	4770      	bx	lr
 80016da:	bf00      	nop
 80016dc:	2000bb58 	.word	0x2000bb58

080016e0 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
 80016e0:	b580      	push	{r7, lr}
 80016e2:	b082      	sub	sp, #8
 80016e4:	af00      	add	r7, sp, #0
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 80016e6:	f7ff ffef 	bl	80016c8 <HAL_RCC_GetHCLKFreq>
 80016ea:	4601      	mov	r1, r0
 80016ec:	4b0b      	ldr	r3, [pc, #44]	; (800171c <HAL_RCC_GetPCLK1Freq+0x3c>)
 80016ee:	689b      	ldr	r3, [r3, #8]
 80016f0:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
 80016f4:	f44f 53e0 	mov.w	r3, #7168	; 0x1c00
 80016f8:	607b      	str	r3, [r7, #4]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80016fa:	687b      	ldr	r3, [r7, #4]
 80016fc:	fa93 f3a3 	rbit	r3, r3
 8001700:	603b      	str	r3, [r7, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001702:	683b      	ldr	r3, [r7, #0]
 8001704:	fab3 f383 	clz	r3, r3
 8001708:	fa22 f303 	lsr.w	r3, r2, r3
 800170c:	4a04      	ldr	r2, [pc, #16]	; (8001720 <HAL_RCC_GetPCLK1Freq+0x40>)
 800170e:	5cd3      	ldrb	r3, [r2, r3]
 8001710:	fa21 f303 	lsr.w	r3, r1, r3
}
 8001714:	4618      	mov	r0, r3
 8001716:	3708      	adds	r7, #8
 8001718:	46bd      	mov	sp, r7
 800171a:	bd80      	pop	{r7, pc}
 800171c:	40023800 	.word	0x40023800
 8001720:	08012a74 	.word	0x08012a74

08001724 <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency: Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 8001724:	b480      	push	{r7}
 8001726:	b083      	sub	sp, #12
 8001728:	af00      	add	r7, sp, #0
 800172a:	6078      	str	r0, [r7, #4]
 800172c:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 800172e:	687b      	ldr	r3, [r7, #4]
 8001730:	220f      	movs	r2, #15
 8001732:	601a      	str	r2, [r3, #0]
   
  /* Get the SYSCLK configuration --------------------------------------------*/ 
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8001734:	4b11      	ldr	r3, [pc, #68]	; (800177c <HAL_RCC_GetClockConfig+0x58>)
 8001736:	689b      	ldr	r3, [r3, #8]
 8001738:	f003 0203 	and.w	r2, r3, #3
 800173c:	687b      	ldr	r3, [r7, #4]
 800173e:	605a      	str	r2, [r3, #4]
  
  /* Get the HCLK configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
 8001740:	4b0e      	ldr	r3, [pc, #56]	; (800177c <HAL_RCC_GetClockConfig+0x58>)
 8001742:	689b      	ldr	r3, [r3, #8]
 8001744:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 8001748:	687b      	ldr	r3, [r7, #4]
 800174a:	609a      	str	r2, [r3, #8]
  
  /* Get the APB1 configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
 800174c:	4b0b      	ldr	r3, [pc, #44]	; (800177c <HAL_RCC_GetClockConfig+0x58>)
 800174e:	689b      	ldr	r3, [r3, #8]
 8001750:	f403 52e0 	and.w	r2, r3, #7168	; 0x1c00
 8001754:	687b      	ldr	r3, [r7, #4]
 8001756:	60da      	str	r2, [r3, #12]
  
  /* Get the APB2 configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3);
 8001758:	4b08      	ldr	r3, [pc, #32]	; (800177c <HAL_RCC_GetClockConfig+0x58>)
 800175a:	689b      	ldr	r3, [r3, #8]
 800175c:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8001760:	08da      	lsrs	r2, r3, #3
 8001762:	687b      	ldr	r3, [r7, #4]
 8001764:	611a      	str	r2, [r3, #16]
  
  /* Get the Flash Wait State (Latency) configuration ------------------------*/   
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
 8001766:	4b06      	ldr	r3, [pc, #24]	; (8001780 <HAL_RCC_GetClockConfig+0x5c>)
 8001768:	681b      	ldr	r3, [r3, #0]
 800176a:	f003 020f 	and.w	r2, r3, #15
 800176e:	683b      	ldr	r3, [r7, #0]
 8001770:	601a      	str	r2, [r3, #0]
}
 8001772:	370c      	adds	r7, #12
 8001774:	46bd      	mov	sp, r7
 8001776:	f85d 7b04 	ldr.w	r7, [sp], #4
 800177a:	4770      	bx	lr
 800177c:	40023800 	.word	0x40023800
 8001780:	40023c00 	.word	0x40023c00

08001784 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8001784:	b590      	push	{r4, r7, lr}
 8001786:	b0d9      	sub	sp, #356	; 0x164
 8001788:	af00      	add	r7, sp, #0
 800178a:	1d3b      	adds	r3, r7, #4
 800178c:	6018      	str	r0, [r3, #0]
  uint32_t tickstart = 0;
 800178e:	2300      	movs	r3, #0
 8001790:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
  uint32_t tmpreg0 = 0;
 8001794:	2300      	movs	r3, #0
 8001796:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
  uint32_t tmpreg1 = 0;
 800179a:	2300      	movs	r3, #0
 800179c:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
  uint32_t plli2sused = 0;
 80017a0:	2300      	movs	r3, #0
 80017a2:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
  uint32_t pllsaiused = 0;
 80017a6:	2300      	movs	r3, #0
 80017a8:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*----------------------------------- I2S configuration ----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 80017ac:	1d3b      	adds	r3, r7, #4
 80017ae:	681b      	ldr	r3, [r3, #0]
 80017b0:	681b      	ldr	r3, [r3, #0]
 80017b2:	f003 0301 	and.w	r3, r3, #1
 80017b6:	2b00      	cmp	r3, #0
 80017b8:	d015      	beq.n	80017e6 <HAL_RCCEx_PeriphCLKConfig+0x62>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));
    
    /* Configure I2S Clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 80017ba:	4a7c      	ldr	r2, [pc, #496]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 80017bc:	4b7b      	ldr	r3, [pc, #492]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 80017be:	689b      	ldr	r3, [r3, #8]
 80017c0:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 80017c4:	6093      	str	r3, [r2, #8]
 80017c6:	4979      	ldr	r1, [pc, #484]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 80017c8:	4b78      	ldr	r3, [pc, #480]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 80017ca:	689a      	ldr	r2, [r3, #8]
 80017cc:	1d3b      	adds	r3, r7, #4
 80017ce:	681b      	ldr	r3, [r3, #0]
 80017d0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80017d2:	4313      	orrs	r3, r2
 80017d4:	608b      	str	r3, [r1, #8]
    
    /* Enable the PLLI2S when it's used as clock source for I2S */
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)
 80017d6:	1d3b      	adds	r3, r7, #4
 80017d8:	681b      	ldr	r3, [r3, #0]
 80017da:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80017dc:	2b00      	cmp	r3, #0
 80017de:	d102      	bne.n	80017e6 <HAL_RCCEx_PeriphCLKConfig+0x62>
    {
      plli2sused = 1; 
 80017e0:	2301      	movs	r3, #1
 80017e2:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    }
  }
  
  /*------------------------------------ SAI1 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == (RCC_PERIPHCLK_SAI1))
 80017e6:	1d3b      	adds	r3, r7, #4
 80017e8:	681b      	ldr	r3, [r3, #0]
 80017ea:	681b      	ldr	r3, [r3, #0]
 80017ec:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80017f0:	2b00      	cmp	r3, #0
 80017f2:	d01c      	beq.n	800182e <HAL_RCCEx_PeriphCLKConfig+0xaa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));
    
    /* Configure SAI1 Clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 80017f4:	496d      	ldr	r1, [pc, #436]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 80017f6:	4b6d      	ldr	r3, [pc, #436]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 80017f8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80017fc:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8001800:	1d3b      	adds	r3, r7, #4
 8001802:	681b      	ldr	r3, [r3, #0]
 8001804:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001806:	4313      	orrs	r3, r2
 8001808:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)
 800180c:	1d3b      	adds	r3, r7, #4
 800180e:	681b      	ldr	r3, [r3, #0]
 8001810:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001812:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8001816:	d102      	bne.n	800181e <HAL_RCCEx_PeriphCLKConfig+0x9a>
    {
      plli2sused = 1; 
 8001818:	2301      	movs	r3, #1
 800181a:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)
 800181e:	1d3b      	adds	r3, r7, #4
 8001820:	681b      	ldr	r3, [r3, #0]
 8001822:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001824:	2b00      	cmp	r3, #0
 8001826:	d102      	bne.n	800182e <HAL_RCCEx_PeriphCLKConfig+0xaa>
    {
      pllsaiused = 1; 
 8001828:	2301      	movs	r3, #1
 800182a:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    }
  }
  
  /*------------------------------------ SAI2 configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == (RCC_PERIPHCLK_SAI2))
 800182e:	1d3b      	adds	r3, r7, #4
 8001830:	681b      	ldr	r3, [r3, #0]
 8001832:	681b      	ldr	r3, [r3, #0]
 8001834:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8001838:	2b00      	cmp	r3, #0
 800183a:	d01c      	beq.n	8001876 <HAL_RCCEx_PeriphCLKConfig+0xf2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));
    
    /* Configure SAI2 Clock source */
    __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 800183c:	495b      	ldr	r1, [pc, #364]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 800183e:	4b5b      	ldr	r3, [pc, #364]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 8001840:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8001844:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 8001848:	1d3b      	adds	r3, r7, #4
 800184a:	681b      	ldr	r3, [r3, #0]
 800184c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800184e:	4313      	orrs	r3, r2
 8001850:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    
    /* Enable the PLLI2S when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S)
 8001854:	1d3b      	adds	r3, r7, #4
 8001856:	681b      	ldr	r3, [r3, #0]
 8001858:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800185a:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 800185e:	d102      	bne.n	8001866 <HAL_RCCEx_PeriphCLKConfig+0xe2>
    {
      plli2sused = 1; 
 8001860:	2301      	movs	r3, #1
 8001862:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
    }
    /* Enable the PLLSAI when it's used as clock source for SAI */
    if(PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)
 8001866:	1d3b      	adds	r3, r7, #4
 8001868:	681b      	ldr	r3, [r3, #0]
 800186a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800186c:	2b00      	cmp	r3, #0
 800186e:	d102      	bne.n	8001876 <HAL_RCCEx_PeriphCLKConfig+0xf2>
    {
      pllsaiused = 1; 
 8001870:	2301      	movs	r3, #1
 8001872:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    }
  }
  
  /*-------------------------------------- SPDIF-RX Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8001876:	1d3b      	adds	r3, r7, #4
 8001878:	681b      	ldr	r3, [r3, #0]
 800187a:	681b      	ldr	r3, [r3, #0]
 800187c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8001880:	2b00      	cmp	r3, #0
 8001882:	d002      	beq.n	800188a <HAL_RCCEx_PeriphCLKConfig+0x106>
  {    
      plli2sused = 1; 
 8001884:	2301      	movs	r3, #1
 8001886:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
  }  
  
  /*------------------------------------ RTC configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 800188a:	1d3b      	adds	r3, r7, #4
 800188c:	681b      	ldr	r3, [r3, #0]
 800188e:	681b      	ldr	r3, [r3, #0]
 8001890:	f003 0320 	and.w	r3, r3, #32
 8001894:	2b00      	cmp	r3, #0
 8001896:	f000 809f 	beq.w	80019d8 <HAL_RCCEx_PeriphCLKConfig+0x254>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 800189a:	4a44      	ldr	r2, [pc, #272]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 800189c:	4b43      	ldr	r3, [pc, #268]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 800189e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80018a0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80018a4:	6413      	str	r3, [r2, #64]	; 0x40
 80018a6:	4b41      	ldr	r3, [pc, #260]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 80018a8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80018aa:	f003 5280 	and.w	r2, r3, #268435456	; 0x10000000
 80018ae:	f107 0308 	add.w	r3, r7, #8
 80018b2:	601a      	str	r2, [r3, #0]
 80018b4:	f107 0308 	add.w	r3, r7, #8
 80018b8:	681b      	ldr	r3, [r3, #0]
    
    /* Enable write access to Backup domain */
    PWR->CR1 |= PWR_CR1_DBP;
 80018ba:	4a3d      	ldr	r2, [pc, #244]	; (80019b0 <HAL_RCCEx_PeriphCLKConfig+0x22c>)
 80018bc:	4b3c      	ldr	r3, [pc, #240]	; (80019b0 <HAL_RCCEx_PeriphCLKConfig+0x22c>)
 80018be:	681b      	ldr	r3, [r3, #0]
 80018c0:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80018c4:	6013      	str	r3, [r2, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80018c6:	f7fe ff9d 	bl	8000804 <HAL_GetTick>
 80018ca:	f8c7 0154 	str.w	r0, [r7, #340]	; 0x154
    
    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 80018ce:	e00a      	b.n	80018e6 <HAL_RCCEx_PeriphCLKConfig+0x162>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80018d0:	f7fe ff98 	bl	8000804 <HAL_GetTick>
 80018d4:	4602      	mov	r2, r0
 80018d6:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 80018da:	1ad3      	subs	r3, r2, r3
 80018dc:	2b64      	cmp	r3, #100	; 0x64
 80018de:	d902      	bls.n	80018e6 <HAL_RCCEx_PeriphCLKConfig+0x162>
      {
        return HAL_TIMEOUT;
 80018e0:	2303      	movs	r3, #3
 80018e2:	f000 be8a 	b.w	80025fa <HAL_RCCEx_PeriphCLKConfig+0xe76>
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    /* Wait for Backup domain Write protection disable */
    while((PWR->CR1 & PWR_CR1_DBP) == RESET)
 80018e6:	4b32      	ldr	r3, [pc, #200]	; (80019b0 <HAL_RCCEx_PeriphCLKConfig+0x22c>)
 80018e8:	681b      	ldr	r3, [r3, #0]
 80018ea:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80018ee:	2b00      	cmp	r3, #0
 80018f0:	d0ee      	beq.n	80018d0 <HAL_RCCEx_PeriphCLKConfig+0x14c>
        return HAL_TIMEOUT;
      }
    }

    /* Reset the Backup domain only if the RTC Clock source selection is modified */
    tmpreg0 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 80018f2:	4b2e      	ldr	r3, [pc, #184]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 80018f4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80018f6:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80018fa:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150

    if((tmpreg0 != 0x00000000U) && (tmpreg0 != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 80018fe:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8001902:	2b00      	cmp	r3, #0
 8001904:	d03c      	beq.n	8001980 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
 8001906:	1d3b      	adds	r3, r7, #4
 8001908:	681b      	ldr	r3, [r3, #0]
 800190a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800190c:	f403 7240 	and.w	r2, r3, #768	; 0x300
 8001910:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8001914:	429a      	cmp	r2, r3
 8001916:	d033      	beq.n	8001980 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg0 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8001918:	4b24      	ldr	r3, [pc, #144]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 800191a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800191c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001920:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150

      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8001924:	4a21      	ldr	r2, [pc, #132]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 8001926:	4b21      	ldr	r3, [pc, #132]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 8001928:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800192a:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800192e:	6713      	str	r3, [r2, #112]	; 0x70
      __HAL_RCC_BACKUPRESET_RELEASE();
 8001930:	4a1e      	ldr	r2, [pc, #120]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 8001932:	4b1e      	ldr	r3, [pc, #120]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 8001934:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001936:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800193a:	6713      	str	r3, [r2, #112]	; 0x70

      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg0;
 800193c:	4a1b      	ldr	r2, [pc, #108]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 800193e:	f8d7 3150 	ldr.w	r3, [r7, #336]	; 0x150
 8001942:	6713      	str	r3, [r2, #112]	; 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8001944:	4b19      	ldr	r3, [pc, #100]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 8001946:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001948:	f003 0301 	and.w	r3, r3, #1
 800194c:	2b00      	cmp	r3, #0
 800194e:	d017      	beq.n	8001980 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001950:	f7fe ff58 	bl	8000804 <HAL_GetTick>
 8001954:	f8c7 0154 	str.w	r0, [r7, #340]	; 0x154
        
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001958:	e00c      	b.n	8001974 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800195a:	f7fe ff53 	bl	8000804 <HAL_GetTick>
 800195e:	4602      	mov	r2, r0
 8001960:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8001964:	1ad3      	subs	r3, r2, r3
 8001966:	f241 3288 	movw	r2, #5000	; 0x1388
 800196a:	4293      	cmp	r3, r2
 800196c:	d902      	bls.n	8001974 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
          {
            return HAL_TIMEOUT;
 800196e:	2303      	movs	r3, #3
 8001970:	f000 be43 	b.w	80025fa <HAL_RCCEx_PeriphCLKConfig+0xe76>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
        
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001974:	4b0d      	ldr	r3, [pc, #52]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 8001976:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001978:	f003 0302 	and.w	r3, r3, #2
 800197c:	2b00      	cmp	r3, #0
 800197e:	d0ec      	beq.n	800195a <HAL_RCCEx_PeriphCLKConfig+0x1d6>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8001980:	1d3b      	adds	r3, r7, #4
 8001982:	681b      	ldr	r3, [r3, #0]
 8001984:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001986:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800198a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800198e:	d113      	bne.n	80019b8 <HAL_RCCEx_PeriphCLKConfig+0x234>
 8001990:	4806      	ldr	r0, [pc, #24]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 8001992:	4b06      	ldr	r3, [pc, #24]	; (80019ac <HAL_RCCEx_PeriphCLKConfig+0x228>)
 8001994:	689b      	ldr	r3, [r3, #8]
 8001996:	f423 12f8 	bic.w	r2, r3, #2031616	; 0x1f0000
 800199a:	1d3b      	adds	r3, r7, #4
 800199c:	681b      	ldr	r3, [r3, #0]
 800199e:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80019a0:	4b04      	ldr	r3, [pc, #16]	; (80019b4 <HAL_RCCEx_PeriphCLKConfig+0x230>)
 80019a2:	400b      	ands	r3, r1
 80019a4:	4313      	orrs	r3, r2
 80019a6:	6083      	str	r3, [r0, #8]
 80019a8:	e00c      	b.n	80019c4 <HAL_RCCEx_PeriphCLKConfig+0x240>
 80019aa:	bf00      	nop
 80019ac:	40023800 	.word	0x40023800
 80019b0:	40007000 	.word	0x40007000
 80019b4:	0ffffcff 	.word	0x0ffffcff
 80019b8:	4ab6      	ldr	r2, [pc, #728]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 80019ba:	4bb6      	ldr	r3, [pc, #728]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 80019bc:	689b      	ldr	r3, [r3, #8]
 80019be:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
 80019c2:	6093      	str	r3, [r2, #8]
 80019c4:	49b3      	ldr	r1, [pc, #716]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 80019c6:	4bb3      	ldr	r3, [pc, #716]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 80019c8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 80019ca:	1d3b      	adds	r3, r7, #4
 80019cc:	681b      	ldr	r3, [r3, #0]
 80019ce:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80019d0:	f3c3 030b 	ubfx	r3, r3, #0, #12
 80019d4:	4313      	orrs	r3, r2
 80019d6:	670b      	str	r3, [r1, #112]	; 0x70
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 80019d8:	1d3b      	adds	r3, r7, #4
 80019da:	681b      	ldr	r3, [r3, #0]
 80019dc:	681b      	ldr	r3, [r3, #0]
 80019de:	f003 0310 	and.w	r3, r3, #16
 80019e2:	2b00      	cmp	r3, #0
 80019e4:	d011      	beq.n	8001a0a <HAL_RCCEx_PeriphCLKConfig+0x286>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));
    
    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 80019e6:	4aab      	ldr	r2, [pc, #684]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 80019e8:	4baa      	ldr	r3, [pc, #680]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 80019ea:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80019ee:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80019f2:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
 80019f6:	49a7      	ldr	r1, [pc, #668]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 80019f8:	4ba6      	ldr	r3, [pc, #664]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 80019fa:	f8d3 208c 	ldr.w	r2, [r3, #140]	; 0x8c
 80019fe:	1d3b      	adds	r3, r7, #4
 8001a00:	681b      	ldr	r3, [r3, #0]
 8001a02:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8001a04:	4313      	orrs	r3, r2
 8001a06:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }
  
  /*-------------------------------------- I2C1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8001a0a:	1d3b      	adds	r3, r7, #4
 8001a0c:	681b      	ldr	r3, [r3, #0]
 8001a0e:	681b      	ldr	r3, [r3, #0]
 8001a10:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8001a14:	2b00      	cmp	r3, #0
 8001a16:	d00b      	beq.n	8001a30 <HAL_RCCEx_PeriphCLKConfig+0x2ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
    
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8001a18:	499e      	ldr	r1, [pc, #632]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001a1a:	4b9e      	ldr	r3, [pc, #632]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001a1c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001a20:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 8001a24:	1d3b      	adds	r3, r7, #4
 8001a26:	681b      	ldr	r3, [r3, #0]
 8001a28:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001a2a:	4313      	orrs	r3, r2
 8001a2c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }
  
  /*-------------------------------------- I2C2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8001a30:	1d3b      	adds	r3, r7, #4
 8001a32:	681b      	ldr	r3, [r3, #0]
 8001a34:	681b      	ldr	r3, [r3, #0]
 8001a36:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8001a3a:	2b00      	cmp	r3, #0
 8001a3c:	d00b      	beq.n	8001a56 <HAL_RCCEx_PeriphCLKConfig+0x2d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
    
    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8001a3e:	4995      	ldr	r1, [pc, #596]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001a40:	4b94      	ldr	r3, [pc, #592]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001a42:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001a46:	f423 2240 	bic.w	r2, r3, #786432	; 0xc0000
 8001a4a:	1d3b      	adds	r3, r7, #4
 8001a4c:	681b      	ldr	r3, [r3, #0]
 8001a4e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8001a50:	4313      	orrs	r3, r2
 8001a52:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }
  
  /*-------------------------------------- I2C3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8001a56:	1d3b      	adds	r3, r7, #4
 8001a58:	681b      	ldr	r3, [r3, #0]
 8001a5a:	681b      	ldr	r3, [r3, #0]
 8001a5c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8001a60:	2b00      	cmp	r3, #0
 8001a62:	d00b      	beq.n	8001a7c <HAL_RCCEx_PeriphCLKConfig+0x2f8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
    
    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8001a64:	498b      	ldr	r1, [pc, #556]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001a66:	4b8b      	ldr	r3, [pc, #556]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001a68:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001a6c:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
 8001a70:	1d3b      	adds	r3, r7, #4
 8001a72:	681b      	ldr	r3, [r3, #0]
 8001a74:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001a76:	4313      	orrs	r3, r2
 8001a78:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }
    
  /*-------------------------------------- I2C4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8001a7c:	1d3b      	adds	r3, r7, #4
 8001a7e:	681b      	ldr	r3, [r3, #0]
 8001a80:	681b      	ldr	r3, [r3, #0]
 8001a82:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001a86:	2b00      	cmp	r3, #0
 8001a88:	d00b      	beq.n	8001aa2 <HAL_RCCEx_PeriphCLKConfig+0x31e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));
    
    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8001a8a:	4982      	ldr	r1, [pc, #520]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001a8c:	4b81      	ldr	r3, [pc, #516]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001a8e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001a92:	f423 0240 	bic.w	r2, r3, #12582912	; 0xc00000
 8001a96:	1d3b      	adds	r3, r7, #4
 8001a98:	681b      	ldr	r3, [r3, #0]
 8001a9a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001a9c:	4313      	orrs	r3, r2
 8001a9e:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8001aa2:	1d3b      	adds	r3, r7, #4
 8001aa4:	681b      	ldr	r3, [r3, #0]
 8001aa6:	681b      	ldr	r3, [r3, #0]
 8001aa8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8001aac:	2b00      	cmp	r3, #0
 8001aae:	d00b      	beq.n	8001ac8 <HAL_RCCEx_PeriphCLKConfig+0x344>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8001ab0:	4978      	ldr	r1, [pc, #480]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001ab2:	4b78      	ldr	r3, [pc, #480]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001ab4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001ab8:	f023 0203 	bic.w	r2, r3, #3
 8001abc:	1d3b      	adds	r3, r7, #4
 8001abe:	681b      	ldr	r3, [r3, #0]
 8001ac0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001ac2:	4313      	orrs	r3, r2
 8001ac4:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART2 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8001ac8:	1d3b      	adds	r3, r7, #4
 8001aca:	681b      	ldr	r3, [r3, #0]
 8001acc:	681b      	ldr	r3, [r3, #0]
 8001ace:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8001ad2:	2b00      	cmp	r3, #0
 8001ad4:	d00b      	beq.n	8001aee <HAL_RCCEx_PeriphCLKConfig+0x36a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
    
    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8001ad6:	496f      	ldr	r1, [pc, #444]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001ad8:	4b6e      	ldr	r3, [pc, #440]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001ada:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001ade:	f023 020c 	bic.w	r2, r3, #12
 8001ae2:	1d3b      	adds	r3, r7, #4
 8001ae4:	681b      	ldr	r3, [r3, #0]
 8001ae6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001ae8:	4313      	orrs	r3, r2
 8001aea:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART3 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8001aee:	1d3b      	adds	r3, r7, #4
 8001af0:	681b      	ldr	r3, [r3, #0]
 8001af2:	681b      	ldr	r3, [r3, #0]
 8001af4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8001af8:	2b00      	cmp	r3, #0
 8001afa:	d00b      	beq.n	8001b14 <HAL_RCCEx_PeriphCLKConfig+0x390>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
    
    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8001afc:	4965      	ldr	r1, [pc, #404]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001afe:	4b65      	ldr	r3, [pc, #404]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001b00:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001b04:	f023 0230 	bic.w	r2, r3, #48	; 0x30
 8001b08:	1d3b      	adds	r3, r7, #4
 8001b0a:	681b      	ldr	r3, [r3, #0]
 8001b0c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001b0e:	4313      	orrs	r3, r2
 8001b10:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART4 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8001b14:	1d3b      	adds	r3, r7, #4
 8001b16:	681b      	ldr	r3, [r3, #0]
 8001b18:	681b      	ldr	r3, [r3, #0]
 8001b1a:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8001b1e:	2b00      	cmp	r3, #0
 8001b20:	d00b      	beq.n	8001b3a <HAL_RCCEx_PeriphCLKConfig+0x3b6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
    
    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8001b22:	495c      	ldr	r1, [pc, #368]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001b24:	4b5b      	ldr	r3, [pc, #364]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001b26:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001b2a:	f023 02c0 	bic.w	r2, r3, #192	; 0xc0
 8001b2e:	1d3b      	adds	r3, r7, #4
 8001b30:	681b      	ldr	r3, [r3, #0]
 8001b32:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001b34:	4313      	orrs	r3, r2
 8001b36:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART5 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8001b3a:	1d3b      	adds	r3, r7, #4
 8001b3c:	681b      	ldr	r3, [r3, #0]
 8001b3e:	681b      	ldr	r3, [r3, #0]
 8001b40:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8001b44:	2b00      	cmp	r3, #0
 8001b46:	d00b      	beq.n	8001b60 <HAL_RCCEx_PeriphCLKConfig+0x3dc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
    
    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8001b48:	4952      	ldr	r1, [pc, #328]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001b4a:	4b52      	ldr	r3, [pc, #328]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001b4c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001b50:	f423 7240 	bic.w	r2, r3, #768	; 0x300
 8001b54:	1d3b      	adds	r3, r7, #4
 8001b56:	681b      	ldr	r3, [r3, #0]
 8001b58:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8001b5a:	4313      	orrs	r3, r2
 8001b5c:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- USART6 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART6) == RCC_PERIPHCLK_USART6)
 8001b60:	1d3b      	adds	r3, r7, #4
 8001b62:	681b      	ldr	r3, [r3, #0]
 8001b64:	681b      	ldr	r3, [r3, #0]
 8001b66:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8001b6a:	2b00      	cmp	r3, #0
 8001b6c:	d00b      	beq.n	8001b86 <HAL_RCCEx_PeriphCLKConfig+0x402>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART6CLKSOURCE(PeriphClkInit->Usart6ClockSelection));
    
    /* Configure the USART6 clock source */
    __HAL_RCC_USART6_CONFIG(PeriphClkInit->Usart6ClockSelection);
 8001b6e:	4949      	ldr	r1, [pc, #292]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001b70:	4b48      	ldr	r3, [pc, #288]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001b72:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001b76:	f423 6240 	bic.w	r2, r3, #3072	; 0xc00
 8001b7a:	1d3b      	adds	r3, r7, #4
 8001b7c:	681b      	ldr	r3, [r3, #0]
 8001b7e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8001b80:	4313      	orrs	r3, r2
 8001b82:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART7 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART7) == RCC_PERIPHCLK_UART7)
 8001b86:	1d3b      	adds	r3, r7, #4
 8001b88:	681b      	ldr	r3, [r3, #0]
 8001b8a:	681b      	ldr	r3, [r3, #0]
 8001b8c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8001b90:	2b00      	cmp	r3, #0
 8001b92:	d00b      	beq.n	8001bac <HAL_RCCEx_PeriphCLKConfig+0x428>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART7CLKSOURCE(PeriphClkInit->Uart7ClockSelection));
    
    /* Configure the UART7 clock source */
    __HAL_RCC_UART7_CONFIG(PeriphClkInit->Uart7ClockSelection);
 8001b94:	493f      	ldr	r1, [pc, #252]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001b96:	4b3f      	ldr	r3, [pc, #252]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001b98:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001b9c:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000
 8001ba0:	1d3b      	adds	r3, r7, #4
 8001ba2:	681b      	ldr	r3, [r3, #0]
 8001ba4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001ba6:	4313      	orrs	r3, r2
 8001ba8:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }

  /*-------------------------------------- UART8 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART8) == RCC_PERIPHCLK_UART8)
 8001bac:	1d3b      	adds	r3, r7, #4
 8001bae:	681b      	ldr	r3, [r3, #0]
 8001bb0:	681b      	ldr	r3, [r3, #0]
 8001bb2:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8001bb6:	2b00      	cmp	r3, #0
 8001bb8:	d00b      	beq.n	8001bd2 <HAL_RCCEx_PeriphCLKConfig+0x44e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART8CLKSOURCE(PeriphClkInit->Uart8ClockSelection));
    
    /* Configure the UART8 clock source */
    __HAL_RCC_UART8_CONFIG(PeriphClkInit->Uart8ClockSelection);
 8001bba:	4936      	ldr	r1, [pc, #216]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001bbc:	4b35      	ldr	r3, [pc, #212]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001bbe:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001bc2:	f423 4240 	bic.w	r2, r3, #49152	; 0xc000
 8001bc6:	1d3b      	adds	r3, r7, #4
 8001bc8:	681b      	ldr	r3, [r3, #0]
 8001bca:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001bcc:	4313      	orrs	r3, r2
 8001bce:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }
  
  /*--------------------------------------- CEC Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 8001bd2:	1d3b      	adds	r3, r7, #4
 8001bd4:	681b      	ldr	r3, [r3, #0]
 8001bd6:	681b      	ldr	r3, [r3, #0]
 8001bd8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8001bdc:	2b00      	cmp	r3, #0
 8001bde:	d00b      	beq.n	8001bf8 <HAL_RCCEx_PeriphCLKConfig+0x474>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8001be0:	492c      	ldr	r1, [pc, #176]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001be2:	4b2c      	ldr	r3, [pc, #176]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001be4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001be8:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
 8001bec:	1d3b      	adds	r3, r7, #4
 8001bee:	681b      	ldr	r3, [r3, #0]
 8001bf0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8001bf2:	4313      	orrs	r3, r2
 8001bf4:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }
  
  /*-------------------------------------- CK48 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48)
 8001bf8:	1d3b      	adds	r3, r7, #4
 8001bfa:	681b      	ldr	r3, [r3, #0]
 8001bfc:	681b      	ldr	r3, [r3, #0]
 8001bfe:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8001c02:	2b00      	cmp	r3, #0
 8001c04:	d014      	beq.n	8001c30 <HAL_RCCEx_PeriphCLKConfig+0x4ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLK48SOURCE(PeriphClkInit->Clk48ClockSelection));
    
    /* Configure the CLK48 source */
    __HAL_RCC_CLK48_CONFIG(PeriphClkInit->Clk48ClockSelection);
 8001c06:	4923      	ldr	r1, [pc, #140]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001c08:	4b22      	ldr	r3, [pc, #136]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001c0a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001c0e:	f023 6200 	bic.w	r2, r3, #134217728	; 0x8000000
 8001c12:	1d3b      	adds	r3, r7, #4
 8001c14:	681b      	ldr	r3, [r3, #0]
 8001c16:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8001c18:	4313      	orrs	r3, r2
 8001c1a:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90

    /* Enable the PLLSAI when it's used as clock source for CK48 */
    if(PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP)
 8001c1e:	1d3b      	adds	r3, r7, #4
 8001c20:	681b      	ldr	r3, [r3, #0]
 8001c22:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8001c24:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 8001c28:	d102      	bne.n	8001c30 <HAL_RCCEx_PeriphCLKConfig+0x4ac>
    {
      pllsaiused = 1; 
 8001c2a:	2301      	movs	r3, #1
 8001c2c:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
    }
  }

  /*-------------------------------------- LTDC Configuration -----------------------------------*/
#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 8001c30:	1d3b      	adds	r3, r7, #4
 8001c32:	681b      	ldr	r3, [r3, #0]
 8001c34:	681b      	ldr	r3, [r3, #0]
 8001c36:	f003 0308 	and.w	r3, r3, #8
 8001c3a:	2b00      	cmp	r3, #0
 8001c3c:	d002      	beq.n	8001c44 <HAL_RCCEx_PeriphCLKConfig+0x4c0>
  {
    pllsaiused = 1; 
 8001c3e:	2301      	movs	r3, #1
 8001c40:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
  }
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
  
  /*-------------------------------------- LPTIM1 Configuration -----------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8001c44:	1d3b      	adds	r3, r7, #4
 8001c46:	681b      	ldr	r3, [r3, #0]
 8001c48:	681b      	ldr	r3, [r3, #0]
 8001c4a:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8001c4e:	2b00      	cmp	r3, #0
 8001c50:	d00b      	beq.n	8001c6a <HAL_RCCEx_PeriphCLKConfig+0x4e6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLK(PeriphClkInit->Lptim1ClockSelection));
    
    /* Configure the LTPIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8001c52:	4910      	ldr	r1, [pc, #64]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001c54:	4b0f      	ldr	r3, [pc, #60]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001c56:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001c5a:	f023 7240 	bic.w	r2, r3, #50331648	; 0x3000000
 8001c5e:	1d3b      	adds	r3, r7, #4
 8001c60:	681b      	ldr	r3, [r3, #0]
 8001c62:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001c64:	4313      	orrs	r3, r2
 8001c66:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
   }
  
  /*------------------------------------- SDMMC1 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == RCC_PERIPHCLK_SDMMC1)
 8001c6a:	1d3b      	adds	r3, r7, #4
 8001c6c:	681b      	ldr	r3, [r3, #0]
 8001c6e:	681b      	ldr	r3, [r3, #0]
 8001c70:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8001c74:	2b00      	cmp	r3, #0
 8001c76:	d00f      	beq.n	8001c98 <HAL_RCCEx_PeriphCLKConfig+0x514>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC1CLKSOURCE(PeriphClkInit->Sdmmc1ClockSelection));
    
    /* Configure the SDMMC1 clock source */
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8001c78:	4906      	ldr	r1, [pc, #24]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001c7a:	4b06      	ldr	r3, [pc, #24]	; (8001c94 <HAL_RCCEx_PeriphCLKConfig+0x510>)
 8001c7c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001c80:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
 8001c84:	1d3b      	adds	r3, r7, #4
 8001c86:	681b      	ldr	r3, [r3, #0]
 8001c88:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8001c8c:	4313      	orrs	r3, r2
 8001c8e:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
 8001c92:	e001      	b.n	8001c98 <HAL_RCCEx_PeriphCLKConfig+0x514>
 8001c94:	40023800 	.word	0x40023800
  }
  
#if defined (STM32F765xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx)  
  /*------------------------------------- SDMMC2 Configuration ------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC2) == RCC_PERIPHCLK_SDMMC2)
 8001c98:	1d3b      	adds	r3, r7, #4
 8001c9a:	681b      	ldr	r3, [r3, #0]
 8001c9c:	681b      	ldr	r3, [r3, #0]
 8001c9e:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 8001ca2:	2b00      	cmp	r3, #0
 8001ca4:	d00c      	beq.n	8001cc0 <HAL_RCCEx_PeriphCLKConfig+0x53c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC2CLKSOURCE(PeriphClkInit->Sdmmc2ClockSelection));
    
    /* Configure the SDMMC2 clock source */
    __HAL_RCC_SDMMC2_CONFIG(PeriphClkInit->Sdmmc2ClockSelection);
 8001ca6:	492b      	ldr	r1, [pc, #172]	; (8001d54 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 8001ca8:	4b2a      	ldr	r3, [pc, #168]	; (8001d54 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 8001caa:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8001cae:	f023 5200 	bic.w	r2, r3, #536870912	; 0x20000000
 8001cb2:	1d3b      	adds	r3, r7, #4
 8001cb4:	681b      	ldr	r3, [r3, #0]
 8001cb6:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8001cba:	4313      	orrs	r3, r2
 8001cbc:	f8c1 3090 	str.w	r3, [r1, #144]	; 0x90
  }
	
  /*------------------------------------- DFSDM1 Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8001cc0:	1d3b      	adds	r3, r7, #4
 8001cc2:	681b      	ldr	r3, [r3, #0]
 8001cc4:	681b      	ldr	r3, [r3, #0]
 8001cc6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8001cca:	2b00      	cmp	r3, #0
 8001ccc:	d00c      	beq.n	8001ce8 <HAL_RCCEx_PeriphCLKConfig+0x564>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8001cce:	4921      	ldr	r1, [pc, #132]	; (8001d54 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 8001cd0:	4b20      	ldr	r3, [pc, #128]	; (8001d54 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 8001cd2:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8001cd6:	f023 7200 	bic.w	r2, r3, #33554432	; 0x2000000
 8001cda:	1d3b      	adds	r3, r7, #4
 8001cdc:	681b      	ldr	r3, [r3, #0]
 8001cde:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8001ce2:	4313      	orrs	r3, r2
 8001ce4:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }
  
  /*------------------------------------- DFSDM AUDIO Configuration -------------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1_AUDIO) == RCC_PERIPHCLK_DFSDM1_AUDIO)
 8001ce8:	1d3b      	adds	r3, r7, #4
 8001cea:	681b      	ldr	r3, [r3, #0]
 8001cec:	681b      	ldr	r3, [r3, #0]
 8001cee:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001cf2:	2b00      	cmp	r3, #0
 8001cf4:	d00c      	beq.n	8001d10 <HAL_RCCEx_PeriphCLKConfig+0x58c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1AUDIOCLKSOURCE(PeriphClkInit->Dfsdm1AudioClockSelection));

    /* Configure the DFSDM interface clock source */
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 8001cf6:	4917      	ldr	r1, [pc, #92]	; (8001d54 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 8001cf8:	4b16      	ldr	r3, [pc, #88]	; (8001d54 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 8001cfa:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8001cfe:	f023 6280 	bic.w	r2, r3, #67108864	; 0x4000000
 8001d02:	1d3b      	adds	r3, r7, #4
 8001d04:	681b      	ldr	r3, [r3, #0]
 8001d06:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8001d0a:	4313      	orrs	r3, r2
 8001d0c:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
  }  
#endif /* STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */
  
  /*-------------------------------------- PLLI2S Configuration ---------------------------------*/
  /* PLLI2S is configured when a peripheral will use it as source clock : SAI1, SAI2, I2S or SPDIF-RX */
  if((plli2sused == 1) || (PeriphClkInit->PeriphClockSelection == RCC_PERIPHCLK_PLLI2S))
 8001d10:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 8001d14:	2b01      	cmp	r3, #1
 8001d16:	d006      	beq.n	8001d26 <HAL_RCCEx_PeriphCLKConfig+0x5a2>
 8001d18:	1d3b      	adds	r3, r7, #4
 8001d1a:	681b      	ldr	r3, [r3, #0]
 8001d1c:	681b      	ldr	r3, [r3, #0]
 8001d1e:	f1b3 7f00 	cmp.w	r3, #33554432	; 0x2000000
 8001d22:	f040 8249 	bne.w	80021b8 <HAL_RCCEx_PeriphCLKConfig+0xa34>
  {
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();  
 8001d26:	4a0b      	ldr	r2, [pc, #44]	; (8001d54 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 8001d28:	4b0a      	ldr	r3, [pc, #40]	; (8001d54 <HAL_RCCEx_PeriphCLKConfig+0x5d0>)
 8001d2a:	681b      	ldr	r3, [r3, #0]
 8001d2c:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 8001d30:	6013      	str	r3, [r2, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8001d32:	f7fe fd67 	bl	8000804 <HAL_GetTick>
 8001d36:	f8c7 0154 	str.w	r0, [r7, #340]	; 0x154
    
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8001d3a:	e00d      	b.n	8001d58 <HAL_RCCEx_PeriphCLKConfig+0x5d4>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8001d3c:	f7fe fd62 	bl	8000804 <HAL_GetTick>
 8001d40:	4602      	mov	r2, r0
 8001d42:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 8001d46:	1ad3      	subs	r3, r2, r3
 8001d48:	2b64      	cmp	r3, #100	; 0x64
 8001d4a:	d905      	bls.n	8001d58 <HAL_RCCEx_PeriphCLKConfig+0x5d4>
      {
        /* return in case of Timeout detected */         
        return HAL_TIMEOUT;
 8001d4c:	2303      	movs	r3, #3
 8001d4e:	f000 bc54 	b.w	80025fa <HAL_RCCEx_PeriphCLKConfig+0xe76>
 8001d52:	bf00      	nop
 8001d54:	40023800 	.word	0x40023800
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8001d58:	4be3      	ldr	r3, [pc, #908]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 8001d5a:	681b      	ldr	r3, [r3, #0]
 8001d5c:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 8001d60:	2b00      	cmp	r3, #0
 8001d62:	d1eb      	bne.n	8001d3c <HAL_RCCEx_PeriphCLKConfig+0x5b8>
    
    /* check for common PLLI2S Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
      
    /*----------------- In Case of PLLI2S is selected as source clock for I2S -------------------*/ 
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) && (PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLLI2S)))
 8001d64:	1d3b      	adds	r3, r7, #4
 8001d66:	681b      	ldr	r3, [r3, #0]
 8001d68:	681b      	ldr	r3, [r3, #0]
 8001d6a:	f003 0301 	and.w	r3, r3, #1
 8001d6e:	2b00      	cmp	r3, #0
 8001d70:	f000 8082 	beq.w	8001e78 <HAL_RCCEx_PeriphCLKConfig+0x6f4>
 8001d74:	1d3b      	adds	r3, r7, #4
 8001d76:	681b      	ldr	r3, [r3, #0]
 8001d78:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001d7a:	2b00      	cmp	r3, #0
 8001d7c:	d17c      	bne.n	8001e78 <HAL_RCCEx_PeriphCLKConfig+0x6f4>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));
    
      /* Read PLLI2SP and PLLI2SQ value from PLLI2SCFGR register (this value is not needed for I2S configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP));
 8001d7e:	4bda      	ldr	r3, [pc, #872]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 8001d80:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8001d84:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 8001d88:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8001d8c:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001d90:	f8d7 3148 	ldr.w	r3, [r7, #328]	; 0x148
 8001d94:	fa93 f3a3 	rbit	r3, r3
 8001d98:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001d9c:	f8d7 3144 	ldr.w	r3, [r7, #324]	; 0x144
 8001da0:	fab3 f383 	clz	r3, r3
 8001da4:	fa22 f303 	lsr.w	r3, r2, r3
 8001da8:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ));
 8001dac:	4bce      	ldr	r3, [pc, #824]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 8001dae:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8001db2:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 8001db6:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 8001dba:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001dbe:	f8d7 3140 	ldr.w	r3, [r7, #320]	; 0x140
 8001dc2:	fa93 f3a3 	rbit	r3, r3
 8001dc6:	f8c7 313c 	str.w	r3, [r7, #316]	; 0x13c
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001dca:	f8d7 313c 	ldr.w	r3, [r7, #316]	; 0x13c
 8001dce:	fab3 f383 	clz	r3, r3
 8001dd2:	fa22 f303 	lsr.w	r3, r2, r3
 8001dd6:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
 8001dda:	48c3      	ldr	r0, [pc, #780]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 8001ddc:	1d3b      	adds	r3, r7, #4
 8001dde:	681b      	ldr	r3, [r3, #0]
 8001de0:	685a      	ldr	r2, [r3, #4]
 8001de2:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8001de6:	f8c7 3138 	str.w	r3, [r7, #312]	; 0x138
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001dea:	f8d7 3138 	ldr.w	r3, [r7, #312]	; 0x138
 8001dee:	fa93 f3a3 	rbit	r3, r3
 8001df2:	f8c7 3134 	str.w	r3, [r7, #308]	; 0x134
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001df6:	f8d7 3134 	ldr.w	r3, [r7, #308]	; 0x134
 8001dfa:	fab3 f383 	clz	r3, r3
 8001dfe:	409a      	lsls	r2, r3
 8001e00:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8001e04:	f8c7 3130 	str.w	r3, [r7, #304]	; 0x130
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001e08:	f8d7 3130 	ldr.w	r3, [r7, #304]	; 0x130
 8001e0c:	fa93 f3a3 	rbit	r3, r3
 8001e10:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001e14:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 8001e18:	fab3 f383 	clz	r3, r3
 8001e1c:	f8d7 1150 	ldr.w	r1, [r7, #336]	; 0x150
 8001e20:	fa01 f303 	lsl.w	r3, r1, r3
 8001e24:	431a      	orrs	r2, r3
 8001e26:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 8001e2a:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001e2e:	f8d7 3128 	ldr.w	r3, [r7, #296]	; 0x128
 8001e32:	fa93 f3a3 	rbit	r3, r3
 8001e36:	f8c7 3124 	str.w	r3, [r7, #292]	; 0x124
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001e3a:	f8d7 3124 	ldr.w	r3, [r7, #292]	; 0x124
 8001e3e:	fab3 f383 	clz	r3, r3
 8001e42:	f8d7 114c 	ldr.w	r1, [r7, #332]	; 0x14c
 8001e46:	fa01 f303 	lsl.w	r3, r1, r3
 8001e4a:	431a      	orrs	r2, r3
 8001e4c:	1d3b      	adds	r3, r7, #4
 8001e4e:	681b      	ldr	r3, [r3, #0]
 8001e50:	6899      	ldr	r1, [r3, #8]
 8001e52:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 8001e56:	f8c7 3120 	str.w	r3, [r7, #288]	; 0x120
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001e5a:	f8d7 3120 	ldr.w	r3, [r7, #288]	; 0x120
 8001e5e:	fa93 f3a3 	rbit	r3, r3
 8001e62:	f8c7 311c 	str.w	r3, [r7, #284]	; 0x11c
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001e66:	f8d7 311c 	ldr.w	r3, [r7, #284]	; 0x11c
 8001e6a:	fab3 f383 	clz	r3, r3
 8001e6e:	fa01 f303 	lsl.w	r3, r1, r3
 8001e72:	4313      	orrs	r3, r2
 8001e74:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    }
        
    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/  
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8001e78:	1d3b      	adds	r3, r7, #4
 8001e7a:	681b      	ldr	r3, [r3, #0]
 8001e7c:	681b      	ldr	r3, [r3, #0]
 8001e7e:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8001e82:	2b00      	cmp	r3, #0
 8001e84:	d005      	beq.n	8001e92 <HAL_RCCEx_PeriphCLKConfig+0x70e>
 8001e86:	1d3b      	adds	r3, r7, #4
 8001e88:	681b      	ldr	r3, [r3, #0]
 8001e8a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001e8c:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 8001e90:	d00e      	beq.n	8001eb0 <HAL_RCCEx_PeriphCLKConfig+0x72c>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S))) 
 8001e92:	1d3b      	adds	r3, r7, #4
 8001e94:	681b      	ldr	r3, [r3, #0]
 8001e96:	681b      	ldr	r3, [r3, #0]
 8001e98:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , tmpreg0, tmpreg1, PeriphClkInit->PLLI2S.PLLI2SR);
    }
        
    /*----------------- In Case of PLLI2S is selected as source clock for SAI -------------------*/  
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLI2S)) ||
 8001e9c:	2b00      	cmp	r3, #0
 8001e9e:	f000 8091 	beq.w	8001fc4 <HAL_RCCEx_PeriphCLKConfig+0x840>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLI2S))) 
 8001ea2:	1d3b      	adds	r3, r7, #4
 8001ea4:	681b      	ldr	r3, [r3, #0]
 8001ea6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001ea8:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 8001eac:	f040 808a 	bne.w	8001fc4 <HAL_RCCEx_PeriphCLKConfig+0x840>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
      /* Check for PLLI2S/DIVQ parameters */
      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));
            
      /* Read PLLI2SP and PLLI2SR values from PLLI2SCFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SP) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SP));
 8001eb0:	4b8d      	ldr	r3, [pc, #564]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 8001eb2:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8001eb6:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 8001eba:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8001ebe:	f8c7 3118 	str.w	r3, [r7, #280]	; 0x118
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001ec2:	f8d7 3118 	ldr.w	r3, [r7, #280]	; 0x118
 8001ec6:	fa93 f3a3 	rbit	r3, r3
 8001eca:	f8c7 3114 	str.w	r3, [r7, #276]	; 0x114
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001ece:	f8d7 3114 	ldr.w	r3, [r7, #276]	; 0x114
 8001ed2:	fab3 f383 	clz	r3, r3
 8001ed6:	fa22 f303 	lsr.w	r3, r2, r3
 8001eda:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
 8001ede:	4b82      	ldr	r3, [pc, #520]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 8001ee0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8001ee4:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
 8001ee8:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 8001eec:	f8c7 3110 	str.w	r3, [r7, #272]	; 0x110
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001ef0:	f8d7 3110 	ldr.w	r3, [r7, #272]	; 0x110
 8001ef4:	fa93 f3a3 	rbit	r3, r3
 8001ef8:	f8c7 310c 	str.w	r3, [r7, #268]	; 0x10c
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001efc:	f8d7 310c 	ldr.w	r3, [r7, #268]	; 0x10c
 8001f00:	fab3 f383 	clz	r3, r3
 8001f04:	fa22 f303 	lsr.w	r3, r2, r3
 8001f08:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
      /* Configure the PLLI2S division factors */      
      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN, tmpreg0, PeriphClkInit->PLLI2S.PLLI2SQ, tmpreg1);
 8001f0c:	4876      	ldr	r0, [pc, #472]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 8001f0e:	1d3b      	adds	r3, r7, #4
 8001f10:	681b      	ldr	r3, [r3, #0]
 8001f12:	685a      	ldr	r2, [r3, #4]
 8001f14:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8001f18:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001f1c:	f8d7 3108 	ldr.w	r3, [r7, #264]	; 0x108
 8001f20:	fa93 f3a3 	rbit	r3, r3
 8001f24:	f8c7 3104 	str.w	r3, [r7, #260]	; 0x104
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001f28:	f8d7 3104 	ldr.w	r3, [r7, #260]	; 0x104
 8001f2c:	fab3 f383 	clz	r3, r3
 8001f30:	409a      	lsls	r2, r3
 8001f32:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8001f36:	f8c7 3100 	str.w	r3, [r7, #256]	; 0x100
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001f3a:	f8d7 3100 	ldr.w	r3, [r7, #256]	; 0x100
 8001f3e:	fa93 f3a3 	rbit	r3, r3
 8001f42:	f8c7 30fc 	str.w	r3, [r7, #252]	; 0xfc
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001f46:	f8d7 30fc 	ldr.w	r3, [r7, #252]	; 0xfc
 8001f4a:	fab3 f383 	clz	r3, r3
 8001f4e:	f8d7 1150 	ldr.w	r1, [r7, #336]	; 0x150
 8001f52:	fa01 f303 	lsl.w	r3, r1, r3
 8001f56:	431a      	orrs	r2, r3
 8001f58:	1d3b      	adds	r3, r7, #4
 8001f5a:	681b      	ldr	r3, [r3, #0]
 8001f5c:	68d9      	ldr	r1, [r3, #12]
 8001f5e:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 8001f62:	f8c7 30f8 	str.w	r3, [r7, #248]	; 0xf8
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001f66:	f8d7 30f8 	ldr.w	r3, [r7, #248]	; 0xf8
 8001f6a:	fa93 f3a3 	rbit	r3, r3
 8001f6e:	f8c7 30f4 	str.w	r3, [r7, #244]	; 0xf4
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001f72:	f8d7 30f4 	ldr.w	r3, [r7, #244]	; 0xf4
 8001f76:	fab3 f383 	clz	r3, r3
 8001f7a:	fa01 f303 	lsl.w	r3, r1, r3
 8001f7e:	431a      	orrs	r2, r3
 8001f80:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 8001f84:	f8c7 30f0 	str.w	r3, [r7, #240]	; 0xf0
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001f88:	f8d7 30f0 	ldr.w	r3, [r7, #240]	; 0xf0
 8001f8c:	fa93 f3a3 	rbit	r3, r3
 8001f90:	f8c7 30ec 	str.w	r3, [r7, #236]	; 0xec
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001f94:	f8d7 30ec 	ldr.w	r3, [r7, #236]	; 0xec
 8001f98:	fab3 f383 	clz	r3, r3
 8001f9c:	f8d7 114c 	ldr.w	r1, [r7, #332]	; 0x14c
 8001fa0:	fa01 f303 	lsl.w	r3, r1, r3
 8001fa4:	4313      	orrs	r3, r2
 8001fa6:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
   
      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */ 
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);   
 8001faa:	494f      	ldr	r1, [pc, #316]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 8001fac:	4b4e      	ldr	r3, [pc, #312]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 8001fae:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8001fb2:	f023 021f 	bic.w	r2, r3, #31
 8001fb6:	1d3b      	adds	r3, r7, #4
 8001fb8:	681b      	ldr	r3, [r3, #0]
 8001fba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001fbc:	3b01      	subs	r3, #1
 8001fbe:	4313      	orrs	r3, r2
 8001fc0:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }          

    /*----------------- In Case of PLLI2S is selected as source clock for SPDIF-RX -------------------*/  
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 8001fc4:	1d3b      	adds	r3, r7, #4
 8001fc6:	681b      	ldr	r3, [r3, #0]
 8001fc8:	681b      	ldr	r3, [r3, #0]
 8001fca:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 8001fce:	2b00      	cmp	r3, #0
 8001fd0:	d07c      	beq.n	80020cc <HAL_RCCEx_PeriphCLKConfig+0x948>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SP_VALUE(PeriphClkInit->PLLI2S.PLLI2SP));
     
     /* Read PLLI2SR value from PLLI2SCFGR register (this value is not needed for SPDIF-RX configuration) */
      tmpreg0 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SQ) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SQ));
 8001fd2:	4b45      	ldr	r3, [pc, #276]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 8001fd4:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8001fd8:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 8001fdc:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 8001fe0:	f8c7 30e8 	str.w	r3, [r7, #232]	; 0xe8
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001fe4:	f8d7 30e8 	ldr.w	r3, [r7, #232]	; 0xe8
 8001fe8:	fa93 f3a3 	rbit	r3, r3
 8001fec:	f8c7 30e4 	str.w	r3, [r7, #228]	; 0xe4
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8001ff0:	f8d7 30e4 	ldr.w	r3, [r7, #228]	; 0xe4
 8001ff4:	fab3 f383 	clz	r3, r3
 8001ff8:	fa22 f303 	lsr.w	r3, r2, r3
 8001ffc:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
 8002000:	4b39      	ldr	r3, [pc, #228]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 8002002:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 8002006:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
 800200a:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 800200e:	f8c7 30e0 	str.w	r3, [r7, #224]	; 0xe0
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002012:	f8d7 30e0 	ldr.w	r3, [r7, #224]	; 0xe0
 8002016:	fa93 f3a3 	rbit	r3, r3
 800201a:	f8c7 30dc 	str.w	r3, [r7, #220]	; 0xdc
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 800201e:	f8d7 30dc 	ldr.w	r3, [r7, #220]	; 0xdc
 8002022:	fab3 f383 	clz	r3, r3
 8002026:	fa22 f303 	lsr.w	r3, r2, r3
 800202a:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLM) */
      /* SPDIFCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, tmpreg0, tmpreg1);
 800202e:	482e      	ldr	r0, [pc, #184]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 8002030:	1d3b      	adds	r3, r7, #4
 8002032:	681b      	ldr	r3, [r3, #0]
 8002034:	685a      	ldr	r2, [r3, #4]
 8002036:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 800203a:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800203e:	f8d7 30d8 	ldr.w	r3, [r7, #216]	; 0xd8
 8002042:	fa93 f3a3 	rbit	r3, r3
 8002046:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 800204a:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
 800204e:	fab3 f383 	clz	r3, r3
 8002052:	409a      	lsls	r2, r3
 8002054:	1d3b      	adds	r3, r7, #4
 8002056:	681b      	ldr	r3, [r3, #0]
 8002058:	6919      	ldr	r1, [r3, #16]
 800205a:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 800205e:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002062:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
 8002066:	fa93 f3a3 	rbit	r3, r3
 800206a:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 800206e:	f8d7 30cc 	ldr.w	r3, [r7, #204]	; 0xcc
 8002072:	fab3 f383 	clz	r3, r3
 8002076:	fa01 f303 	lsl.w	r3, r1, r3
 800207a:	431a      	orrs	r2, r3
 800207c:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 8002080:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002084:	f8d7 30c8 	ldr.w	r3, [r7, #200]	; 0xc8
 8002088:	fa93 f3a3 	rbit	r3, r3
 800208c:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8002090:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 8002094:	fab3 f383 	clz	r3, r3
 8002098:	f8d7 1150 	ldr.w	r1, [r7, #336]	; 0x150
 800209c:	fa01 f303 	lsl.w	r3, r1, r3
 80020a0:	431a      	orrs	r2, r3
 80020a2:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 80020a6:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80020aa:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 80020ae:	fa93 f3a3 	rbit	r3, r3
 80020b2:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 80020b6:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 80020ba:	fab3 f383 	clz	r3, r3
 80020be:	f8d7 114c 	ldr.w	r1, [r7, #332]	; 0x14c
 80020c2:	fa01 f303 	lsl.w	r3, r1, r3
 80020c6:	4313      	orrs	r3, r2
 80020c8:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    }  
         
    /*----------------- In Case of PLLI2S is just selected  -----------------*/  
    if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PLLI2S) == RCC_PERIPHCLK_PLLI2S)
 80020cc:	1d3b      	adds	r3, r7, #4
 80020ce:	681b      	ldr	r3, [r3, #0]
 80020d0:	681b      	ldr	r3, [r3, #0]
 80020d2:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80020d6:	2b00      	cmp	r3, #0
 80020d8:	d053      	beq.n	8002182 <HAL_RCCEx_PeriphCLKConfig+0x9fe>
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));

      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) x (PLLI2SN/PLLI2SM) */
      /* SPDIFRXCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SP */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SP, PeriphClkInit->PLLI2S.PLLI2SQ, PeriphClkInit->PLLI2S.PLLI2SR);
 80020da:	4803      	ldr	r0, [pc, #12]	; (80020e8 <HAL_RCCEx_PeriphCLKConfig+0x964>)
 80020dc:	1d3b      	adds	r3, r7, #4
 80020de:	681b      	ldr	r3, [r3, #0]
 80020e0:	685a      	ldr	r2, [r3, #4]
 80020e2:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 80020e6:	e001      	b.n	80020ec <HAL_RCCEx_PeriphCLKConfig+0x968>
 80020e8:	40023800 	.word	0x40023800
 80020ec:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80020f0:	f8d7 30b8 	ldr.w	r3, [r7, #184]	; 0xb8
 80020f4:	fa93 f3a3 	rbit	r3, r3
 80020f8:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 80020fc:	f8d7 30b4 	ldr.w	r3, [r7, #180]	; 0xb4
 8002100:	fab3 f383 	clz	r3, r3
 8002104:	409a      	lsls	r2, r3
 8002106:	1d3b      	adds	r3, r7, #4
 8002108:	681b      	ldr	r3, [r3, #0]
 800210a:	6919      	ldr	r1, [r3, #16]
 800210c:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 8002110:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002114:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 8002118:	fa93 f3a3 	rbit	r3, r3
 800211c:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8002120:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 8002124:	fab3 f383 	clz	r3, r3
 8002128:	fa01 f303 	lsl.w	r3, r1, r3
 800212c:	431a      	orrs	r2, r3
 800212e:	1d3b      	adds	r3, r7, #4
 8002130:	681b      	ldr	r3, [r3, #0]
 8002132:	68d9      	ldr	r1, [r3, #12]
 8002134:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 8002138:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800213c:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
 8002140:	fa93 f3a3 	rbit	r3, r3
 8002144:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8002148:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800214c:	fab3 f383 	clz	r3, r3
 8002150:	fa01 f303 	lsl.w	r3, r1, r3
 8002154:	431a      	orrs	r2, r3
 8002156:	1d3b      	adds	r3, r7, #4
 8002158:	681b      	ldr	r3, [r3, #0]
 800215a:	6899      	ldr	r1, [r3, #8]
 800215c:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 8002160:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002164:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 8002168:	fa93 f3a3 	rbit	r3, r3
 800216c:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8002170:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 8002174:	fab3 f383 	clz	r3, r3
 8002178:	fa01 f303 	lsl.w	r3, r1, r3
 800217c:	4313      	orrs	r3, r2
 800217e:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    } 
    
    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 8002182:	4a1a      	ldr	r2, [pc, #104]	; (80021ec <HAL_RCCEx_PeriphCLKConfig+0xa68>)
 8002184:	4b19      	ldr	r3, [pc, #100]	; (80021ec <HAL_RCCEx_PeriphCLKConfig+0xa68>)
 8002186:	681b      	ldr	r3, [r3, #0]
 8002188:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800218c:	6013      	str	r3, [r2, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800218e:	f7fe fb39 	bl	8000804 <HAL_GetTick>
 8002192:	f8c7 0154 	str.w	r0, [r7, #340]	; 0x154

    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 8002196:	e009      	b.n	80021ac <HAL_RCCEx_PeriphCLKConfig+0xa28>
    {
      if((HAL_GetTick() - tickstart) > PLLI2S_TIMEOUT_VALUE)
 8002198:	f7fe fb34 	bl	8000804 <HAL_GetTick>
 800219c:	4602      	mov	r2, r0
 800219e:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 80021a2:	1ad3      	subs	r3, r2, r3
 80021a4:	2b64      	cmp	r3, #100	; 0x64
 80021a6:	d901      	bls.n	80021ac <HAL_RCCEx_PeriphCLKConfig+0xa28>
      {
        /* return in case of Timeout detected */                
        return HAL_TIMEOUT;
 80021a8:	2303      	movs	r3, #3
 80021aa:	e226      	b.n	80025fa <HAL_RCCEx_PeriphCLKConfig+0xe76>
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80021ac:	4b0f      	ldr	r3, [pc, #60]	; (80021ec <HAL_RCCEx_PeriphCLKConfig+0xa68>)
 80021ae:	681b      	ldr	r3, [r3, #0]
 80021b0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80021b4:	2b00      	cmp	r3, #0
 80021b6:	d0ef      	beq.n	8002198 <HAL_RCCEx_PeriphCLKConfig+0xa14>
    }
  } 
  
  /*-------------------------------------- PLLSAI Configuration ---------------------------------*/
  /* PLLSAI is configured when a peripheral will use it as source clock : SAI1, SAI2, LTDC or CK48 */
  if(pllsaiused == 1)
 80021b8:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 80021bc:	2b01      	cmp	r3, #1
 80021be:	f040 821b 	bne.w	80025f8 <HAL_RCCEx_PeriphCLKConfig+0xe74>
  {
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE(); 
 80021c2:	4a0a      	ldr	r2, [pc, #40]	; (80021ec <HAL_RCCEx_PeriphCLKConfig+0xa68>)
 80021c4:	4b09      	ldr	r3, [pc, #36]	; (80021ec <HAL_RCCEx_PeriphCLKConfig+0xa68>)
 80021c6:	681b      	ldr	r3, [r3, #0]
 80021c8:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80021cc:	6013      	str	r3, [r2, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80021ce:	f7fe fb19 	bl	8000804 <HAL_GetTick>
 80021d2:	f8c7 0154 	str.w	r0, [r7, #340]	; 0x154

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 80021d6:	e00b      	b.n	80021f0 <HAL_RCCEx_PeriphCLKConfig+0xa6c>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 80021d8:	f7fe fb14 	bl	8000804 <HAL_GetTick>
 80021dc:	4602      	mov	r2, r0
 80021de:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 80021e2:	1ad3      	subs	r3, r2, r3
 80021e4:	2b64      	cmp	r3, #100	; 0x64
 80021e6:	d903      	bls.n	80021f0 <HAL_RCCEx_PeriphCLKConfig+0xa6c>
      { 
        /* return in case of Timeout detected */        
        return HAL_TIMEOUT;
 80021e8:	2303      	movs	r3, #3
 80021ea:	e206      	b.n	80025fa <HAL_RCCEx_PeriphCLKConfig+0xe76>
 80021ec:	40023800 	.word	0x40023800
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 80021f0:	4bd0      	ldr	r3, [pc, #832]	; (8002534 <HAL_RCCEx_PeriphCLKConfig+0xdb0>)
 80021f2:	681b      	ldr	r3, [r3, #0]
 80021f4:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 80021f8:	2b00      	cmp	r3, #0
 80021fa:	d1ed      	bne.n	80021d8 <HAL_RCCEx_PeriphCLKConfig+0xa54>
    
    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));
    
    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/  
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 80021fc:	1d3b      	adds	r3, r7, #4
 80021fe:	681b      	ldr	r3, [r3, #0]
 8002200:	681b      	ldr	r3, [r3, #0]
 8002202:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8002206:	2b00      	cmp	r3, #0
 8002208:	d004      	beq.n	8002214 <HAL_RCCEx_PeriphCLKConfig+0xa90>
 800220a:	1d3b      	adds	r3, r7, #4
 800220c:	681b      	ldr	r3, [r3, #0]
 800220e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002210:	2b00      	cmp	r3, #0
 8002212:	d00d      	beq.n	8002230 <HAL_RCCEx_PeriphCLKConfig+0xaac>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 8002214:	1d3b      	adds	r3, r7, #4
 8002216:	681b      	ldr	r3, [r3, #0]
 8002218:	681b      	ldr	r3, [r3, #0]
 800221a:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    
    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));
    
    /*----------------- In Case of PLLSAI is selected as source clock for SAI -------------------*/  
    if(((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1) && (PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLLSAI)) ||\
 800221e:	2b00      	cmp	r3, #0
 8002220:	f000 8087 	beq.w	8002332 <HAL_RCCEx_PeriphCLKConfig+0xbae>
       ((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2) && (PeriphClkInit->Sai2ClockSelection == RCC_SAI2CLKSOURCE_PLLSAI)))
 8002224:	1d3b      	adds	r3, r7, #4
 8002226:	681b      	ldr	r3, [r3, #0]
 8002228:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800222a:	2b00      	cmp	r3, #0
 800222c:	f040 8081 	bne.w	8002332 <HAL_RCCEx_PeriphCLKConfig+0xbae>
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      /* check for PLLSAI/DIVQ Parameter */
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));
    
      /* Read PLLSAIP value from PLLSAICFGR register (this value is not needed for SAI configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP));
 8002230:	4bc0      	ldr	r3, [pc, #768]	; (8002534 <HAL_RCCEx_PeriphCLKConfig+0xdb0>)
 8002232:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002236:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 800223a:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 800223e:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002242:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 8002246:	fa93 f3a3 	rbit	r3, r3
 800224a:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 800224e:	f8d7 3094 	ldr.w	r3, [r7, #148]	; 0x94
 8002252:	fab3 f383 	clz	r3, r3
 8002256:	fa22 f303 	lsr.w	r3, r2, r3
 800225a:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
 800225e:	4bb5      	ldr	r3, [pc, #724]	; (8002534 <HAL_RCCEx_PeriphCLKConfig+0xdb0>)
 8002260:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002264:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
 8002268:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 800226c:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002270:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8002274:	fa93 f3a3 	rbit	r3, r3
 8002278:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 800227c:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 8002280:	fab3 f383 	clz	r3, r3
 8002284:	fa22 f303 	lsr.w	r3, r2, r3
 8002288:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg0, PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 800228c:	48a9      	ldr	r0, [pc, #676]	; (8002534 <HAL_RCCEx_PeriphCLKConfig+0xdb0>)
 800228e:	1d3b      	adds	r3, r7, #4
 8002290:	681b      	ldr	r3, [r3, #0]
 8002292:	695a      	ldr	r2, [r3, #20]
 8002294:	f647 73c0 	movw	r3, #32704	; 0x7fc0
 8002298:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800229c:	f8d7 3088 	ldr.w	r3, [r7, #136]	; 0x88
 80022a0:	fa93 f3a3 	rbit	r3, r3
 80022a4:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 80022a8:	f8d7 3084 	ldr.w	r3, [r7, #132]	; 0x84
 80022ac:	fab3 f383 	clz	r3, r3
 80022b0:	409a      	lsls	r2, r3
 80022b2:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 80022b6:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80022ba:	f8d7 3080 	ldr.w	r3, [r7, #128]	; 0x80
 80022be:	fa93 f3a3 	rbit	r3, r3
 80022c2:	67fb      	str	r3, [r7, #124]	; 0x7c
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 80022c4:	6ffb      	ldr	r3, [r7, #124]	; 0x7c
 80022c6:	fab3 f383 	clz	r3, r3
 80022ca:	f8d7 1150 	ldr.w	r1, [r7, #336]	; 0x150
 80022ce:	fa01 f303 	lsl.w	r3, r1, r3
 80022d2:	431a      	orrs	r2, r3
 80022d4:	1d3b      	adds	r3, r7, #4
 80022d6:	681b      	ldr	r3, [r3, #0]
 80022d8:	6999      	ldr	r1, [r3, #24]
 80022da:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 80022de:	67bb      	str	r3, [r7, #120]	; 0x78
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80022e0:	6fbb      	ldr	r3, [r7, #120]	; 0x78
 80022e2:	fa93 f3a3 	rbit	r3, r3
 80022e6:	677b      	str	r3, [r7, #116]	; 0x74
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 80022e8:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 80022ea:	fab3 f383 	clz	r3, r3
 80022ee:	fa01 f303 	lsl.w	r3, r1, r3
 80022f2:	431a      	orrs	r2, r3
 80022f4:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 80022f8:	673b      	str	r3, [r7, #112]	; 0x70
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80022fa:	6f3b      	ldr	r3, [r7, #112]	; 0x70
 80022fc:	fa93 f3a3 	rbit	r3, r3
 8002300:	66fb      	str	r3, [r7, #108]	; 0x6c
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8002302:	6efb      	ldr	r3, [r7, #108]	; 0x6c
 8002304:	fab3 f383 	clz	r3, r3
 8002308:	f8d7 114c 	ldr.w	r1, [r7, #332]	; 0x14c
 800230c:	fa01 f303 	lsl.w	r3, r1, r3
 8002310:	4313      	orrs	r3, r2
 8002312:	f8c0 3088 	str.w	r3, [r0, #136]	; 0x88
      
      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */ 
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 8002316:	4987      	ldr	r1, [pc, #540]	; (8002534 <HAL_RCCEx_PeriphCLKConfig+0xdb0>)
 8002318:	4b86      	ldr	r3, [pc, #536]	; (8002534 <HAL_RCCEx_PeriphCLKConfig+0xdb0>)
 800231a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800231e:	f423 52f8 	bic.w	r2, r3, #7936	; 0x1f00
 8002322:	1d3b      	adds	r3, r7, #4
 8002324:	681b      	ldr	r3, [r3, #0]
 8002326:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8002328:	3b01      	subs	r3, #1
 800232a:	021b      	lsls	r3, r3, #8
 800232c:	4313      	orrs	r3, r2
 800232e:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }           

    /*----------------- In Case of PLLSAI is selected as source clock for CLK48 -------------------*/   
    /* In Case of PLLI2S is selected as source clock for CK48 */ 
    if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CLK48) == RCC_PERIPHCLK_CLK48) && (PeriphClkInit->Clk48ClockSelection == RCC_CLK48SOURCE_PLLSAIP))
 8002332:	1d3b      	adds	r3, r7, #4
 8002334:	681b      	ldr	r3, [r3, #0]
 8002336:	681b      	ldr	r3, [r3, #0]
 8002338:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 800233c:	2b00      	cmp	r3, #0
 800233e:	f000 8094 	beq.w	800246a <HAL_RCCEx_PeriphCLKConfig+0xce6>
 8002342:	1d3b      	adds	r3, r7, #4
 8002344:	681b      	ldr	r3, [r3, #0]
 8002346:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8002348:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
 800234c:	f040 808d 	bne.w	800246a <HAL_RCCEx_PeriphCLKConfig+0xce6>
    {
      /* check for Parameters */
      assert_param(IS_RCC_PLLSAIP_VALUE(PeriphClkInit->PLLSAI.PLLSAIP));
      /* Read PLLSAIQ and PLLSAIR value from PLLSAICFGR register (this value is not needed for CK48 configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
 8002350:	4b78      	ldr	r3, [pc, #480]	; (8002534 <HAL_RCCEx_PeriphCLKConfig+0xdb0>)
 8002352:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002356:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 800235a:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 800235e:	66bb      	str	r3, [r7, #104]	; 0x68
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002360:	6ebb      	ldr	r3, [r7, #104]	; 0x68
 8002362:	fa93 f3a3 	rbit	r3, r3
 8002366:	667b      	str	r3, [r7, #100]	; 0x64
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8002368:	6e7b      	ldr	r3, [r7, #100]	; 0x64
 800236a:	fab3 f383 	clz	r3, r3
 800236e:	fa22 f303 	lsr.w	r3, r2, r3
 8002372:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
 8002376:	4b6f      	ldr	r3, [pc, #444]	; (8002534 <HAL_RCCEx_PeriphCLKConfig+0xdb0>)
 8002378:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800237c:	f003 42e0 	and.w	r2, r3, #1879048192	; 0x70000000
 8002380:	f107 0360 	add.w	r3, r7, #96	; 0x60
 8002384:	f04f 41e0 	mov.w	r1, #1879048192	; 0x70000000
 8002388:	6019      	str	r1, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800238a:	f107 0360 	add.w	r3, r7, #96	; 0x60
 800238e:	681b      	ldr	r3, [r3, #0]
 8002390:	fa93 f1a3 	rbit	r1, r3
 8002394:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 8002398:	6019      	str	r1, [r3, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 800239a:	f107 035c 	add.w	r3, r7, #92	; 0x5c
 800239e:	681b      	ldr	r3, [r3, #0]
 80023a0:	fab3 f383 	clz	r3, r3
 80023a4:	fa22 f303 	lsr.w	r3, r2, r3
 80023a8:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
      
      /* Configure the PLLSAI division factors */
      /* PLLSAI_VCO = f(VCO clock) = f(PLLSAI clock input) x (PLLI2SN/PLLM) */
      /* 48CLK = f(PLLSAI clock output) = f(VCO clock) / PLLSAIP */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIP, tmpreg0, tmpreg1);
 80023ac:	4c61      	ldr	r4, [pc, #388]	; (8002534 <HAL_RCCEx_PeriphCLKConfig+0xdb0>)
 80023ae:	1d3b      	adds	r3, r7, #4
 80023b0:	681b      	ldr	r3, [r3, #0]
 80023b2:	695a      	ldr	r2, [r3, #20]
 80023b4:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80023b8:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 80023bc:	6019      	str	r1, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80023be:	f107 0358 	add.w	r3, r7, #88	; 0x58
 80023c2:	681b      	ldr	r3, [r3, #0]
 80023c4:	fa93 f1a3 	rbit	r1, r3
 80023c8:	f107 0354 	add.w	r3, r7, #84	; 0x54
 80023cc:	6019      	str	r1, [r3, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 80023ce:	f107 0354 	add.w	r3, r7, #84	; 0x54
 80023d2:	681b      	ldr	r3, [r3, #0]
 80023d4:	fab3 f383 	clz	r3, r3
 80023d8:	409a      	lsls	r2, r3
 80023da:	1d3b      	adds	r3, r7, #4
 80023dc:	681b      	ldr	r3, [r3, #0]
 80023de:	6a19      	ldr	r1, [r3, #32]
 80023e0:	f107 0350 	add.w	r3, r7, #80	; 0x50
 80023e4:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 80023e8:	6018      	str	r0, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80023ea:	f107 0350 	add.w	r3, r7, #80	; 0x50
 80023ee:	681b      	ldr	r3, [r3, #0]
 80023f0:	fa93 f0a3 	rbit	r0, r3
 80023f4:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80023f8:	6018      	str	r0, [r3, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 80023fa:	f107 034c 	add.w	r3, r7, #76	; 0x4c
 80023fe:	681b      	ldr	r3, [r3, #0]
 8002400:	fab3 f383 	clz	r3, r3
 8002404:	fa01 f303 	lsl.w	r3, r1, r3
 8002408:	431a      	orrs	r2, r3
 800240a:	f107 0348 	add.w	r3, r7, #72	; 0x48
 800240e:	f04f 6170 	mov.w	r1, #251658240	; 0xf000000
 8002412:	6019      	str	r1, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002414:	f107 0348 	add.w	r3, r7, #72	; 0x48
 8002418:	681b      	ldr	r3, [r3, #0]
 800241a:	fa93 f1a3 	rbit	r1, r3
 800241e:	f107 0344 	add.w	r3, r7, #68	; 0x44
 8002422:	6019      	str	r1, [r3, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8002424:	f107 0344 	add.w	r3, r7, #68	; 0x44
 8002428:	681b      	ldr	r3, [r3, #0]
 800242a:	fab3 f383 	clz	r3, r3
 800242e:	f8d7 1150 	ldr.w	r1, [r7, #336]	; 0x150
 8002432:	fa01 f303 	lsl.w	r3, r1, r3
 8002436:	431a      	orrs	r2, r3
 8002438:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800243c:	f04f 41e0 	mov.w	r1, #1879048192	; 0x70000000
 8002440:	6019      	str	r1, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002442:	f107 0340 	add.w	r3, r7, #64	; 0x40
 8002446:	681b      	ldr	r3, [r3, #0]
 8002448:	fa93 f1a3 	rbit	r1, r3
 800244c:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8002450:	6019      	str	r1, [r3, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8002452:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 8002456:	681b      	ldr	r3, [r3, #0]
 8002458:	fab3 f383 	clz	r3, r3
 800245c:	f8d7 114c 	ldr.w	r1, [r7, #332]	; 0x14c
 8002460:	fa01 f303 	lsl.w	r3, r1, r3
 8002464:	4313      	orrs	r3, r2
 8002466:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
    }        

#if defined(STM32F746xx) || defined(STM32F756xx) || defined (STM32F767xx) || defined (STM32F769xx) || defined (STM32F777xx) || defined (STM32F779xx) 
    /*---------------------------- LTDC configuration -------------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 800246a:	1d3b      	adds	r3, r7, #4
 800246c:	681b      	ldr	r3, [r3, #0]
 800246e:	681b      	ldr	r3, [r3, #0]
 8002470:	f003 0308 	and.w	r3, r3, #8
 8002474:	2b00      	cmp	r3, #0
 8002476:	f000 80a4 	beq.w	80025c2 <HAL_RCCEx_PeriphCLKConfig+0xe3e>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));
      
      /* Read PLLSAIP and PLLSAIQ value from PLLSAICFGR register (these value are not needed for LTDC configuration) */
      tmpreg0 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
 800247a:	4b2e      	ldr	r3, [pc, #184]	; (8002534 <HAL_RCCEx_PeriphCLKConfig+0xdb0>)
 800247c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002480:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
 8002484:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8002488:	f04f 6170 	mov.w	r1, #251658240	; 0xf000000
 800248c:	6019      	str	r1, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800248e:	f107 0338 	add.w	r3, r7, #56	; 0x38
 8002492:	681b      	ldr	r3, [r3, #0]
 8002494:	fa93 f1a3 	rbit	r1, r3
 8002498:	f107 0334 	add.w	r3, r7, #52	; 0x34
 800249c:	6019      	str	r1, [r3, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 800249e:	f107 0334 	add.w	r3, r7, #52	; 0x34
 80024a2:	681b      	ldr	r3, [r3, #0]
 80024a4:	fab3 f383 	clz	r3, r3
 80024a8:	fa22 f303 	lsr.w	r3, r2, r3
 80024ac:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIP) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIP));
 80024b0:	4b20      	ldr	r3, [pc, #128]	; (8002534 <HAL_RCCEx_PeriphCLKConfig+0xdb0>)
 80024b2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80024b6:	f403 3240 	and.w	r2, r3, #196608	; 0x30000
 80024ba:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80024be:	f44f 3140 	mov.w	r1, #196608	; 0x30000
 80024c2:	6019      	str	r1, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80024c4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 80024c8:	681b      	ldr	r3, [r3, #0]
 80024ca:	fa93 f1a3 	rbit	r1, r3
 80024ce:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80024d2:	6019      	str	r1, [r3, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 80024d4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80024d8:	681b      	ldr	r3, [r3, #0]
 80024da:	fab3 f383 	clz	r3, r3
 80024de:	fa22 f303 	lsr.w	r3, r2, r3
 80024e2:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
      
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, tmpreg0, PeriphClkInit->PLLSAI.PLLSAIR);
 80024e6:	4c13      	ldr	r4, [pc, #76]	; (8002534 <HAL_RCCEx_PeriphCLKConfig+0xdb0>)
 80024e8:	1d3b      	adds	r3, r7, #4
 80024ea:	681b      	ldr	r3, [r3, #0]
 80024ec:	695a      	ldr	r2, [r3, #20]
 80024ee:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80024f2:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 80024f6:	6019      	str	r1, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 80024f8:	f107 0328 	add.w	r3, r7, #40	; 0x28
 80024fc:	681b      	ldr	r3, [r3, #0]
 80024fe:	fa93 f1a3 	rbit	r1, r3
 8002502:	f107 0324 	add.w	r3, r7, #36	; 0x24
 8002506:	6019      	str	r1, [r3, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8002508:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800250c:	681b      	ldr	r3, [r3, #0]
 800250e:	fab3 f383 	clz	r3, r3
 8002512:	409a      	lsls	r2, r3
 8002514:	f107 0320 	add.w	r3, r7, #32
 8002518:	f44f 3140 	mov.w	r1, #196608	; 0x30000
 800251c:	6019      	str	r1, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800251e:	f107 0320 	add.w	r3, r7, #32
 8002522:	681b      	ldr	r3, [r3, #0]
 8002524:	fa93 f1a3 	rbit	r1, r3
 8002528:	f107 031c 	add.w	r3, r7, #28
 800252c:	6019      	str	r1, [r3, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 800252e:	f107 031c 	add.w	r3, r7, #28
 8002532:	e001      	b.n	8002538 <HAL_RCCEx_PeriphCLKConfig+0xdb4>
 8002534:	40023800 	.word	0x40023800
 8002538:	681b      	ldr	r3, [r3, #0]
 800253a:	fab3 f383 	clz	r3, r3
 800253e:	f8d7 114c 	ldr.w	r1, [r7, #332]	; 0x14c
 8002542:	fa01 f303 	lsl.w	r3, r1, r3
 8002546:	431a      	orrs	r2, r3
 8002548:	f107 0318 	add.w	r3, r7, #24
 800254c:	f04f 6170 	mov.w	r1, #251658240	; 0xf000000
 8002550:	6019      	str	r1, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002552:	f107 0318 	add.w	r3, r7, #24
 8002556:	681b      	ldr	r3, [r3, #0]
 8002558:	fa93 f1a3 	rbit	r1, r3
 800255c:	f107 0314 	add.w	r3, r7, #20
 8002560:	6019      	str	r1, [r3, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8002562:	f107 0314 	add.w	r3, r7, #20
 8002566:	681b      	ldr	r3, [r3, #0]
 8002568:	fab3 f383 	clz	r3, r3
 800256c:	f8d7 1150 	ldr.w	r1, [r7, #336]	; 0x150
 8002570:	fa01 f303 	lsl.w	r3, r1, r3
 8002574:	431a      	orrs	r2, r3
 8002576:	1d3b      	adds	r3, r7, #4
 8002578:	681b      	ldr	r3, [r3, #0]
 800257a:	69d9      	ldr	r1, [r3, #28]
 800257c:	f107 0310 	add.w	r3, r7, #16
 8002580:	f04f 40e0 	mov.w	r0, #1879048192	; 0x70000000
 8002584:	6018      	str	r0, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002586:	f107 0310 	add.w	r3, r7, #16
 800258a:	681b      	ldr	r3, [r3, #0]
 800258c:	fa93 f0a3 	rbit	r0, r3
 8002590:	f107 030c 	add.w	r3, r7, #12
 8002594:	6018      	str	r0, [r3, #0]
    result |= value & 1U;
    s--;
  }
  result <<= s;                        /* shift when v's highest bits are zero */
#endif
  return(result);
 8002596:	f107 030c 	add.w	r3, r7, #12
 800259a:	681b      	ldr	r3, [r3, #0]
 800259c:	fab3 f383 	clz	r3, r3
 80025a0:	fa01 f303 	lsl.w	r3, r1, r3
 80025a4:	4313      	orrs	r3, r2
 80025a6:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
      
      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */ 
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 80025aa:	4916      	ldr	r1, [pc, #88]	; (8002604 <HAL_RCCEx_PeriphCLKConfig+0xe80>)
 80025ac:	4b15      	ldr	r3, [pc, #84]	; (8002604 <HAL_RCCEx_PeriphCLKConfig+0xe80>)
 80025ae:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80025b2:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 80025b6:	1d3b      	adds	r3, r7, #4
 80025b8:	681b      	ldr	r3, [r3, #0]
 80025ba:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80025bc:	4313      	orrs	r3, r2
 80025be:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
    }    
#endif /* STM32F746xx || STM32F756xx || STM32F767xx || STM32F769xx || STM32F777xx || STM32F779xx */  

    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
 80025c2:	4a10      	ldr	r2, [pc, #64]	; (8002604 <HAL_RCCEx_PeriphCLKConfig+0xe80>)
 80025c4:	4b0f      	ldr	r3, [pc, #60]	; (8002604 <HAL_RCCEx_PeriphCLKConfig+0xe80>)
 80025c6:	681b      	ldr	r3, [r3, #0]
 80025c8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80025cc:	6013      	str	r3, [r2, #0]
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80025ce:	f7fe f919 	bl	8000804 <HAL_GetTick>
 80025d2:	f8c7 0154 	str.w	r0, [r7, #340]	; 0x154

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 80025d6:	e009      	b.n	80025ec <HAL_RCCEx_PeriphCLKConfig+0xe68>
    {
      if((HAL_GetTick() - tickstart) > PLLSAI_TIMEOUT_VALUE)
 80025d8:	f7fe f914 	bl	8000804 <HAL_GetTick>
 80025dc:	4602      	mov	r2, r0
 80025de:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 80025e2:	1ad3      	subs	r3, r2, r3
 80025e4:	2b64      	cmp	r3, #100	; 0x64
 80025e6:	d901      	bls.n	80025ec <HAL_RCCEx_PeriphCLKConfig+0xe68>
      { 
        /* return in case of Timeout detected */        
        return HAL_TIMEOUT;
 80025e8:	2303      	movs	r3, #3
 80025ea:	e006      	b.n	80025fa <HAL_RCCEx_PeriphCLKConfig+0xe76>
    
    /* Get Start Tick*/
    tickstart = HAL_GetTick();

    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 80025ec:	4b05      	ldr	r3, [pc, #20]	; (8002604 <HAL_RCCEx_PeriphCLKConfig+0xe80>)
 80025ee:	681b      	ldr	r3, [r3, #0]
 80025f0:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 80025f4:	2b00      	cmp	r3, #0
 80025f6:	d0ef      	beq.n	80025d8 <HAL_RCCEx_PeriphCLKConfig+0xe54>
        /* return in case of Timeout detected */        
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 80025f8:	2300      	movs	r3, #0
}
 80025fa:	4618      	mov	r0, r3
 80025fc:	f507 77b2 	add.w	r7, r7, #356	; 0x164
 8002600:	46bd      	mov	sp, r7
 8002602:	bd90      	pop	{r4, r7, pc}
 8002604:	40023800 	.word	0x40023800

08002608 <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing: Pointer to SDRAM control timing structure 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{   
 8002608:	b580      	push	{r7, lr}
 800260a:	b082      	sub	sp, #8
 800260c:	af00      	add	r7, sp, #0
 800260e:	6078      	str	r0, [r7, #4]
 8002610:	6039      	str	r1, [r7, #0]
  /* Check the SDRAM handle parameter */
  if(hsdram == NULL)
 8002612:	687b      	ldr	r3, [r7, #4]
 8002614:	2b00      	cmp	r3, #0
 8002616:	d101      	bne.n	800261c <HAL_SDRAM_Init+0x14>
  {
    return HAL_ERROR;
 8002618:	2301      	movs	r3, #1
 800261a:	e026      	b.n	800266a <HAL_SDRAM_Init+0x62>
  }
  
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
 800261c:	687b      	ldr	r3, [r7, #4]
 800261e:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8002622:	b2db      	uxtb	r3, r3
 8002624:	2b00      	cmp	r3, #0
 8002626:	d106      	bne.n	8002636 <HAL_SDRAM_Init+0x2e>
  {  
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
 8002628:	687b      	ldr	r3, [r7, #4]
 800262a:	2200      	movs	r2, #0
 800262c:	f883 202d 	strb.w	r2, [r3, #45]	; 0x2d
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
 8002630:	6878      	ldr	r0, [r7, #4]
 8002632:	f000 f81f 	bl	8002674 <HAL_SDRAM_MspInit>
  }
  
  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8002636:	687b      	ldr	r3, [r7, #4]
 8002638:	2202      	movs	r2, #2
 800263a:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  /* Initialize SDRAM control Interface */
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 800263e:	687b      	ldr	r3, [r7, #4]
 8002640:	681a      	ldr	r2, [r3, #0]
 8002642:	687b      	ldr	r3, [r7, #4]
 8002644:	3304      	adds	r3, #4
 8002646:	4610      	mov	r0, r2
 8002648:	4619      	mov	r1, r3
 800264a:	f000 fa6d 	bl	8002b28 <FMC_SDRAM_Init>
  
  /* Initialize SDRAM timing Interface */
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
 800264e:	687b      	ldr	r3, [r7, #4]
 8002650:	681a      	ldr	r2, [r3, #0]
 8002652:	687b      	ldr	r3, [r7, #4]
 8002654:	685b      	ldr	r3, [r3, #4]
 8002656:	4610      	mov	r0, r2
 8002658:	6839      	ldr	r1, [r7, #0]
 800265a:	461a      	mov	r2, r3
 800265c:	f000 fad6 	bl	8002c0c <FMC_SDRAM_Timing_Init>
  
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 8002660:	687b      	ldr	r3, [r7, #4]
 8002662:	2201      	movs	r2, #1
 8002664:	f883 202c 	strb.w	r2, [r3, #44]	; 0x2c
  
  return HAL_OK;
 8002668:	2300      	movs	r3, #0
}
 800266a:	4618      	mov	r0, r3
 800266c:	3708      	adds	r7, #8
 800266e:	46bd      	mov	sp, r7
 8002670:	bd80      	pop	{r7, pc}
 8002672:	bf00      	nop

08002674 <HAL_SDRAM_MspInit>:
  * @param  hsdram: pointer to a SDRAM_HandleTypeDef structure that contains
  *                the configuration information for SDRAM module.
  * @retval None
  */
__weak void HAL_SDRAM_MspInit(SDRAM_HandleTypeDef *hsdram)
{
 8002674:	b480      	push	{r7}
 8002676:	b083      	sub	sp, #12
 8002678:	af00      	add	r7, sp, #0
 800267a:	6078      	str	r0, [r7, #4]
  UNUSED(hsdram);
 
  /* NOTE: This function Should not be modified, when the callback is needed,
            the HAL_SDRAM_MspInit could be implemented in the user file
   */ 
}
 800267c:	370c      	adds	r7, #12
 800267e:	46bd      	mov	sp, r7
 8002680:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002684:	4770      	bx	lr
 8002686:	bf00      	nop

08002688 <HAL_TIM_Base_Init>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{ 
 8002688:	b580      	push	{r7, lr}
 800268a:	b082      	sub	sp, #8
 800268c:	af00      	add	r7, sp, #0
 800268e:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if(htim == NULL)
 8002690:	687b      	ldr	r3, [r7, #4]
 8002692:	2b00      	cmp	r3, #0
 8002694:	d101      	bne.n	800269a <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 8002696:	2301      	movs	r3, #1
 8002698:	e019      	b.n	80026ce <HAL_TIM_Base_Init+0x46>
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance)); 
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  
  if(htim->State == HAL_TIM_STATE_RESET)
 800269a:	687b      	ldr	r3, [r7, #4]
 800269c:	f893 3039 	ldrb.w	r3, [r3, #57]	; 0x39
 80026a0:	b2db      	uxtb	r3, r3
 80026a2:	2b00      	cmp	r3, #0
 80026a4:	d102      	bne.n	80026ac <HAL_TIM_Base_Init+0x24>
  {  
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 80026a6:	6878      	ldr	r0, [r7, #4]
 80026a8:	f000 f816 	bl	80026d8 <HAL_TIM_Base_MspInit>
  }
  
  /* Set the TIM state */
  htim->State= HAL_TIM_STATE_BUSY;
 80026ac:	687b      	ldr	r3, [r7, #4]
 80026ae:	2202      	movs	r2, #2
 80026b0:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 80026b4:	687b      	ldr	r3, [r7, #4]
 80026b6:	681a      	ldr	r2, [r3, #0]
 80026b8:	687b      	ldr	r3, [r7, #4]
 80026ba:	3304      	adds	r3, #4
 80026bc:	4610      	mov	r0, r2
 80026be:	4619      	mov	r1, r3
 80026c0:	f000 f976 	bl	80029b0 <TIM_Base_SetConfig>
  
  /* Initialize the TIM state*/
  htim->State= HAL_TIM_STATE_READY;
 80026c4:	687b      	ldr	r3, [r7, #4]
 80026c6:	2201      	movs	r2, #1
 80026c8:	f883 2039 	strb.w	r2, [r3, #57]	; 0x39
  
  return HAL_OK;
 80026cc:	2300      	movs	r3, #0
}
 80026ce:	4618      	mov	r0, r3
 80026d0:	3708      	adds	r7, #8
 80026d2:	46bd      	mov	sp, r7
 80026d4:	bd80      	pop	{r7, pc}
 80026d6:	bf00      	nop

080026d8 <HAL_TIM_Base_MspInit>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
{
 80026d8:	b480      	push	{r7}
 80026da:	b083      	sub	sp, #12
 80026dc:	af00      	add	r7, sp, #0
 80026de:	6078      	str	r0, [r7, #4]
  UNUSED(htim);
 
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 80026e0:	370c      	adds	r7, #12
 80026e2:	46bd      	mov	sp, r7
 80026e4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80026e8:	4770      	bx	lr
 80026ea:	bf00      	nop

080026ec <HAL_TIM_Base_Start_IT>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 80026ec:	b480      	push	{r7}
 80026ee:	b083      	sub	sp, #12
 80026f0:	af00      	add	r7, sp, #0
 80026f2:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  
  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 80026f4:	687b      	ldr	r3, [r7, #4]
 80026f6:	681b      	ldr	r3, [r3, #0]
 80026f8:	687a      	ldr	r2, [r7, #4]
 80026fa:	6812      	ldr	r2, [r2, #0]
 80026fc:	68d2      	ldr	r2, [r2, #12]
 80026fe:	f042 0201 	orr.w	r2, r2, #1
 8002702:	60da      	str	r2, [r3, #12]
      
  /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8002704:	687b      	ldr	r3, [r7, #4]
 8002706:	681b      	ldr	r3, [r3, #0]
 8002708:	687a      	ldr	r2, [r7, #4]
 800270a:	6812      	ldr	r2, [r2, #0]
 800270c:	6812      	ldr	r2, [r2, #0]
 800270e:	f042 0201 	orr.w	r2, r2, #1
 8002712:	601a      	str	r2, [r3, #0]
      
  /* Return function status */
  return HAL_OK;
 8002714:	2300      	movs	r3, #0
}
 8002716:	4618      	mov	r0, r3
 8002718:	370c      	adds	r7, #12
 800271a:	46bd      	mov	sp, r7
 800271c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002720:	4770      	bx	lr
 8002722:	bf00      	nop

08002724 <HAL_TIM_IRQHandler>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 8002724:	b580      	push	{r7, lr}
 8002726:	b082      	sub	sp, #8
 8002728:	af00      	add	r7, sp, #0
 800272a:	6078      	str	r0, [r7, #4]
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 800272c:	687b      	ldr	r3, [r7, #4]
 800272e:	681b      	ldr	r3, [r3, #0]
 8002730:	691b      	ldr	r3, [r3, #16]
 8002732:	f003 0302 	and.w	r3, r3, #2
 8002736:	2b00      	cmp	r3, #0
 8002738:	d022      	beq.n	8002780 <HAL_TIM_IRQHandler+0x5c>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
 800273a:	687b      	ldr	r3, [r7, #4]
 800273c:	681b      	ldr	r3, [r3, #0]
 800273e:	68db      	ldr	r3, [r3, #12]
 8002740:	f003 0302 	and.w	r3, r3, #2
 8002744:	2b00      	cmp	r3, #0
 8002746:	d01b      	beq.n	8002780 <HAL_TIM_IRQHandler+0x5c>
    {
      {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
 8002748:	687b      	ldr	r3, [r7, #4]
 800274a:	681b      	ldr	r3, [r3, #0]
 800274c:	f06f 0202 	mvn.w	r2, #2
 8002750:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8002752:	687b      	ldr	r3, [r7, #4]
 8002754:	2201      	movs	r2, #1
 8002756:	761a      	strb	r2, [r3, #24]
        
        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00)
 8002758:	687b      	ldr	r3, [r7, #4]
 800275a:	681b      	ldr	r3, [r3, #0]
 800275c:	699b      	ldr	r3, [r3, #24]
 800275e:	f003 0303 	and.w	r3, r3, #3
 8002762:	2b00      	cmp	r3, #0
 8002764:	d003      	beq.n	800276e <HAL_TIM_IRQHandler+0x4a>
        {
          HAL_TIM_IC_CaptureCallback(htim);
 8002766:	6878      	ldr	r0, [r7, #4]
 8002768:	f000 f904 	bl	8002974 <HAL_TIM_IC_CaptureCallback>
 800276c:	e005      	b.n	800277a <HAL_TIM_IRQHandler+0x56>
        }
        /* Output compare event */
        else
        {
          HAL_TIM_OC_DelayElapsedCallback(htim);
 800276e:	6878      	ldr	r0, [r7, #4]
 8002770:	f000 f8f6 	bl	8002960 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002774:	6878      	ldr	r0, [r7, #4]
 8002776:	f000 f907 	bl	8002988 <HAL_TIM_PWM_PulseFinishedCallback>
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 800277a:	687b      	ldr	r3, [r7, #4]
 800277c:	2200      	movs	r2, #0
 800277e:	761a      	strb	r2, [r3, #24]
      }
    }
  }
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8002780:	687b      	ldr	r3, [r7, #4]
 8002782:	681b      	ldr	r3, [r3, #0]
 8002784:	691b      	ldr	r3, [r3, #16]
 8002786:	f003 0304 	and.w	r3, r3, #4
 800278a:	2b00      	cmp	r3, #0
 800278c:	d022      	beq.n	80027d4 <HAL_TIM_IRQHandler+0xb0>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
 800278e:	687b      	ldr	r3, [r7, #4]
 8002790:	681b      	ldr	r3, [r3, #0]
 8002792:	68db      	ldr	r3, [r3, #12]
 8002794:	f003 0304 	and.w	r3, r3, #4
 8002798:	2b00      	cmp	r3, #0
 800279a:	d01b      	beq.n	80027d4 <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
 800279c:	687b      	ldr	r3, [r7, #4]
 800279e:	681b      	ldr	r3, [r3, #0]
 80027a0:	f06f 0204 	mvn.w	r2, #4
 80027a4:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 80027a6:	687b      	ldr	r3, [r7, #4]
 80027a8:	2202      	movs	r2, #2
 80027aa:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00)
 80027ac:	687b      	ldr	r3, [r7, #4]
 80027ae:	681b      	ldr	r3, [r3, #0]
 80027b0:	699b      	ldr	r3, [r3, #24]
 80027b2:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80027b6:	2b00      	cmp	r3, #0
 80027b8:	d003      	beq.n	80027c2 <HAL_TIM_IRQHandler+0x9e>
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 80027ba:	6878      	ldr	r0, [r7, #4]
 80027bc:	f000 f8da 	bl	8002974 <HAL_TIM_IC_CaptureCallback>
 80027c0:	e005      	b.n	80027ce <HAL_TIM_IRQHandler+0xaa>
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 80027c2:	6878      	ldr	r0, [r7, #4]
 80027c4:	f000 f8cc 	bl	8002960 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 80027c8:	6878      	ldr	r0, [r7, #4]
 80027ca:	f000 f8dd 	bl	8002988 <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 80027ce:	687b      	ldr	r3, [r7, #4]
 80027d0:	2200      	movs	r2, #0
 80027d2:	761a      	strb	r2, [r3, #24]
    }
  }
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 80027d4:	687b      	ldr	r3, [r7, #4]
 80027d6:	681b      	ldr	r3, [r3, #0]
 80027d8:	691b      	ldr	r3, [r3, #16]
 80027da:	f003 0308 	and.w	r3, r3, #8
 80027de:	2b00      	cmp	r3, #0
 80027e0:	d022      	beq.n	8002828 <HAL_TIM_IRQHandler+0x104>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
 80027e2:	687b      	ldr	r3, [r7, #4]
 80027e4:	681b      	ldr	r3, [r3, #0]
 80027e6:	68db      	ldr	r3, [r3, #12]
 80027e8:	f003 0308 	and.w	r3, r3, #8
 80027ec:	2b00      	cmp	r3, #0
 80027ee:	d01b      	beq.n	8002828 <HAL_TIM_IRQHandler+0x104>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
 80027f0:	687b      	ldr	r3, [r7, #4]
 80027f2:	681b      	ldr	r3, [r3, #0]
 80027f4:	f06f 0208 	mvn.w	r2, #8
 80027f8:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 80027fa:	687b      	ldr	r3, [r7, #4]
 80027fc:	2204      	movs	r2, #4
 80027fe:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00)
 8002800:	687b      	ldr	r3, [r7, #4]
 8002802:	681b      	ldr	r3, [r3, #0]
 8002804:	69db      	ldr	r3, [r3, #28]
 8002806:	f003 0303 	and.w	r3, r3, #3
 800280a:	2b00      	cmp	r3, #0
 800280c:	d003      	beq.n	8002816 <HAL_TIM_IRQHandler+0xf2>
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 800280e:	6878      	ldr	r0, [r7, #4]
 8002810:	f000 f8b0 	bl	8002974 <HAL_TIM_IC_CaptureCallback>
 8002814:	e005      	b.n	8002822 <HAL_TIM_IRQHandler+0xfe>
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8002816:	6878      	ldr	r0, [r7, #4]
 8002818:	f000 f8a2 	bl	8002960 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim); 
 800281c:	6878      	ldr	r0, [r7, #4]
 800281e:	f000 f8b3 	bl	8002988 <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002822:	687b      	ldr	r3, [r7, #4]
 8002824:	2200      	movs	r2, #0
 8002826:	761a      	strb	r2, [r3, #24]
    }
  }
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8002828:	687b      	ldr	r3, [r7, #4]
 800282a:	681b      	ldr	r3, [r3, #0]
 800282c:	691b      	ldr	r3, [r3, #16]
 800282e:	f003 0310 	and.w	r3, r3, #16
 8002832:	2b00      	cmp	r3, #0
 8002834:	d022      	beq.n	800287c <HAL_TIM_IRQHandler+0x158>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
 8002836:	687b      	ldr	r3, [r7, #4]
 8002838:	681b      	ldr	r3, [r3, #0]
 800283a:	68db      	ldr	r3, [r3, #12]
 800283c:	f003 0310 	and.w	r3, r3, #16
 8002840:	2b00      	cmp	r3, #0
 8002842:	d01b      	beq.n	800287c <HAL_TIM_IRQHandler+0x158>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
 8002844:	687b      	ldr	r3, [r7, #4]
 8002846:	681b      	ldr	r3, [r3, #0]
 8002848:	f06f 0210 	mvn.w	r2, #16
 800284c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 800284e:	687b      	ldr	r3, [r7, #4]
 8002850:	2208      	movs	r2, #8
 8002852:	761a      	strb	r2, [r3, #24]
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00)
 8002854:	687b      	ldr	r3, [r7, #4]
 8002856:	681b      	ldr	r3, [r3, #0]
 8002858:	69db      	ldr	r3, [r3, #28]
 800285a:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800285e:	2b00      	cmp	r3, #0
 8002860:	d003      	beq.n	800286a <HAL_TIM_IRQHandler+0x146>
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 8002862:	6878      	ldr	r0, [r7, #4]
 8002864:	f000 f886 	bl	8002974 <HAL_TIM_IC_CaptureCallback>
 8002868:	e005      	b.n	8002876 <HAL_TIM_IRQHandler+0x152>
      }
      /* Output compare event */
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
 800286a:	6878      	ldr	r0, [r7, #4]
 800286c:	f000 f878 	bl	8002960 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8002870:	6878      	ldr	r0, [r7, #4]
 8002872:	f000 f889 	bl	8002988 <HAL_TIM_PWM_PulseFinishedCallback>
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8002876:	687b      	ldr	r3, [r7, #4]
 8002878:	2200      	movs	r2, #0
 800287a:	761a      	strb	r2, [r3, #24]
    }
  }
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 800287c:	687b      	ldr	r3, [r7, #4]
 800287e:	681b      	ldr	r3, [r3, #0]
 8002880:	691b      	ldr	r3, [r3, #16]
 8002882:	f003 0301 	and.w	r3, r3, #1
 8002886:	2b00      	cmp	r3, #0
 8002888:	d00e      	beq.n	80028a8 <HAL_TIM_IRQHandler+0x184>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
 800288a:	687b      	ldr	r3, [r7, #4]
 800288c:	681b      	ldr	r3, [r3, #0]
 800288e:	68db      	ldr	r3, [r3, #12]
 8002890:	f003 0301 	and.w	r3, r3, #1
 8002894:	2b00      	cmp	r3, #0
 8002896:	d007      	beq.n	80028a8 <HAL_TIM_IRQHandler+0x184>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
 8002898:	687b      	ldr	r3, [r7, #4]
 800289a:	681b      	ldr	r3, [r3, #0]
 800289c:	f06f 0201 	mvn.w	r2, #1
 80028a0:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 80028a2:	6878      	ldr	r0, [r7, #4]
 80028a4:	f00d fbe4 	bl	8010070 <HAL_TIM_PeriodElapsedCallback>
    }
  }
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 80028a8:	687b      	ldr	r3, [r7, #4]
 80028aa:	681b      	ldr	r3, [r3, #0]
 80028ac:	691b      	ldr	r3, [r3, #16]
 80028ae:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80028b2:	2b00      	cmp	r3, #0
 80028b4:	d00e      	beq.n	80028d4 <HAL_TIM_IRQHandler+0x1b0>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 80028b6:	687b      	ldr	r3, [r7, #4]
 80028b8:	681b      	ldr	r3, [r3, #0]
 80028ba:	68db      	ldr	r3, [r3, #12]
 80028bc:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80028c0:	2b00      	cmp	r3, #0
 80028c2:	d007      	beq.n	80028d4 <HAL_TIM_IRQHandler+0x1b0>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 80028c4:	687b      	ldr	r3, [r7, #4]
 80028c6:	681b      	ldr	r3, [r3, #0]
 80028c8:	f06f 0280 	mvn.w	r2, #128	; 0x80
 80028cc:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 80028ce:	6878      	ldr	r0, [r7, #4]
 80028d0:	f000 f920 	bl	8002b14 <HAL_TIMEx_BreakCallback>
    }
  }
  
    /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 80028d4:	687b      	ldr	r3, [r7, #4]
 80028d6:	681b      	ldr	r3, [r3, #0]
 80028d8:	691b      	ldr	r3, [r3, #16]
 80028da:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80028de:	2b00      	cmp	r3, #0
 80028e0:	d00e      	beq.n	8002900 <HAL_TIM_IRQHandler+0x1dc>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 80028e2:	687b      	ldr	r3, [r7, #4]
 80028e4:	681b      	ldr	r3, [r3, #0]
 80028e6:	68db      	ldr	r3, [r3, #12]
 80028e8:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80028ec:	2b00      	cmp	r3, #0
 80028ee:	d007      	beq.n	8002900 <HAL_TIM_IRQHandler+0x1dc>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
 80028f0:	687b      	ldr	r3, [r7, #4]
 80028f2:	681b      	ldr	r3, [r3, #0]
 80028f4:	f06f 0280 	mvn.w	r2, #128	; 0x80
 80028f8:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 80028fa:	6878      	ldr	r0, [r7, #4]
 80028fc:	f000 f90a 	bl	8002b14 <HAL_TIMEx_BreakCallback>
    }
  }

  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8002900:	687b      	ldr	r3, [r7, #4]
 8002902:	681b      	ldr	r3, [r3, #0]
 8002904:	691b      	ldr	r3, [r3, #16]
 8002906:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800290a:	2b00      	cmp	r3, #0
 800290c:	d00e      	beq.n	800292c <HAL_TIM_IRQHandler+0x208>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
 800290e:	687b      	ldr	r3, [r7, #4]
 8002910:	681b      	ldr	r3, [r3, #0]
 8002912:	68db      	ldr	r3, [r3, #12]
 8002914:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002918:	2b00      	cmp	r3, #0
 800291a:	d007      	beq.n	800292c <HAL_TIM_IRQHandler+0x208>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
 800291c:	687b      	ldr	r3, [r7, #4]
 800291e:	681b      	ldr	r3, [r3, #0]
 8002920:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8002924:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8002926:	6878      	ldr	r0, [r7, #4]
 8002928:	f000 f838 	bl	800299c <HAL_TIM_TriggerCallback>
    }
  }
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 800292c:	687b      	ldr	r3, [r7, #4]
 800292e:	681b      	ldr	r3, [r3, #0]
 8002930:	691b      	ldr	r3, [r3, #16]
 8002932:	f003 0320 	and.w	r3, r3, #32
 8002936:	2b00      	cmp	r3, #0
 8002938:	d00e      	beq.n	8002958 <HAL_TIM_IRQHandler+0x234>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
 800293a:	687b      	ldr	r3, [r7, #4]
 800293c:	681b      	ldr	r3, [r3, #0]
 800293e:	68db      	ldr	r3, [r3, #12]
 8002940:	f003 0320 	and.w	r3, r3, #32
 8002944:	2b00      	cmp	r3, #0
 8002946:	d007      	beq.n	8002958 <HAL_TIM_IRQHandler+0x234>
    {
      __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
 8002948:	687b      	ldr	r3, [r7, #4]
 800294a:	681b      	ldr	r3, [r3, #0]
 800294c:	f06f 0220 	mvn.w	r2, #32
 8002950:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_CommutationCallback(htim);
 8002952:	6878      	ldr	r0, [r7, #4]
 8002954:	f000 f8d4 	bl	8002b00 <HAL_TIMEx_CommutationCallback>
    }
  }
}
 8002958:	3708      	adds	r7, #8
 800295a:	46bd      	mov	sp, r7
 800295c:	bd80      	pop	{r7, pc}
 800295e:	bf00      	nop

08002960 <HAL_TIM_OC_DelayElapsedCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 8002960:	b480      	push	{r7}
 8002962:	b083      	sub	sp, #12
 8002964:	af00      	add	r7, sp, #0
 8002966:	6078      	str	r0, [r7, #4]
  UNUSED(htim);
 
  /* NOTE : This function Should not be modified, when the callback is needed,
            the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 8002968:	370c      	adds	r7, #12
 800296a:	46bd      	mov	sp, r7
 800296c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002970:	4770      	bx	lr
 8002972:	bf00      	nop

08002974 <HAL_TIM_IC_CaptureCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 8002974:	b480      	push	{r7}
 8002976:	b083      	sub	sp, #12
 8002978:	af00      	add	r7, sp, #0
 800297a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);
 
  /* NOTE : This function Should not be modified, when the callback is needed,
            the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 800297c:	370c      	adds	r7, #12
 800297e:	46bd      	mov	sp, r7
 8002980:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002984:	4770      	bx	lr
 8002986:	bf00      	nop

08002988 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 8002988:	b480      	push	{r7}
 800298a:	b083      	sub	sp, #12
 800298c:	af00      	add	r7, sp, #0
 800298e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);
 
  /* NOTE : This function Should not be modified, when the callback is needed,
            the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8002990:	370c      	adds	r7, #12
 8002992:	46bd      	mov	sp, r7
 8002994:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002998:	4770      	bx	lr
 800299a:	bf00      	nop

0800299c <HAL_TIM_TriggerCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 800299c:	b480      	push	{r7}
 800299e:	b083      	sub	sp, #12
 80029a0:	af00      	add	r7, sp, #0
 80029a2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);
 
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 80029a4:	370c      	adds	r7, #12
 80029a6:	46bd      	mov	sp, r7
 80029a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 80029ac:	4770      	bx	lr
 80029ae:	bf00      	nop

080029b0 <TIM_Base_SetConfig>:
  * @param  TIMx: TIM peripheral
  * @param  Structure: pointer on TIM Time Base required parameters  
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
{
 80029b0:	b480      	push	{r7}
 80029b2:	b085      	sub	sp, #20
 80029b4:	af00      	add	r7, sp, #0
 80029b6:	6078      	str	r0, [r7, #4]
 80029b8:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1 = 0;
 80029ba:	2300      	movs	r3, #0
 80029bc:	60fb      	str	r3, [r7, #12]
  tmpcr1 = TIMx->CR1;
 80029be:	687b      	ldr	r3, [r7, #4]
 80029c0:	681b      	ldr	r3, [r3, #0]
 80029c2:	60fb      	str	r3, [r7, #12]
  
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if(IS_TIM_CC3_INSTANCE(TIMx) != RESET)   
 80029c4:	687b      	ldr	r3, [r7, #4]
 80029c6:	4a43      	ldr	r2, [pc, #268]	; (8002ad4 <TIM_Base_SetConfig+0x124>)
 80029c8:	4293      	cmp	r3, r2
 80029ca:	d013      	beq.n	80029f4 <TIM_Base_SetConfig+0x44>
 80029cc:	687b      	ldr	r3, [r7, #4]
 80029ce:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 80029d2:	d00f      	beq.n	80029f4 <TIM_Base_SetConfig+0x44>
 80029d4:	687b      	ldr	r3, [r7, #4]
 80029d6:	4a40      	ldr	r2, [pc, #256]	; (8002ad8 <TIM_Base_SetConfig+0x128>)
 80029d8:	4293      	cmp	r3, r2
 80029da:	d00b      	beq.n	80029f4 <TIM_Base_SetConfig+0x44>
 80029dc:	687b      	ldr	r3, [r7, #4]
 80029de:	4a3f      	ldr	r2, [pc, #252]	; (8002adc <TIM_Base_SetConfig+0x12c>)
 80029e0:	4293      	cmp	r3, r2
 80029e2:	d007      	beq.n	80029f4 <TIM_Base_SetConfig+0x44>
 80029e4:	687b      	ldr	r3, [r7, #4]
 80029e6:	4a3e      	ldr	r2, [pc, #248]	; (8002ae0 <TIM_Base_SetConfig+0x130>)
 80029e8:	4293      	cmp	r3, r2
 80029ea:	d003      	beq.n	80029f4 <TIM_Base_SetConfig+0x44>
 80029ec:	687b      	ldr	r3, [r7, #4]
 80029ee:	4a3d      	ldr	r2, [pc, #244]	; (8002ae4 <TIM_Base_SetConfig+0x134>)
 80029f0:	4293      	cmp	r3, r2
 80029f2:	d101      	bne.n	80029f8 <TIM_Base_SetConfig+0x48>
 80029f4:	2301      	movs	r3, #1
 80029f6:	e000      	b.n	80029fa <TIM_Base_SetConfig+0x4a>
 80029f8:	2300      	movs	r3, #0
 80029fa:	2b00      	cmp	r3, #0
 80029fc:	d008      	beq.n	8002a10 <TIM_Base_SetConfig+0x60>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 80029fe:	68fb      	ldr	r3, [r7, #12]
 8002a00:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8002a04:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 8002a06:	683b      	ldr	r3, [r7, #0]
 8002a08:	685b      	ldr	r3, [r3, #4]
 8002a0a:	68fa      	ldr	r2, [r7, #12]
 8002a0c:	4313      	orrs	r3, r2
 8002a0e:	60fb      	str	r3, [r7, #12]
  }
 
  if(IS_TIM_CC1_INSTANCE(TIMx) != RESET)  
 8002a10:	687b      	ldr	r3, [r7, #4]
 8002a12:	4a30      	ldr	r2, [pc, #192]	; (8002ad4 <TIM_Base_SetConfig+0x124>)
 8002a14:	4293      	cmp	r3, r2
 8002a16:	d02b      	beq.n	8002a70 <TIM_Base_SetConfig+0xc0>
 8002a18:	687b      	ldr	r3, [r7, #4]
 8002a1a:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
 8002a1e:	d027      	beq.n	8002a70 <TIM_Base_SetConfig+0xc0>
 8002a20:	687b      	ldr	r3, [r7, #4]
 8002a22:	4a2d      	ldr	r2, [pc, #180]	; (8002ad8 <TIM_Base_SetConfig+0x128>)
 8002a24:	4293      	cmp	r3, r2
 8002a26:	d023      	beq.n	8002a70 <TIM_Base_SetConfig+0xc0>
 8002a28:	687b      	ldr	r3, [r7, #4]
 8002a2a:	4a2c      	ldr	r2, [pc, #176]	; (8002adc <TIM_Base_SetConfig+0x12c>)
 8002a2c:	4293      	cmp	r3, r2
 8002a2e:	d01f      	beq.n	8002a70 <TIM_Base_SetConfig+0xc0>
 8002a30:	687b      	ldr	r3, [r7, #4]
 8002a32:	4a2b      	ldr	r2, [pc, #172]	; (8002ae0 <TIM_Base_SetConfig+0x130>)
 8002a34:	4293      	cmp	r3, r2
 8002a36:	d01b      	beq.n	8002a70 <TIM_Base_SetConfig+0xc0>
 8002a38:	687b      	ldr	r3, [r7, #4]
 8002a3a:	4a2a      	ldr	r2, [pc, #168]	; (8002ae4 <TIM_Base_SetConfig+0x134>)
 8002a3c:	4293      	cmp	r3, r2
 8002a3e:	d017      	beq.n	8002a70 <TIM_Base_SetConfig+0xc0>
 8002a40:	687b      	ldr	r3, [r7, #4]
 8002a42:	4a29      	ldr	r2, [pc, #164]	; (8002ae8 <TIM_Base_SetConfig+0x138>)
 8002a44:	4293      	cmp	r3, r2
 8002a46:	d013      	beq.n	8002a70 <TIM_Base_SetConfig+0xc0>
 8002a48:	687b      	ldr	r3, [r7, #4]
 8002a4a:	4a28      	ldr	r2, [pc, #160]	; (8002aec <TIM_Base_SetConfig+0x13c>)
 8002a4c:	4293      	cmp	r3, r2
 8002a4e:	d00f      	beq.n	8002a70 <TIM_Base_SetConfig+0xc0>
 8002a50:	687b      	ldr	r3, [r7, #4]
 8002a52:	4a27      	ldr	r2, [pc, #156]	; (8002af0 <TIM_Base_SetConfig+0x140>)
 8002a54:	4293      	cmp	r3, r2
 8002a56:	d00b      	beq.n	8002a70 <TIM_Base_SetConfig+0xc0>
 8002a58:	687b      	ldr	r3, [r7, #4]
 8002a5a:	4a26      	ldr	r2, [pc, #152]	; (8002af4 <TIM_Base_SetConfig+0x144>)
 8002a5c:	4293      	cmp	r3, r2
 8002a5e:	d007      	beq.n	8002a70 <TIM_Base_SetConfig+0xc0>
 8002a60:	687b      	ldr	r3, [r7, #4]
 8002a62:	4a25      	ldr	r2, [pc, #148]	; (8002af8 <TIM_Base_SetConfig+0x148>)
 8002a64:	4293      	cmp	r3, r2
 8002a66:	d003      	beq.n	8002a70 <TIM_Base_SetConfig+0xc0>
 8002a68:	687b      	ldr	r3, [r7, #4]
 8002a6a:	4a24      	ldr	r2, [pc, #144]	; (8002afc <TIM_Base_SetConfig+0x14c>)
 8002a6c:	4293      	cmp	r3, r2
 8002a6e:	d101      	bne.n	8002a74 <TIM_Base_SetConfig+0xc4>
 8002a70:	2301      	movs	r3, #1
 8002a72:	e000      	b.n	8002a76 <TIM_Base_SetConfig+0xc6>
 8002a74:	2300      	movs	r3, #0
 8002a76:	2b00      	cmp	r3, #0
 8002a78:	d008      	beq.n	8002a8c <TIM_Base_SetConfig+0xdc>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8002a7a:	68fb      	ldr	r3, [r7, #12]
 8002a7c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002a80:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002a82:	683b      	ldr	r3, [r7, #0]
 8002a84:	68db      	ldr	r3, [r3, #12]
 8002a86:	68fa      	ldr	r2, [r7, #12]
 8002a88:	4313      	orrs	r3, r2
 8002a8a:	60fb      	str	r3, [r7, #12]
  }

  TIMx->CR1 = tmpcr1;
 8002a8c:	687b      	ldr	r3, [r7, #4]
 8002a8e:	68fa      	ldr	r2, [r7, #12]
 8002a90:	601a      	str	r2, [r3, #0]

  /* Set the Auto-reload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002a92:	683b      	ldr	r3, [r7, #0]
 8002a94:	689a      	ldr	r2, [r3, #8]
 8002a96:	687b      	ldr	r3, [r7, #4]
 8002a98:	62da      	str	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8002a9a:	683b      	ldr	r3, [r7, #0]
 8002a9c:	681a      	ldr	r2, [r3, #0]
 8002a9e:	687b      	ldr	r3, [r7, #4]
 8002aa0:	629a      	str	r2, [r3, #40]	; 0x28
    
  if(IS_TIM_ADVANCED_INSTANCE(TIMx) != RESET)  
 8002aa2:	687b      	ldr	r3, [r7, #4]
 8002aa4:	4a0b      	ldr	r2, [pc, #44]	; (8002ad4 <TIM_Base_SetConfig+0x124>)
 8002aa6:	4293      	cmp	r3, r2
 8002aa8:	d003      	beq.n	8002ab2 <TIM_Base_SetConfig+0x102>
 8002aaa:	687b      	ldr	r3, [r7, #4]
 8002aac:	4a0d      	ldr	r2, [pc, #52]	; (8002ae4 <TIM_Base_SetConfig+0x134>)
 8002aae:	4293      	cmp	r3, r2
 8002ab0:	d101      	bne.n	8002ab6 <TIM_Base_SetConfig+0x106>
 8002ab2:	2301      	movs	r3, #1
 8002ab4:	e000      	b.n	8002ab8 <TIM_Base_SetConfig+0x108>
 8002ab6:	2300      	movs	r3, #0
 8002ab8:	2b00      	cmp	r3, #0
 8002aba:	d003      	beq.n	8002ac4 <TIM_Base_SetConfig+0x114>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8002abc:	683b      	ldr	r3, [r7, #0]
 8002abe:	691a      	ldr	r2, [r3, #16]
 8002ac0:	687b      	ldr	r3, [r7, #4]
 8002ac2:	631a      	str	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8002ac4:	687b      	ldr	r3, [r7, #4]
 8002ac6:	2201      	movs	r2, #1
 8002ac8:	615a      	str	r2, [r3, #20]
}
 8002aca:	3714      	adds	r7, #20
 8002acc:	46bd      	mov	sp, r7
 8002ace:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002ad2:	4770      	bx	lr
 8002ad4:	40010000 	.word	0x40010000
 8002ad8:	40000400 	.word	0x40000400
 8002adc:	40000800 	.word	0x40000800
 8002ae0:	40000c00 	.word	0x40000c00
 8002ae4:	40010400 	.word	0x40010400
 8002ae8:	40014000 	.word	0x40014000
 8002aec:	40014400 	.word	0x40014400
 8002af0:	40014800 	.word	0x40014800
 8002af4:	40001800 	.word	0x40001800
 8002af8:	40001c00 	.word	0x40001c00
 8002afc:	40002000 	.word	0x40002000

08002b00 <HAL_TIMEx_CommutationCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIMEx_CommutationCallback(TIM_HandleTypeDef *htim)
{
 8002b00:	b480      	push	{r7}
 8002b02:	b083      	sub	sp, #12
 8002b04:	af00      	add	r7, sp, #0
 8002b06:	6078      	str	r0, [r7, #4]
  UNUSED(htim);
 
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutationCallback could be implemented in the user file
   */
}
 8002b08:	370c      	adds	r7, #12
 8002b0a:	46bd      	mov	sp, r7
 8002b0c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b10:	4770      	bx	lr
 8002b12:	bf00      	nop

08002b14 <HAL_TIMEx_BreakCallback>:
  * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
  *                the configuration information for TIM module.
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8002b14:	b480      	push	{r7}
 8002b16:	b083      	sub	sp, #12
 8002b18:	af00      	add	r7, sp, #0
 8002b1a:	6078      	str	r0, [r7, #4]
  UNUSED(htim);
 
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8002b1c:	370c      	adds	r7, #12
 8002b1e:	46bd      	mov	sp, r7
 8002b20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002b24:	4770      	bx	lr
 8002b26:	bf00      	nop

08002b28 <FMC_SDRAM_Init>:
  * @param  Device: Pointer to SDRAM device instance
  * @param  Init: Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 8002b28:	b480      	push	{r7}
 8002b2a:	b085      	sub	sp, #20
 8002b2c:	af00      	add	r7, sp, #0
 8002b2e:	6078      	str	r0, [r7, #4]
 8002b30:	6039      	str	r1, [r7, #0]
  uint32_t tmpr1 = 0;
 8002b32:	2300      	movs	r3, #0
 8002b34:	60fb      	str	r3, [r7, #12]
  uint32_t tmpr2 = 0;
 8002b36:	2300      	movs	r3, #0
 8002b38:	60bb      	str	r3, [r7, #8]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 8002b3a:	683b      	ldr	r3, [r7, #0]
 8002b3c:	681b      	ldr	r3, [r3, #0]
 8002b3e:	2b01      	cmp	r3, #1
 8002b40:	d027      	beq.n	8002b92 <FMC_SDRAM_Init+0x6a>
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 8002b42:	687b      	ldr	r3, [r7, #4]
 8002b44:	681b      	ldr	r3, [r3, #0]
 8002b46:	60fb      	str	r3, [r7, #12]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8002b48:	68fa      	ldr	r2, [r7, #12]
 8002b4a:	4b2f      	ldr	r3, [pc, #188]	; (8002c08 <FMC_SDRAM_Init+0xe0>)
 8002b4c:	4013      	ands	r3, r2
 8002b4e:	60fb      	str	r3, [r7, #12]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8002b50:	683b      	ldr	r3, [r7, #0]
 8002b52:	685a      	ldr	r2, [r3, #4]
                        Init->RowBitsNumber      |\
 8002b54:	683b      	ldr	r3, [r7, #0]
 8002b56:	689b      	ldr	r3, [r3, #8]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8002b58:	431a      	orrs	r2, r3
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
 8002b5a:	683b      	ldr	r3, [r7, #0]
 8002b5c:	68db      	ldr	r3, [r3, #12]
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
 8002b5e:	431a      	orrs	r2, r3
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
 8002b60:	683b      	ldr	r3, [r7, #0]
 8002b62:	691b      	ldr	r3, [r3, #16]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
 8002b64:	431a      	orrs	r2, r3
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
 8002b66:	683b      	ldr	r3, [r7, #0]
 8002b68:	695b      	ldr	r3, [r3, #20]
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
 8002b6a:	431a      	orrs	r2, r3
                        Init->CASLatency         |\
                        Init->WriteProtection    |\
 8002b6c:	683b      	ldr	r3, [r7, #0]
 8002b6e:	699b      	ldr	r3, [r3, #24]

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
 8002b70:	431a      	orrs	r2, r3
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
 8002b72:	683b      	ldr	r3, [r7, #0]
 8002b74:	69db      	ldr	r3, [r3, #28]
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
                        Init->WriteProtection    |\
 8002b76:	431a      	orrs	r2, r3
                        Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
 8002b78:	683b      	ldr	r3, [r7, #0]
 8002b7a:	6a1b      	ldr	r3, [r3, #32]
                        Init->RowBitsNumber      |\
                        Init->MemoryDataWidth    |\
                        Init->InternalBankNumber |\
                        Init->CASLatency         |\
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
 8002b7c:	431a      	orrs	r2, r3
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay
 8002b7e:	683b      	ldr	r3, [r7, #0]
 8002b80:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8002b82:	4313      	orrs	r3, r2
 8002b84:	68fa      	ldr	r2, [r7, #12]
 8002b86:	4313      	orrs	r3, r2
 8002b88:	60fb      	str	r3, [r7, #12]
                        Init->WriteProtection    |\
                        Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay
                        );                                      
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 8002b8a:	687b      	ldr	r3, [r7, #4]
 8002b8c:	68fa      	ldr	r2, [r7, #12]
 8002b8e:	601a      	str	r2, [r3, #0]
 8002b90:	e032      	b.n	8002bf8 <FMC_SDRAM_Init+0xd0>
  }
  else /* FMC_Bank2_SDRAM */                      
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 8002b92:	687b      	ldr	r3, [r7, #4]
 8002b94:	681b      	ldr	r3, [r3, #0]
 8002b96:	60fb      	str	r3, [r7, #12]
    
    /* Clear SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
 8002b98:	68fb      	ldr	r3, [r7, #12]
 8002b9a:	f423 43f8 	bic.w	r3, r3, #31744	; 0x7c00
 8002b9e:	60fb      	str	r3, [r7, #12]
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 8002ba0:	683b      	ldr	r3, [r7, #0]
 8002ba2:	69da      	ldr	r2, [r3, #28]
                        Init->ReadBurst          |\
 8002ba4:	683b      	ldr	r3, [r7, #0]
 8002ba6:	6a1b      	ldr	r3, [r3, #32]
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
    
    /* Clear SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 8002ba8:	431a      	orrs	r2, r3
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay);
 8002baa:	683b      	ldr	r3, [r7, #0]
 8002bac:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
    
    /* Clear SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 8002bae:	4313      	orrs	r3, r2
 8002bb0:	68fa      	ldr	r2, [r7, #12]
 8002bb2:	4313      	orrs	r3, r2
 8002bb4:	60fb      	str	r3, [r7, #12]
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay);
    
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
 8002bb6:	687b      	ldr	r3, [r7, #4]
 8002bb8:	685b      	ldr	r3, [r3, #4]
 8002bba:	60bb      	str	r3, [r7, #8]
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8002bbc:	68ba      	ldr	r2, [r7, #8]
 8002bbe:	4b12      	ldr	r3, [pc, #72]	; (8002c08 <FMC_SDRAM_Init+0xe0>)
 8002bc0:	4013      	ands	r3, r2
 8002bc2:	60bb      	str	r3, [r7, #8]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8002bc4:	683b      	ldr	r3, [r7, #0]
 8002bc6:	685a      	ldr	r2, [r3, #4]
                       Init->RowBitsNumber       |\
 8002bc8:	683b      	ldr	r3, [r7, #0]
 8002bca:	689b      	ldr	r3, [r3, #8]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8002bcc:	431a      	orrs	r2, r3
                       Init->RowBitsNumber       |\
                       Init->MemoryDataWidth     |\
 8002bce:	683b      	ldr	r3, [r7, #0]
 8002bd0:	68db      	ldr	r3, [r3, #12]
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
                       Init->RowBitsNumber       |\
 8002bd2:	431a      	orrs	r2, r3
                       Init->MemoryDataWidth     |\
                       Init->InternalBankNumber  |\
 8002bd4:	683b      	ldr	r3, [r7, #0]
 8002bd6:	691b      	ldr	r3, [r3, #16]
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
                       Init->RowBitsNumber       |\
                       Init->MemoryDataWidth     |\
 8002bd8:	431a      	orrs	r2, r3
                       Init->InternalBankNumber  |\
                       Init->CASLatency          |\
 8002bda:	683b      	ldr	r3, [r7, #0]
 8002bdc:	695b      	ldr	r3, [r3, #20]
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
                       Init->RowBitsNumber       |\
                       Init->MemoryDataWidth     |\
                       Init->InternalBankNumber  |\
 8002bde:	431a      	orrs	r2, r3
                       Init->CASLatency          |\
                       Init->WriteProtection);
 8002be0:	683b      	ldr	r3, [r7, #0]
 8002be2:	699b      	ldr	r3, [r3, #24]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP   | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8002be4:	4313      	orrs	r3, r2
 8002be6:	68ba      	ldr	r2, [r7, #8]
 8002be8:	4313      	orrs	r3, r2
 8002bea:	60bb      	str	r3, [r7, #8]
                       Init->MemoryDataWidth     |\
                       Init->InternalBankNumber  |\
                       Init->CASLatency          |\
                       Init->WriteProtection);

    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 8002bec:	687b      	ldr	r3, [r7, #4]
 8002bee:	68fa      	ldr	r2, [r7, #12]
 8002bf0:	601a      	str	r2, [r3, #0]
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
 8002bf2:	687b      	ldr	r3, [r7, #4]
 8002bf4:	68ba      	ldr	r2, [r7, #8]
 8002bf6:	605a      	str	r2, [r3, #4]
  }
  
  return HAL_OK;
 8002bf8:	2300      	movs	r3, #0
}
 8002bfa:	4618      	mov	r0, r3
 8002bfc:	3714      	adds	r7, #20
 8002bfe:	46bd      	mov	sp, r7
 8002c00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002c04:	4770      	bx	lr
 8002c06:	bf00      	nop
 8002c08:	ffff8000 	.word	0xffff8000

08002c0c <FMC_SDRAM_Timing_Init>:
  * @param  Timing: Pointer to SDRAM Timing structure
  * @param  Bank: SDRAM bank number   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 8002c0c:	b480      	push	{r7}
 8002c0e:	b087      	sub	sp, #28
 8002c10:	af00      	add	r7, sp, #0
 8002c12:	60f8      	str	r0, [r7, #12]
 8002c14:	60b9      	str	r1, [r7, #8]
 8002c16:	607a      	str	r2, [r7, #4]
  uint32_t tmpr1 = 0;
 8002c18:	2300      	movs	r3, #0
 8002c1a:	617b      	str	r3, [r7, #20]
  uint32_t tmpr2 = 0;
 8002c1c:	2300      	movs	r3, #0
 8002c1e:	613b      	str	r3, [r7, #16]
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
 8002c20:	687b      	ldr	r3, [r7, #4]
 8002c22:	2b01      	cmp	r3, #1
 8002c24:	d02e      	beq.n	8002c84 <FMC_SDRAM_Timing_Init+0x78>
  {
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 8002c26:	68fb      	ldr	r3, [r7, #12]
 8002c28:	689b      	ldr	r3, [r3, #8]
 8002c2a:	617b      	str	r3, [r7, #20]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 8002c2c:	697b      	ldr	r3, [r7, #20]
 8002c2e:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8002c32:	617b      	str	r3, [r7, #20]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8002c34:	68bb      	ldr	r3, [r7, #8]
 8002c36:	681b      	ldr	r3, [r3, #0]
 8002c38:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8002c3a:	68bb      	ldr	r3, [r7, #8]
 8002c3c:	685b      	ldr	r3, [r3, #4]
 8002c3e:	3b01      	subs	r3, #1
 8002c40:	011b      	lsls	r3, r3, #4
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8002c42:	431a      	orrs	r2, r3
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 8002c44:	68bb      	ldr	r3, [r7, #8]
 8002c46:	689b      	ldr	r3, [r3, #8]
 8002c48:	3b01      	subs	r3, #1
 8002c4a:	021b      	lsls	r3, r3, #8
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
 8002c4c:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
 8002c4e:	68bb      	ldr	r3, [r7, #8]
 8002c50:	68db      	ldr	r3, [r3, #12]
 8002c52:	3b01      	subs	r3, #1
 8002c54:	031b      	lsls	r3, r3, #12
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
 8002c56:	431a      	orrs	r2, r3
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 8002c58:	68bb      	ldr	r3, [r7, #8]
 8002c5a:	691b      	ldr	r3, [r3, #16]
 8002c5c:	3b01      	subs	r3, #1
 8002c5e:	041b      	lsls	r3, r3, #16
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
 8002c60:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RPDelay)-1) << 20)             |\
 8002c62:	68bb      	ldr	r3, [r7, #8]
 8002c64:	695b      	ldr	r3, [r3, #20]
 8002c66:	3b01      	subs	r3, #1
 8002c68:	051b      	lsls	r3, r3, #20
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4) |\
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
 8002c6a:	431a      	orrs	r2, r3
                       (((Timing->RPDelay)-1) << 20)             |\
                       (((Timing->RCDDelay)-1) << 24));
 8002c6c:	68bb      	ldr	r3, [r7, #8]
 8002c6e:	699b      	ldr	r3, [r3, #24]
 8002c70:	3b01      	subs	r3, #1
 8002c72:	061b      	lsls	r3, r3, #24
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8002c74:	4313      	orrs	r3, r2
 8002c76:	697a      	ldr	r2, [r7, #20]
 8002c78:	4313      	orrs	r3, r2
 8002c7a:	617b      	str	r3, [r7, #20]
                       (((Timing->SelfRefreshTime)-1) << 8)      |\
                       (((Timing->RowCycleDelay)-1) << 12)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)    |\
                       (((Timing->RPDelay)-1) << 20)             |\
                       (((Timing->RCDDelay)-1) << 24));
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 8002c7c:	68fb      	ldr	r3, [r7, #12]
 8002c7e:	697a      	ldr	r2, [r7, #20]
 8002c80:	609a      	str	r2, [r3, #8]
 8002c82:	e039      	b.n	8002cf8 <FMC_SDRAM_Timing_Init+0xec>
  }
  else /* FMC_Bank2_SDRAM */
  {
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 8002c84:	68fb      	ldr	r3, [r7, #12]
 8002c86:	689b      	ldr	r3, [r3, #8]
 8002c88:	617b      	str	r3, [r7, #20]
    
    /* Clear TRC and TRP bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 8002c8a:	697a      	ldr	r2, [r7, #20]
 8002c8c:	4b1e      	ldr	r3, [pc, #120]	; (8002d08 <FMC_SDRAM_Timing_Init+0xfc>)
 8002c8e:	4013      	ands	r3, r2
 8002c90:	617b      	str	r3, [r7, #20]
    
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 8002c92:	68bb      	ldr	r3, [r7, #8]
 8002c94:	68db      	ldr	r3, [r3, #12]
 8002c96:	3b01      	subs	r3, #1
 8002c98:	031a      	lsls	r2, r3, #12
                        (((Timing->RPDelay)-1) << 20)); 
 8002c9a:	68bb      	ldr	r3, [r7, #8]
 8002c9c:	695b      	ldr	r3, [r3, #20]
 8002c9e:	3b01      	subs	r3, #1
 8002ca0:	051b      	lsls	r3, r3, #20
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
    
    /* Clear TRC and TRP bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
    
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 8002ca2:	4313      	orrs	r3, r2
 8002ca4:	697a      	ldr	r2, [r7, #20]
 8002ca6:	4313      	orrs	r3, r2
 8002ca8:	617b      	str	r3, [r7, #20]
                        (((Timing->RPDelay)-1) << 20)); 
    
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
 8002caa:	68fb      	ldr	r3, [r7, #12]
 8002cac:	68db      	ldr	r3, [r3, #12]
 8002cae:	613b      	str	r3, [r7, #16]
    
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
 8002cb0:	693b      	ldr	r3, [r7, #16]
 8002cb2:	f003 4370 	and.w	r3, r3, #4026531840	; 0xf0000000
 8002cb6:	613b      	str	r3, [r7, #16]
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8002cb8:	68bb      	ldr	r3, [r7, #8]
 8002cba:	681b      	ldr	r3, [r3, #0]
 8002cbc:	1e5a      	subs	r2, r3, #1
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
 8002cbe:	68bb      	ldr	r3, [r7, #8]
 8002cc0:	685b      	ldr	r3, [r3, #4]
 8002cc2:	3b01      	subs	r3, #1
 8002cc4:	011b      	lsls	r3, r3, #4
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8002cc6:	431a      	orrs	r2, r3
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
 8002cc8:	68bb      	ldr	r3, [r7, #8]
 8002cca:	689b      	ldr	r3, [r3, #8]
 8002ccc:	3b01      	subs	r3, #1
 8002cce:	021b      	lsls	r3, r3, #8
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
 8002cd0:	431a      	orrs	r2, r3
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)     |\
 8002cd2:	68bb      	ldr	r3, [r7, #8]
 8002cd4:	691b      	ldr	r3, [r3, #16]
 8002cd6:	3b01      	subs	r3, #1
 8002cd8:	041b      	lsls	r3, r3, #16
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
 8002cda:	431a      	orrs	r2, r3
                       (((Timing->WriteRecoveryTime)-1) <<16)     |\
                       (((Timing->RCDDelay)-1) << 24));   
 8002cdc:	68bb      	ldr	r3, [r7, #8]
 8002cde:	699b      	ldr	r3, [r3, #24]
 8002ce0:	3b01      	subs	r3, #1
 8002ce2:	061b      	lsls	r3, r3, #24
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr2 |= (uint32_t)(((Timing->LoadToActiveDelay)-1)           |\
 8002ce4:	4313      	orrs	r3, r2
 8002ce6:	693a      	ldr	r2, [r7, #16]
 8002ce8:	4313      	orrs	r3, r2
 8002cea:	613b      	str	r3, [r7, #16]
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)     |\
                       (((Timing->RCDDelay)-1) << 24));   

    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 8002cec:	68fb      	ldr	r3, [r7, #12]
 8002cee:	697a      	ldr	r2, [r7, #20]
 8002cf0:	609a      	str	r2, [r3, #8]
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
 8002cf2:	68fb      	ldr	r3, [r7, #12]
 8002cf4:	693a      	ldr	r2, [r7, #16]
 8002cf6:	60da      	str	r2, [r3, #12]
  }
  
  return HAL_OK;
 8002cf8:	2300      	movs	r3, #0
}
 8002cfa:	4618      	mov	r0, r3
 8002cfc:	371c      	adds	r7, #28
 8002cfe:	46bd      	mov	sp, r7
 8002d00:	f85d 7b04 	ldr.w	r7, [sp], #4
 8002d04:	4770      	bx	lr
 8002d06:	bf00      	nop
 8002d08:	ff0f0fff 	.word	0xff0f0fff

08002d0c <HAL_RTC_Init>:
  * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RTC_Init(RTC_HandleTypeDef *hrtc)
{
 8002d0c:	b580      	push	{r7, lr}
 8002d0e:	b082      	sub	sp, #8
 8002d10:	af00      	add	r7, sp, #0
 8002d12:	6078      	str	r0, [r7, #4]
  /* Check the RTC peripheral state */
  if(hrtc == NULL)
 8002d14:	687b      	ldr	r3, [r7, #4]
 8002d16:	2b00      	cmp	r3, #0
 8002d18:	d101      	bne.n	8002d1e <HAL_RTC_Init+0x12>
  {
     return HAL_ERROR;
 8002d1a:	2301      	movs	r3, #1
 8002d1c:	e06b      	b.n	8002df6 <HAL_RTC_Init+0xea>
  assert_param(IS_RTC_SYNCH_PREDIV(hrtc->Init.SynchPrediv));
  assert_param (IS_RTC_OUTPUT(hrtc->Init.OutPut));
  assert_param (IS_RTC_OUTPUT_POL(hrtc->Init.OutPutPolarity));
  assert_param(IS_RTC_OUTPUT_TYPE(hrtc->Init.OutPutType));
    
  if(hrtc->State == HAL_RTC_STATE_RESET)
 8002d1e:	687b      	ldr	r3, [r7, #4]
 8002d20:	7f5b      	ldrb	r3, [r3, #29]
 8002d22:	b2db      	uxtb	r3, r3
 8002d24:	2b00      	cmp	r3, #0
 8002d26:	d105      	bne.n	8002d34 <HAL_RTC_Init+0x28>
  {
    /* Allocate lock resource and initialize it */
    hrtc->Lock = HAL_UNLOCKED;
 8002d28:	687b      	ldr	r3, [r7, #4]
 8002d2a:	2200      	movs	r2, #0
 8002d2c:	771a      	strb	r2, [r3, #28]
    /* Initialize RTC MSP */
    HAL_RTC_MspInit(hrtc);
 8002d2e:	6878      	ldr	r0, [r7, #4]
 8002d30:	f00d fc48 	bl	80105c4 <HAL_RTC_MspInit>
  }
  
  /* Set RTC state */  
  hrtc->State = HAL_RTC_STATE_BUSY;  
 8002d34:	687b      	ldr	r3, [r7, #4]
 8002d36:	2202      	movs	r2, #2
 8002d38:	775a      	strb	r2, [r3, #29]
       
  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8002d3a:	687b      	ldr	r3, [r7, #4]
 8002d3c:	681b      	ldr	r3, [r3, #0]
 8002d3e:	22ca      	movs	r2, #202	; 0xca
 8002d40:	625a      	str	r2, [r3, #36]	; 0x24
 8002d42:	687b      	ldr	r3, [r7, #4]
 8002d44:	681b      	ldr	r3, [r3, #0]
 8002d46:	2253      	movs	r2, #83	; 0x53
 8002d48:	625a      	str	r2, [r3, #36]	; 0x24

  /* Set Initialization mode */
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8002d4a:	6878      	ldr	r0, [r7, #4]
 8002d4c:	f000 f85a 	bl	8002e04 <RTC_EnterInitMode>
 8002d50:	4603      	mov	r3, r0
 8002d52:	2b00      	cmp	r3, #0
 8002d54:	d008      	beq.n	8002d68 <HAL_RTC_Init+0x5c>
  {
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8002d56:	687b      	ldr	r3, [r7, #4]
 8002d58:	681b      	ldr	r3, [r3, #0]
 8002d5a:	22ff      	movs	r2, #255	; 0xff
 8002d5c:	625a      	str	r2, [r3, #36]	; 0x24
    
    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_ERROR;
 8002d5e:	687b      	ldr	r3, [r7, #4]
 8002d60:	2204      	movs	r2, #4
 8002d62:	775a      	strb	r2, [r3, #29]
    
    return HAL_ERROR;
 8002d64:	2301      	movs	r3, #1
 8002d66:	e046      	b.n	8002df6 <HAL_RTC_Init+0xea>
  } 
  else
  { 
    /* Clear RTC_CR FMT, OSEL and POL Bits */
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 8002d68:	687b      	ldr	r3, [r7, #4]
 8002d6a:	681a      	ldr	r2, [r3, #0]
 8002d6c:	687b      	ldr	r3, [r7, #4]
 8002d6e:	681b      	ldr	r3, [r3, #0]
 8002d70:	6899      	ldr	r1, [r3, #8]
 8002d72:	4b23      	ldr	r3, [pc, #140]	; (8002e00 <HAL_RTC_Init+0xf4>)
 8002d74:	400b      	ands	r3, r1
 8002d76:	6093      	str	r3, [r2, #8]
    /* Set RTC_CR register */
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 8002d78:	687b      	ldr	r3, [r7, #4]
 8002d7a:	681b      	ldr	r3, [r3, #0]
 8002d7c:	687a      	ldr	r2, [r7, #4]
 8002d7e:	6812      	ldr	r2, [r2, #0]
 8002d80:	6891      	ldr	r1, [r2, #8]
 8002d82:	687a      	ldr	r2, [r7, #4]
 8002d84:	6850      	ldr	r0, [r2, #4]
 8002d86:	687a      	ldr	r2, [r7, #4]
 8002d88:	6912      	ldr	r2, [r2, #16]
 8002d8a:	4310      	orrs	r0, r2
 8002d8c:	687a      	ldr	r2, [r7, #4]
 8002d8e:	6952      	ldr	r2, [r2, #20]
 8002d90:	4302      	orrs	r2, r0
 8002d92:	430a      	orrs	r2, r1
 8002d94:	609a      	str	r2, [r3, #8]
    
    /* Configure the RTC PRER */
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 8002d96:	687b      	ldr	r3, [r7, #4]
 8002d98:	681b      	ldr	r3, [r3, #0]
 8002d9a:	687a      	ldr	r2, [r7, #4]
 8002d9c:	68d2      	ldr	r2, [r2, #12]
 8002d9e:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16);
 8002da0:	687b      	ldr	r3, [r7, #4]
 8002da2:	681b      	ldr	r3, [r3, #0]
 8002da4:	687a      	ldr	r2, [r7, #4]
 8002da6:	6812      	ldr	r2, [r2, #0]
 8002da8:	6911      	ldr	r1, [r2, #16]
 8002daa:	687a      	ldr	r2, [r7, #4]
 8002dac:	6892      	ldr	r2, [r2, #8]
 8002dae:	0412      	lsls	r2, r2, #16
 8002db0:	430a      	orrs	r2, r1
 8002db2:	611a      	str	r2, [r3, #16]
    
    /* Exit Initialization mode */
    hrtc->Instance->ISR &= (uint32_t)~RTC_ISR_INIT; 
 8002db4:	687b      	ldr	r3, [r7, #4]
 8002db6:	681b      	ldr	r3, [r3, #0]
 8002db8:	687a      	ldr	r2, [r7, #4]
 8002dba:	6812      	ldr	r2, [r2, #0]
 8002dbc:	68d2      	ldr	r2, [r2, #12]
 8002dbe:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8002dc2:	60da      	str	r2, [r3, #12]
    
    hrtc->Instance->OR &= (uint32_t)~RTC_OR_ALARMTYPE;
 8002dc4:	687b      	ldr	r3, [r7, #4]
 8002dc6:	681b      	ldr	r3, [r3, #0]
 8002dc8:	687a      	ldr	r2, [r7, #4]
 8002dca:	6812      	ldr	r2, [r2, #0]
 8002dcc:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8002dce:	f022 0208 	bic.w	r2, r2, #8
 8002dd2:	64da      	str	r2, [r3, #76]	; 0x4c
    hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType); 
 8002dd4:	687b      	ldr	r3, [r7, #4]
 8002dd6:	681b      	ldr	r3, [r3, #0]
 8002dd8:	687a      	ldr	r2, [r7, #4]
 8002dda:	6812      	ldr	r2, [r2, #0]
 8002ddc:	6cd1      	ldr	r1, [r2, #76]	; 0x4c
 8002dde:	687a      	ldr	r2, [r7, #4]
 8002de0:	6992      	ldr	r2, [r2, #24]
 8002de2:	430a      	orrs	r2, r1
 8002de4:	64da      	str	r2, [r3, #76]	; 0x4c
    
    /* Enable the write protection for RTC registers */
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc); 
 8002de6:	687b      	ldr	r3, [r7, #4]
 8002de8:	681b      	ldr	r3, [r3, #0]
 8002dea:	22ff      	movs	r2, #255	; 0xff
 8002dec:	625a      	str	r2, [r3, #36]	; 0x24
    
    /* Set RTC state */
    hrtc->State = HAL_RTC_STATE_READY;
 8002dee:	687b      	ldr	r3, [r7, #4]
 8002df0:	2201      	movs	r2, #1
 8002df2:	775a      	strb	r2, [r3, #29]
    
    return HAL_OK;
 8002df4:	2300      	movs	r3, #0
  }
}
 8002df6:	4618      	mov	r0, r3
 8002df8:	3708      	adds	r7, #8
 8002dfa:	46bd      	mov	sp, r7
 8002dfc:	bd80      	pop	{r7, pc}
 8002dfe:	bf00      	nop
 8002e00:	ff8fffbf 	.word	0xff8fffbf

08002e04 <RTC_EnterInitMode>:
  * @param  hrtc: pointer to a RTC_HandleTypeDef structure that contains
  *                the configuration information for RTC.
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 8002e04:	b580      	push	{r7, lr}
 8002e06:	b084      	sub	sp, #16
 8002e08:	af00      	add	r7, sp, #0
 8002e0a:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = 0; 
 8002e0c:	2300      	movs	r3, #0
 8002e0e:	60fb      	str	r3, [r7, #12]
  
  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8002e10:	687b      	ldr	r3, [r7, #4]
 8002e12:	681b      	ldr	r3, [r3, #0]
 8002e14:	68db      	ldr	r3, [r3, #12]
 8002e16:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002e1a:	2b00      	cmp	r3, #0
 8002e1c:	d119      	bne.n	8002e52 <RTC_EnterInitMode+0x4e>
  {
    /* Set the Initialization mode */
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 8002e1e:	687b      	ldr	r3, [r7, #4]
 8002e20:	681b      	ldr	r3, [r3, #0]
 8002e22:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002e26:	60da      	str	r2, [r3, #12]

    /* Get tick */
    tickstart = HAL_GetTick();
 8002e28:	f7fd fcec 	bl	8000804 <HAL_GetTick>
 8002e2c:	60f8      	str	r0, [r7, #12]

    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8002e2e:	e009      	b.n	8002e44 <RTC_EnterInitMode+0x40>
    {
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8002e30:	f7fd fce8 	bl	8000804 <HAL_GetTick>
 8002e34:	4602      	mov	r2, r0
 8002e36:	68fb      	ldr	r3, [r7, #12]
 8002e38:	1ad3      	subs	r3, r2, r3
 8002e3a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8002e3e:	d901      	bls.n	8002e44 <RTC_EnterInitMode+0x40>
      {       
        return HAL_TIMEOUT;
 8002e40:	2303      	movs	r3, #3
 8002e42:	e007      	b.n	8002e54 <RTC_EnterInitMode+0x50>

    /* Get tick */
    tickstart = HAL_GetTick();

    /* Wait till RTC is in INIT state and if Time out is reached exit */
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8002e44:	687b      	ldr	r3, [r7, #4]
 8002e46:	681b      	ldr	r3, [r3, #0]
 8002e48:	68db      	ldr	r3, [r3, #12]
 8002e4a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8002e4e:	2b00      	cmp	r3, #0
 8002e50:	d0ee      	beq.n	8002e30 <RTC_EnterInitMode+0x2c>
        return HAL_TIMEOUT;
      } 
    }
  }
  
  return HAL_OK;  
 8002e52:	2300      	movs	r3, #0
}
 8002e54:	4618      	mov	r0, r3
 8002e56:	3710      	adds	r7, #16
 8002e58:	46bd      	mov	sp, r7
 8002e5a:	bd80      	pop	{r7, pc}

08002e5c <HAL_RNG_Init>:
  * @param  hrng: pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{ 
 8002e5c:	b580      	push	{r7, lr}
 8002e5e:	b082      	sub	sp, #8
 8002e60:	af00      	add	r7, sp, #0
 8002e62:	6078      	str	r0, [r7, #4]
  /* Check the RNG handle allocation */
  if(hrng == NULL)
 8002e64:	687b      	ldr	r3, [r7, #4]
 8002e66:	2b00      	cmp	r3, #0
 8002e68:	d101      	bne.n	8002e6e <HAL_RNG_Init+0x12>
  {
    return HAL_ERROR;
 8002e6a:	2301      	movs	r3, #1
 8002e6c:	e025      	b.n	8002eba <HAL_RNG_Init+0x5e>
  }
  
  __HAL_LOCK(hrng);
 8002e6e:	687b      	ldr	r3, [r7, #4]
 8002e70:	7a1b      	ldrb	r3, [r3, #8]
 8002e72:	2b01      	cmp	r3, #1
 8002e74:	d101      	bne.n	8002e7a <HAL_RNG_Init+0x1e>
 8002e76:	2302      	movs	r3, #2
 8002e78:	e01f      	b.n	8002eba <HAL_RNG_Init+0x5e>
 8002e7a:	687b      	ldr	r3, [r7, #4]
 8002e7c:	2201      	movs	r2, #1
 8002e7e:	721a      	strb	r2, [r3, #8]
  
  if(hrng->State == HAL_RNG_STATE_RESET)
 8002e80:	687b      	ldr	r3, [r7, #4]
 8002e82:	7a5b      	ldrb	r3, [r3, #9]
 8002e84:	b2db      	uxtb	r3, r3
 8002e86:	2b00      	cmp	r3, #0
 8002e88:	d105      	bne.n	8002e96 <HAL_RNG_Init+0x3a>
  {  
    /* Allocate lock resource and initialize it */
    hrng->Lock = HAL_UNLOCKED;
 8002e8a:	687b      	ldr	r3, [r7, #4]
 8002e8c:	2200      	movs	r2, #0
 8002e8e:	721a      	strb	r2, [r3, #8]

    /* Init the low level hardware */
    HAL_RNG_MspInit(hrng);
 8002e90:	6878      	ldr	r0, [r7, #4]
 8002e92:	f00d fbaf 	bl	80105f4 <HAL_RNG_MspInit>
  }
  
  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
 8002e96:	687b      	ldr	r3, [r7, #4]
 8002e98:	2202      	movs	r2, #2
 8002e9a:	725a      	strb	r2, [r3, #9]

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 8002e9c:	687b      	ldr	r3, [r7, #4]
 8002e9e:	681b      	ldr	r3, [r3, #0]
 8002ea0:	687a      	ldr	r2, [r7, #4]
 8002ea2:	6812      	ldr	r2, [r2, #0]
 8002ea4:	6812      	ldr	r2, [r2, #0]
 8002ea6:	f042 0204 	orr.w	r2, r2, #4
 8002eaa:	601a      	str	r2, [r3, #0]

  /* Initialize the RNG state */
  hrng->State = HAL_RNG_STATE_READY;
 8002eac:	687b      	ldr	r3, [r7, #4]
 8002eae:	2201      	movs	r2, #1
 8002eb0:	725a      	strb	r2, [r3, #9]
  
  __HAL_UNLOCK(hrng);
 8002eb2:	687b      	ldr	r3, [r7, #4]
 8002eb4:	2200      	movs	r2, #0
 8002eb6:	721a      	strb	r2, [r3, #8]
  
  /* Return function status */
  return HAL_OK;
 8002eb8:	2300      	movs	r3, #0
}
 8002eba:	4618      	mov	r0, r3
 8002ebc:	3708      	adds	r7, #8
 8002ebe:	46bd      	mov	sp, r7
 8002ec0:	bd80      	pop	{r7, pc}
 8002ec2:	bf00      	nop

08002ec4 <HAL_RNG_GenerateRandomNumber>:
  * @param  random32bit: pointer to generated random number variable if successful.
  * @retval HAL status
  */

HAL_StatusTypeDef HAL_RNG_GenerateRandomNumber(RNG_HandleTypeDef *hrng, uint32_t *random32bit)
{
 8002ec4:	b580      	push	{r7, lr}
 8002ec6:	b084      	sub	sp, #16
 8002ec8:	af00      	add	r7, sp, #0
 8002eca:	6078      	str	r0, [r7, #4]
 8002ecc:	6039      	str	r1, [r7, #0]
  uint32_t tickstart = 0;    
 8002ece:	2300      	movs	r3, #0
 8002ed0:	60bb      	str	r3, [r7, #8]
  HAL_StatusTypeDef status = HAL_OK;
 8002ed2:	2300      	movs	r3, #0
 8002ed4:	73fb      	strb	r3, [r7, #15]

  /* Process Locked */
  __HAL_LOCK(hrng); 
 8002ed6:	687b      	ldr	r3, [r7, #4]
 8002ed8:	7a1b      	ldrb	r3, [r3, #8]
 8002eda:	2b01      	cmp	r3, #1
 8002edc:	d101      	bne.n	8002ee2 <HAL_RNG_GenerateRandomNumber+0x1e>
 8002ede:	2302      	movs	r3, #2
 8002ee0:	e037      	b.n	8002f52 <HAL_RNG_GenerateRandomNumber+0x8e>
 8002ee2:	687b      	ldr	r3, [r7, #4]
 8002ee4:	2201      	movs	r2, #1
 8002ee6:	721a      	strb	r2, [r3, #8]
  
  /* Check RNG peripheral state */
  if(hrng->State == HAL_RNG_STATE_READY)
 8002ee8:	687b      	ldr	r3, [r7, #4]
 8002eea:	7a5b      	ldrb	r3, [r3, #9]
 8002eec:	b2db      	uxtb	r3, r3
 8002eee:	2b01      	cmp	r3, #1
 8002ef0:	d129      	bne.n	8002f46 <HAL_RNG_GenerateRandomNumber+0x82>
  {
    /* Change RNG peripheral state */  
    hrng->State = HAL_RNG_STATE_BUSY;  
 8002ef2:	687b      	ldr	r3, [r7, #4]
 8002ef4:	2202      	movs	r2, #2
 8002ef6:	725a      	strb	r2, [r3, #9]

    /* Get tick */
    tickstart = HAL_GetTick();
 8002ef8:	f7fd fc84 	bl	8000804 <HAL_GetTick>
 8002efc:	60b8      	str	r0, [r7, #8]
  
    /* Check if data register contains valid random data */
    while(__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8002efe:	e00e      	b.n	8002f1e <HAL_RNG_GenerateRandomNumber+0x5a>
    {
      if((HAL_GetTick() - tickstart ) > RNG_TIMEOUT_VALUE)
 8002f00:	f7fd fc80 	bl	8000804 <HAL_GetTick>
 8002f04:	4602      	mov	r2, r0
 8002f06:	68bb      	ldr	r3, [r7, #8]
 8002f08:	1ad3      	subs	r3, r2, r3
 8002f0a:	2b02      	cmp	r3, #2
 8002f0c:	d907      	bls.n	8002f1e <HAL_RNG_GenerateRandomNumber+0x5a>
      {    
        hrng->State = HAL_RNG_STATE_ERROR;
 8002f0e:	687b      	ldr	r3, [r7, #4]
 8002f10:	2204      	movs	r2, #4
 8002f12:	725a      	strb	r2, [r3, #9]

        /* Process Unlocked */
        __HAL_UNLOCK(hrng);
 8002f14:	687b      	ldr	r3, [r7, #4]
 8002f16:	2200      	movs	r2, #0
 8002f18:	721a      	strb	r2, [r3, #8]
      
        return HAL_TIMEOUT;
 8002f1a:	2303      	movs	r3, #3
 8002f1c:	e019      	b.n	8002f52 <HAL_RNG_GenerateRandomNumber+0x8e>

    /* Get tick */
    tickstart = HAL_GetTick();
  
    /* Check if data register contains valid random data */
    while(__HAL_RNG_GET_FLAG(hrng, RNG_FLAG_DRDY) == RESET)
 8002f1e:	687b      	ldr	r3, [r7, #4]
 8002f20:	681b      	ldr	r3, [r3, #0]
 8002f22:	685b      	ldr	r3, [r3, #4]
 8002f24:	f003 0301 	and.w	r3, r3, #1
 8002f28:	2b00      	cmp	r3, #0
 8002f2a:	d0e9      	beq.n	8002f00 <HAL_RNG_GenerateRandomNumber+0x3c>
        return HAL_TIMEOUT;
      } 
    }
  
    /* Get a 32bit Random number */
    hrng->RandomNumber = hrng->Instance->DR;
 8002f2c:	687b      	ldr	r3, [r7, #4]
 8002f2e:	681b      	ldr	r3, [r3, #0]
 8002f30:	689a      	ldr	r2, [r3, #8]
 8002f32:	687b      	ldr	r3, [r7, #4]
 8002f34:	605a      	str	r2, [r3, #4]
    *random32bit = hrng->RandomNumber;
 8002f36:	687b      	ldr	r3, [r7, #4]
 8002f38:	685a      	ldr	r2, [r3, #4]
 8002f3a:	683b      	ldr	r3, [r7, #0]
 8002f3c:	601a      	str	r2, [r3, #0]
  
    hrng->State = HAL_RNG_STATE_READY;
 8002f3e:	687b      	ldr	r3, [r7, #4]
 8002f40:	2201      	movs	r2, #1
 8002f42:	725a      	strb	r2, [r3, #9]
 8002f44:	e001      	b.n	8002f4a <HAL_RNG_GenerateRandomNumber+0x86>
  }
  else
  {
    status = HAL_ERROR;
 8002f46:	2301      	movs	r3, #1
 8002f48:	73fb      	strb	r3, [r7, #15]
  }
  
  /* Process Unlocked */
  __HAL_UNLOCK(hrng);
 8002f4a:	687b      	ldr	r3, [r7, #4]
 8002f4c:	2200      	movs	r2, #0
 8002f4e:	721a      	strb	r2, [r3, #8]
  
  return status;
 8002f50:	7bfb      	ldrb	r3, [r7, #15]
}
 8002f52:	4618      	mov	r0, r3
 8002f54:	3710      	adds	r7, #16
 8002f56:	46bd      	mov	sp, r7
 8002f58:	bd80      	pop	{r7, pc}
 8002f5a:	bf00      	nop

08002f5c <HAL_ETH_Init>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_Init(ETH_HandleTypeDef *heth)
{
 8002f5c:	b580      	push	{r7, lr}
 8002f5e:	b086      	sub	sp, #24
 8002f60:	af00      	add	r7, sp, #0
 8002f62:	6078      	str	r0, [r7, #4]
	uint32_t tmpreg = 0;
 8002f64:	2300      	movs	r3, #0
 8002f66:	617b      	str	r3, [r7, #20]
	uint32_t hclk = 60000000;
 8002f68:	4b49      	ldr	r3, [pc, #292]	; (8003090 <HAL_ETH_Init+0x134>)
 8002f6a:	613b      	str	r3, [r7, #16]
	uint32_t err = ETH_SUCCESS;
 8002f6c:	2300      	movs	r3, #0
 8002f6e:	60fb      	str	r3, [r7, #12]

	/* Check the ETH peripheral state */
	if( heth == NULL )
 8002f70:	687b      	ldr	r3, [r7, #4]
 8002f72:	2b00      	cmp	r3, #0
 8002f74:	d101      	bne.n	8002f7a <HAL_ETH_Init+0x1e>
	{
		return HAL_ERROR;
 8002f76:	2301      	movs	r3, #1
 8002f78:	e085      	b.n	8003086 <HAL_ETH_Init+0x12a>
	assert_param(IS_ETH_AUTONEGOTIATION(heth->Init.AutoNegotiation));
	assert_param(IS_ETH_RX_MODE(heth->Init.RxMode));
	assert_param(IS_ETH_CHECKSUM_MODE(heth->Init.ChecksumMode));
	assert_param(IS_ETH_MEDIA_INTERFACE(heth->Init.MediaInterface));

	if( heth->State == HAL_ETH_STATE_RESET )
 8002f7a:	687b      	ldr	r3, [r7, #4]
 8002f7c:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8002f80:	b2db      	uxtb	r3, r3
 8002f82:	2b00      	cmp	r3, #0
 8002f84:	d102      	bne.n	8002f8c <HAL_ETH_Init+0x30>
	{
		/* Init the low level hardware : GPIO, CLOCK, NVIC. */
		HAL_ETH_MspInit( heth );
 8002f86:	6878      	ldr	r0, [r7, #4]
 8002f88:	f00c fb06 	bl	800f598 <HAL_ETH_MspInit>
	}

	/* Enable SYSCFG Clock */
	__HAL_RCC_SYSCFG_CLK_ENABLE();
 8002f8c:	4a41      	ldr	r2, [pc, #260]	; (8003094 <HAL_ETH_Init+0x138>)
 8002f8e:	4b41      	ldr	r3, [pc, #260]	; (8003094 <HAL_ETH_Init+0x138>)
 8002f90:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002f92:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002f96:	6453      	str	r3, [r2, #68]	; 0x44
 8002f98:	4b3e      	ldr	r3, [pc, #248]	; (8003094 <HAL_ETH_Init+0x138>)
 8002f9a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002f9c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8002fa0:	60bb      	str	r3, [r7, #8]
 8002fa2:	68bb      	ldr	r3, [r7, #8]

	/* Select MII or RMII Mode*/
	SYSCFG->PMC &= ~(SYSCFG_PMC_MII_RMII_SEL);
 8002fa4:	4a3c      	ldr	r2, [pc, #240]	; (8003098 <HAL_ETH_Init+0x13c>)
 8002fa6:	4b3c      	ldr	r3, [pc, #240]	; (8003098 <HAL_ETH_Init+0x13c>)
 8002fa8:	685b      	ldr	r3, [r3, #4]
 8002faa:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8002fae:	6053      	str	r3, [r2, #4]
	SYSCFG->PMC |= (uint32_t)heth->Init.MediaInterface;
 8002fb0:	4939      	ldr	r1, [pc, #228]	; (8003098 <HAL_ETH_Init+0x13c>)
 8002fb2:	4b39      	ldr	r3, [pc, #228]	; (8003098 <HAL_ETH_Init+0x13c>)
 8002fb4:	685a      	ldr	r2, [r3, #4]
 8002fb6:	687b      	ldr	r3, [r7, #4]
 8002fb8:	6a1b      	ldr	r3, [r3, #32]
 8002fba:	4313      	orrs	r3, r2
 8002fbc:	604b      	str	r3, [r1, #4]
	/* Ethernet Software reset */
	/* Set the SWR bit: resets all MAC subsystem internal registers and logic */
	/* After reset all the registers holds their respective reset values */
	/* Also enable EDFE: Enhanced descriptor format enable. */
//	heth->Instance->DMABMR |= ETH_DMABMR_SR | ETH_DMABMR_EDE;
	heth->Instance->DMABMR |= ETH_DMABMR_SR;
 8002fbe:	687b      	ldr	r3, [r7, #4]
 8002fc0:	681b      	ldr	r3, [r3, #0]
 8002fc2:	687a      	ldr	r2, [r7, #4]
 8002fc4:	6812      	ldr	r2, [r2, #0]
 8002fc6:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8002fca:	6812      	ldr	r2, [r2, #0]
 8002fcc:	f042 0201 	orr.w	r2, r2, #1
 8002fd0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8002fd4:	601a      	str	r2, [r3, #0]

	/* Wait for software reset */
	while ((heth->Instance->DMABMR & ETH_DMABMR_SR) != (uint32_t)RESET)
 8002fd6:	bf00      	nop
 8002fd8:	687b      	ldr	r3, [r7, #4]
 8002fda:	681b      	ldr	r3, [r3, #0]
 8002fdc:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8002fe0:	681b      	ldr	r3, [r3, #0]
 8002fe2:	f003 0301 	and.w	r3, r3, #1
 8002fe6:	2b00      	cmp	r3, #0
 8002fe8:	d1f6      	bne.n	8002fd8 <HAL_ETH_Init+0x7c>
	{
	}

	/*-------------------------------- MAC Initialization ----------------------*/
	/* Get the ETHERNET MACMIIAR value */
	tmpreg = heth->Instance->MACMIIAR;
 8002fea:	687b      	ldr	r3, [r7, #4]
 8002fec:	681b      	ldr	r3, [r3, #0]
 8002fee:	691b      	ldr	r3, [r3, #16]
 8002ff0:	617b      	str	r3, [r7, #20]
	/* Clear CSR Clock Range CR[2:0] bits */
	tmpreg &= ETH_MACMIIAR_CR_MASK;
 8002ff2:	697b      	ldr	r3, [r7, #20]
 8002ff4:	f023 031c 	bic.w	r3, r3, #28
 8002ff8:	617b      	str	r3, [r7, #20]

	/* Get hclk frequency value (168,000,000) */
	hclk = HAL_RCC_GetHCLKFreq();
 8002ffa:	f7fe fb65 	bl	80016c8 <HAL_RCC_GetHCLKFreq>
 8002ffe:	6138      	str	r0, [r7, #16]

	/* Set CR bits depending on hclk value */
	if( ( hclk >= 20000000 ) && ( hclk < 35000000 ) )
 8003000:	693b      	ldr	r3, [r7, #16]
 8003002:	4a26      	ldr	r2, [pc, #152]	; (800309c <HAL_ETH_Init+0x140>)
 8003004:	4293      	cmp	r3, r2
 8003006:	d908      	bls.n	800301a <HAL_ETH_Init+0xbe>
 8003008:	693b      	ldr	r3, [r7, #16]
 800300a:	4a25      	ldr	r2, [pc, #148]	; (80030a0 <HAL_ETH_Init+0x144>)
 800300c:	4293      	cmp	r3, r2
 800300e:	d804      	bhi.n	800301a <HAL_ETH_Init+0xbe>
	{
		/* CSR Clock Range between 20-35 MHz */
		tmpreg |= (uint32_t) ETH_MACMIIAR_CR_Div16;
 8003010:	697b      	ldr	r3, [r7, #20]
 8003012:	f043 0308 	orr.w	r3, r3, #8
 8003016:	617b      	str	r3, [r7, #20]
 8003018:	e026      	b.n	8003068 <HAL_ETH_Init+0x10c>
	}
	else if( ( hclk >= 35000000 ) && ( hclk < 60000000 ) )
 800301a:	693b      	ldr	r3, [r7, #16]
 800301c:	4a20      	ldr	r2, [pc, #128]	; (80030a0 <HAL_ETH_Init+0x144>)
 800301e:	4293      	cmp	r3, r2
 8003020:	d908      	bls.n	8003034 <HAL_ETH_Init+0xd8>
 8003022:	693b      	ldr	r3, [r7, #16]
 8003024:	4a1f      	ldr	r2, [pc, #124]	; (80030a4 <HAL_ETH_Init+0x148>)
 8003026:	4293      	cmp	r3, r2
 8003028:	d804      	bhi.n	8003034 <HAL_ETH_Init+0xd8>
	{
	/* CSR Clock Range between 35-60 MHz */
	tmpreg |= ( uint32_t ) ETH_MACMIIAR_CR_Div26;
 800302a:	697b      	ldr	r3, [r7, #20]
 800302c:	f043 030c 	orr.w	r3, r3, #12
 8003030:	617b      	str	r3, [r7, #20]
 8003032:	e019      	b.n	8003068 <HAL_ETH_Init+0x10c>
	}
	else if((hclk >= 60000000 ) && ( hclk < 100000000 ) )
 8003034:	693b      	ldr	r3, [r7, #16]
 8003036:	4a1b      	ldr	r2, [pc, #108]	; (80030a4 <HAL_ETH_Init+0x148>)
 8003038:	4293      	cmp	r3, r2
 800303a:	d904      	bls.n	8003046 <HAL_ETH_Init+0xea>
 800303c:	693b      	ldr	r3, [r7, #16]
 800303e:	4a1a      	ldr	r2, [pc, #104]	; (80030a8 <HAL_ETH_Init+0x14c>)
 8003040:	4293      	cmp	r3, r2
 8003042:	d800      	bhi.n	8003046 <HAL_ETH_Init+0xea>
	{
		/* CSR Clock Range between 60-100 MHz */
		tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div42;
 8003044:	e010      	b.n	8003068 <HAL_ETH_Init+0x10c>
	}
	else if((hclk >= 100000000 ) && ( hclk < 150000000))
 8003046:	693b      	ldr	r3, [r7, #16]
 8003048:	4a17      	ldr	r2, [pc, #92]	; (80030a8 <HAL_ETH_Init+0x14c>)
 800304a:	4293      	cmp	r3, r2
 800304c:	d908      	bls.n	8003060 <HAL_ETH_Init+0x104>
 800304e:	693b      	ldr	r3, [r7, #16]
 8003050:	4a16      	ldr	r2, [pc, #88]	; (80030ac <HAL_ETH_Init+0x150>)
 8003052:	4293      	cmp	r3, r2
 8003054:	d804      	bhi.n	8003060 <HAL_ETH_Init+0x104>
	{
		/* CSR Clock Range between 100-150 MHz */
		tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div62;
 8003056:	697b      	ldr	r3, [r7, #20]
 8003058:	f043 0304 	orr.w	r3, r3, #4
 800305c:	617b      	str	r3, [r7, #20]
 800305e:	e003      	b.n	8003068 <HAL_ETH_Init+0x10c>
	}
	else /* ((hclk >= 150000000 ) && ( hclk <= 168000000)) */
	{
		/* CSR Clock Range between 150-168 MHz */
		tmpreg |= (uint32_t)ETH_MACMIIAR_CR_Div102;
 8003060:	697b      	ldr	r3, [r7, #20]
 8003062:	f043 0310 	orr.w	r3, r3, #16
 8003066:	617b      	str	r3, [r7, #20]
	}

	/* Write to ETHERNET MAC MIIAR: Configure the ETHERNET CSR Clock Range */
	heth->Instance->MACMIIAR = (uint32_t)tmpreg;
 8003068:	687b      	ldr	r3, [r7, #4]
 800306a:	681b      	ldr	r3, [r3, #0]
 800306c:	697a      	ldr	r2, [r7, #20]
 800306e:	611a      	str	r2, [r3, #16]

	/* Initialise the MACB and set all PHY properties */
	vMACBProbePhy();
 8003070:	f003 ffba 	bl	8006fe8 <vMACBProbePhy>

	/* Config MAC and DMA */
	ETH_MACDMAConfig(heth, err);
 8003074:	6878      	ldr	r0, [r7, #4]
 8003076:	68f9      	ldr	r1, [r7, #12]
 8003078:	f000 fad2 	bl	8003620 <ETH_MACDMAConfig>

	/* Set ETH HAL State to Ready */
	heth->State= HAL_ETH_STATE_READY;
 800307c:	687b      	ldr	r3, [r7, #4]
 800307e:	2201      	movs	r2, #1
 8003080:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

	/* Return function status */
	return HAL_OK;
 8003084:	2300      	movs	r3, #0
}
 8003086:	4618      	mov	r0, r3
 8003088:	3718      	adds	r7, #24
 800308a:	46bd      	mov	sp, r7
 800308c:	bd80      	pop	{r7, pc}
 800308e:	bf00      	nop
 8003090:	03938700 	.word	0x03938700
 8003094:	40023800 	.word	0x40023800
 8003098:	40013800 	.word	0x40013800
 800309c:	01312cff 	.word	0x01312cff
 80030a0:	02160ebf 	.word	0x02160ebf
 80030a4:	039386ff 	.word	0x039386ff
 80030a8:	05f5e0ff 	.word	0x05f5e0ff
 80030ac:	08f0d17f 	.word	0x08f0d17f

080030b0 <HAL_ETH_IRQHandler>:

//#define ETH_DMA_ALL_INTS		ETH_DMA_IT_RBU | ETH_DMA_FLAG_T | ETH_DMA_FLAG_AIS

#define INT_MASK		( ( uint32_t ) ~ ( ETH_DMA_IT_TBU ) )
void HAL_ETH_IRQHandler(ETH_HandleTypeDef *heth)
{
 80030b0:	b580      	push	{r7, lr}
 80030b2:	b084      	sub	sp, #16
 80030b4:	af00      	add	r7, sp, #0
 80030b6:	6078      	str	r0, [r7, #4]
	uint32_t dmasr;

	STM32_STAT_INC( int_count );

	dmasr = heth->Instance->DMASR & ETH_DMA_ALL_INTS;
 80030b8:	687b      	ldr	r3, [r7, #4]
 80030ba:	681a      	ldr	r2, [r3, #0]
 80030bc:	f241 0314 	movw	r3, #4116	; 0x1014
 80030c0:	4413      	add	r3, r2
 80030c2:	681a      	ldr	r2, [r3, #0]
 80030c4:	4b12      	ldr	r3, [pc, #72]	; (8003110 <HAL_ETH_IRQHandler+0x60>)
 80030c6:	4013      	ands	r3, r2
 80030c8:	60fb      	str	r3, [r7, #12]
	heth->Instance->DMASR = dmasr;
 80030ca:	687b      	ldr	r3, [r7, #4]
 80030cc:	681a      	ldr	r2, [r3, #0]
 80030ce:	f241 0314 	movw	r3, #4116	; 0x1014
 80030d2:	4413      	add	r3, r2
 80030d4:	68fa      	ldr	r2, [r7, #12]
 80030d6:	601a      	str	r2, [r3, #0]
		tx_status[ ( dmasr >> 20 ) & 0x07 ]++;
	}
#endif

	/* Frame received */
	if( ( dmasr & ( ETH_DMA_FLAG_R | ETH_DMA_IT_RBU ) ) != 0 )
 80030d8:	68fb      	ldr	r3, [r7, #12]
 80030da:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 80030de:	2b00      	cmp	r3, #0
 80030e0:	d002      	beq.n	80030e8 <HAL_ETH_IRQHandler+0x38>
	{
		/* Receive complete callback */
		HAL_ETH_RxCpltCallback( heth );
 80030e2:	6878      	ldr	r0, [r7, #4]
 80030e4:	f003 fbfc 	bl	80068e0 <HAL_ETH_RxCpltCallback>
		STM32_STAT_INC( rx_count );
	}
	/* Frame transmitted */
	if( ( dmasr & ( ETH_DMA_FLAG_T ) ) != 0 )
 80030e8:	68fb      	ldr	r3, [r7, #12]
 80030ea:	f003 0301 	and.w	r3, r3, #1
 80030ee:	2b00      	cmp	r3, #0
 80030f0:	d002      	beq.n	80030f8 <HAL_ETH_IRQHandler+0x48>
	{
		/* Transfer complete callback */
		HAL_ETH_TxCpltCallback( heth );
 80030f2:	6878      	ldr	r0, [r7, #4]
 80030f4:	f003 fc26 	bl	8006944 <HAL_ETH_TxCpltCallback>
		STM32_STAT_INC( tx_count );
	}

	/* ETH DMA Error */
	if( ( dmasr & ( ETH_DMA_FLAG_AIS ) ) != 0 )
 80030f8:	68fb      	ldr	r3, [r7, #12]
 80030fa:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80030fe:	2b00      	cmp	r3, #0
 8003100:	d002      	beq.n	8003108 <HAL_ETH_IRQHandler+0x58>
	{
		/* Ethernet Error callback */
		HAL_ETH_ErrorCallback( heth );
 8003102:	6878      	ldr	r0, [r7, #4]
 8003104:	f000 f806 	bl	8003114 <HAL_ETH_ErrorCallback>
	}
}
 8003108:	3710      	adds	r7, #16
 800310a:	46bd      	mov	sp, r7
 800310c:	bd80      	pop	{r7, pc}
 800310e:	bf00      	nop
 8003110:	3801e7fb 	.word	0x3801e7fb

08003114 <HAL_ETH_ErrorCallback>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
__weak void HAL_ETH_ErrorCallback(ETH_HandleTypeDef *heth)
{
 8003114:	b480      	push	{r7}
 8003116:	b083      	sub	sp, #12
 8003118:	af00      	add	r7, sp, #0
 800311a:	6078      	str	r0, [r7, #4]
  /* NOTE : This function Should not be modified, when the callback is needed,
  the HAL_ETH_TxCpltCallback could be implemented in the user file
  */
}
 800311c:	370c      	adds	r7, #12
 800311e:	46bd      	mov	sp, r7
 8003120:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003124:	4770      	bx	lr
 8003126:	bf00      	nop

08003128 <HAL_ETH_ReadPHYRegister>:
  *                   More PHY register could be read depending on the used PHY
  * @param RegValue: PHY register value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_ReadPHYRegister(ETH_HandleTypeDef *heth, uint16_t PHYReg, uint32_t *RegValue)
{
 8003128:	b580      	push	{r7, lr}
 800312a:	b088      	sub	sp, #32
 800312c:	af00      	add	r7, sp, #0
 800312e:	60f8      	str	r0, [r7, #12]
 8003130:	460b      	mov	r3, r1
 8003132:	607a      	str	r2, [r7, #4]
 8003134:	817b      	strh	r3, [r7, #10]
uint32_t tmpreg = 0;
 8003136:	2300      	movs	r3, #0
 8003138:	61bb      	str	r3, [r7, #24]
uint32_t tickstart = 0;
 800313a:	2300      	movs	r3, #0
 800313c:	617b      	str	r3, [r7, #20]

	/* Check parameters */
	assert_param(IS_ETH_PHY_ADDRESS(heth->Init.PhyAddress));

	/* Check the ETH peripheral state */
	if( heth->State == HAL_ETH_STATE_BUSY_RD )
 800313e:	68fb      	ldr	r3, [r7, #12]
 8003140:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8003144:	b2db      	uxtb	r3, r3
 8003146:	2b82      	cmp	r3, #130	; 0x82
 8003148:	d102      	bne.n	8003150 <HAL_ETH_ReadPHYRegister+0x28>
	{
		xResult = HAL_BUSY;
 800314a:	2302      	movs	r3, #2
 800314c:	77fb      	strb	r3, [r7, #31]
 800314e:	e058      	b.n	8003202 <HAL_ETH_ReadPHYRegister+0xda>
	}
	else
	{
		__HAL_LOCK( heth );
 8003150:	68fb      	ldr	r3, [r7, #12]
 8003152:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8003156:	2b01      	cmp	r3, #1
 8003158:	d101      	bne.n	800315e <HAL_ETH_ReadPHYRegister+0x36>
 800315a:	2302      	movs	r3, #2
 800315c:	e05a      	b.n	8003214 <HAL_ETH_ReadPHYRegister+0xec>
 800315e:	68fb      	ldr	r3, [r7, #12]
 8003160:	2201      	movs	r2, #1
 8003162:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		/* Set ETH HAL State to BUSY_RD */
		heth->State = HAL_ETH_STATE_BUSY_RD;
 8003166:	68fb      	ldr	r3, [r7, #12]
 8003168:	2282      	movs	r2, #130	; 0x82
 800316a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

		/* Get the ETHERNET MACMIIAR value */
		tmpreg = heth->Instance->MACMIIAR;
 800316e:	68fb      	ldr	r3, [r7, #12]
 8003170:	681b      	ldr	r3, [r3, #0]
 8003172:	691b      	ldr	r3, [r3, #16]
 8003174:	61bb      	str	r3, [r7, #24]

		/* Keep only the CSR Clock Range CR[2:0] bits value */
		tmpreg &= ~ETH_MACMIIAR_CR_MASK;
 8003176:	69bb      	ldr	r3, [r7, #24]
 8003178:	f003 031c 	and.w	r3, r3, #28
 800317c:	61bb      	str	r3, [r7, #24]

		/* Prepare the MII address register value */
		tmpreg |= ( ( ( uint32_t )heth->Init.PhyAddress << 11) & ETH_MACMIIAR_PA );    /* Set the PHY device address   */
 800317e:	68fb      	ldr	r3, [r7, #12]
 8003180:	8a1b      	ldrh	r3, [r3, #16]
 8003182:	02db      	lsls	r3, r3, #11
 8003184:	b29b      	uxth	r3, r3
 8003186:	69ba      	ldr	r2, [r7, #24]
 8003188:	4313      	orrs	r3, r2
 800318a:	61bb      	str	r3, [r7, #24]
		tmpreg |= ( ( ( uint32_t )PHYReg << 6 ) & ETH_MACMIIAR_MR );                   /* Set the PHY register address */
 800318c:	897b      	ldrh	r3, [r7, #10]
 800318e:	019b      	lsls	r3, r3, #6
 8003190:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
 8003194:	69ba      	ldr	r2, [r7, #24]
 8003196:	4313      	orrs	r3, r2
 8003198:	61bb      	str	r3, [r7, #24]
		tmpreg &= ~ETH_MACMIIAR_MW;                                           /* Set the read mode            */
 800319a:	69bb      	ldr	r3, [r7, #24]
 800319c:	f023 0302 	bic.w	r3, r3, #2
 80031a0:	61bb      	str	r3, [r7, #24]
		tmpreg |= ETH_MACMIIAR_MB;                                            /* Set the MII Busy bit         */
 80031a2:	69bb      	ldr	r3, [r7, #24]
 80031a4:	f043 0301 	orr.w	r3, r3, #1
 80031a8:	61bb      	str	r3, [r7, #24]

		/* Write the result value into the MII Address register */
		heth->Instance->MACMIIAR = tmpreg;
 80031aa:	68fb      	ldr	r3, [r7, #12]
 80031ac:	681b      	ldr	r3, [r3, #0]
 80031ae:	69ba      	ldr	r2, [r7, #24]
 80031b0:	611a      	str	r2, [r3, #16]

		/* Get tick */
		tickstart = HAL_GetTick();
 80031b2:	f7fd fb27 	bl	8000804 <HAL_GetTick>
 80031b6:	6178      	str	r0, [r7, #20]

		/* Check for the Busy flag */
		while( 1 )
		{
			tmpreg = heth->Instance->MACMIIAR;
 80031b8:	68fb      	ldr	r3, [r7, #12]
 80031ba:	681b      	ldr	r3, [r3, #0]
 80031bc:	691b      	ldr	r3, [r3, #16]
 80031be:	61bb      	str	r3, [r7, #24]

			if( ( tmpreg & ETH_MACMIIAR_MB ) == 0ul )
 80031c0:	69bb      	ldr	r3, [r7, #24]
 80031c2:	f003 0301 	and.w	r3, r3, #1
 80031c6:	2b00      	cmp	r3, #0
 80031c8:	d107      	bne.n	80031da <HAL_ETH_ReadPHYRegister+0xb2>
			{
				/* Get MACMIIDR value */
				*RegValue = ( uint32_t ) heth->Instance->MACMIIDR;
 80031ca:	68fb      	ldr	r3, [r7, #12]
 80031cc:	681b      	ldr	r3, [r3, #0]
 80031ce:	695a      	ldr	r2, [r3, #20]
 80031d0:	687b      	ldr	r3, [r7, #4]
 80031d2:	601a      	str	r2, [r3, #0]
				xResult = HAL_OK;
 80031d4:	2300      	movs	r3, #0
 80031d6:	77fb      	strb	r3, [r7, #31]
				break;
 80031d8:	e00b      	b.n	80031f2 <HAL_ETH_ReadPHYRegister+0xca>
			}
			/* Check for the Timeout */
			if( ( HAL_GetTick( ) - tickstart ) > PHY_READ_TO )
 80031da:	f7fd fb13 	bl	8000804 <HAL_GetTick>
 80031de:	4602      	mov	r2, r0
 80031e0:	697b      	ldr	r3, [r7, #20]
 80031e2:	1ad3      	subs	r3, r2, r3
 80031e4:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80031e8:	d302      	bcc.n	80031f0 <HAL_ETH_ReadPHYRegister+0xc8>
			{
				xResult = HAL_TIMEOUT;
 80031ea:	2303      	movs	r3, #3
 80031ec:	77fb      	strb	r3, [r7, #31]
				break;
 80031ee:	e000      	b.n	80031f2 <HAL_ETH_ReadPHYRegister+0xca>
			}

		}
 80031f0:	e7e2      	b.n	80031b8 <HAL_ETH_ReadPHYRegister+0x90>

		/* Set ETH HAL State to READY */
		heth->State = HAL_ETH_STATE_READY;
 80031f2:	68fb      	ldr	r3, [r7, #12]
 80031f4:	2201      	movs	r2, #1
 80031f6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

		/* Process Unlocked */
		__HAL_UNLOCK( heth );
 80031fa:	68fb      	ldr	r3, [r7, #12]
 80031fc:	2200      	movs	r2, #0
 80031fe:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}

	if( xResult != HAL_OK )
 8003202:	7ffb      	ldrb	r3, [r7, #31]
 8003204:	2b00      	cmp	r3, #0
 8003206:	d004      	beq.n	8003212 <HAL_ETH_ReadPHYRegister+0xea>
	{
		lUDPLoggingPrintf( "ReadPHY: %d\n", xResult );
 8003208:	7ffb      	ldrb	r3, [r7, #31]
 800320a:	4804      	ldr	r0, [pc, #16]	; (800321c <HAL_ETH_ReadPHYRegister+0xf4>)
 800320c:	4619      	mov	r1, r3
 800320e:	f00b fe6b 	bl	800eee8 <lUDPLoggingPrintf>
	}
	/* Return function status */
	return xResult;
 8003212:	7ffb      	ldrb	r3, [r7, #31]
}
 8003214:	4618      	mov	r0, r3
 8003216:	3720      	adds	r7, #32
 8003218:	46bd      	mov	sp, r7
 800321a:	bd80      	pop	{r7, pc}
 800321c:	08012448 	.word	0x08012448

08003220 <HAL_ETH_WritePHYRegister>:
  *             More PHY register could be written depending on the used PHY
  * @param  RegValue: the value to write
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_WritePHYRegister(ETH_HandleTypeDef *heth, uint16_t PHYReg, uint32_t RegValue)
{
 8003220:	b580      	push	{r7, lr}
 8003222:	b088      	sub	sp, #32
 8003224:	af00      	add	r7, sp, #0
 8003226:	60f8      	str	r0, [r7, #12]
 8003228:	460b      	mov	r3, r1
 800322a:	607a      	str	r2, [r7, #4]
 800322c:	817b      	strh	r3, [r7, #10]
uint32_t tmpreg = 0;
 800322e:	2300      	movs	r3, #0
 8003230:	61bb      	str	r3, [r7, #24]
uint32_t tickstart = 0;
 8003232:	2300      	movs	r3, #0
 8003234:	617b      	str	r3, [r7, #20]

	/* Check parameters */
	assert_param( IS_ETH_PHY_ADDRESS( heth->Init.PhyAddress ) );

	/* Check the ETH peripheral state */
	if( heth->State == HAL_ETH_STATE_BUSY_WR )
 8003236:	68fb      	ldr	r3, [r7, #12]
 8003238:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800323c:	b2db      	uxtb	r3, r3
 800323e:	2b42      	cmp	r3, #66	; 0x42
 8003240:	d102      	bne.n	8003248 <HAL_ETH_WritePHYRegister+0x28>
	{
		xResult = HAL_BUSY;
 8003242:	2302      	movs	r3, #2
 8003244:	77fb      	strb	r3, [r7, #31]
 8003246:	e058      	b.n	80032fa <HAL_ETH_WritePHYRegister+0xda>
	}
	else
	{
		__HAL_LOCK( heth );
 8003248:	68fb      	ldr	r3, [r7, #12]
 800324a:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 800324e:	2b01      	cmp	r3, #1
 8003250:	d101      	bne.n	8003256 <HAL_ETH_WritePHYRegister+0x36>
 8003252:	2302      	movs	r3, #2
 8003254:	e05a      	b.n	800330c <HAL_ETH_WritePHYRegister+0xec>
 8003256:	68fb      	ldr	r3, [r7, #12]
 8003258:	2201      	movs	r2, #1
 800325a:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		/* Set ETH HAL State to BUSY_WR */
		heth->State = HAL_ETH_STATE_BUSY_WR;
 800325e:	68fb      	ldr	r3, [r7, #12]
 8003260:	2242      	movs	r2, #66	; 0x42
 8003262:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

		/* Get the ETHERNET MACMIIAR value */
		tmpreg = heth->Instance->MACMIIAR;
 8003266:	68fb      	ldr	r3, [r7, #12]
 8003268:	681b      	ldr	r3, [r3, #0]
 800326a:	691b      	ldr	r3, [r3, #16]
 800326c:	61bb      	str	r3, [r7, #24]

		/* Keep only the CSR Clock Range CR[2:0] bits value */
		tmpreg &= ~ETH_MACMIIAR_CR_MASK;
 800326e:	69bb      	ldr	r3, [r7, #24]
 8003270:	f003 031c 	and.w	r3, r3, #28
 8003274:	61bb      	str	r3, [r7, #24]

		/* Prepare the MII register address value */
		tmpreg |= ( ( ( uint32_t ) heth->Init.PhyAddress << 11 ) & ETH_MACMIIAR_PA ); /* Set the PHY device address */
 8003276:	68fb      	ldr	r3, [r7, #12]
 8003278:	8a1b      	ldrh	r3, [r3, #16]
 800327a:	02db      	lsls	r3, r3, #11
 800327c:	b29b      	uxth	r3, r3
 800327e:	69ba      	ldr	r2, [r7, #24]
 8003280:	4313      	orrs	r3, r2
 8003282:	61bb      	str	r3, [r7, #24]
		tmpreg |= ( ( ( uint32_t ) PHYReg << 6 ) & ETH_MACMIIAR_MR );                 /* Set the PHY register address */
 8003284:	897b      	ldrh	r3, [r7, #10]
 8003286:	019b      	lsls	r3, r3, #6
 8003288:	f403 63f8 	and.w	r3, r3, #1984	; 0x7c0
 800328c:	69ba      	ldr	r2, [r7, #24]
 800328e:	4313      	orrs	r3, r2
 8003290:	61bb      	str	r3, [r7, #24]
		tmpreg |= ETH_MACMIIAR_MW;                                          /* Set the write mode */
 8003292:	69bb      	ldr	r3, [r7, #24]
 8003294:	f043 0302 	orr.w	r3, r3, #2
 8003298:	61bb      	str	r3, [r7, #24]
		tmpreg |= ETH_MACMIIAR_MB;                                          /* Set the MII Busy bit */
 800329a:	69bb      	ldr	r3, [r7, #24]
 800329c:	f043 0301 	orr.w	r3, r3, #1
 80032a0:	61bb      	str	r3, [r7, #24]

		/* Give the value to the MII data register */
		heth->Instance->MACMIIDR = ( uint16_t ) RegValue;
 80032a2:	68fb      	ldr	r3, [r7, #12]
 80032a4:	681b      	ldr	r3, [r3, #0]
 80032a6:	687a      	ldr	r2, [r7, #4]
 80032a8:	b292      	uxth	r2, r2
 80032aa:	615a      	str	r2, [r3, #20]

		/* Write the result value into the MII Address register */
		heth->Instance->MACMIIAR = tmpreg;
 80032ac:	68fb      	ldr	r3, [r7, #12]
 80032ae:	681b      	ldr	r3, [r3, #0]
 80032b0:	69ba      	ldr	r2, [r7, #24]
 80032b2:	611a      	str	r2, [r3, #16]

		/* Get tick */
		tickstart = HAL_GetTick();
 80032b4:	f7fd faa6 	bl	8000804 <HAL_GetTick>
 80032b8:	6178      	str	r0, [r7, #20]

		/* Check for the Busy flag */
		while( 1 )
		{
			tmpreg = heth->Instance->MACMIIAR;
 80032ba:	68fb      	ldr	r3, [r7, #12]
 80032bc:	681b      	ldr	r3, [r3, #0]
 80032be:	691b      	ldr	r3, [r3, #16]
 80032c0:	61bb      	str	r3, [r7, #24]

			if( ( tmpreg & ETH_MACMIIAR_MB ) == 0ul )
 80032c2:	69bb      	ldr	r3, [r7, #24]
 80032c4:	f003 0301 	and.w	r3, r3, #1
 80032c8:	2b00      	cmp	r3, #0
 80032ca:	d102      	bne.n	80032d2 <HAL_ETH_WritePHYRegister+0xb2>
			{
				xResult = HAL_OK;
 80032cc:	2300      	movs	r3, #0
 80032ce:	77fb      	strb	r3, [r7, #31]
				break;
 80032d0:	e00b      	b.n	80032ea <HAL_ETH_WritePHYRegister+0xca>
			}
			/* Check for the Timeout */
			if( ( HAL_GetTick( ) - tickstart ) > PHY_WRITE_TO )
 80032d2:	f7fd fa97 	bl	8000804 <HAL_GetTick>
 80032d6:	4602      	mov	r2, r0
 80032d8:	697b      	ldr	r3, [r7, #20]
 80032da:	1ad3      	subs	r3, r2, r3
 80032dc:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80032e0:	d302      	bcc.n	80032e8 <HAL_ETH_WritePHYRegister+0xc8>
			{
				xResult = HAL_TIMEOUT;
 80032e2:	2303      	movs	r3, #3
 80032e4:	77fb      	strb	r3, [r7, #31]
				break;
 80032e6:	e000      	b.n	80032ea <HAL_ETH_WritePHYRegister+0xca>
			}
		}
 80032e8:	e7e7      	b.n	80032ba <HAL_ETH_WritePHYRegister+0x9a>

		/* Set ETH HAL State to READY */
		heth->State = HAL_ETH_STATE_READY;
 80032ea:	68fb      	ldr	r3, [r7, #12]
 80032ec:	2201      	movs	r2, #1
 80032ee:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		/* Process Unlocked */
		__HAL_UNLOCK( heth );
 80032f2:	68fb      	ldr	r3, [r7, #12]
 80032f4:	2200      	movs	r2, #0
 80032f6:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}

	if( xResult != HAL_OK )
 80032fa:	7ffb      	ldrb	r3, [r7, #31]
 80032fc:	2b00      	cmp	r3, #0
 80032fe:	d004      	beq.n	800330a <HAL_ETH_WritePHYRegister+0xea>
	{
		lUDPLoggingPrintf( "WritePHY: %d\n", xResult );
 8003300:	7ffb      	ldrb	r3, [r7, #31]
 8003302:	4804      	ldr	r0, [pc, #16]	; (8003314 <HAL_ETH_WritePHYRegister+0xf4>)
 8003304:	4619      	mov	r1, r3
 8003306:	f00b fdef 	bl	800eee8 <lUDPLoggingPrintf>
	}
	/* Return function status */
	return xResult;
 800330a:	7ffb      	ldrb	r3, [r7, #31]
}
 800330c:	4618      	mov	r0, r3
 800330e:	3720      	adds	r7, #32
 8003310:	46bd      	mov	sp, r7
 8003312:	bd80      	pop	{r7, pc}
 8003314:	08012458 	.word	0x08012458

08003318 <HAL_ETH_Start>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_Start( ETH_HandleTypeDef *heth )
{
 8003318:	b580      	push	{r7, lr}
 800331a:	b082      	sub	sp, #8
 800331c:	af00      	add	r7, sp, #0
 800331e:	6078      	str	r0, [r7, #4]
	/* Process Locked */
	__HAL_LOCK( heth );
 8003320:	687b      	ldr	r3, [r7, #4]
 8003322:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8003326:	2b01      	cmp	r3, #1
 8003328:	d101      	bne.n	800332e <HAL_ETH_Start+0x16>
 800332a:	2302      	movs	r3, #2
 800332c:	e01f      	b.n	800336e <HAL_ETH_Start+0x56>
 800332e:	687b      	ldr	r3, [r7, #4]
 8003330:	2201      	movs	r2, #1
 8003332:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

	/* Set the ETH peripheral state to BUSY */
	heth->State = HAL_ETH_STATE_BUSY;
 8003336:	687b      	ldr	r3, [r7, #4]
 8003338:	2202      	movs	r2, #2
 800333a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

	/* Enable transmit state machine of the MAC for transmission on the MII */
	ETH_MACTransmissionEnable( heth );
 800333e:	6878      	ldr	r0, [r7, #4]
 8003340:	f000 fb3e 	bl	80039c0 <ETH_MACTransmissionEnable>

	/* Enable receive state machine of the MAC for reception from the MII */
	ETH_MACReceptionEnable( heth );
 8003344:	6878      	ldr	r0, [r7, #4]
 8003346:	f000 fb5f 	bl	8003a08 <ETH_MACReceptionEnable>

	/* Flush Transmit FIFO */
	ETH_FlushTransmitFIFO( heth );
 800334a:	6878      	ldr	r0, [r7, #4]
 800334c:	f000 fbd8 	bl	8003b00 <ETH_FlushTransmitFIFO>

	/* Start DMA transmission */
	ETH_DMATransmissionEnable( heth );
 8003350:	6878      	ldr	r0, [r7, #4]
 8003352:	f000 fb7d 	bl	8003a50 <ETH_DMATransmissionEnable>

	/* Start DMA reception */
	ETH_DMAReceptionEnable( heth );
 8003356:	6878      	ldr	r0, [r7, #4]
 8003358:	f000 fba6 	bl	8003aa8 <ETH_DMAReceptionEnable>

	/* Set the ETH state to READY*/
	heth->State= HAL_ETH_STATE_READY;
 800335c:	687b      	ldr	r3, [r7, #4]
 800335e:	2201      	movs	r2, #1
 8003360:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

	/* Process Unlocked */
	__HAL_UNLOCK( heth );
 8003364:	687b      	ldr	r3, [r7, #4]
 8003366:	2200      	movs	r2, #0
 8003368:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

	/* Return function status */
	return HAL_OK;
 800336c:	2300      	movs	r3, #0
}
 800336e:	4618      	mov	r0, r3
 8003370:	3708      	adds	r7, #8
 8003372:	46bd      	mov	sp, r7
 8003374:	bd80      	pop	{r7, pc}
 8003376:	bf00      	nop

08003378 <HAL_ETH_Stop>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_Stop(ETH_HandleTypeDef *heth)
{
 8003378:	b580      	push	{r7, lr}
 800337a:	b082      	sub	sp, #8
 800337c:	af00      	add	r7, sp, #0
 800337e:	6078      	str	r0, [r7, #4]
  /* Process Locked */
  __HAL_LOCK( heth );
 8003380:	687b      	ldr	r3, [r7, #4]
 8003382:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8003386:	2b01      	cmp	r3, #1
 8003388:	d101      	bne.n	800338e <HAL_ETH_Stop+0x16>
 800338a:	2302      	movs	r3, #2
 800338c:	e01f      	b.n	80033ce <HAL_ETH_Stop+0x56>
 800338e:	687b      	ldr	r3, [r7, #4]
 8003390:	2201      	movs	r2, #1
 8003392:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Set the ETH peripheral state to BUSY */
  heth->State = HAL_ETH_STATE_BUSY;
 8003396:	687b      	ldr	r3, [r7, #4]
 8003398:	2202      	movs	r2, #2
 800339a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

  /* Stop DMA transmission */
  ETH_DMATransmissionDisable( heth );
 800339e:	6878      	ldr	r0, [r7, #4]
 80033a0:	f000 fb6c 	bl	8003a7c <ETH_DMATransmissionDisable>

  /* Stop DMA reception */
  ETH_DMAReceptionDisable( heth );
 80033a4:	6878      	ldr	r0, [r7, #4]
 80033a6:	f000 fb95 	bl	8003ad4 <ETH_DMAReceptionDisable>

  /* Disable receive state machine of the MAC for reception from the MII */
  ETH_MACReceptionDisable( heth );
 80033aa:	6878      	ldr	r0, [r7, #4]
 80033ac:	f000 fb3e 	bl	8003a2c <ETH_MACReceptionDisable>

  /* Flush Transmit FIFO */
  ETH_FlushTransmitFIFO( heth );
 80033b0:	6878      	ldr	r0, [r7, #4]
 80033b2:	f000 fba5 	bl	8003b00 <ETH_FlushTransmitFIFO>

  /* Disable transmit state machine of the MAC for transmission on the MII */
  ETH_MACTransmissionDisable( heth );
 80033b6:	6878      	ldr	r0, [r7, #4]
 80033b8:	f000 fb14 	bl	80039e4 <ETH_MACTransmissionDisable>

  /* Set the ETH state*/
  heth->State = HAL_ETH_STATE_READY;
 80033bc:	687b      	ldr	r3, [r7, #4]
 80033be:	2201      	movs	r2, #1
 80033c0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

  /* Process Unlocked */
  __HAL_UNLOCK( heth );
 80033c4:	687b      	ldr	r3, [r7, #4]
 80033c6:	2200      	movs	r2, #0
 80033c8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

  /* Return function status */
  return HAL_OK;
 80033cc:	2300      	movs	r3, #0
}
 80033ce:	4618      	mov	r0, r3
 80033d0:	3708      	adds	r7, #8
 80033d2:	46bd      	mov	sp, r7
 80033d4:	bd80      	pop	{r7, pc}
 80033d6:	bf00      	nop

080033d8 <prvWriteMACFCR>:

static void prvWriteMACFCR( ETH_HandleTypeDef *heth, uint32_t ulValue)
{
 80033d8:	b580      	push	{r7, lr}
 80033da:	b082      	sub	sp, #8
 80033dc:	af00      	add	r7, sp, #0
 80033de:	6078      	str	r0, [r7, #4]
 80033e0:	6039      	str	r1, [r7, #0]
	/* Enable the MAC transmission */
	heth->Instance->MACFCR = ulValue;
 80033e2:	687b      	ldr	r3, [r7, #4]
 80033e4:	681b      	ldr	r3, [r3, #0]
 80033e6:	683a      	ldr	r2, [r7, #0]
 80033e8:	619a      	str	r2, [r3, #24]

	/* Wait until the write operation will be taken into account:
	at least four TX_CLK/RX_CLK clock cycles.
	Read it back, wait a ms and */
	( void ) heth->Instance->MACFCR;
 80033ea:	687b      	ldr	r3, [r7, #4]
 80033ec:	681b      	ldr	r3, [r3, #0]
 80033ee:	699b      	ldr	r3, [r3, #24]

	HAL_Delay( ETH_REG_WRITE_DELAY );
 80033f0:	2001      	movs	r0, #1
 80033f2:	f7fd fa13 	bl	800081c <HAL_Delay>

	heth->Instance->MACFCR = ulValue;
 80033f6:	687b      	ldr	r3, [r7, #4]
 80033f8:	681b      	ldr	r3, [r3, #0]
 80033fa:	683a      	ldr	r2, [r7, #0]
 80033fc:	619a      	str	r2, [r3, #24]
}
 80033fe:	3708      	adds	r7, #8
 8003400:	46bd      	mov	sp, r7
 8003402:	bd80      	pop	{r7, pc}

08003404 <prvWriteDMAOMR>:

static void prvWriteDMAOMR( ETH_HandleTypeDef *heth, uint32_t ulValue)
{
 8003404:	b580      	push	{r7, lr}
 8003406:	b082      	sub	sp, #8
 8003408:	af00      	add	r7, sp, #0
 800340a:	6078      	str	r0, [r7, #4]
 800340c:	6039      	str	r1, [r7, #0]
	/* Enable the MAC transmission */
	heth->Instance->DMAOMR = ulValue;
 800340e:	687b      	ldr	r3, [r7, #4]
 8003410:	681a      	ldr	r2, [r3, #0]
 8003412:	f241 0318 	movw	r3, #4120	; 0x1018
 8003416:	4413      	add	r3, r2
 8003418:	683a      	ldr	r2, [r7, #0]
 800341a:	601a      	str	r2, [r3, #0]

	/* Wait until the write operation will be taken into account:
	at least four TX_CLK/RX_CLK clock cycles.
	Read it back, wait a ms and */
	( void ) heth->Instance->DMAOMR;
 800341c:	687b      	ldr	r3, [r7, #4]
 800341e:	681a      	ldr	r2, [r3, #0]
 8003420:	f241 0318 	movw	r3, #4120	; 0x1018
 8003424:	4413      	add	r3, r2
 8003426:	681b      	ldr	r3, [r3, #0]

	HAL_Delay( ETH_REG_WRITE_DELAY );
 8003428:	2001      	movs	r0, #1
 800342a:	f7fd f9f7 	bl	800081c <HAL_Delay>

	heth->Instance->DMAOMR = ulValue;
 800342e:	687b      	ldr	r3, [r7, #4]
 8003430:	681a      	ldr	r2, [r3, #0]
 8003432:	f241 0318 	movw	r3, #4120	; 0x1018
 8003436:	4413      	add	r3, r2
 8003438:	683a      	ldr	r2, [r7, #0]
 800343a:	601a      	str	r2, [r3, #0]
}
 800343c:	3708      	adds	r7, #8
 800343e:	46bd      	mov	sp, r7
 8003440:	bd80      	pop	{r7, pc}
 8003442:	bf00      	nop

08003444 <prvWriteMACCR>:

static void prvWriteMACCR( ETH_HandleTypeDef *heth, uint32_t ulValue)
{
 8003444:	b580      	push	{r7, lr}
 8003446:	b082      	sub	sp, #8
 8003448:	af00      	add	r7, sp, #0
 800344a:	6078      	str	r0, [r7, #4]
 800344c:	6039      	str	r1, [r7, #0]
	/* Enable the MAC transmission */
	heth->Instance->MACCR = ulValue;
 800344e:	687b      	ldr	r3, [r7, #4]
 8003450:	681b      	ldr	r3, [r3, #0]
 8003452:	683a      	ldr	r2, [r7, #0]
 8003454:	601a      	str	r2, [r3, #0]

	/* Wait until the write operation will be taken into account:
	at least four TX_CLK/RX_CLK clock cycles.
	Read it back, wait a ms and */
	( void ) heth->Instance->MACCR;
 8003456:	687b      	ldr	r3, [r7, #4]
 8003458:	681b      	ldr	r3, [r3, #0]
 800345a:	681b      	ldr	r3, [r3, #0]

	HAL_Delay( ETH_REG_WRITE_DELAY );
 800345c:	2001      	movs	r0, #1
 800345e:	f7fd f9dd 	bl	800081c <HAL_Delay>

	heth->Instance->MACCR = ulValue;
 8003462:	687b      	ldr	r3, [r7, #4]
 8003464:	681b      	ldr	r3, [r3, #0]
 8003466:	683a      	ldr	r2, [r7, #0]
 8003468:	601a      	str	r2, [r3, #0]
}
 800346a:	3708      	adds	r7, #8
 800346c:	46bd      	mov	sp, r7
 800346e:	bd80      	pop	{r7, pc}

08003470 <HAL_ETH_ConfigMAC>:
  *         the configuration information for ETHERNET module
  * @param  macconf: MAC Configuration structure
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ETH_ConfigMAC(ETH_HandleTypeDef *heth, ETH_MACInitTypeDef *macconf)
{
 8003470:	b580      	push	{r7, lr}
 8003472:	b084      	sub	sp, #16
 8003474:	af00      	add	r7, sp, #0
 8003476:	6078      	str	r0, [r7, #4]
 8003478:	6039      	str	r1, [r7, #0]
	uint32_t tmpreg = 0;
 800347a:	2300      	movs	r3, #0
 800347c:	60fb      	str	r3, [r7, #12]

	/* Process Locked */
	__HAL_LOCK( heth );
 800347e:	687b      	ldr	r3, [r7, #4]
 8003480:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8003484:	2b01      	cmp	r3, #1
 8003486:	d101      	bne.n	800348c <HAL_ETH_ConfigMAC+0x1c>
 8003488:	2302      	movs	r3, #2
 800348a:	e0c2      	b.n	8003612 <HAL_ETH_ConfigMAC+0x1a2>
 800348c:	687b      	ldr	r3, [r7, #4]
 800348e:	2201      	movs	r2, #1
 8003490:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

	/* Set the ETH peripheral state to BUSY */
	heth->State= HAL_ETH_STATE_BUSY;
 8003494:	687b      	ldr	r3, [r7, #4]
 8003496:	2202      	movs	r2, #2
 8003498:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

	assert_param(IS_ETH_SPEED(heth->Init.Speed));
	assert_param(IS_ETH_DUPLEX_MODE(heth->Init.DuplexMode));

	if (macconf != NULL)
 800349c:	683b      	ldr	r3, [r7, #0]
 800349e:	2b00      	cmp	r3, #0
 80034a0:	f000 809a 	beq.w	80035d8 <HAL_ETH_ConfigMAC+0x168>
		assert_param(IS_ETH_VLAN_TAG_COMPARISON(macconf->VLANTagComparison));
		assert_param(IS_ETH_VLAN_TAG_IDENTIFIER(macconf->VLANTagIdentifier));

		/*------------------------ ETHERNET MACCR Configuration --------------------*/
		/* Get the ETHERNET MACCR value */
		tmpreg = heth->Instance->MACCR;
 80034a4:	687b      	ldr	r3, [r7, #4]
 80034a6:	681b      	ldr	r3, [r3, #0]
 80034a8:	681b      	ldr	r3, [r3, #0]
 80034aa:	60fb      	str	r3, [r7, #12]
		/* Clear WD, PCE, PS, TE and RE bits */
		tmpreg &= ETH_MACCR_CLEAR_MASK;
 80034ac:	68fa      	ldr	r2, [r7, #12]
 80034ae:	4b5b      	ldr	r3, [pc, #364]	; (800361c <HAL_ETH_ConfigMAC+0x1ac>)
 80034b0:	4013      	ands	r3, r2
 80034b2:	60fb      	str	r3, [r7, #12]

		tmpreg |= (uint32_t)(
			macconf->Watchdog |
 80034b4:	683b      	ldr	r3, [r7, #0]
 80034b6:	681a      	ldr	r2, [r3, #0]
			macconf->Jabber |
 80034b8:	683b      	ldr	r3, [r7, #0]
 80034ba:	685b      	ldr	r3, [r3, #4]
		tmpreg = heth->Instance->MACCR;
		/* Clear WD, PCE, PS, TE and RE bits */
		tmpreg &= ETH_MACCR_CLEAR_MASK;

		tmpreg |= (uint32_t)(
			macconf->Watchdog |
 80034bc:	431a      	orrs	r2, r3
			macconf->Jabber |
			macconf->InterFrameGap |
 80034be:	683b      	ldr	r3, [r7, #0]
 80034c0:	689b      	ldr	r3, [r3, #8]
		/* Clear WD, PCE, PS, TE and RE bits */
		tmpreg &= ETH_MACCR_CLEAR_MASK;

		tmpreg |= (uint32_t)(
			macconf->Watchdog |
			macconf->Jabber |
 80034c2:	431a      	orrs	r2, r3
			macconf->InterFrameGap |
			macconf->CarrierSense |
 80034c4:	683b      	ldr	r3, [r7, #0]
 80034c6:	68db      	ldr	r3, [r3, #12]
		tmpreg &= ETH_MACCR_CLEAR_MASK;

		tmpreg |= (uint32_t)(
			macconf->Watchdog |
			macconf->Jabber |
			macconf->InterFrameGap |
 80034c8:	431a      	orrs	r2, r3
			macconf->CarrierSense |
			heth->Init.Speed |
 80034ca:	687b      	ldr	r3, [r7, #4]
 80034cc:	689b      	ldr	r3, [r3, #8]

		tmpreg |= (uint32_t)(
			macconf->Watchdog |
			macconf->Jabber |
			macconf->InterFrameGap |
			macconf->CarrierSense |
 80034ce:	431a      	orrs	r2, r3
			heth->Init.Speed |
			macconf->ReceiveOwn |
 80034d0:	683b      	ldr	r3, [r7, #0]
 80034d2:	691b      	ldr	r3, [r3, #16]
		tmpreg |= (uint32_t)(
			macconf->Watchdog |
			macconf->Jabber |
			macconf->InterFrameGap |
			macconf->CarrierSense |
			heth->Init.Speed |
 80034d4:	431a      	orrs	r2, r3
			macconf->ReceiveOwn |
			macconf->LoopbackMode |
 80034d6:	683b      	ldr	r3, [r7, #0]
 80034d8:	695b      	ldr	r3, [r3, #20]
			macconf->Watchdog |
			macconf->Jabber |
			macconf->InterFrameGap |
			macconf->CarrierSense |
			heth->Init.Speed |
			macconf->ReceiveOwn |
 80034da:	431a      	orrs	r2, r3
			macconf->LoopbackMode |
			heth->Init.DuplexMode |
 80034dc:	687b      	ldr	r3, [r7, #4]
 80034de:	68db      	ldr	r3, [r3, #12]
			macconf->Jabber |
			macconf->InterFrameGap |
			macconf->CarrierSense |
			heth->Init.Speed |
			macconf->ReceiveOwn |
			macconf->LoopbackMode |
 80034e0:	431a      	orrs	r2, r3
			heth->Init.DuplexMode |
			macconf->ChecksumOffload |
 80034e2:	683b      	ldr	r3, [r7, #0]
 80034e4:	699b      	ldr	r3, [r3, #24]
			macconf->InterFrameGap |
			macconf->CarrierSense |
			heth->Init.Speed |
			macconf->ReceiveOwn |
			macconf->LoopbackMode |
			heth->Init.DuplexMode |
 80034e6:	431a      	orrs	r2, r3
			macconf->ChecksumOffload |
			macconf->RetryTransmission |
 80034e8:	683b      	ldr	r3, [r7, #0]
 80034ea:	69db      	ldr	r3, [r3, #28]
			macconf->CarrierSense |
			heth->Init.Speed |
			macconf->ReceiveOwn |
			macconf->LoopbackMode |
			heth->Init.DuplexMode |
			macconf->ChecksumOffload |
 80034ec:	431a      	orrs	r2, r3
			macconf->RetryTransmission |
			macconf->AutomaticPadCRCStrip |
 80034ee:	683b      	ldr	r3, [r7, #0]
 80034f0:	6a1b      	ldr	r3, [r3, #32]
			heth->Init.Speed |
			macconf->ReceiveOwn |
			macconf->LoopbackMode |
			heth->Init.DuplexMode |
			macconf->ChecksumOffload |
			macconf->RetryTransmission |
 80034f2:	431a      	orrs	r2, r3
			macconf->AutomaticPadCRCStrip |
			macconf->BackOffLimit |
 80034f4:	683b      	ldr	r3, [r7, #0]
 80034f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
			macconf->ReceiveOwn |
			macconf->LoopbackMode |
			heth->Init.DuplexMode |
			macconf->ChecksumOffload |
			macconf->RetryTransmission |
			macconf->AutomaticPadCRCStrip |
 80034f8:	431a      	orrs	r2, r3
			macconf->BackOffLimit |
			macconf->DeferralCheck);
 80034fa:	683b      	ldr	r3, [r7, #0]
 80034fc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
		/* Get the ETHERNET MACCR value */
		tmpreg = heth->Instance->MACCR;
		/* Clear WD, PCE, PS, TE and RE bits */
		tmpreg &= ETH_MACCR_CLEAR_MASK;

		tmpreg |= (uint32_t)(
 80034fe:	4313      	orrs	r3, r2
 8003500:	68fa      	ldr	r2, [r7, #12]
 8003502:	4313      	orrs	r3, r2
 8003504:	60fb      	str	r3, [r7, #12]
			macconf->AutomaticPadCRCStrip |
			macconf->BackOffLimit |
			macconf->DeferralCheck);

		/* Write to ETHERNET MACCR */
		prvWriteMACCR( heth, tmpreg );
 8003506:	6878      	ldr	r0, [r7, #4]
 8003508:	68f9      	ldr	r1, [r7, #12]
 800350a:	f7ff ff9b 	bl	8003444 <prvWriteMACCR>

		/*----------------------- ETHERNET MACFFR Configuration --------------------*/
		/* Write to ETHERNET MACFFR */
		heth->Instance->MACFFR = (uint32_t)(
 800350e:	687b      	ldr	r3, [r7, #4]
 8003510:	681b      	ldr	r3, [r3, #0]
			macconf->ReceiveAll |
 8003512:	683a      	ldr	r2, [r7, #0]
 8003514:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
			macconf->SourceAddrFilter |
 8003516:	683a      	ldr	r2, [r7, #0]
 8003518:	6b12      	ldr	r2, [r2, #48]	; 0x30
		prvWriteMACCR( heth, tmpreg );

		/*----------------------- ETHERNET MACFFR Configuration --------------------*/
		/* Write to ETHERNET MACFFR */
		heth->Instance->MACFFR = (uint32_t)(
			macconf->ReceiveAll |
 800351a:	4311      	orrs	r1, r2
			macconf->SourceAddrFilter |
			macconf->PassControlFrames |
 800351c:	683a      	ldr	r2, [r7, #0]
 800351e:	6b52      	ldr	r2, [r2, #52]	; 0x34

		/*----------------------- ETHERNET MACFFR Configuration --------------------*/
		/* Write to ETHERNET MACFFR */
		heth->Instance->MACFFR = (uint32_t)(
			macconf->ReceiveAll |
			macconf->SourceAddrFilter |
 8003520:	4311      	orrs	r1, r2
			macconf->PassControlFrames |
			macconf->BroadcastFramesReception |
 8003522:	683a      	ldr	r2, [r7, #0]
 8003524:	6b92      	ldr	r2, [r2, #56]	; 0x38
		/*----------------------- ETHERNET MACFFR Configuration --------------------*/
		/* Write to ETHERNET MACFFR */
		heth->Instance->MACFFR = (uint32_t)(
			macconf->ReceiveAll |
			macconf->SourceAddrFilter |
			macconf->PassControlFrames |
 8003526:	4311      	orrs	r1, r2
			macconf->BroadcastFramesReception |
			macconf->DestinationAddrFilter |
 8003528:	683a      	ldr	r2, [r7, #0]
 800352a:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
		/* Write to ETHERNET MACFFR */
		heth->Instance->MACFFR = (uint32_t)(
			macconf->ReceiveAll |
			macconf->SourceAddrFilter |
			macconf->PassControlFrames |
			macconf->BroadcastFramesReception |
 800352c:	4311      	orrs	r1, r2
			macconf->DestinationAddrFilter |
			macconf->PromiscuousMode |
 800352e:	683a      	ldr	r2, [r7, #0]
 8003530:	6c12      	ldr	r2, [r2, #64]	; 0x40
		heth->Instance->MACFFR = (uint32_t)(
			macconf->ReceiveAll |
			macconf->SourceAddrFilter |
			macconf->PassControlFrames |
			macconf->BroadcastFramesReception |
			macconf->DestinationAddrFilter |
 8003532:	4311      	orrs	r1, r2
			macconf->PromiscuousMode |
			macconf->MulticastFramesFilter |
 8003534:	683a      	ldr	r2, [r7, #0]
 8003536:	6c52      	ldr	r2, [r2, #68]	; 0x44
			macconf->ReceiveAll |
			macconf->SourceAddrFilter |
			macconf->PassControlFrames |
			macconf->BroadcastFramesReception |
			macconf->DestinationAddrFilter |
			macconf->PromiscuousMode |
 8003538:	4311      	orrs	r1, r2
			macconf->MulticastFramesFilter |
			macconf->UnicastFramesFilter);
 800353a:	683a      	ldr	r2, [r7, #0]
 800353c:	6c92      	ldr	r2, [r2, #72]	; 0x48
		/* Write to ETHERNET MACCR */
		prvWriteMACCR( heth, tmpreg );

		/*----------------------- ETHERNET MACFFR Configuration --------------------*/
		/* Write to ETHERNET MACFFR */
		heth->Instance->MACFFR = (uint32_t)(
 800353e:	430a      	orrs	r2, r1
 8003540:	605a      	str	r2, [r3, #4]
			macconf->MulticastFramesFilter |
			macconf->UnicastFramesFilter);

		/* Wait until the write operation will be taken into account :
		at least four TX_CLK/RX_CLK clock cycles */
		tmpreg = heth->Instance->MACFFR;
 8003542:	687b      	ldr	r3, [r7, #4]
 8003544:	681b      	ldr	r3, [r3, #0]
 8003546:	685b      	ldr	r3, [r3, #4]
 8003548:	60fb      	str	r3, [r7, #12]
		HAL_Delay(ETH_REG_WRITE_DELAY);
 800354a:	2001      	movs	r0, #1
 800354c:	f7fd f966 	bl	800081c <HAL_Delay>
		heth->Instance->MACFFR = tmpreg;
 8003550:	687b      	ldr	r3, [r7, #4]
 8003552:	681b      	ldr	r3, [r3, #0]
 8003554:	68fa      	ldr	r2, [r7, #12]
 8003556:	605a      	str	r2, [r3, #4]

		/*--------------- ETHERNET MACHTHR and MACHTLR Configuration ---------------*/
		/* Write to ETHERNET MACHTHR */
		heth->Instance->MACHTHR = (uint32_t)macconf->HashTableHigh;
 8003558:	687b      	ldr	r3, [r7, #4]
 800355a:	681b      	ldr	r3, [r3, #0]
 800355c:	683a      	ldr	r2, [r7, #0]
 800355e:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8003560:	609a      	str	r2, [r3, #8]

		/* Write to ETHERNET MACHTLR */
		heth->Instance->MACHTLR = (uint32_t)macconf->HashTableLow;
 8003562:	687b      	ldr	r3, [r7, #4]
 8003564:	681b      	ldr	r3, [r3, #0]
 8003566:	683a      	ldr	r2, [r7, #0]
 8003568:	6d12      	ldr	r2, [r2, #80]	; 0x50
 800356a:	60da      	str	r2, [r3, #12]
		/*----------------------- ETHERNET MACFCR Configuration --------------------*/

		/* Get the ETHERNET MACFCR value */
		tmpreg = heth->Instance->MACFCR;
 800356c:	687b      	ldr	r3, [r7, #4]
 800356e:	681b      	ldr	r3, [r3, #0]
 8003570:	699b      	ldr	r3, [r3, #24]
 8003572:	60fb      	str	r3, [r7, #12]
		/* Clear xx bits */
		tmpreg &= ETH_MACFCR_CLEAR_MASK;
 8003574:	68fa      	ldr	r2, [r7, #12]
 8003576:	f64f 7341 	movw	r3, #65345	; 0xff41
 800357a:	4013      	ands	r3, r2
 800357c:	60fb      	str	r3, [r7, #12]

		tmpreg |= (uint32_t)((
			macconf->PauseTime << 16) |
 800357e:	683b      	ldr	r3, [r7, #0]
 8003580:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8003582:	041a      	lsls	r2, r3, #16
			macconf->ZeroQuantaPause |
 8003584:	683b      	ldr	r3, [r7, #0]
 8003586:	6d9b      	ldr	r3, [r3, #88]	; 0x58
		tmpreg = heth->Instance->MACFCR;
		/* Clear xx bits */
		tmpreg &= ETH_MACFCR_CLEAR_MASK;

		tmpreg |= (uint32_t)((
			macconf->PauseTime << 16) |
 8003588:	431a      	orrs	r2, r3
			macconf->ZeroQuantaPause |
			macconf->PauseLowThreshold |
 800358a:	683b      	ldr	r3, [r7, #0]
 800358c:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
		/* Clear xx bits */
		tmpreg &= ETH_MACFCR_CLEAR_MASK;

		tmpreg |= (uint32_t)((
			macconf->PauseTime << 16) |
			macconf->ZeroQuantaPause |
 800358e:	431a      	orrs	r2, r3
			macconf->PauseLowThreshold |
			macconf->UnicastPauseFrameDetect |
 8003590:	683b      	ldr	r3, [r7, #0]
 8003592:	6e1b      	ldr	r3, [r3, #96]	; 0x60
		tmpreg &= ETH_MACFCR_CLEAR_MASK;

		tmpreg |= (uint32_t)((
			macconf->PauseTime << 16) |
			macconf->ZeroQuantaPause |
			macconf->PauseLowThreshold |
 8003594:	431a      	orrs	r2, r3
			macconf->UnicastPauseFrameDetect |
			macconf->ReceiveFlowControl |
 8003596:	683b      	ldr	r3, [r7, #0]
 8003598:	6e5b      	ldr	r3, [r3, #100]	; 0x64

		tmpreg |= (uint32_t)((
			macconf->PauseTime << 16) |
			macconf->ZeroQuantaPause |
			macconf->PauseLowThreshold |
			macconf->UnicastPauseFrameDetect |
 800359a:	431a      	orrs	r2, r3
			macconf->ReceiveFlowControl |
			macconf->TransmitFlowControl);
 800359c:	683b      	ldr	r3, [r7, #0]
 800359e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
		/* Get the ETHERNET MACFCR value */
		tmpreg = heth->Instance->MACFCR;
		/* Clear xx bits */
		tmpreg &= ETH_MACFCR_CLEAR_MASK;

		tmpreg |= (uint32_t)((
 80035a0:	4313      	orrs	r3, r2
 80035a2:	68fa      	ldr	r2, [r7, #12]
 80035a4:	4313      	orrs	r3, r2
 80035a6:	60fb      	str	r3, [r7, #12]
			macconf->UnicastPauseFrameDetect |
			macconf->ReceiveFlowControl |
			macconf->TransmitFlowControl);

		/* Write to ETHERNET MACFCR */
		prvWriteMACFCR( heth, tmpreg );
 80035a8:	6878      	ldr	r0, [r7, #4]
 80035aa:	68f9      	ldr	r1, [r7, #12]
 80035ac:	f7ff ff14 	bl	80033d8 <prvWriteMACFCR>

		/*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
		heth->Instance->MACVLANTR = (uint32_t)(macconf->VLANTagComparison |
 80035b0:	687b      	ldr	r3, [r7, #4]
 80035b2:	681b      	ldr	r3, [r3, #0]
 80035b4:	683a      	ldr	r2, [r7, #0]
 80035b6:	6ed1      	ldr	r1, [r2, #108]	; 0x6c
		macconf->VLANTagIdentifier);
 80035b8:	683a      	ldr	r2, [r7, #0]
 80035ba:	6f12      	ldr	r2, [r2, #112]	; 0x70

		/* Write to ETHERNET MACFCR */
		prvWriteMACFCR( heth, tmpreg );

		/*----------------------- ETHERNET MACVLANTR Configuration -----------------*/
		heth->Instance->MACVLANTR = (uint32_t)(macconf->VLANTagComparison |
 80035bc:	430a      	orrs	r2, r1
 80035be:	61da      	str	r2, [r3, #28]
		macconf->VLANTagIdentifier);

		/* Wait until the write operation will be taken into account :
		at least four TX_CLK/RX_CLK clock cycles */
		tmpreg = heth->Instance->MACVLANTR;
 80035c0:	687b      	ldr	r3, [r7, #4]
 80035c2:	681b      	ldr	r3, [r3, #0]
 80035c4:	69db      	ldr	r3, [r3, #28]
 80035c6:	60fb      	str	r3, [r7, #12]
		HAL_Delay(ETH_REG_WRITE_DELAY);
 80035c8:	2001      	movs	r0, #1
 80035ca:	f7fd f927 	bl	800081c <HAL_Delay>
		heth->Instance->MACVLANTR = tmpreg;
 80035ce:	687b      	ldr	r3, [r7, #4]
 80035d0:	681b      	ldr	r3, [r3, #0]
 80035d2:	68fa      	ldr	r2, [r7, #12]
 80035d4:	61da      	str	r2, [r3, #28]
 80035d6:	e013      	b.n	8003600 <HAL_ETH_ConfigMAC+0x190>
	}
	else /* macconf == NULL : here we just configure Speed and Duplex mode */
	{
		/*------------------------ ETHERNET MACCR Configuration --------------------*/
		/* Get the ETHERNET MACCR value */
		tmpreg = heth->Instance->MACCR;
 80035d8:	687b      	ldr	r3, [r7, #4]
 80035da:	681b      	ldr	r3, [r3, #0]
 80035dc:	681b      	ldr	r3, [r3, #0]
 80035de:	60fb      	str	r3, [r7, #12]

		/* Clear FES and DM bits */
		tmpreg &= ~((uint32_t)0x00004800);
 80035e0:	68fb      	ldr	r3, [r7, #12]
 80035e2:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 80035e6:	60fb      	str	r3, [r7, #12]

		tmpreg |= (uint32_t)(heth->Init.Speed | heth->Init.DuplexMode);
 80035e8:	687b      	ldr	r3, [r7, #4]
 80035ea:	689a      	ldr	r2, [r3, #8]
 80035ec:	687b      	ldr	r3, [r7, #4]
 80035ee:	68db      	ldr	r3, [r3, #12]
 80035f0:	4313      	orrs	r3, r2
 80035f2:	68fa      	ldr	r2, [r7, #12]
 80035f4:	4313      	orrs	r3, r2
 80035f6:	60fb      	str	r3, [r7, #12]

		/* Write to ETHERNET MACCR */
		prvWriteMACCR( heth, tmpreg );
 80035f8:	6878      	ldr	r0, [r7, #4]
 80035fa:	68f9      	ldr	r1, [r7, #12]
 80035fc:	f7ff ff22 	bl	8003444 <prvWriteMACCR>
	}

	/* Set the ETH state to Ready */
	heth->State= HAL_ETH_STATE_READY;
 8003600:	687b      	ldr	r3, [r7, #4]
 8003602:	2201      	movs	r2, #1
 8003604:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44

	/* Process Unlocked */
	__HAL_UNLOCK( heth );
 8003608:	687b      	ldr	r3, [r7, #4]
 800360a:	2200      	movs	r2, #0
 800360c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

	/* Return function status */
	return HAL_OK;
 8003610:	2300      	movs	r3, #0
}
 8003612:	4618      	mov	r0, r3
 8003614:	3710      	adds	r7, #16
 8003616:	46bd      	mov	sp, r7
 8003618:	bd80      	pop	{r7, pc}
 800361a:	bf00      	nop
 800361c:	ff20810f 	.word	0xff20810f

08003620 <ETH_MACDMAConfig>:
  *         the configuration information for ETHERNET module
  * @param  err: Ethernet Init error
  * @retval HAL status
  */
static void ETH_MACDMAConfig(ETH_HandleTypeDef *heth, uint32_t err)
{
 8003620:	b580      	push	{r7, lr}
 8003622:	b0b0      	sub	sp, #192	; 0xc0
 8003624:	af00      	add	r7, sp, #0
 8003626:	6078      	str	r0, [r7, #4]
 8003628:	6039      	str	r1, [r7, #0]
  ETH_MACInitTypeDef macinit;
  ETH_DMAInitTypeDef dmainit;
  uint32_t tmpreg = 0;
 800362a:	2300      	movs	r3, #0
 800362c:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

  if (err != ETH_SUCCESS) /* Auto-negotiation failed */
 8003630:	683b      	ldr	r3, [r7, #0]
 8003632:	2b00      	cmp	r3, #0
 8003634:	d007      	beq.n	8003646 <ETH_MACDMAConfig+0x26>
  {
    /* Set Ethernet duplex mode to Full-duplex */
    heth->Init.DuplexMode = ETH_MODE_FULLDUPLEX;
 8003636:	687b      	ldr	r3, [r7, #4]
 8003638:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800363c:	60da      	str	r2, [r3, #12]

    /* Set Ethernet speed to 100M */
    heth->Init.Speed = ETH_SPEED_100M;
 800363e:	687b      	ldr	r3, [r7, #4]
 8003640:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8003644:	609a      	str	r2, [r3, #8]
  }

  /* Ethernet MAC default initialization **************************************/
  macinit.Watchdog = ETH_WATCHDOG_ENABLE;
 8003646:	2300      	movs	r3, #0
 8003648:	64bb      	str	r3, [r7, #72]	; 0x48
  macinit.Jabber = ETH_JABBER_ENABLE;
 800364a:	2300      	movs	r3, #0
 800364c:	64fb      	str	r3, [r7, #76]	; 0x4c
  macinit.InterFrameGap = ETH_INTERFRAMEGAP_96BIT;
 800364e:	2300      	movs	r3, #0
 8003650:	653b      	str	r3, [r7, #80]	; 0x50
  macinit.CarrierSense = ETH_CARRIERSENCE_ENABLE;
 8003652:	2300      	movs	r3, #0
 8003654:	657b      	str	r3, [r7, #84]	; 0x54
  macinit.ReceiveOwn = ETH_RECEIVEOWN_ENABLE;
 8003656:	2300      	movs	r3, #0
 8003658:	65bb      	str	r3, [r7, #88]	; 0x58
  macinit.LoopbackMode = ETH_LOOPBACKMODE_DISABLE;
 800365a:	2300      	movs	r3, #0
 800365c:	65fb      	str	r3, [r7, #92]	; 0x5c
  if(heth->Init.ChecksumMode == ETH_CHECKSUM_BY_HARDWARE)
 800365e:	687b      	ldr	r3, [r7, #4]
 8003660:	69db      	ldr	r3, [r3, #28]
 8003662:	2b00      	cmp	r3, #0
 8003664:	d103      	bne.n	800366e <ETH_MACDMAConfig+0x4e>
  {
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_ENABLE;
 8003666:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800366a:	663b      	str	r3, [r7, #96]	; 0x60
 800366c:	e001      	b.n	8003672 <ETH_MACDMAConfig+0x52>
  }
  else
  {
    macinit.ChecksumOffload = ETH_CHECKSUMOFFLAOD_DISABLE;
 800366e:	2300      	movs	r3, #0
 8003670:	663b      	str	r3, [r7, #96]	; 0x60
  }
  macinit.RetryTransmission = ETH_RETRYTRANSMISSION_DISABLE;
 8003672:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003676:	667b      	str	r3, [r7, #100]	; 0x64
  macinit.AutomaticPadCRCStrip = ETH_AUTOMATICPADCRCSTRIP_DISABLE;
 8003678:	2300      	movs	r3, #0
 800367a:	66bb      	str	r3, [r7, #104]	; 0x68
  macinit.BackOffLimit = ETH_BACKOFFLIMIT_10;
 800367c:	2300      	movs	r3, #0
 800367e:	66fb      	str	r3, [r7, #108]	; 0x6c
  macinit.DeferralCheck = ETH_DEFFERRALCHECK_DISABLE;
 8003680:	2300      	movs	r3, #0
 8003682:	673b      	str	r3, [r7, #112]	; 0x70
  macinit.ReceiveAll = ETH_RECEIVEAll_DISABLE;
 8003684:	2300      	movs	r3, #0
 8003686:	677b      	str	r3, [r7, #116]	; 0x74
  macinit.SourceAddrFilter = ETH_SOURCEADDRFILTER_DISABLE;
 8003688:	2300      	movs	r3, #0
 800368a:	67bb      	str	r3, [r7, #120]	; 0x78
  macinit.PassControlFrames = ETH_PASSCONTROLFRAMES_BLOCKALL;
 800368c:	2340      	movs	r3, #64	; 0x40
 800368e:	67fb      	str	r3, [r7, #124]	; 0x7c
  macinit.BroadcastFramesReception = ETH_BROADCASTFRAMESRECEPTION_ENABLE;
 8003690:	2300      	movs	r3, #0
 8003692:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
  macinit.DestinationAddrFilter = ETH_DESTINATIONADDRFILTER_NORMAL;
 8003696:	2300      	movs	r3, #0
 8003698:	f8c7 3084 	str.w	r3, [r7, #132]	; 0x84
  macinit.PromiscuousMode = ETH_PROMISCUOUS_MODE_DISABLE;
 800369c:	2300      	movs	r3, #0
 800369e:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
  macinit.MulticastFramesFilter = ETH_MULTICASTFRAMESFILTER_PERFECT;
 80036a2:	2300      	movs	r3, #0
 80036a4:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
  macinit.UnicastFramesFilter = ETH_UNICASTFRAMESFILTER_PERFECT;
 80036a8:	2300      	movs	r3, #0
 80036aa:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
  macinit.HashTableHigh = 0x0;
 80036ae:	2300      	movs	r3, #0
 80036b0:	f8c7 3094 	str.w	r3, [r7, #148]	; 0x94
  macinit.HashTableLow = 0x0;
 80036b4:	2300      	movs	r3, #0
 80036b6:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
  macinit.PauseTime = 0x0;
 80036ba:	2300      	movs	r3, #0
 80036bc:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  macinit.ZeroQuantaPause = ETH_ZEROQUANTAPAUSE_DISABLE;
 80036c0:	2380      	movs	r3, #128	; 0x80
 80036c2:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  macinit.PauseLowThreshold = ETH_PAUSELOWTHRESHOLD_MINUS4;
 80036c6:	2300      	movs	r3, #0
 80036c8:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  macinit.UnicastPauseFrameDetect = ETH_UNICASTPAUSEFRAMEDETECT_DISABLE;
 80036cc:	2300      	movs	r3, #0
 80036ce:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
  macinit.ReceiveFlowControl = ETH_RECEIVEFLOWCONTROL_DISABLE;
 80036d2:	2300      	movs	r3, #0
 80036d4:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  macinit.TransmitFlowControl = ETH_TRANSMITFLOWCONTROL_DISABLE;
 80036d8:	2300      	movs	r3, #0
 80036da:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
  macinit.VLANTagComparison = ETH_VLANTAGCOMPARISON_16BIT;
 80036de:	2300      	movs	r3, #0
 80036e0:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  macinit.VLANTagIdentifier = 0x0;
 80036e4:	2300      	movs	r3, #0
 80036e6:	f8c7 30b8 	str.w	r3, [r7, #184]	; 0xb8

  /*------------------------ ETHERNET MACCR Configuration --------------------*/
  /* Get the ETHERNET MACCR value */
  tmpreg = heth->Instance->MACCR;
 80036ea:	687b      	ldr	r3, [r7, #4]
 80036ec:	681b      	ldr	r3, [r3, #0]
 80036ee:	681b      	ldr	r3, [r3, #0]
 80036f0:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  /* Clear WD, PCE, PS, TE and RE bits */
  tmpreg &= ETH_MACCR_CLEAR_MASK;
 80036f4:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80036f8:	4b92      	ldr	r3, [pc, #584]	; (8003944 <ETH_MACDMAConfig+0x324>)
 80036fa:	4013      	ands	r3, r2
 80036fc:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
  /* Set the IPCO bit according to ETH ChecksumOffload value */
  /* Set the DR bit according to ETH RetryTransmission value */
  /* Set the ACS bit according to ETH AutomaticPadCRCStrip value */
  /* Set the BL bit according to ETH BackOffLimit value */
  /* Set the DC bit according to ETH DeferralCheck value */
  tmpreg |= (uint32_t)(macinit.Watchdog |
 8003700:	6cba      	ldr	r2, [r7, #72]	; 0x48
                       macinit.Jabber |
 8003702:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  /* Set the IPCO bit according to ETH ChecksumOffload value */
  /* Set the DR bit according to ETH RetryTransmission value */
  /* Set the ACS bit according to ETH AutomaticPadCRCStrip value */
  /* Set the BL bit according to ETH BackOffLimit value */
  /* Set the DC bit according to ETH DeferralCheck value */
  tmpreg |= (uint32_t)(macinit.Watchdog |
 8003704:	431a      	orrs	r2, r3
                       macinit.Jabber |
                       macinit.InterFrameGap |
 8003706:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  /* Set the DR bit according to ETH RetryTransmission value */
  /* Set the ACS bit according to ETH AutomaticPadCRCStrip value */
  /* Set the BL bit according to ETH BackOffLimit value */
  /* Set the DC bit according to ETH DeferralCheck value */
  tmpreg |= (uint32_t)(macinit.Watchdog |
                       macinit.Jabber |
 8003708:	431a      	orrs	r2, r3
                       macinit.InterFrameGap |
                       macinit.CarrierSense |
 800370a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  /* Set the ACS bit according to ETH AutomaticPadCRCStrip value */
  /* Set the BL bit according to ETH BackOffLimit value */
  /* Set the DC bit according to ETH DeferralCheck value */
  tmpreg |= (uint32_t)(macinit.Watchdog |
                       macinit.Jabber |
                       macinit.InterFrameGap |
 800370c:	431a      	orrs	r2, r3
                       macinit.CarrierSense |
                       heth->Init.Speed |
 800370e:	687b      	ldr	r3, [r7, #4]
 8003710:	689b      	ldr	r3, [r3, #8]
  /* Set the BL bit according to ETH BackOffLimit value */
  /* Set the DC bit according to ETH DeferralCheck value */
  tmpreg |= (uint32_t)(macinit.Watchdog |
                       macinit.Jabber |
                       macinit.InterFrameGap |
                       macinit.CarrierSense |
 8003712:	431a      	orrs	r2, r3
                       heth->Init.Speed |
                       macinit.ReceiveOwn |
 8003714:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  /* Set the DC bit according to ETH DeferralCheck value */
  tmpreg |= (uint32_t)(macinit.Watchdog |
                       macinit.Jabber |
                       macinit.InterFrameGap |
                       macinit.CarrierSense |
                       heth->Init.Speed |
 8003716:	431a      	orrs	r2, r3
                       macinit.ReceiveOwn |
                       macinit.LoopbackMode |
 8003718:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
  tmpreg |= (uint32_t)(macinit.Watchdog |
                       macinit.Jabber |
                       macinit.InterFrameGap |
                       macinit.CarrierSense |
                       heth->Init.Speed |
                       macinit.ReceiveOwn |
 800371a:	431a      	orrs	r2, r3
                       macinit.LoopbackMode |
                       heth->Init.DuplexMode |
 800371c:	687b      	ldr	r3, [r7, #4]
 800371e:	68db      	ldr	r3, [r3, #12]
                       macinit.Jabber |
                       macinit.InterFrameGap |
                       macinit.CarrierSense |
                       heth->Init.Speed |
                       macinit.ReceiveOwn |
                       macinit.LoopbackMode |
 8003720:	431a      	orrs	r2, r3
                       heth->Init.DuplexMode |
                       macinit.ChecksumOffload |
 8003722:	6e3b      	ldr	r3, [r7, #96]	; 0x60
                       macinit.InterFrameGap |
                       macinit.CarrierSense |
                       heth->Init.Speed |
                       macinit.ReceiveOwn |
                       macinit.LoopbackMode |
                       heth->Init.DuplexMode |
 8003724:	431a      	orrs	r2, r3
                       macinit.ChecksumOffload |
                       macinit.RetryTransmission |
 8003726:	6e7b      	ldr	r3, [r7, #100]	; 0x64
                       macinit.CarrierSense |
                       heth->Init.Speed |
                       macinit.ReceiveOwn |
                       macinit.LoopbackMode |
                       heth->Init.DuplexMode |
                       macinit.ChecksumOffload |
 8003728:	431a      	orrs	r2, r3
                       macinit.RetryTransmission |
                       macinit.AutomaticPadCRCStrip |
 800372a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
                       heth->Init.Speed |
                       macinit.ReceiveOwn |
                       macinit.LoopbackMode |
                       heth->Init.DuplexMode |
                       macinit.ChecksumOffload |
                       macinit.RetryTransmission |
 800372c:	431a      	orrs	r2, r3
                       macinit.AutomaticPadCRCStrip |
                       macinit.BackOffLimit |
 800372e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
                       macinit.ReceiveOwn |
                       macinit.LoopbackMode |
                       heth->Init.DuplexMode |
                       macinit.ChecksumOffload |
                       macinit.RetryTransmission |
                       macinit.AutomaticPadCRCStrip |
 8003730:	431a      	orrs	r2, r3
                       macinit.BackOffLimit |
                       macinit.DeferralCheck);
 8003732:	6f3b      	ldr	r3, [r7, #112]	; 0x70
  /* Set the IPCO bit according to ETH ChecksumOffload value */
  /* Set the DR bit according to ETH RetryTransmission value */
  /* Set the ACS bit according to ETH AutomaticPadCRCStrip value */
  /* Set the BL bit according to ETH BackOffLimit value */
  /* Set the DC bit according to ETH DeferralCheck value */
  tmpreg |= (uint32_t)(macinit.Watchdog |
 8003734:	4313      	orrs	r3, r2
 8003736:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 800373a:	4313      	orrs	r3, r2
 800373c:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
                       macinit.AutomaticPadCRCStrip |
                       macinit.BackOffLimit |
                       macinit.DeferralCheck);

  /* Write to ETHERNET MACCR */
  prvWriteMACCR( heth, tmpreg );
 8003740:	6878      	ldr	r0, [r7, #4]
 8003742:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
 8003746:	f7ff fe7d 	bl	8003444 <prvWriteMACCR>
  /* Set the DAIF bit according to ETH DestinationAddrFilter value */
  /* Set the PR bit according to ETH PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */
  heth->Instance->MACFFR = (uint32_t)(macinit.ReceiveAll |
 800374a:	687b      	ldr	r3, [r7, #4]
 800374c:	681b      	ldr	r3, [r3, #0]
 800374e:	6f79      	ldr	r1, [r7, #116]	; 0x74
                                        macinit.SourceAddrFilter |
 8003750:	6fba      	ldr	r2, [r7, #120]	; 0x78
  /* Set the DAIF bit according to ETH DestinationAddrFilter value */
  /* Set the PR bit according to ETH PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */
  heth->Instance->MACFFR = (uint32_t)(macinit.ReceiveAll |
 8003752:	4311      	orrs	r1, r2
                                        macinit.SourceAddrFilter |
                                        macinit.PassControlFrames |
 8003754:	6ffa      	ldr	r2, [r7, #124]	; 0x7c
  /* Set the PR bit according to ETH PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */
  heth->Instance->MACFFR = (uint32_t)(macinit.ReceiveAll |
                                        macinit.SourceAddrFilter |
 8003756:	4311      	orrs	r1, r2
                                        macinit.PassControlFrames |
                                        macinit.BroadcastFramesReception |
 8003758:	f8d7 2080 	ldr.w	r2, [r7, #128]	; 0x80
  /* Set the PM, HMC and HPF bits according to ETH MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */
  heth->Instance->MACFFR = (uint32_t)(macinit.ReceiveAll |
                                        macinit.SourceAddrFilter |
                                        macinit.PassControlFrames |
 800375c:	4311      	orrs	r1, r2
                                        macinit.BroadcastFramesReception |
                                        macinit.DestinationAddrFilter |
 800375e:	f8d7 2084 	ldr.w	r2, [r7, #132]	; 0x84
  /* Set the HUC and HPF bits according to ETH UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */
  heth->Instance->MACFFR = (uint32_t)(macinit.ReceiveAll |
                                        macinit.SourceAddrFilter |
                                        macinit.PassControlFrames |
                                        macinit.BroadcastFramesReception |
 8003762:	4311      	orrs	r1, r2
                                        macinit.DestinationAddrFilter |
                                        macinit.PromiscuousMode |
 8003764:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
  /* Write to ETHERNET MACFFR */
  heth->Instance->MACFFR = (uint32_t)(macinit.ReceiveAll |
                                        macinit.SourceAddrFilter |
                                        macinit.PassControlFrames |
                                        macinit.BroadcastFramesReception |
                                        macinit.DestinationAddrFilter |
 8003768:	4311      	orrs	r1, r2
                                        macinit.PromiscuousMode |
                                        macinit.MulticastFramesFilter |
 800376a:	f8d7 208c 	ldr.w	r2, [r7, #140]	; 0x8c
  heth->Instance->MACFFR = (uint32_t)(macinit.ReceiveAll |
                                        macinit.SourceAddrFilter |
                                        macinit.PassControlFrames |
                                        macinit.BroadcastFramesReception |
                                        macinit.DestinationAddrFilter |
                                        macinit.PromiscuousMode |
 800376e:	4311      	orrs	r1, r2
                                        macinit.MulticastFramesFilter |
                                        macinit.UnicastFramesFilter);
 8003770:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
  /* Set the DAIF bit according to ETH DestinationAddrFilter value */
  /* Set the PR bit according to ETH PromiscuousMode value */
  /* Set the PM, HMC and HPF bits according to ETH MulticastFramesFilter value */
  /* Set the HUC and HPF bits according to ETH UnicastFramesFilter value */
  /* Write to ETHERNET MACFFR */
  heth->Instance->MACFFR = (uint32_t)(macinit.ReceiveAll |
 8003774:	430a      	orrs	r2, r1
 8003776:	605a      	str	r2, [r3, #4]
                                        macinit.MulticastFramesFilter |
                                        macinit.UnicastFramesFilter);

   /* Wait until the write operation will be taken into account:
      at least four TX_CLK/RX_CLK clock cycles */
   tmpreg = heth->Instance->MACFFR;
 8003778:	687b      	ldr	r3, [r7, #4]
 800377a:	681b      	ldr	r3, [r3, #0]
 800377c:	685b      	ldr	r3, [r3, #4]
 800377e:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
   HAL_Delay(ETH_REG_WRITE_DELAY);
 8003782:	2001      	movs	r0, #1
 8003784:	f7fd f84a 	bl	800081c <HAL_Delay>
   heth->Instance->MACFFR = tmpreg;
 8003788:	687b      	ldr	r3, [r7, #4]
 800378a:	681b      	ldr	r3, [r3, #0]
 800378c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8003790:	605a      	str	r2, [r3, #4]

   /*--------------- ETHERNET MACHTHR and MACHTLR Configuration --------------*/
   /* Write to ETHERNET MACHTHR */
   heth->Instance->MACHTHR = (uint32_t)macinit.HashTableHigh;
 8003792:	687b      	ldr	r3, [r7, #4]
 8003794:	681b      	ldr	r3, [r3, #0]
 8003796:	f8d7 2094 	ldr.w	r2, [r7, #148]	; 0x94
 800379a:	609a      	str	r2, [r3, #8]

   /* Write to ETHERNET MACHTLR */
   heth->Instance->MACHTLR = (uint32_t)macinit.HashTableLow;
 800379c:	687b      	ldr	r3, [r7, #4]
 800379e:	681b      	ldr	r3, [r3, #0]
 80037a0:	f8d7 2098 	ldr.w	r2, [r7, #152]	; 0x98
 80037a4:	60da      	str	r2, [r3, #12]
   /*----------------------- ETHERNET MACFCR Configuration -------------------*/

   /* Get the ETHERNET MACFCR value */
   tmpreg = heth->Instance->MACFCR;
 80037a6:	687b      	ldr	r3, [r7, #4]
 80037a8:	681b      	ldr	r3, [r3, #0]
 80037aa:	699b      	ldr	r3, [r3, #24]
 80037ac:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
   /* Clear xx bits */
   tmpreg &= ETH_MACFCR_CLEAR_MASK;
 80037b0:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80037b4:	f64f 7341 	movw	r3, #65345	; 0xff41
 80037b8:	4013      	ands	r3, r2
 80037ba:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
   /* Set the DZPQ bit according to ETH ZeroQuantaPause value */
   /* Set the PLT bit according to ETH PauseLowThreshold value */
   /* Set the UP bit according to ETH UnicastPauseFrameDetect value */
   /* Set the RFE bit according to ETH ReceiveFlowControl value */
   /* Set the TFE bit according to ETH TransmitFlowControl value */
   tmpreg |= (uint32_t)((macinit.PauseTime << 16) |
 80037be:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 80037c2:	041a      	lsls	r2, r3, #16
                        macinit.ZeroQuantaPause |
 80037c4:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
   /* Set the DZPQ bit according to ETH ZeroQuantaPause value */
   /* Set the PLT bit according to ETH PauseLowThreshold value */
   /* Set the UP bit according to ETH UnicastPauseFrameDetect value */
   /* Set the RFE bit according to ETH ReceiveFlowControl value */
   /* Set the TFE bit according to ETH TransmitFlowControl value */
   tmpreg |= (uint32_t)((macinit.PauseTime << 16) |
 80037c8:	431a      	orrs	r2, r3
                        macinit.ZeroQuantaPause |
                        macinit.PauseLowThreshold |
 80037ca:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
   /* Set the PLT bit according to ETH PauseLowThreshold value */
   /* Set the UP bit according to ETH UnicastPauseFrameDetect value */
   /* Set the RFE bit according to ETH ReceiveFlowControl value */
   /* Set the TFE bit according to ETH TransmitFlowControl value */
   tmpreg |= (uint32_t)((macinit.PauseTime << 16) |
                        macinit.ZeroQuantaPause |
 80037ce:	431a      	orrs	r2, r3
                        macinit.PauseLowThreshold |
                        macinit.UnicastPauseFrameDetect |
 80037d0:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   /* Set the UP bit according to ETH UnicastPauseFrameDetect value */
   /* Set the RFE bit according to ETH ReceiveFlowControl value */
   /* Set the TFE bit according to ETH TransmitFlowControl value */
   tmpreg |= (uint32_t)((macinit.PauseTime << 16) |
                        macinit.ZeroQuantaPause |
                        macinit.PauseLowThreshold |
 80037d4:	431a      	orrs	r2, r3
                        macinit.UnicastPauseFrameDetect |
                        macinit.ReceiveFlowControl |
 80037d6:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   /* Set the RFE bit according to ETH ReceiveFlowControl value */
   /* Set the TFE bit according to ETH TransmitFlowControl value */
   tmpreg |= (uint32_t)((macinit.PauseTime << 16) |
                        macinit.ZeroQuantaPause |
                        macinit.PauseLowThreshold |
                        macinit.UnicastPauseFrameDetect |
 80037da:	431a      	orrs	r2, r3
                        macinit.ReceiveFlowControl |
                        macinit.TransmitFlowControl);
 80037dc:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
   /* Set the DZPQ bit according to ETH ZeroQuantaPause value */
   /* Set the PLT bit according to ETH PauseLowThreshold value */
   /* Set the UP bit according to ETH UnicastPauseFrameDetect value */
   /* Set the RFE bit according to ETH ReceiveFlowControl value */
   /* Set the TFE bit according to ETH TransmitFlowControl value */
   tmpreg |= (uint32_t)((macinit.PauseTime << 16) |
 80037e0:	4313      	orrs	r3, r2
 80037e2:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80037e6:	4313      	orrs	r3, r2
 80037e8:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
                        macinit.UnicastPauseFrameDetect |
                        macinit.ReceiveFlowControl |
                        macinit.TransmitFlowControl);

   /* Write to ETHERNET MACFCR */
   prvWriteMACFCR( heth, tmpreg );
 80037ec:	6878      	ldr	r0, [r7, #4]
 80037ee:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
 80037f2:	f7ff fdf1 	bl	80033d8 <prvWriteMACFCR>

   /*----------------------- ETHERNET MACVLANTR Configuration ----------------*/
   /* Set the ETV bit according to ETH VLANTagComparison value */
   /* Set the VL bit according to ETH VLANTagIdentifier value */
   heth->Instance->MACVLANTR = (uint32_t)(macinit.VLANTagComparison |
 80037f6:	687b      	ldr	r3, [r7, #4]
 80037f8:	681b      	ldr	r3, [r3, #0]
 80037fa:	f8d7 10b4 	ldr.w	r1, [r7, #180]	; 0xb4
                                            macinit.VLANTagIdentifier);
 80037fe:	f8d7 20b8 	ldr.w	r2, [r7, #184]	; 0xb8
   prvWriteMACFCR( heth, tmpreg );

   /*----------------------- ETHERNET MACVLANTR Configuration ----------------*/
   /* Set the ETV bit according to ETH VLANTagComparison value */
   /* Set the VL bit according to ETH VLANTagIdentifier value */
   heth->Instance->MACVLANTR = (uint32_t)(macinit.VLANTagComparison |
 8003802:	430a      	orrs	r2, r1
 8003804:	61da      	str	r2, [r3, #28]
                                            macinit.VLANTagIdentifier);

    /* Wait until the write operation will be taken into account:
       at least four TX_CLK/RX_CLK clock cycles */
    tmpreg = heth->Instance->MACVLANTR;
 8003806:	687b      	ldr	r3, [r7, #4]
 8003808:	681b      	ldr	r3, [r3, #0]
 800380a:	69db      	ldr	r3, [r3, #28]
 800380c:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    HAL_Delay(ETH_REG_WRITE_DELAY);
 8003810:	2001      	movs	r0, #1
 8003812:	f7fd f803 	bl	800081c <HAL_Delay>
    heth->Instance->MACVLANTR = tmpreg;
 8003816:	687b      	ldr	r3, [r7, #4]
 8003818:	681b      	ldr	r3, [r3, #0]
 800381a:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 800381e:	61da      	str	r2, [r3, #28]

    /* Ethernet DMA default initialization ************************************/
    dmainit.DropTCPIPChecksumErrorFrame = ETH_DROPTCPIPCHECKSUMERRORFRAME_ENABLE;
 8003820:	2300      	movs	r3, #0
 8003822:	60bb      	str	r3, [r7, #8]
    dmainit.ReceiveStoreForward = ETH_RECEIVESTOREFORWARD_ENABLE;
 8003824:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8003828:	60fb      	str	r3, [r7, #12]
    dmainit.FlushReceivedFrame = ETH_FLUSHRECEIVEDFRAME_ENABLE;
 800382a:	2300      	movs	r3, #0
 800382c:	613b      	str	r3, [r7, #16]
    dmainit.TransmitStoreForward = ETH_TRANSMITSTOREFORWARD_ENABLE;
 800382e:	f44f 1300 	mov.w	r3, #2097152	; 0x200000
 8003832:	617b      	str	r3, [r7, #20]
    dmainit.TransmitThresholdControl = ETH_TRANSMITTHRESHOLDCONTROL_64BYTES;
 8003834:	2300      	movs	r3, #0
 8003836:	61bb      	str	r3, [r7, #24]
    dmainit.ForwardErrorFrames = ETH_FORWARDERRORFRAMES_DISABLE;
 8003838:	2300      	movs	r3, #0
 800383a:	61fb      	str	r3, [r7, #28]
    dmainit.ForwardUndersizedGoodFrames = ETH_FORWARDUNDERSIZEDGOODFRAMES_DISABLE;
 800383c:	2300      	movs	r3, #0
 800383e:	623b      	str	r3, [r7, #32]
    dmainit.ReceiveThresholdControl = ETH_RECEIVEDTHRESHOLDCONTROL_64BYTES;
 8003840:	2300      	movs	r3, #0
 8003842:	627b      	str	r3, [r7, #36]	; 0x24
    dmainit.SecondFrameOperate = ETH_SECONDFRAMEOPERARTE_ENABLE;
 8003844:	2304      	movs	r3, #4
 8003846:	62bb      	str	r3, [r7, #40]	; 0x28
    dmainit.AddressAlignedBeats = ETH_ADDRESSALIGNEDBEATS_ENABLE;
 8003848:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800384c:	62fb      	str	r3, [r7, #44]	; 0x2c
    dmainit.FixedBurst = ETH_FIXEDBURST_ENABLE;
 800384e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8003852:	633b      	str	r3, [r7, #48]	; 0x30
    dmainit.RxDMABurstLength = ETH_RXDMABURSTLENGTH_32BEAT;
 8003854:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8003858:	637b      	str	r3, [r7, #52]	; 0x34
    dmainit.TxDMABurstLength = ETH_TXDMABURSTLENGTH_32BEAT;
 800385a:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800385e:	63bb      	str	r3, [r7, #56]	; 0x38
    dmainit.EnhancedDescriptorFormat = ETH_DMAENHANCEDDESCRIPTOR_ENABLE;
 8003860:	2380      	movs	r3, #128	; 0x80
 8003862:	63fb      	str	r3, [r7, #60]	; 0x3c
    dmainit.DescriptorSkipLength = 0x0;
 8003864:	2300      	movs	r3, #0
 8003866:	643b      	str	r3, [r7, #64]	; 0x40
    dmainit.DMAArbitration = ETH_DMAARBITRATION_ROUNDROBIN_RXTX_1_1;
 8003868:	2300      	movs	r3, #0
 800386a:	647b      	str	r3, [r7, #68]	; 0x44

    /* Get the ETHERNET DMAOMR value */
    tmpreg = heth->Instance->DMAOMR;
 800386c:	687b      	ldr	r3, [r7, #4]
 800386e:	681a      	ldr	r2, [r3, #0]
 8003870:	f241 0318 	movw	r3, #4120	; 0x1018
 8003874:	4413      	add	r3, r2
 8003876:	681b      	ldr	r3, [r3, #0]
 8003878:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    /* Clear xx bits */
    tmpreg &= ETH_DMAOMR_CLEAR_MASK;
 800387c:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8003880:	4b31      	ldr	r3, [pc, #196]	; (8003948 <ETH_MACDMAConfig+0x328>)
 8003882:	4013      	ands	r3, r2
 8003884:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
    /* Set the TTC bit according to ETH TransmitThresholdControl value */
    /* Set the FEF bit according to ETH ForwardErrorFrames value */
    /* Set the FUF bit according to ETH ForwardUndersizedGoodFrames value */
    /* Set the RTC bit according to ETH ReceiveThresholdControl value */
    /* Set the OSF bit according to ETH SecondFrameOperate value */
    tmpreg |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame |
 8003888:	68ba      	ldr	r2, [r7, #8]
                         dmainit.ReceiveStoreForward |
 800388a:	68fb      	ldr	r3, [r7, #12]
    /* Set the TTC bit according to ETH TransmitThresholdControl value */
    /* Set the FEF bit according to ETH ForwardErrorFrames value */
    /* Set the FUF bit according to ETH ForwardUndersizedGoodFrames value */
    /* Set the RTC bit according to ETH ReceiveThresholdControl value */
    /* Set the OSF bit according to ETH SecondFrameOperate value */
    tmpreg |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame |
 800388c:	431a      	orrs	r2, r3
                         dmainit.ReceiveStoreForward |
                         dmainit.FlushReceivedFrame |
 800388e:	693b      	ldr	r3, [r7, #16]
    /* Set the FEF bit according to ETH ForwardErrorFrames value */
    /* Set the FUF bit according to ETH ForwardUndersizedGoodFrames value */
    /* Set the RTC bit according to ETH ReceiveThresholdControl value */
    /* Set the OSF bit according to ETH SecondFrameOperate value */
    tmpreg |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame |
                         dmainit.ReceiveStoreForward |
 8003890:	431a      	orrs	r2, r3
                         dmainit.FlushReceivedFrame |
                         dmainit.TransmitStoreForward |
 8003892:	697b      	ldr	r3, [r7, #20]
    /* Set the FUF bit according to ETH ForwardUndersizedGoodFrames value */
    /* Set the RTC bit according to ETH ReceiveThresholdControl value */
    /* Set the OSF bit according to ETH SecondFrameOperate value */
    tmpreg |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame |
                         dmainit.ReceiveStoreForward |
                         dmainit.FlushReceivedFrame |
 8003894:	431a      	orrs	r2, r3
                         dmainit.TransmitStoreForward |
                         dmainit.TransmitThresholdControl |
 8003896:	69bb      	ldr	r3, [r7, #24]
    /* Set the RTC bit according to ETH ReceiveThresholdControl value */
    /* Set the OSF bit according to ETH SecondFrameOperate value */
    tmpreg |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame |
                         dmainit.ReceiveStoreForward |
                         dmainit.FlushReceivedFrame |
                         dmainit.TransmitStoreForward |
 8003898:	431a      	orrs	r2, r3
                         dmainit.TransmitThresholdControl |
                         dmainit.ForwardErrorFrames |
 800389a:	69fb      	ldr	r3, [r7, #28]
    /* Set the OSF bit according to ETH SecondFrameOperate value */
    tmpreg |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame |
                         dmainit.ReceiveStoreForward |
                         dmainit.FlushReceivedFrame |
                         dmainit.TransmitStoreForward |
                         dmainit.TransmitThresholdControl |
 800389c:	431a      	orrs	r2, r3
                         dmainit.ForwardErrorFrames |
                         dmainit.ForwardUndersizedGoodFrames |
 800389e:	6a3b      	ldr	r3, [r7, #32]
    tmpreg |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame |
                         dmainit.ReceiveStoreForward |
                         dmainit.FlushReceivedFrame |
                         dmainit.TransmitStoreForward |
                         dmainit.TransmitThresholdControl |
                         dmainit.ForwardErrorFrames |
 80038a0:	431a      	orrs	r2, r3
                         dmainit.ForwardUndersizedGoodFrames |
                         dmainit.ReceiveThresholdControl |
 80038a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
                         dmainit.ReceiveStoreForward |
                         dmainit.FlushReceivedFrame |
                         dmainit.TransmitStoreForward |
                         dmainit.TransmitThresholdControl |
                         dmainit.ForwardErrorFrames |
                         dmainit.ForwardUndersizedGoodFrames |
 80038a4:	431a      	orrs	r2, r3
                         dmainit.ReceiveThresholdControl |
                         dmainit.SecondFrameOperate);
 80038a6:	6abb      	ldr	r3, [r7, #40]	; 0x28
    /* Set the TTC bit according to ETH TransmitThresholdControl value */
    /* Set the FEF bit according to ETH ForwardErrorFrames value */
    /* Set the FUF bit according to ETH ForwardUndersizedGoodFrames value */
    /* Set the RTC bit according to ETH ReceiveThresholdControl value */
    /* Set the OSF bit according to ETH SecondFrameOperate value */
    tmpreg |= (uint32_t)(dmainit.DropTCPIPChecksumErrorFrame |
 80038a8:	4313      	orrs	r3, r2
 80038aa:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 80038ae:	4313      	orrs	r3, r2
 80038b0:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
                         dmainit.ForwardUndersizedGoodFrames |
                         dmainit.ReceiveThresholdControl |
                         dmainit.SecondFrameOperate);

    /* Write to ETHERNET DMAOMR */
    prvWriteDMAOMR( heth, tmpreg );
 80038b4:	6878      	ldr	r0, [r7, #4]
 80038b6:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
 80038ba:	f7ff fda3 	bl	8003404 <prvWriteDMAOMR>
    /* Set the RPBL and 4*PBL bits according to ETH RxDMABurstLength value */
    /* Set the PBL and 4*PBL bits according to ETH TxDMABurstLength value */
    /* Set the Enhanced DMA descriptors bit according to ETH EnhancedDescriptorFormat value*/
    /* Set the DSL bit according to ETH DesciptorSkipLength value */
    /* Set the PR and DA bits according to ETH DMAArbitration value */
    heth->Instance->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats |
 80038be:	687b      	ldr	r3, [r7, #4]
 80038c0:	681b      	ldr	r3, [r3, #0]
 80038c2:	6af9      	ldr	r1, [r7, #44]	; 0x2c
                                          dmainit.FixedBurst |
 80038c4:	6b3a      	ldr	r2, [r7, #48]	; 0x30
    /* Set the RPBL and 4*PBL bits according to ETH RxDMABurstLength value */
    /* Set the PBL and 4*PBL bits according to ETH TxDMABurstLength value */
    /* Set the Enhanced DMA descriptors bit according to ETH EnhancedDescriptorFormat value*/
    /* Set the DSL bit according to ETH DesciptorSkipLength value */
    /* Set the PR and DA bits according to ETH DMAArbitration value */
    heth->Instance->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats |
 80038c6:	4311      	orrs	r1, r2
                                          dmainit.FixedBurst |
                                          dmainit.RxDMABurstLength |    /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
 80038c8:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    /* Set the PBL and 4*PBL bits according to ETH TxDMABurstLength value */
    /* Set the Enhanced DMA descriptors bit according to ETH EnhancedDescriptorFormat value*/
    /* Set the DSL bit according to ETH DesciptorSkipLength value */
    /* Set the PR and DA bits according to ETH DMAArbitration value */
    heth->Instance->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats |
                                          dmainit.FixedBurst |
 80038ca:	4311      	orrs	r1, r2
                                          dmainit.RxDMABurstLength |    /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
                                          dmainit.TxDMABurstLength |
 80038cc:	6bba      	ldr	r2, [r7, #56]	; 0x38
    /* Set the Enhanced DMA descriptors bit according to ETH EnhancedDescriptorFormat value*/
    /* Set the DSL bit according to ETH DesciptorSkipLength value */
    /* Set the PR and DA bits according to ETH DMAArbitration value */
    heth->Instance->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats |
                                          dmainit.FixedBurst |
                                          dmainit.RxDMABurstLength |    /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
 80038ce:	4311      	orrs	r1, r2
                                          dmainit.TxDMABurstLength |
                                          dmainit.EnhancedDescriptorFormat |
 80038d0:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
    /* Set the DSL bit according to ETH DesciptorSkipLength value */
    /* Set the PR and DA bits according to ETH DMAArbitration value */
    heth->Instance->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats |
                                          dmainit.FixedBurst |
                                          dmainit.RxDMABurstLength |    /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
                                          dmainit.TxDMABurstLength |
 80038d2:	4311      	orrs	r1, r2
                                          dmainit.EnhancedDescriptorFormat |
                                          (dmainit.DescriptorSkipLength << 2) |
 80038d4:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80038d6:	0092      	lsls	r2, r2, #2
    /* Set the PR and DA bits according to ETH DMAArbitration value */
    heth->Instance->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats |
                                          dmainit.FixedBurst |
                                          dmainit.RxDMABurstLength |    /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
                                          dmainit.TxDMABurstLength |
                                          dmainit.EnhancedDescriptorFormat |
 80038d8:	4311      	orrs	r1, r2
                                          (dmainit.DescriptorSkipLength << 2) |
                                          dmainit.DMAArbitration |
 80038da:	6c7a      	ldr	r2, [r7, #68]	; 0x44
    heth->Instance->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats |
                                          dmainit.FixedBurst |
                                          dmainit.RxDMABurstLength |    /* !! if 4xPBL is selected for Tx or Rx it is applied for the other */
                                          dmainit.TxDMABurstLength |
                                          dmainit.EnhancedDescriptorFormat |
                                          (dmainit.DescriptorSkipLength << 2) |
 80038dc:	430a      	orrs	r2, r1
    /* Set the RPBL and 4*PBL bits according to ETH RxDMABurstLength value */
    /* Set the PBL and 4*PBL bits according to ETH TxDMABurstLength value */
    /* Set the Enhanced DMA descriptors bit according to ETH EnhancedDescriptorFormat value*/
    /* Set the DSL bit according to ETH DesciptorSkipLength value */
    /* Set the PR and DA bits according to ETH DMAArbitration value */
    heth->Instance->DMABMR = (uint32_t)(dmainit.AddressAlignedBeats |
 80038de:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80038e2:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80038e6:	601a      	str	r2, [r3, #0]
                                          dmainit.DMAArbitration |
                                          ETH_DMABMR_USP); /* Enable use of separate PBL for Rx and Tx */

     /* Wait until the write operation will be taken into account:
        at least four TX_CLK/RX_CLK clock cycles */
     tmpreg = heth->Instance->DMABMR;
 80038e8:	687b      	ldr	r3, [r7, #4]
 80038ea:	681b      	ldr	r3, [r3, #0]
 80038ec:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80038f0:	681b      	ldr	r3, [r3, #0]
 80038f2:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
     HAL_Delay(ETH_REG_WRITE_DELAY);
 80038f6:	2001      	movs	r0, #1
 80038f8:	f7fc ff90 	bl	800081c <HAL_Delay>
     heth->Instance->DMABMR = tmpreg;
 80038fc:	687b      	ldr	r3, [r7, #4]
 80038fe:	681b      	ldr	r3, [r3, #0]
 8003900:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8003904:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 8003908:	601a      	str	r2, [r3, #0]

     if(heth->Init.RxMode == ETH_RXINTERRUPT_MODE)
 800390a:	687b      	ldr	r3, [r7, #4]
 800390c:	699b      	ldr	r3, [r3, #24]
 800390e:	2b01      	cmp	r3, #1
 8003910:	d10d      	bne.n	800392e <ETH_MACDMAConfig+0x30e>
     {
       /* Enable the Ethernet Rx Interrupt */
       __HAL_ETH_DMA_ENABLE_IT(( heth ), ETH_DMA_IT_NIS | ETH_DMA_IT_R);
 8003912:	687b      	ldr	r3, [r7, #4]
 8003914:	6819      	ldr	r1, [r3, #0]
 8003916:	687b      	ldr	r3, [r7, #4]
 8003918:	681a      	ldr	r2, [r3, #0]
 800391a:	f241 031c 	movw	r3, #4124	; 0x101c
 800391e:	4413      	add	r3, r2
 8003920:	681b      	ldr	r3, [r3, #0]
 8003922:	4a0a      	ldr	r2, [pc, #40]	; (800394c <ETH_MACDMAConfig+0x32c>)
 8003924:	431a      	orrs	r2, r3
 8003926:	f241 031c 	movw	r3, #4124	; 0x101c
 800392a:	440b      	add	r3, r1
 800392c:	601a      	str	r2, [r3, #0]
     }

     /* Initialize MAC address in ethernet MAC */
     ETH_MACAddressConfig(heth, ETH_MAC_ADDRESS0, heth->Init.MACAddr);
 800392e:	687b      	ldr	r3, [r7, #4]
 8003930:	695b      	ldr	r3, [r3, #20]
 8003932:	6878      	ldr	r0, [r7, #4]
 8003934:	2100      	movs	r1, #0
 8003936:	461a      	mov	r2, r3
 8003938:	f000 f80a 	bl	8003950 <ETH_MACAddressConfig>
}
 800393c:	37c0      	adds	r7, #192	; 0xc0
 800393e:	46bd      	mov	sp, r7
 8003940:	bd80      	pop	{r7, pc}
 8003942:	bf00      	nop
 8003944:	ff20810f 	.word	0xff20810f
 8003948:	f8de3f23 	.word	0xf8de3f23
 800394c:	00010040 	.word	0x00010040

08003950 <ETH_MACAddressConfig>:
  *             @arg ETH_MAC_Address3: MAC Address3
  * @param  Addr: Pointer to MAC address buffer data (6 bytes)
  * @retval HAL status
  */
static void ETH_MACAddressConfig(ETH_HandleTypeDef *heth, uint32_t MacAddr, uint8_t *Addr)
{
 8003950:	b480      	push	{r7}
 8003952:	b087      	sub	sp, #28
 8003954:	af00      	add	r7, sp, #0
 8003956:	60f8      	str	r0, [r7, #12]
 8003958:	60b9      	str	r1, [r7, #8]
 800395a:	607a      	str	r2, [r7, #4]

	/* Check the parameters */
	assert_param( IS_ETH_MAC_ADDRESS0123( MacAddr ) );

	/* Calculate the selected MAC address high register */
	tmpreg = 0x80000000ul | ( ( uint32_t )Addr[ 5 ] << 8) | (uint32_t)Addr[ 4 ];
 800395c:	687b      	ldr	r3, [r7, #4]
 800395e:	3305      	adds	r3, #5
 8003960:	781b      	ldrb	r3, [r3, #0]
 8003962:	021b      	lsls	r3, r3, #8
 8003964:	687a      	ldr	r2, [r7, #4]
 8003966:	3204      	adds	r2, #4
 8003968:	7812      	ldrb	r2, [r2, #0]
 800396a:	4313      	orrs	r3, r2
 800396c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003970:	617b      	str	r3, [r7, #20]
	/* Load the selected MAC address high register */
	( * ( __IO uint32_t * ) ( ( uint32_t ) ( ETH_MAC_ADDR_HBASE + MacAddr ) ) ) = tmpreg;
 8003972:	68ba      	ldr	r2, [r7, #8]
 8003974:	4b10      	ldr	r3, [pc, #64]	; (80039b8 <ETH_MACAddressConfig+0x68>)
 8003976:	4413      	add	r3, r2
 8003978:	461a      	mov	r2, r3
 800397a:	697b      	ldr	r3, [r7, #20]
 800397c:	6013      	str	r3, [r2, #0]
	/* Calculate the selected MAC address low register */
	tmpreg = ( ( uint32_t )Addr[ 3 ] << 24 ) | ( ( uint32_t )Addr[ 2 ] << 16 ) | ( ( uint32_t )Addr[ 1 ] << 8 ) | Addr[ 0 ];
 800397e:	687b      	ldr	r3, [r7, #4]
 8003980:	3303      	adds	r3, #3
 8003982:	781b      	ldrb	r3, [r3, #0]
 8003984:	061a      	lsls	r2, r3, #24
 8003986:	687b      	ldr	r3, [r7, #4]
 8003988:	3302      	adds	r3, #2
 800398a:	781b      	ldrb	r3, [r3, #0]
 800398c:	041b      	lsls	r3, r3, #16
 800398e:	431a      	orrs	r2, r3
 8003990:	687b      	ldr	r3, [r7, #4]
 8003992:	3301      	adds	r3, #1
 8003994:	781b      	ldrb	r3, [r3, #0]
 8003996:	021b      	lsls	r3, r3, #8
 8003998:	4313      	orrs	r3, r2
 800399a:	687a      	ldr	r2, [r7, #4]
 800399c:	7812      	ldrb	r2, [r2, #0]
 800399e:	4313      	orrs	r3, r2
 80039a0:	617b      	str	r3, [r7, #20]

	/* Load the selected MAC address low register */
	( * ( __IO uint32_t * ) ( ( uint32_t ) ( ETH_MAC_ADDR_LBASE + MacAddr ) ) ) = tmpreg;
 80039a2:	68ba      	ldr	r2, [r7, #8]
 80039a4:	4b05      	ldr	r3, [pc, #20]	; (80039bc <ETH_MACAddressConfig+0x6c>)
 80039a6:	4413      	add	r3, r2
 80039a8:	461a      	mov	r2, r3
 80039aa:	697b      	ldr	r3, [r7, #20]
 80039ac:	6013      	str	r3, [r2, #0]
}
 80039ae:	371c      	adds	r7, #28
 80039b0:	46bd      	mov	sp, r7
 80039b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80039b6:	4770      	bx	lr
 80039b8:	40028040 	.word	0x40028040
 80039bc:	40028044 	.word	0x40028044

080039c0 <ETH_MACTransmissionEnable>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_MACTransmissionEnable(ETH_HandleTypeDef *heth)
{
 80039c0:	b580      	push	{r7, lr}
 80039c2:	b084      	sub	sp, #16
 80039c4:	af00      	add	r7, sp, #0
 80039c6:	6078      	str	r0, [r7, #4]
	uint32_t tmpreg = heth->Instance->MACCR | ETH_MACCR_TE;
 80039c8:	687b      	ldr	r3, [r7, #4]
 80039ca:	681b      	ldr	r3, [r3, #0]
 80039cc:	681b      	ldr	r3, [r3, #0]
 80039ce:	f043 0308 	orr.w	r3, r3, #8
 80039d2:	60fb      	str	r3, [r7, #12]

	prvWriteMACCR( heth, tmpreg );
 80039d4:	6878      	ldr	r0, [r7, #4]
 80039d6:	68f9      	ldr	r1, [r7, #12]
 80039d8:	f7ff fd34 	bl	8003444 <prvWriteMACCR>
}
 80039dc:	3710      	adds	r7, #16
 80039de:	46bd      	mov	sp, r7
 80039e0:	bd80      	pop	{r7, pc}
 80039e2:	bf00      	nop

080039e4 <ETH_MACTransmissionDisable>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_MACTransmissionDisable(ETH_HandleTypeDef *heth)
{
 80039e4:	b580      	push	{r7, lr}
 80039e6:	b084      	sub	sp, #16
 80039e8:	af00      	add	r7, sp, #0
 80039ea:	6078      	str	r0, [r7, #4]
	uint32_t tmpreg = heth->Instance->MACCR & ~( ETH_MACCR_TE );
 80039ec:	687b      	ldr	r3, [r7, #4]
 80039ee:	681b      	ldr	r3, [r3, #0]
 80039f0:	681b      	ldr	r3, [r3, #0]
 80039f2:	f023 0308 	bic.w	r3, r3, #8
 80039f6:	60fb      	str	r3, [r7, #12]

	prvWriteMACCR( heth, tmpreg );
 80039f8:	6878      	ldr	r0, [r7, #4]
 80039fa:	68f9      	ldr	r1, [r7, #12]
 80039fc:	f7ff fd22 	bl	8003444 <prvWriteMACCR>
}
 8003a00:	3710      	adds	r7, #16
 8003a02:	46bd      	mov	sp, r7
 8003a04:	bd80      	pop	{r7, pc}
 8003a06:	bf00      	nop

08003a08 <ETH_MACReceptionEnable>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_MACReceptionEnable(ETH_HandleTypeDef *heth)
{
 8003a08:	b580      	push	{r7, lr}
 8003a0a:	b084      	sub	sp, #16
 8003a0c:	af00      	add	r7, sp, #0
 8003a0e:	6078      	str	r0, [r7, #4]
	__IO uint32_t tmpreg = heth->Instance->MACCR | ETH_MACCR_RE;
 8003a10:	687b      	ldr	r3, [r7, #4]
 8003a12:	681b      	ldr	r3, [r3, #0]
 8003a14:	681b      	ldr	r3, [r3, #0]
 8003a16:	f043 0304 	orr.w	r3, r3, #4
 8003a1a:	60fb      	str	r3, [r7, #12]

	prvWriteMACCR( heth, tmpreg );
 8003a1c:	68fb      	ldr	r3, [r7, #12]
 8003a1e:	6878      	ldr	r0, [r7, #4]
 8003a20:	4619      	mov	r1, r3
 8003a22:	f7ff fd0f 	bl	8003444 <prvWriteMACCR>
}
 8003a26:	3710      	adds	r7, #16
 8003a28:	46bd      	mov	sp, r7
 8003a2a:	bd80      	pop	{r7, pc}

08003a2c <ETH_MACReceptionDisable>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_MACReceptionDisable(ETH_HandleTypeDef *heth)
{
 8003a2c:	b580      	push	{r7, lr}
 8003a2e:	b084      	sub	sp, #16
 8003a30:	af00      	add	r7, sp, #0
 8003a32:	6078      	str	r0, [r7, #4]
	__IO uint32_t tmpreg = heth->Instance->MACCR & ~( ETH_MACCR_RE );
 8003a34:	687b      	ldr	r3, [r7, #4]
 8003a36:	681b      	ldr	r3, [r3, #0]
 8003a38:	681b      	ldr	r3, [r3, #0]
 8003a3a:	f023 0304 	bic.w	r3, r3, #4
 8003a3e:	60fb      	str	r3, [r7, #12]

	prvWriteMACCR( heth, tmpreg );
 8003a40:	68fb      	ldr	r3, [r7, #12]
 8003a42:	6878      	ldr	r0, [r7, #4]
 8003a44:	4619      	mov	r1, r3
 8003a46:	f7ff fcfd 	bl	8003444 <prvWriteMACCR>
}
 8003a4a:	3710      	adds	r7, #16
 8003a4c:	46bd      	mov	sp, r7
 8003a4e:	bd80      	pop	{r7, pc}

08003a50 <ETH_DMATransmissionEnable>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_DMATransmissionEnable(ETH_HandleTypeDef *heth)
{
 8003a50:	b580      	push	{r7, lr}
 8003a52:	b084      	sub	sp, #16
 8003a54:	af00      	add	r7, sp, #0
 8003a56:	6078      	str	r0, [r7, #4]
	/* Enable the DMA transmission */
	__IO uint32_t tmpreg = heth->Instance->DMAOMR | ETH_DMAOMR_ST;
 8003a58:	687b      	ldr	r3, [r7, #4]
 8003a5a:	681a      	ldr	r2, [r3, #0]
 8003a5c:	f241 0318 	movw	r3, #4120	; 0x1018
 8003a60:	4413      	add	r3, r2
 8003a62:	681b      	ldr	r3, [r3, #0]
 8003a64:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8003a68:	60fb      	str	r3, [r7, #12]

	prvWriteDMAOMR( heth, tmpreg );
 8003a6a:	68fb      	ldr	r3, [r7, #12]
 8003a6c:	6878      	ldr	r0, [r7, #4]
 8003a6e:	4619      	mov	r1, r3
 8003a70:	f7ff fcc8 	bl	8003404 <prvWriteDMAOMR>
}
 8003a74:	3710      	adds	r7, #16
 8003a76:	46bd      	mov	sp, r7
 8003a78:	bd80      	pop	{r7, pc}
 8003a7a:	bf00      	nop

08003a7c <ETH_DMATransmissionDisable>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_DMATransmissionDisable(ETH_HandleTypeDef *heth)
{
 8003a7c:	b580      	push	{r7, lr}
 8003a7e:	b084      	sub	sp, #16
 8003a80:	af00      	add	r7, sp, #0
 8003a82:	6078      	str	r0, [r7, #4]
	/* Disable the DMA transmission */
	__IO uint32_t tmpreg = heth->Instance->DMAOMR & ~( ETH_DMAOMR_ST );
 8003a84:	687b      	ldr	r3, [r7, #4]
 8003a86:	681a      	ldr	r2, [r3, #0]
 8003a88:	f241 0318 	movw	r3, #4120	; 0x1018
 8003a8c:	4413      	add	r3, r2
 8003a8e:	681b      	ldr	r3, [r3, #0]
 8003a90:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003a94:	60fb      	str	r3, [r7, #12]

	prvWriteDMAOMR( heth, tmpreg );
 8003a96:	68fb      	ldr	r3, [r7, #12]
 8003a98:	6878      	ldr	r0, [r7, #4]
 8003a9a:	4619      	mov	r1, r3
 8003a9c:	f7ff fcb2 	bl	8003404 <prvWriteDMAOMR>
}
 8003aa0:	3710      	adds	r7, #16
 8003aa2:	46bd      	mov	sp, r7
 8003aa4:	bd80      	pop	{r7, pc}
 8003aa6:	bf00      	nop

08003aa8 <ETH_DMAReceptionEnable>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_DMAReceptionEnable(ETH_HandleTypeDef *heth)
{
 8003aa8:	b580      	push	{r7, lr}
 8003aaa:	b084      	sub	sp, #16
 8003aac:	af00      	add	r7, sp, #0
 8003aae:	6078      	str	r0, [r7, #4]
	/* Enable the DMA reception */
	__IO uint32_t tmpreg = heth->Instance->DMAOMR | ETH_DMAOMR_SR;
 8003ab0:	687b      	ldr	r3, [r7, #4]
 8003ab2:	681a      	ldr	r2, [r3, #0]
 8003ab4:	f241 0318 	movw	r3, #4120	; 0x1018
 8003ab8:	4413      	add	r3, r2
 8003aba:	681b      	ldr	r3, [r3, #0]
 8003abc:	f043 0302 	orr.w	r3, r3, #2
 8003ac0:	60fb      	str	r3, [r7, #12]

	prvWriteDMAOMR( heth, tmpreg );
 8003ac2:	68fb      	ldr	r3, [r7, #12]
 8003ac4:	6878      	ldr	r0, [r7, #4]
 8003ac6:	4619      	mov	r1, r3
 8003ac8:	f7ff fc9c 	bl	8003404 <prvWriteDMAOMR>
}
 8003acc:	3710      	adds	r7, #16
 8003ace:	46bd      	mov	sp, r7
 8003ad0:	bd80      	pop	{r7, pc}
 8003ad2:	bf00      	nop

08003ad4 <ETH_DMAReceptionDisable>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_DMAReceptionDisable(ETH_HandleTypeDef *heth)
{
 8003ad4:	b580      	push	{r7, lr}
 8003ad6:	b084      	sub	sp, #16
 8003ad8:	af00      	add	r7, sp, #0
 8003ada:	6078      	str	r0, [r7, #4]
	/* Disable the DMA reception */
	__IO uint32_t tmpreg = heth->Instance->DMAOMR & ~( ETH_DMAOMR_SR );
 8003adc:	687b      	ldr	r3, [r7, #4]
 8003ade:	681a      	ldr	r2, [r3, #0]
 8003ae0:	f241 0318 	movw	r3, #4120	; 0x1018
 8003ae4:	4413      	add	r3, r2
 8003ae6:	681b      	ldr	r3, [r3, #0]
 8003ae8:	f023 0302 	bic.w	r3, r3, #2
 8003aec:	60fb      	str	r3, [r7, #12]

	prvWriteDMAOMR( heth, tmpreg );
 8003aee:	68fb      	ldr	r3, [r7, #12]
 8003af0:	6878      	ldr	r0, [r7, #4]
 8003af2:	4619      	mov	r1, r3
 8003af4:	f7ff fc86 	bl	8003404 <prvWriteDMAOMR>
}
 8003af8:	3710      	adds	r7, #16
 8003afa:	46bd      	mov	sp, r7
 8003afc:	bd80      	pop	{r7, pc}
 8003afe:	bf00      	nop

08003b00 <ETH_FlushTransmitFIFO>:
  * @param  heth: pointer to a ETH_HandleTypeDef structure that contains
  *         the configuration information for ETHERNET module
  * @retval None
  */
static void ETH_FlushTransmitFIFO(ETH_HandleTypeDef *heth)
{
 8003b00:	b580      	push	{r7, lr}
 8003b02:	b084      	sub	sp, #16
 8003b04:	af00      	add	r7, sp, #0
 8003b06:	6078      	str	r0, [r7, #4]
	/* Set the Flush Transmit FIFO bit */
	__IO uint32_t tmpreg = heth->Instance->DMAOMR | ETH_DMAOMR_FTF;
 8003b08:	687b      	ldr	r3, [r7, #4]
 8003b0a:	681a      	ldr	r2, [r3, #0]
 8003b0c:	f241 0318 	movw	r3, #4120	; 0x1018
 8003b10:	4413      	add	r3, r2
 8003b12:	681b      	ldr	r3, [r3, #0]
 8003b14:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8003b18:	60fb      	str	r3, [r7, #12]

	prvWriteDMAOMR( heth, tmpreg );
 8003b1a:	68fb      	ldr	r3, [r7, #12]
 8003b1c:	6878      	ldr	r0, [r7, #4]
 8003b1e:	4619      	mov	r1, r3
 8003b20:	f7ff fc70 	bl	8003404 <prvWriteDMAOMR>
}
 8003b24:	3710      	adds	r7, #16
 8003b26:	46bd      	mov	sp, r7
 8003b28:	bd80      	pop	{r7, pc}
 8003b2a:	bf00      	nop

08003b2c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 8003b2c:	b480      	push	{r7}
 8003b2e:	b083      	sub	sp, #12
 8003b30:	af00      	add	r7, sp, #0
 8003b32:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003b34:	687b      	ldr	r3, [r7, #4]
 8003b36:	f103 0208 	add.w	r2, r3, #8
 8003b3a:	687b      	ldr	r3, [r7, #4]
 8003b3c:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8003b3e:	687b      	ldr	r3, [r7, #4]
 8003b40:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003b44:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003b46:	687b      	ldr	r3, [r7, #4]
 8003b48:	f103 0208 	add.w	r2, r3, #8
 8003b4c:	687b      	ldr	r3, [r7, #4]
 8003b4e:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003b50:	687b      	ldr	r3, [r7, #4]
 8003b52:	f103 0208 	add.w	r2, r3, #8
 8003b56:	687b      	ldr	r3, [r7, #4]
 8003b58:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 8003b5a:	687b      	ldr	r3, [r7, #4]
 8003b5c:	2200      	movs	r2, #0
 8003b5e:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 8003b60:	370c      	adds	r7, #12
 8003b62:	46bd      	mov	sp, r7
 8003b64:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003b68:	4770      	bx	lr
 8003b6a:	bf00      	nop

08003b6c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 8003b6c:	b480      	push	{r7}
 8003b6e:	b083      	sub	sp, #12
 8003b70:	af00      	add	r7, sp, #0
 8003b72:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 8003b74:	687b      	ldr	r3, [r7, #4]
 8003b76:	2200      	movs	r2, #0
 8003b78:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 8003b7a:	370c      	adds	r7, #12
 8003b7c:	46bd      	mov	sp, r7
 8003b7e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003b82:	4770      	bx	lr

08003b84 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8003b84:	b480      	push	{r7}
 8003b86:	b085      	sub	sp, #20
 8003b88:	af00      	add	r7, sp, #0
 8003b8a:	6078      	str	r0, [r7, #4]
 8003b8c:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
 8003b8e:	687b      	ldr	r3, [r7, #4]
 8003b90:	685b      	ldr	r3, [r3, #4]
 8003b92:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 8003b94:	683b      	ldr	r3, [r7, #0]
 8003b96:	68fa      	ldr	r2, [r7, #12]
 8003b98:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8003b9a:	68fb      	ldr	r3, [r7, #12]
 8003b9c:	689a      	ldr	r2, [r3, #8]
 8003b9e:	683b      	ldr	r3, [r7, #0]
 8003ba0:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8003ba2:	68fb      	ldr	r3, [r7, #12]
 8003ba4:	689b      	ldr	r3, [r3, #8]
 8003ba6:	683a      	ldr	r2, [r7, #0]
 8003ba8:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8003baa:	68fb      	ldr	r3, [r7, #12]
 8003bac:	683a      	ldr	r2, [r7, #0]
 8003bae:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003bb0:	683b      	ldr	r3, [r7, #0]
 8003bb2:	687a      	ldr	r2, [r7, #4]
 8003bb4:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8003bb6:	687b      	ldr	r3, [r7, #4]
 8003bb8:	681b      	ldr	r3, [r3, #0]
 8003bba:	1c5a      	adds	r2, r3, #1
 8003bbc:	687b      	ldr	r3, [r7, #4]
 8003bbe:	601a      	str	r2, [r3, #0]
}
 8003bc0:	3714      	adds	r7, #20
 8003bc2:	46bd      	mov	sp, r7
 8003bc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003bc8:	4770      	bx	lr
 8003bca:	bf00      	nop

08003bcc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 8003bcc:	b480      	push	{r7}
 8003bce:	b085      	sub	sp, #20
 8003bd0:	af00      	add	r7, sp, #0
 8003bd2:	6078      	str	r0, [r7, #4]
 8003bd4:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8003bd6:	683b      	ldr	r3, [r7, #0]
 8003bd8:	681b      	ldr	r3, [r3, #0]
 8003bda:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8003bdc:	68bb      	ldr	r3, [r7, #8]
 8003bde:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8003be2:	d103      	bne.n	8003bec <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8003be4:	687b      	ldr	r3, [r7, #4]
 8003be6:	691b      	ldr	r3, [r3, #16]
 8003be8:	60fb      	str	r3, [r7, #12]
 8003bea:	e00c      	b.n	8003c06 <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8003bec:	687b      	ldr	r3, [r7, #4]
 8003bee:	3308      	adds	r3, #8
 8003bf0:	60fb      	str	r3, [r7, #12]
 8003bf2:	e002      	b.n	8003bfa <vListInsert+0x2e>
 8003bf4:	68fb      	ldr	r3, [r7, #12]
 8003bf6:	685b      	ldr	r3, [r3, #4]
 8003bf8:	60fb      	str	r3, [r7, #12]
 8003bfa:	68fb      	ldr	r3, [r7, #12]
 8003bfc:	685b      	ldr	r3, [r3, #4]
 8003bfe:	681a      	ldr	r2, [r3, #0]
 8003c00:	68bb      	ldr	r3, [r7, #8]
 8003c02:	429a      	cmp	r2, r3
 8003c04:	d9f6      	bls.n	8003bf4 <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8003c06:	68fb      	ldr	r3, [r7, #12]
 8003c08:	685a      	ldr	r2, [r3, #4]
 8003c0a:	683b      	ldr	r3, [r7, #0]
 8003c0c:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8003c0e:	683b      	ldr	r3, [r7, #0]
 8003c10:	685b      	ldr	r3, [r3, #4]
 8003c12:	683a      	ldr	r2, [r7, #0]
 8003c14:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8003c16:	683b      	ldr	r3, [r7, #0]
 8003c18:	68fa      	ldr	r2, [r7, #12]
 8003c1a:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
 8003c1c:	68fb      	ldr	r3, [r7, #12]
 8003c1e:	683a      	ldr	r2, [r7, #0]
 8003c20:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 8003c22:	683b      	ldr	r3, [r7, #0]
 8003c24:	687a      	ldr	r2, [r7, #4]
 8003c26:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8003c28:	687b      	ldr	r3, [r7, #4]
 8003c2a:	681b      	ldr	r3, [r3, #0]
 8003c2c:	1c5a      	adds	r2, r3, #1
 8003c2e:	687b      	ldr	r3, [r7, #4]
 8003c30:	601a      	str	r2, [r3, #0]
}
 8003c32:	3714      	adds	r7, #20
 8003c34:	46bd      	mov	sp, r7
 8003c36:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c3a:	4770      	bx	lr

08003c3c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 8003c3c:	b480      	push	{r7}
 8003c3e:	b085      	sub	sp, #20
 8003c40:	af00      	add	r7, sp, #0
 8003c42:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8003c44:	687b      	ldr	r3, [r7, #4]
 8003c46:	691b      	ldr	r3, [r3, #16]
 8003c48:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8003c4a:	687b      	ldr	r3, [r7, #4]
 8003c4c:	685b      	ldr	r3, [r3, #4]
 8003c4e:	687a      	ldr	r2, [r7, #4]
 8003c50:	6892      	ldr	r2, [r2, #8]
 8003c52:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8003c54:	687b      	ldr	r3, [r7, #4]
 8003c56:	689b      	ldr	r3, [r3, #8]
 8003c58:	687a      	ldr	r2, [r7, #4]
 8003c5a:	6852      	ldr	r2, [r2, #4]
 8003c5c:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8003c5e:	68fb      	ldr	r3, [r7, #12]
 8003c60:	685a      	ldr	r2, [r3, #4]
 8003c62:	687b      	ldr	r3, [r7, #4]
 8003c64:	429a      	cmp	r2, r3
 8003c66:	d103      	bne.n	8003c70 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8003c68:	687b      	ldr	r3, [r7, #4]
 8003c6a:	689a      	ldr	r2, [r3, #8]
 8003c6c:	68fb      	ldr	r3, [r7, #12]
 8003c6e:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8003c70:	687b      	ldr	r3, [r7, #4]
 8003c72:	2200      	movs	r2, #0
 8003c74:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 8003c76:	68fb      	ldr	r3, [r7, #12]
 8003c78:	681b      	ldr	r3, [r3, #0]
 8003c7a:	1e5a      	subs	r2, r3, #1
 8003c7c:	68fb      	ldr	r3, [r7, #12]
 8003c7e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 8003c80:	68fb      	ldr	r3, [r7, #12]
 8003c82:	681b      	ldr	r3, [r3, #0]
}
 8003c84:	4618      	mov	r0, r3
 8003c86:	3714      	adds	r7, #20
 8003c88:	46bd      	mov	sp, r7
 8003c8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003c8e:	4770      	bx	lr

08003c90 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
 8003c90:	b480      	push	{r7}
 8003c92:	b085      	sub	sp, #20
 8003c94:	af00      	add	r7, sp, #0
 8003c96:	60f8      	str	r0, [r7, #12]
 8003c98:	60b9      	str	r1, [r7, #8]
 8003c9a:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
 8003c9c:	68fb      	ldr	r3, [r7, #12]
 8003c9e:	3b04      	subs	r3, #4
 8003ca0:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8003ca2:	68fb      	ldr	r3, [r7, #12]
 8003ca4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8003ca8:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8003caa:	68fb      	ldr	r3, [r7, #12]
 8003cac:	3b04      	subs	r3, #4
 8003cae:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 8003cb0:	68bb      	ldr	r3, [r7, #8]
 8003cb2:	f023 0201 	bic.w	r2, r3, #1
 8003cb6:	68fb      	ldr	r3, [r7, #12]
 8003cb8:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8003cba:	68fb      	ldr	r3, [r7, #12]
 8003cbc:	3b04      	subs	r3, #4
 8003cbe:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 8003cc0:	68fb      	ldr	r3, [r7, #12]
 8003cc2:	2200      	movs	r2, #0
 8003cc4:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 8003cc6:	68fb      	ldr	r3, [r7, #12]
 8003cc8:	3b14      	subs	r3, #20
 8003cca:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 8003ccc:	687a      	ldr	r2, [r7, #4]
 8003cce:	68fb      	ldr	r3, [r7, #12]
 8003cd0:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
 8003cd2:	68fb      	ldr	r3, [r7, #12]
 8003cd4:	3b04      	subs	r3, #4
 8003cd6:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 8003cd8:	68fb      	ldr	r3, [r7, #12]
 8003cda:	f06f 0202 	mvn.w	r2, #2
 8003cde:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8003ce0:	68fb      	ldr	r3, [r7, #12]
 8003ce2:	3b20      	subs	r3, #32
 8003ce4:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 8003ce6:	68fb      	ldr	r3, [r7, #12]
}
 8003ce8:	4618      	mov	r0, r3
 8003cea:	3714      	adds	r7, #20
 8003cec:	46bd      	mov	sp, r7
 8003cee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003cf2:	4770      	bx	lr

08003cf4 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 8003cf4:	b480      	push	{r7}
 8003cf6:	b083      	sub	sp, #12
 8003cf8:	af00      	add	r7, sp, #0
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8003cfa:	4b0c      	ldr	r3, [pc, #48]	; (8003d2c <prvTaskExitError+0x38>)
 8003cfc:	681b      	ldr	r3, [r3, #0]
 8003cfe:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8003d02:	d009      	beq.n	8003d18 <prvTaskExitError+0x24>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8003d04:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003d08:	f383 8811 	msr	BASEPRI, r3
 8003d0c:	f3bf 8f6f 	isb	sy
 8003d10:	f3bf 8f4f 	dsb	sy
 8003d14:	607b      	str	r3, [r7, #4]
 8003d16:	e7fe      	b.n	8003d16 <prvTaskExitError+0x22>
 8003d18:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003d1c:	f383 8811 	msr	BASEPRI, r3
 8003d20:	f3bf 8f6f 	isb	sy
 8003d24:	f3bf 8f4f 	dsb	sy
 8003d28:	603b      	str	r3, [r7, #0]
	portDISABLE_INTERRUPTS();
	for( ;; );
 8003d2a:	e7fe      	b.n	8003d2a <prvTaskExitError+0x36>
 8003d2c:	2000bb00 	.word	0x2000bb00

08003d30 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8003d30:	4b07      	ldr	r3, [pc, #28]	; (8003d50 <pxCurrentTCBConst2>)
 8003d32:	6819      	ldr	r1, [r3, #0]
 8003d34:	6808      	ldr	r0, [r1, #0]
 8003d36:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003d3a:	f380 8809 	msr	PSP, r0
 8003d3e:	f3bf 8f6f 	isb	sy
 8003d42:	f04f 0000 	mov.w	r0, #0
 8003d46:	f380 8811 	msr	BASEPRI, r0
 8003d4a:	4770      	bx	lr
 8003d4c:	f3af 8000 	nop.w

08003d50 <pxCurrentTCBConst2>:
 8003d50:	2000bbac 	.word	0x2000bbac

08003d54 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8003d54:	4806      	ldr	r0, [pc, #24]	; (8003d70 <prvPortStartFirstTask+0x1c>)
 8003d56:	6800      	ldr	r0, [r0, #0]
 8003d58:	6800      	ldr	r0, [r0, #0]
 8003d5a:	f380 8808 	msr	MSP, r0
 8003d5e:	b662      	cpsie	i
 8003d60:	b661      	cpsie	f
 8003d62:	f3bf 8f4f 	dsb	sy
 8003d66:	f3bf 8f6f 	isb	sy
 8003d6a:	df00      	svc	0
 8003d6c:	bf00      	nop
 8003d6e:	0000      	.short	0x0000
 8003d70:	e000ed08 	.word	0xe000ed08

08003d74 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 8003d74:	b580      	push	{r7, lr}
 8003d76:	b086      	sub	sp, #24
 8003d78:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* This port can be used on all revisions of the Cortex-M7 core other than
	the r0p1 parts.  r0p1 parts should use the port from the
	/source/portable/GCC/ARM_CM7/r0p1 directory. */
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8003d7a:	4b3b      	ldr	r3, [pc, #236]	; (8003e68 <xPortStartScheduler+0xf4>)
 8003d7c:	681b      	ldr	r3, [r3, #0]
 8003d7e:	4a3b      	ldr	r2, [pc, #236]	; (8003e6c <xPortStartScheduler+0xf8>)
 8003d80:	4293      	cmp	r3, r2
 8003d82:	d109      	bne.n	8003d98 <xPortStartScheduler+0x24>
 8003d84:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003d88:	f383 8811 	msr	BASEPRI, r3
 8003d8c:	f3bf 8f6f 	isb	sy
 8003d90:	f3bf 8f4f 	dsb	sy
 8003d94:	613b      	str	r3, [r7, #16]
 8003d96:	e7fe      	b.n	8003d96 <xPortStartScheduler+0x22>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8003d98:	4b33      	ldr	r3, [pc, #204]	; (8003e68 <xPortStartScheduler+0xf4>)
 8003d9a:	681b      	ldr	r3, [r3, #0]
 8003d9c:	4a34      	ldr	r2, [pc, #208]	; (8003e70 <xPortStartScheduler+0xfc>)
 8003d9e:	4293      	cmp	r3, r2
 8003da0:	d109      	bne.n	8003db6 <xPortStartScheduler+0x42>
 8003da2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003da6:	f383 8811 	msr	BASEPRI, r3
 8003daa:	f3bf 8f6f 	isb	sy
 8003dae:	f3bf 8f4f 	dsb	sy
 8003db2:	60fb      	str	r3, [r7, #12]
 8003db4:	e7fe      	b.n	8003db4 <xPortStartScheduler+0x40>

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
 8003db6:	4b2f      	ldr	r3, [pc, #188]	; (8003e74 <xPortStartScheduler+0x100>)
 8003db8:	617b      	str	r3, [r7, #20]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8003dba:	697b      	ldr	r3, [r7, #20]
 8003dbc:	781b      	ldrb	r3, [r3, #0]
 8003dbe:	b2db      	uxtb	r3, r3
 8003dc0:	60bb      	str	r3, [r7, #8]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8003dc2:	697b      	ldr	r3, [r7, #20]
 8003dc4:	22ff      	movs	r2, #255	; 0xff
 8003dc6:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8003dc8:	697b      	ldr	r3, [r7, #20]
 8003dca:	781b      	ldrb	r3, [r3, #0]
 8003dcc:	b2db      	uxtb	r3, r3
 8003dce:	71fb      	strb	r3, [r7, #7]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8003dd0:	79fb      	ldrb	r3, [r7, #7]
 8003dd2:	b2db      	uxtb	r3, r3
 8003dd4:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8003dd8:	b2da      	uxtb	r2, r3
 8003dda:	4b27      	ldr	r3, [pc, #156]	; (8003e78 <xPortStartScheduler+0x104>)
 8003ddc:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8003dde:	4b27      	ldr	r3, [pc, #156]	; (8003e7c <xPortStartScheduler+0x108>)
 8003de0:	2207      	movs	r2, #7
 8003de2:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8003de4:	e009      	b.n	8003dfa <xPortStartScheduler+0x86>
		{
			ulMaxPRIGROUPValue--;
 8003de6:	4b25      	ldr	r3, [pc, #148]	; (8003e7c <xPortStartScheduler+0x108>)
 8003de8:	681b      	ldr	r3, [r3, #0]
 8003dea:	3b01      	subs	r3, #1
 8003dec:	4a23      	ldr	r2, [pc, #140]	; (8003e7c <xPortStartScheduler+0x108>)
 8003dee:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8003df0:	79fb      	ldrb	r3, [r7, #7]
 8003df2:	b2db      	uxtb	r3, r3
 8003df4:	005b      	lsls	r3, r3, #1
 8003df6:	b2db      	uxtb	r3, r3
 8003df8:	71fb      	strb	r3, [r7, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8003dfa:	79fb      	ldrb	r3, [r7, #7]
 8003dfc:	b2db      	uxtb	r3, r3
 8003dfe:	b2db      	uxtb	r3, r3
 8003e00:	b25b      	sxtb	r3, r3
 8003e02:	2b00      	cmp	r3, #0
 8003e04:	dbef      	blt.n	8003de6 <xPortStartScheduler+0x72>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8003e06:	4b1d      	ldr	r3, [pc, #116]	; (8003e7c <xPortStartScheduler+0x108>)
 8003e08:	681b      	ldr	r3, [r3, #0]
 8003e0a:	021b      	lsls	r3, r3, #8
 8003e0c:	4a1b      	ldr	r2, [pc, #108]	; (8003e7c <xPortStartScheduler+0x108>)
 8003e0e:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8003e10:	4b1a      	ldr	r3, [pc, #104]	; (8003e7c <xPortStartScheduler+0x108>)
 8003e12:	681b      	ldr	r3, [r3, #0]
 8003e14:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 8003e18:	4a18      	ldr	r2, [pc, #96]	; (8003e7c <xPortStartScheduler+0x108>)
 8003e1a:	6013      	str	r3, [r2, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8003e1c:	68bb      	ldr	r3, [r7, #8]
 8003e1e:	b2da      	uxtb	r2, r3
 8003e20:	697b      	ldr	r3, [r7, #20]
 8003e22:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8003e24:	4a16      	ldr	r2, [pc, #88]	; (8003e80 <xPortStartScheduler+0x10c>)
 8003e26:	4b16      	ldr	r3, [pc, #88]	; (8003e80 <xPortStartScheduler+0x10c>)
 8003e28:	681b      	ldr	r3, [r3, #0]
 8003e2a:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8003e2e:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8003e30:	4a13      	ldr	r2, [pc, #76]	; (8003e80 <xPortStartScheduler+0x10c>)
 8003e32:	4b13      	ldr	r3, [pc, #76]	; (8003e80 <xPortStartScheduler+0x10c>)
 8003e34:	681b      	ldr	r3, [r3, #0]
 8003e36:	f043 4370 	orr.w	r3, r3, #4026531840	; 0xf0000000
 8003e3a:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 8003e3c:	f000 f8d8 	bl	8003ff0 <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 8003e40:	4b10      	ldr	r3, [pc, #64]	; (8003e84 <xPortStartScheduler+0x110>)
 8003e42:	2200      	movs	r2, #0
 8003e44:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 8003e46:	f000 f8ed 	bl	8004024 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8003e4a:	4a0f      	ldr	r2, [pc, #60]	; (8003e88 <xPortStartScheduler+0x114>)
 8003e4c:	4b0e      	ldr	r3, [pc, #56]	; (8003e88 <xPortStartScheduler+0x114>)
 8003e4e:	681b      	ldr	r3, [r3, #0]
 8003e50:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8003e54:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 8003e56:	f7ff ff7d 	bl	8003d54 <prvPortStartFirstTask>

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
 8003e5a:	f7ff ff4b 	bl	8003cf4 <prvTaskExitError>

	/* Should not get here! */
	return 0;
 8003e5e:	2300      	movs	r3, #0
}
 8003e60:	4618      	mov	r0, r3
 8003e62:	3718      	adds	r7, #24
 8003e64:	46bd      	mov	sp, r7
 8003e66:	bd80      	pop	{r7, pc}
 8003e68:	e000ed00 	.word	0xe000ed00
 8003e6c:	410fc271 	.word	0x410fc271
 8003e70:	410fc270 	.word	0x410fc270
 8003e74:	e000e400 	.word	0xe000e400
 8003e78:	2000bb8c 	.word	0x2000bb8c
 8003e7c:	2000bb90 	.word	0x2000bb90
 8003e80:	e000ed20 	.word	0xe000ed20
 8003e84:	2000bb00 	.word	0x2000bb00
 8003e88:	e000ef34 	.word	0xe000ef34

08003e8c <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 8003e8c:	b480      	push	{r7}
 8003e8e:	b083      	sub	sp, #12
 8003e90:	af00      	add	r7, sp, #0
 8003e92:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003e96:	f383 8811 	msr	BASEPRI, r3
 8003e9a:	f3bf 8f6f 	isb	sy
 8003e9e:	f3bf 8f4f 	dsb	sy
 8003ea2:	607b      	str	r3, [r7, #4]
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 8003ea4:	4b0e      	ldr	r3, [pc, #56]	; (8003ee0 <vPortEnterCritical+0x54>)
 8003ea6:	681b      	ldr	r3, [r3, #0]
 8003ea8:	3301      	adds	r3, #1
 8003eaa:	4a0d      	ldr	r2, [pc, #52]	; (8003ee0 <vPortEnterCritical+0x54>)
 8003eac:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 8003eae:	4b0c      	ldr	r3, [pc, #48]	; (8003ee0 <vPortEnterCritical+0x54>)
 8003eb0:	681b      	ldr	r3, [r3, #0]
 8003eb2:	2b01      	cmp	r3, #1
 8003eb4:	d10e      	bne.n	8003ed4 <vPortEnterCritical+0x48>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8003eb6:	4b0b      	ldr	r3, [pc, #44]	; (8003ee4 <vPortEnterCritical+0x58>)
 8003eb8:	681b      	ldr	r3, [r3, #0]
 8003eba:	b2db      	uxtb	r3, r3
 8003ebc:	2b00      	cmp	r3, #0
 8003ebe:	d009      	beq.n	8003ed4 <vPortEnterCritical+0x48>
 8003ec0:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003ec4:	f383 8811 	msr	BASEPRI, r3
 8003ec8:	f3bf 8f6f 	isb	sy
 8003ecc:	f3bf 8f4f 	dsb	sy
 8003ed0:	603b      	str	r3, [r7, #0]
 8003ed2:	e7fe      	b.n	8003ed2 <vPortEnterCritical+0x46>
	}
}
 8003ed4:	370c      	adds	r7, #12
 8003ed6:	46bd      	mov	sp, r7
 8003ed8:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003edc:	4770      	bx	lr
 8003ede:	bf00      	nop
 8003ee0:	2000bb00 	.word	0x2000bb00
 8003ee4:	e000ed04 	.word	0xe000ed04

08003ee8 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 8003ee8:	b480      	push	{r7}
 8003eea:	b083      	sub	sp, #12
 8003eec:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
 8003eee:	4b10      	ldr	r3, [pc, #64]	; (8003f30 <vPortExitCritical+0x48>)
 8003ef0:	681b      	ldr	r3, [r3, #0]
 8003ef2:	2b00      	cmp	r3, #0
 8003ef4:	d109      	bne.n	8003f0a <vPortExitCritical+0x22>
 8003ef6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003efa:	f383 8811 	msr	BASEPRI, r3
 8003efe:	f3bf 8f6f 	isb	sy
 8003f02:	f3bf 8f4f 	dsb	sy
 8003f06:	607b      	str	r3, [r7, #4]
 8003f08:	e7fe      	b.n	8003f08 <vPortExitCritical+0x20>
	uxCriticalNesting--;
 8003f0a:	4b09      	ldr	r3, [pc, #36]	; (8003f30 <vPortExitCritical+0x48>)
 8003f0c:	681b      	ldr	r3, [r3, #0]
 8003f0e:	3b01      	subs	r3, #1
 8003f10:	4a07      	ldr	r2, [pc, #28]	; (8003f30 <vPortExitCritical+0x48>)
 8003f12:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8003f14:	4b06      	ldr	r3, [pc, #24]	; (8003f30 <vPortExitCritical+0x48>)
 8003f16:	681b      	ldr	r3, [r3, #0]
 8003f18:	2b00      	cmp	r3, #0
 8003f1a:	d104      	bne.n	8003f26 <vPortExitCritical+0x3e>
 8003f1c:	2300      	movs	r3, #0
 8003f1e:	603b      	str	r3, [r7, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8003f20:	683b      	ldr	r3, [r7, #0]
 8003f22:	f383 8811 	msr	BASEPRI, r3
	{
		portENABLE_INTERRUPTS();
	}
}
 8003f26:	370c      	adds	r7, #12
 8003f28:	46bd      	mov	sp, r7
 8003f2a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8003f2e:	4770      	bx	lr
 8003f30:	2000bb00 	.word	0x2000bb00
	...

08003f40 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8003f40:	f3ef 8009 	mrs	r0, PSP
 8003f44:	f3bf 8f6f 	isb	sy
 8003f48:	4b15      	ldr	r3, [pc, #84]	; (8003fa0 <pxCurrentTCBConst>)
 8003f4a:	681a      	ldr	r2, [r3, #0]
 8003f4c:	f01e 0f10 	tst.w	lr, #16
 8003f50:	bf08      	it	eq
 8003f52:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8003f56:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003f5a:	6010      	str	r0, [r2, #0]
 8003f5c:	f84d 3d04 	str.w	r3, [sp, #-4]!
 8003f60:	f04f 0050 	mov.w	r0, #80	; 0x50
 8003f64:	f380 8811 	msr	BASEPRI, r0
 8003f68:	f3bf 8f4f 	dsb	sy
 8003f6c:	f3bf 8f6f 	isb	sy
 8003f70:	f001 fc18 	bl	80057a4 <vTaskSwitchContext>
 8003f74:	f04f 0000 	mov.w	r0, #0
 8003f78:	f380 8811 	msr	BASEPRI, r0
 8003f7c:	bc08      	pop	{r3}
 8003f7e:	6819      	ldr	r1, [r3, #0]
 8003f80:	6808      	ldr	r0, [r1, #0]
 8003f82:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003f86:	f01e 0f10 	tst.w	lr, #16
 8003f8a:	bf08      	it	eq
 8003f8c:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 8003f90:	f380 8809 	msr	PSP, r0
 8003f94:	f3bf 8f6f 	isb	sy
 8003f98:	4770      	bx	lr
 8003f9a:	bf00      	nop
 8003f9c:	f3af 8000 	nop.w

08003fa0 <pxCurrentTCBConst>:
 8003fa0:	2000bbac 	.word	0x2000bbac

08003fa4 <xPortSysTickHandler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8003fa4:	b580      	push	{r7, lr}
 8003fa6:	b082      	sub	sp, #8
 8003fa8:	af00      	add	r7, sp, #0

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8003faa:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003fae:	f383 8811 	msr	BASEPRI, r3
 8003fb2:	f3bf 8f6f 	isb	sy
 8003fb6:	f3bf 8f4f 	dsb	sy
 8003fba:	607b      	str	r3, [r7, #4]
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	traceISR_ENTER();
 8003fbc:	f00d fcf8 	bl	80119b0 <SEGGER_SYSVIEW_RecordEnterISR>
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8003fc0:	f001 fb26 	bl	8005610 <xTaskIncrementTick>
 8003fc4:	4603      	mov	r3, r0
 8003fc6:	2b00      	cmp	r3, #0
 8003fc8:	d006      	beq.n	8003fd8 <xPortSysTickHandler+0x34>
		{
			traceISR_EXIT_TO_SCHEDULER();
 8003fca:	f00d fd4d 	bl	8011a68 <SEGGER_SYSVIEW_RecordExitISRToScheduler>
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 8003fce:	4b07      	ldr	r3, [pc, #28]	; (8003fec <xPortSysTickHandler+0x48>)
 8003fd0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003fd4:	601a      	str	r2, [r3, #0]
 8003fd6:	e001      	b.n	8003fdc <xPortSysTickHandler+0x38>
		}
		else
		{
			traceISR_EXIT();
 8003fd8:	f00d fd2a 	bl	8011a30 <SEGGER_SYSVIEW_RecordExitISR>
 8003fdc:	2300      	movs	r3, #0
 8003fde:	603b      	str	r3, [r7, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8003fe0:	683b      	ldr	r3, [r7, #0]
 8003fe2:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
 8003fe6:	3708      	adds	r7, #8
 8003fe8:	46bd      	mov	sp, r7
 8003fea:	bd80      	pop	{r7, pc}
 8003fec:	e000ed04 	.word	0xe000ed04

08003ff0 <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
 8003ff0:	b480      	push	{r7}
 8003ff2:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8003ff4:	4a07      	ldr	r2, [pc, #28]	; (8004014 <vPortSetupTimerInterrupt+0x24>)
 8003ff6:	4b08      	ldr	r3, [pc, #32]	; (8004018 <vPortSetupTimerInterrupt+0x28>)
 8003ff8:	681b      	ldr	r3, [r3, #0]
 8003ffa:	4908      	ldr	r1, [pc, #32]	; (800401c <vPortSetupTimerInterrupt+0x2c>)
 8003ffc:	fba1 1303 	umull	r1, r3, r1, r3
 8004000:	099b      	lsrs	r3, r3, #6
 8004002:	3b01      	subs	r3, #1
 8004004:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8004006:	4b06      	ldr	r3, [pc, #24]	; (8004020 <vPortSetupTimerInterrupt+0x30>)
 8004008:	2207      	movs	r2, #7
 800400a:	601a      	str	r2, [r3, #0]
}
 800400c:	46bd      	mov	sp, r7
 800400e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004012:	4770      	bx	lr
 8004014:	e000e014 	.word	0xe000e014
 8004018:	2000bb58 	.word	0x2000bb58
 800401c:	10624dd3 	.word	0x10624dd3
 8004020:	e000e010 	.word	0xe000e010

08004024 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 8004024:	f8df 000c 	ldr.w	r0, [pc, #12]	; 8004034 <vPortEnableVFP+0x10>
 8004028:	6801      	ldr	r1, [r0, #0]
 800402a:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800402e:	6001      	str	r1, [r0, #0]
 8004030:	4770      	bx	lr
 8004032:	0000      	.short	0x0000
 8004034:	e000ed88 	.word	0xe000ed88

08004038 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 8004038:	b480      	push	{r7}
 800403a:	b085      	sub	sp, #20
 800403c:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
 800403e:	f3ef 8305 	mrs	r3, IPSR
 8004042:	60fb      	str	r3, [r7, #12]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 8004044:	68fb      	ldr	r3, [r7, #12]
 8004046:	2b0f      	cmp	r3, #15
 8004048:	d913      	bls.n	8004072 <vPortValidateInterruptPriority+0x3a>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 800404a:	4a15      	ldr	r2, [pc, #84]	; (80040a0 <vPortValidateInterruptPriority+0x68>)
 800404c:	68fb      	ldr	r3, [r7, #12]
 800404e:	4413      	add	r3, r2
 8004050:	781b      	ldrb	r3, [r3, #0]
 8004052:	72fb      	strb	r3, [r7, #11]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 8004054:	4b13      	ldr	r3, [pc, #76]	; (80040a4 <vPortValidateInterruptPriority+0x6c>)
 8004056:	781b      	ldrb	r3, [r3, #0]
 8004058:	7afa      	ldrb	r2, [r7, #11]
 800405a:	429a      	cmp	r2, r3
 800405c:	d209      	bcs.n	8004072 <vPortValidateInterruptPriority+0x3a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 800405e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004062:	f383 8811 	msr	BASEPRI, r3
 8004066:	f3bf 8f6f 	isb	sy
 800406a:	f3bf 8f4f 	dsb	sy
 800406e:	607b      	str	r3, [r7, #4]
 8004070:	e7fe      	b.n	8004070 <vPortValidateInterruptPriority+0x38>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 8004072:	4b0d      	ldr	r3, [pc, #52]	; (80040a8 <vPortValidateInterruptPriority+0x70>)
 8004074:	681b      	ldr	r3, [r3, #0]
 8004076:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 800407a:	4b0c      	ldr	r3, [pc, #48]	; (80040ac <vPortValidateInterruptPriority+0x74>)
 800407c:	681b      	ldr	r3, [r3, #0]
 800407e:	429a      	cmp	r2, r3
 8004080:	d909      	bls.n	8004096 <vPortValidateInterruptPriority+0x5e>
 8004082:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004086:	f383 8811 	msr	BASEPRI, r3
 800408a:	f3bf 8f6f 	isb	sy
 800408e:	f3bf 8f4f 	dsb	sy
 8004092:	603b      	str	r3, [r7, #0]
 8004094:	e7fe      	b.n	8004094 <vPortValidateInterruptPriority+0x5c>
	}
 8004096:	3714      	adds	r7, #20
 8004098:	46bd      	mov	sp, r7
 800409a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800409e:	4770      	bx	lr
 80040a0:	e000e3f0 	.word	0xe000e3f0
 80040a4:	2000bb8c 	.word	0x2000bb8c
 80040a8:	e000ed0c 	.word	0xe000ed0c
 80040ac:	2000bb90 	.word	0x2000bb90

080040b0 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 80040b0:	b580      	push	{r7, lr}
 80040b2:	b088      	sub	sp, #32
 80040b4:	af00      	add	r7, sp, #0
 80040b6:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 80040b8:	2300      	movs	r3, #0
 80040ba:	617b      	str	r3, [r7, #20]

	/* The heap must be initialised before the first call to
	prvPortMalloc(). */
	configASSERT( pxEnd );
 80040bc:	4b47      	ldr	r3, [pc, #284]	; (80041dc <pvPortMalloc+0x12c>)
 80040be:	681b      	ldr	r3, [r3, #0]
 80040c0:	2b00      	cmp	r3, #0
 80040c2:	d109      	bne.n	80040d8 <pvPortMalloc+0x28>
 80040c4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80040c8:	f383 8811 	msr	BASEPRI, r3
 80040cc:	f3bf 8f6f 	isb	sy
 80040d0:	f3bf 8f4f 	dsb	sy
 80040d4:	60fb      	str	r3, [r7, #12]
 80040d6:	e7fe      	b.n	80040d6 <pvPortMalloc+0x26>

	vTaskSuspendAll();
 80040d8:	f001 f9a4 	bl	8005424 <vTaskSuspendAll>
	{
		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 80040dc:	4b40      	ldr	r3, [pc, #256]	; (80041e0 <pvPortMalloc+0x130>)
 80040de:	681a      	ldr	r2, [r3, #0]
 80040e0:	687b      	ldr	r3, [r7, #4]
 80040e2:	4013      	ands	r3, r2
 80040e4:	2b00      	cmp	r3, #0
 80040e6:	d16d      	bne.n	80041c4 <pvPortMalloc+0x114>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 80040e8:	687b      	ldr	r3, [r7, #4]
 80040ea:	2b00      	cmp	r3, #0
 80040ec:	d00d      	beq.n	800410a <pvPortMalloc+0x5a>
			{
				xWantedSize += xHeapStructSize;
 80040ee:	2208      	movs	r2, #8
 80040f0:	687b      	ldr	r3, [r7, #4]
 80040f2:	4413      	add	r3, r2
 80040f4:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 80040f6:	687b      	ldr	r3, [r7, #4]
 80040f8:	f003 0307 	and.w	r3, r3, #7
 80040fc:	2b00      	cmp	r3, #0
 80040fe:	d004      	beq.n	800410a <pvPortMalloc+0x5a>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8004100:	687b      	ldr	r3, [r7, #4]
 8004102:	f023 0307 	bic.w	r3, r3, #7
 8004106:	3308      	adds	r3, #8
 8004108:	607b      	str	r3, [r7, #4]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 800410a:	687b      	ldr	r3, [r7, #4]
 800410c:	2b00      	cmp	r3, #0
 800410e:	d059      	beq.n	80041c4 <pvPortMalloc+0x114>
 8004110:	4b34      	ldr	r3, [pc, #208]	; (80041e4 <pvPortMalloc+0x134>)
 8004112:	681b      	ldr	r3, [r3, #0]
 8004114:	687a      	ldr	r2, [r7, #4]
 8004116:	429a      	cmp	r2, r3
 8004118:	d854      	bhi.n	80041c4 <pvPortMalloc+0x114>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
 800411a:	4b33      	ldr	r3, [pc, #204]	; (80041e8 <pvPortMalloc+0x138>)
 800411c:	61bb      	str	r3, [r7, #24]
				pxBlock = xStart.pxNextFreeBlock;
 800411e:	4b32      	ldr	r3, [pc, #200]	; (80041e8 <pvPortMalloc+0x138>)
 8004120:	681b      	ldr	r3, [r3, #0]
 8004122:	61fb      	str	r3, [r7, #28]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004124:	e004      	b.n	8004130 <pvPortMalloc+0x80>
				{
					pxPreviousBlock = pxBlock;
 8004126:	69fb      	ldr	r3, [r7, #28]
 8004128:	61bb      	str	r3, [r7, #24]
					pxBlock = pxBlock->pxNextFreeBlock;
 800412a:	69fb      	ldr	r3, [r7, #28]
 800412c:	681b      	ldr	r3, [r3, #0]
 800412e:	61fb      	str	r3, [r7, #28]
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8004130:	69fb      	ldr	r3, [r7, #28]
 8004132:	685a      	ldr	r2, [r3, #4]
 8004134:	687b      	ldr	r3, [r7, #4]
 8004136:	429a      	cmp	r2, r3
 8004138:	d203      	bcs.n	8004142 <pvPortMalloc+0x92>
 800413a:	69fb      	ldr	r3, [r7, #28]
 800413c:	681b      	ldr	r3, [r3, #0]
 800413e:	2b00      	cmp	r3, #0
 8004140:	d1f1      	bne.n	8004126 <pvPortMalloc+0x76>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 8004142:	4b26      	ldr	r3, [pc, #152]	; (80041dc <pvPortMalloc+0x12c>)
 8004144:	681b      	ldr	r3, [r3, #0]
 8004146:	69fa      	ldr	r2, [r7, #28]
 8004148:	429a      	cmp	r2, r3
 800414a:	d03b      	beq.n	80041c4 <pvPortMalloc+0x114>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 800414c:	69bb      	ldr	r3, [r7, #24]
 800414e:	681b      	ldr	r3, [r3, #0]
 8004150:	2208      	movs	r2, #8
 8004152:	4413      	add	r3, r2
 8004154:	617b      	str	r3, [r7, #20]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8004156:	69fb      	ldr	r3, [r7, #28]
 8004158:	681a      	ldr	r2, [r3, #0]
 800415a:	69bb      	ldr	r3, [r7, #24]
 800415c:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 800415e:	69fb      	ldr	r3, [r7, #28]
 8004160:	685a      	ldr	r2, [r3, #4]
 8004162:	687b      	ldr	r3, [r7, #4]
 8004164:	1ad2      	subs	r2, r2, r3
 8004166:	2308      	movs	r3, #8
 8004168:	005b      	lsls	r3, r3, #1
 800416a:	429a      	cmp	r2, r3
 800416c:	d90f      	bls.n	800418e <pvPortMalloc+0xde>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 800416e:	69fa      	ldr	r2, [r7, #28]
 8004170:	687b      	ldr	r3, [r7, #4]
 8004172:	4413      	add	r3, r2
 8004174:	613b      	str	r3, [r7, #16]

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8004176:	69fb      	ldr	r3, [r7, #28]
 8004178:	685a      	ldr	r2, [r3, #4]
 800417a:	687b      	ldr	r3, [r7, #4]
 800417c:	1ad2      	subs	r2, r2, r3
 800417e:	693b      	ldr	r3, [r7, #16]
 8004180:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
 8004182:	69fb      	ldr	r3, [r7, #28]
 8004184:	687a      	ldr	r2, [r7, #4]
 8004186:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 8004188:	6938      	ldr	r0, [r7, #16]
 800418a:	f000 f889 	bl	80042a0 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 800418e:	4b15      	ldr	r3, [pc, #84]	; (80041e4 <pvPortMalloc+0x134>)
 8004190:	681a      	ldr	r2, [r3, #0]
 8004192:	69fb      	ldr	r3, [r7, #28]
 8004194:	685b      	ldr	r3, [r3, #4]
 8004196:	1ad3      	subs	r3, r2, r3
 8004198:	4a12      	ldr	r2, [pc, #72]	; (80041e4 <pvPortMalloc+0x134>)
 800419a:	6013      	str	r3, [r2, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 800419c:	4b11      	ldr	r3, [pc, #68]	; (80041e4 <pvPortMalloc+0x134>)
 800419e:	681a      	ldr	r2, [r3, #0]
 80041a0:	4b12      	ldr	r3, [pc, #72]	; (80041ec <pvPortMalloc+0x13c>)
 80041a2:	681b      	ldr	r3, [r3, #0]
 80041a4:	429a      	cmp	r2, r3
 80041a6:	d203      	bcs.n	80041b0 <pvPortMalloc+0x100>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 80041a8:	4b0e      	ldr	r3, [pc, #56]	; (80041e4 <pvPortMalloc+0x134>)
 80041aa:	681b      	ldr	r3, [r3, #0]
 80041ac:	4a0f      	ldr	r2, [pc, #60]	; (80041ec <pvPortMalloc+0x13c>)
 80041ae:	6013      	str	r3, [r2, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 80041b0:	69fb      	ldr	r3, [r7, #28]
 80041b2:	685a      	ldr	r2, [r3, #4]
 80041b4:	4b0a      	ldr	r3, [pc, #40]	; (80041e0 <pvPortMalloc+0x130>)
 80041b6:	681b      	ldr	r3, [r3, #0]
 80041b8:	431a      	orrs	r2, r3
 80041ba:	69fb      	ldr	r3, [r7, #28]
 80041bc:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
 80041be:	69fb      	ldr	r3, [r7, #28]
 80041c0:	2200      	movs	r2, #0
 80041c2:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 80041c4:	f001 f93c 	bl	8005440 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
 80041c8:	697b      	ldr	r3, [r7, #20]
 80041ca:	2b00      	cmp	r3, #0
 80041cc:	d101      	bne.n	80041d2 <pvPortMalloc+0x122>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
 80041ce:	f00b f8f3 	bl	800f3b8 <vApplicationMallocFailedHook>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	return pvReturn;
 80041d2:	697b      	ldr	r3, [r7, #20]
}
 80041d4:	4618      	mov	r0, r3
 80041d6:	3720      	adds	r7, #32
 80041d8:	46bd      	mov	sp, r7
 80041da:	bd80      	pop	{r7, pc}
 80041dc:	2000bb9c 	.word	0x2000bb9c
 80041e0:	2000bba8 	.word	0x2000bba8
 80041e4:	2000bba0 	.word	0x2000bba0
 80041e8:	2000bb94 	.word	0x2000bb94
 80041ec:	2000bba4 	.word	0x2000bba4

080041f0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 80041f0:	b580      	push	{r7, lr}
 80041f2:	b086      	sub	sp, #24
 80041f4:	af00      	add	r7, sp, #0
 80041f6:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
 80041f8:	687b      	ldr	r3, [r7, #4]
 80041fa:	617b      	str	r3, [r7, #20]
BlockLink_t *pxLink;

	if( pv != NULL )
 80041fc:	687b      	ldr	r3, [r7, #4]
 80041fe:	2b00      	cmp	r3, #0
 8004200:	d046      	beq.n	8004290 <vPortFree+0xa0>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
 8004202:	2308      	movs	r3, #8
 8004204:	425b      	negs	r3, r3
 8004206:	697a      	ldr	r2, [r7, #20]
 8004208:	4413      	add	r3, r2
 800420a:	617b      	str	r3, [r7, #20]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 800420c:	697b      	ldr	r3, [r7, #20]
 800420e:	613b      	str	r3, [r7, #16]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8004210:	693b      	ldr	r3, [r7, #16]
 8004212:	685a      	ldr	r2, [r3, #4]
 8004214:	4b20      	ldr	r3, [pc, #128]	; (8004298 <vPortFree+0xa8>)
 8004216:	681b      	ldr	r3, [r3, #0]
 8004218:	4013      	ands	r3, r2
 800421a:	2b00      	cmp	r3, #0
 800421c:	d109      	bne.n	8004232 <vPortFree+0x42>
 800421e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004222:	f383 8811 	msr	BASEPRI, r3
 8004226:	f3bf 8f6f 	isb	sy
 800422a:	f3bf 8f4f 	dsb	sy
 800422e:	60fb      	str	r3, [r7, #12]
 8004230:	e7fe      	b.n	8004230 <vPortFree+0x40>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8004232:	693b      	ldr	r3, [r7, #16]
 8004234:	681b      	ldr	r3, [r3, #0]
 8004236:	2b00      	cmp	r3, #0
 8004238:	d009      	beq.n	800424e <vPortFree+0x5e>
 800423a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800423e:	f383 8811 	msr	BASEPRI, r3
 8004242:	f3bf 8f6f 	isb	sy
 8004246:	f3bf 8f4f 	dsb	sy
 800424a:	60bb      	str	r3, [r7, #8]
 800424c:	e7fe      	b.n	800424c <vPortFree+0x5c>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 800424e:	693b      	ldr	r3, [r7, #16]
 8004250:	685a      	ldr	r2, [r3, #4]
 8004252:	4b11      	ldr	r3, [pc, #68]	; (8004298 <vPortFree+0xa8>)
 8004254:	681b      	ldr	r3, [r3, #0]
 8004256:	4013      	ands	r3, r2
 8004258:	2b00      	cmp	r3, #0
 800425a:	d019      	beq.n	8004290 <vPortFree+0xa0>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 800425c:	693b      	ldr	r3, [r7, #16]
 800425e:	681b      	ldr	r3, [r3, #0]
 8004260:	2b00      	cmp	r3, #0
 8004262:	d115      	bne.n	8004290 <vPortFree+0xa0>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8004264:	693b      	ldr	r3, [r7, #16]
 8004266:	685a      	ldr	r2, [r3, #4]
 8004268:	4b0b      	ldr	r3, [pc, #44]	; (8004298 <vPortFree+0xa8>)
 800426a:	681b      	ldr	r3, [r3, #0]
 800426c:	43db      	mvns	r3, r3
 800426e:	401a      	ands	r2, r3
 8004270:	693b      	ldr	r3, [r7, #16]
 8004272:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
 8004274:	f001 f8d6 	bl	8005424 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 8004278:	693b      	ldr	r3, [r7, #16]
 800427a:	685a      	ldr	r2, [r3, #4]
 800427c:	4b07      	ldr	r3, [pc, #28]	; (800429c <vPortFree+0xac>)
 800427e:	681b      	ldr	r3, [r3, #0]
 8004280:	4413      	add	r3, r2
 8004282:	4a06      	ldr	r2, [pc, #24]	; (800429c <vPortFree+0xac>)
 8004284:	6013      	str	r3, [r2, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8004286:	6938      	ldr	r0, [r7, #16]
 8004288:	f000 f80a 	bl	80042a0 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
 800428c:	f001 f8d8 	bl	8005440 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 8004290:	3718      	adds	r7, #24
 8004292:	46bd      	mov	sp, r7
 8004294:	bd80      	pop	{r7, pc}
 8004296:	bf00      	nop
 8004298:	2000bba8 	.word	0x2000bba8
 800429c:	2000bba0 	.word	0x2000bba0

080042a0 <prvInsertBlockIntoFreeList>:
	return xMinimumEverFreeBytesRemaining;
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 80042a0:	b480      	push	{r7}
 80042a2:	b085      	sub	sp, #20
 80042a4:	af00      	add	r7, sp, #0
 80042a6:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 80042a8:	4b27      	ldr	r3, [pc, #156]	; (8004348 <prvInsertBlockIntoFreeList+0xa8>)
 80042aa:	60fb      	str	r3, [r7, #12]
 80042ac:	e002      	b.n	80042b4 <prvInsertBlockIntoFreeList+0x14>
 80042ae:	68fb      	ldr	r3, [r7, #12]
 80042b0:	681b      	ldr	r3, [r3, #0]
 80042b2:	60fb      	str	r3, [r7, #12]
 80042b4:	68fb      	ldr	r3, [r7, #12]
 80042b6:	681a      	ldr	r2, [r3, #0]
 80042b8:	687b      	ldr	r3, [r7, #4]
 80042ba:	429a      	cmp	r2, r3
 80042bc:	d3f7      	bcc.n	80042ae <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
 80042be:	68fb      	ldr	r3, [r7, #12]
 80042c0:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 80042c2:	68fb      	ldr	r3, [r7, #12]
 80042c4:	685b      	ldr	r3, [r3, #4]
 80042c6:	68ba      	ldr	r2, [r7, #8]
 80042c8:	441a      	add	r2, r3
 80042ca:	687b      	ldr	r3, [r7, #4]
 80042cc:	429a      	cmp	r2, r3
 80042ce:	d108      	bne.n	80042e2 <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 80042d0:	68fb      	ldr	r3, [r7, #12]
 80042d2:	685a      	ldr	r2, [r3, #4]
 80042d4:	687b      	ldr	r3, [r7, #4]
 80042d6:	685b      	ldr	r3, [r3, #4]
 80042d8:	441a      	add	r2, r3
 80042da:	68fb      	ldr	r3, [r7, #12]
 80042dc:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
 80042de:	68fb      	ldr	r3, [r7, #12]
 80042e0:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
 80042e2:	687b      	ldr	r3, [r7, #4]
 80042e4:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 80042e6:	687b      	ldr	r3, [r7, #4]
 80042e8:	685b      	ldr	r3, [r3, #4]
 80042ea:	68ba      	ldr	r2, [r7, #8]
 80042ec:	441a      	add	r2, r3
 80042ee:	68fb      	ldr	r3, [r7, #12]
 80042f0:	681b      	ldr	r3, [r3, #0]
 80042f2:	429a      	cmp	r2, r3
 80042f4:	d118      	bne.n	8004328 <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 80042f6:	68fb      	ldr	r3, [r7, #12]
 80042f8:	681a      	ldr	r2, [r3, #0]
 80042fa:	4b14      	ldr	r3, [pc, #80]	; (800434c <prvInsertBlockIntoFreeList+0xac>)
 80042fc:	681b      	ldr	r3, [r3, #0]
 80042fe:	429a      	cmp	r2, r3
 8004300:	d00d      	beq.n	800431e <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8004302:	687b      	ldr	r3, [r7, #4]
 8004304:	685a      	ldr	r2, [r3, #4]
 8004306:	68fb      	ldr	r3, [r7, #12]
 8004308:	681b      	ldr	r3, [r3, #0]
 800430a:	685b      	ldr	r3, [r3, #4]
 800430c:	441a      	add	r2, r3
 800430e:	687b      	ldr	r3, [r7, #4]
 8004310:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8004312:	68fb      	ldr	r3, [r7, #12]
 8004314:	681b      	ldr	r3, [r3, #0]
 8004316:	681a      	ldr	r2, [r3, #0]
 8004318:	687b      	ldr	r3, [r7, #4]
 800431a:	601a      	str	r2, [r3, #0]
 800431c:	e008      	b.n	8004330 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 800431e:	4b0b      	ldr	r3, [pc, #44]	; (800434c <prvInsertBlockIntoFreeList+0xac>)
 8004320:	681a      	ldr	r2, [r3, #0]
 8004322:	687b      	ldr	r3, [r7, #4]
 8004324:	601a      	str	r2, [r3, #0]
 8004326:	e003      	b.n	8004330 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8004328:	68fb      	ldr	r3, [r7, #12]
 800432a:	681a      	ldr	r2, [r3, #0]
 800432c:	687b      	ldr	r3, [r7, #4]
 800432e:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8004330:	68fa      	ldr	r2, [r7, #12]
 8004332:	687b      	ldr	r3, [r7, #4]
 8004334:	429a      	cmp	r2, r3
 8004336:	d002      	beq.n	800433e <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8004338:	68fb      	ldr	r3, [r7, #12]
 800433a:	687a      	ldr	r2, [r7, #4]
 800433c:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 800433e:	3714      	adds	r7, #20
 8004340:	46bd      	mov	sp, r7
 8004342:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004346:	4770      	bx	lr
 8004348:	2000bb94 	.word	0x2000bb94
 800434c:	2000bb9c 	.word	0x2000bb9c

08004350 <vPortDefineHeapRegions>:
/*-----------------------------------------------------------*/

void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions )
{
 8004350:	b480      	push	{r7}
 8004352:	b08f      	sub	sp, #60	; 0x3c
 8004354:	af00      	add	r7, sp, #0
 8004356:	6078      	str	r0, [r7, #4]
BlockLink_t *pxFirstFreeBlockInRegion = NULL, *pxPreviousFreeBlock;
 8004358:	2300      	movs	r3, #0
 800435a:	623b      	str	r3, [r7, #32]
size_t xAlignedHeap;
size_t xTotalRegionSize, xTotalHeapSize = 0;
 800435c:	2300      	movs	r3, #0
 800435e:	633b      	str	r3, [r7, #48]	; 0x30
BaseType_t xDefinedRegions = 0;
 8004360:	2300      	movs	r3, #0
 8004362:	62fb      	str	r3, [r7, #44]	; 0x2c
size_t xAddress;
const HeapRegion_t *pxHeapRegion;

	/* Can only call once! */
	configASSERT( pxEnd == NULL );
 8004364:	4b58      	ldr	r3, [pc, #352]	; (80044c8 <vPortDefineHeapRegions+0x178>)
 8004366:	681b      	ldr	r3, [r3, #0]
 8004368:	2b00      	cmp	r3, #0
 800436a:	d009      	beq.n	8004380 <vPortDefineHeapRegions+0x30>
 800436c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004370:	f383 8811 	msr	BASEPRI, r3
 8004374:	f3bf 8f6f 	isb	sy
 8004378:	f3bf 8f4f 	dsb	sy
 800437c:	617b      	str	r3, [r7, #20]
 800437e:	e7fe      	b.n	800437e <vPortDefineHeapRegions+0x2e>

	pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
 8004380:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004382:	00db      	lsls	r3, r3, #3
 8004384:	687a      	ldr	r2, [r7, #4]
 8004386:	4413      	add	r3, r2
 8004388:	627b      	str	r3, [r7, #36]	; 0x24

	while( pxHeapRegion->xSizeInBytes > 0 )
 800438a:	e07b      	b.n	8004484 <vPortDefineHeapRegions+0x134>
	{
		xTotalRegionSize = pxHeapRegion->xSizeInBytes;
 800438c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800438e:	685b      	ldr	r3, [r3, #4]
 8004390:	637b      	str	r3, [r7, #52]	; 0x34

		/* Ensure the heap region starts on a correctly aligned boundary. */
		xAddress = ( size_t ) pxHeapRegion->pucStartAddress;
 8004392:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004394:	681b      	ldr	r3, [r3, #0]
 8004396:	62bb      	str	r3, [r7, #40]	; 0x28
		if( ( xAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8004398:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800439a:	f003 0307 	and.w	r3, r3, #7
 800439e:	2b00      	cmp	r3, #0
 80043a0:	d00e      	beq.n	80043c0 <vPortDefineHeapRegions+0x70>
		{
			xAddress += ( portBYTE_ALIGNMENT - 1 );
 80043a2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80043a4:	3307      	adds	r3, #7
 80043a6:	62bb      	str	r3, [r7, #40]	; 0x28
			xAddress &= ~portBYTE_ALIGNMENT_MASK;
 80043a8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80043aa:	f023 0307 	bic.w	r3, r3, #7
 80043ae:	62bb      	str	r3, [r7, #40]	; 0x28

			/* Adjust the size for the bytes lost to alignment. */
			xTotalRegionSize -= xAddress - ( size_t ) pxHeapRegion->pucStartAddress;
 80043b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80043b2:	681b      	ldr	r3, [r3, #0]
 80043b4:	461a      	mov	r2, r3
 80043b6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80043b8:	1ad3      	subs	r3, r2, r3
 80043ba:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80043bc:	4413      	add	r3, r2
 80043be:	637b      	str	r3, [r7, #52]	; 0x34
		}

		xAlignedHeap = xAddress;
 80043c0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80043c2:	61fb      	str	r3, [r7, #28]

		/* Set xStart if it has not already been set. */
		if( xDefinedRegions == 0 )
 80043c4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80043c6:	2b00      	cmp	r3, #0
 80043c8:	d106      	bne.n	80043d8 <vPortDefineHeapRegions+0x88>
		{
			/* xStart is used to hold a pointer to the first item in the list of
			free blocks.  The void cast is used to prevent compiler warnings. */
			xStart.pxNextFreeBlock = ( BlockLink_t * ) xAlignedHeap;
 80043ca:	69fb      	ldr	r3, [r7, #28]
 80043cc:	4a3f      	ldr	r2, [pc, #252]	; (80044cc <vPortDefineHeapRegions+0x17c>)
 80043ce:	6013      	str	r3, [r2, #0]
			xStart.xBlockSize = ( size_t ) 0;
 80043d0:	4b3e      	ldr	r3, [pc, #248]	; (80044cc <vPortDefineHeapRegions+0x17c>)
 80043d2:	2200      	movs	r2, #0
 80043d4:	605a      	str	r2, [r3, #4]
 80043d6:	e01d      	b.n	8004414 <vPortDefineHeapRegions+0xc4>
		}
		else
		{
			/* Should only get here if one region has already been added to the
			heap. */
			configASSERT( pxEnd != NULL );
 80043d8:	4b3b      	ldr	r3, [pc, #236]	; (80044c8 <vPortDefineHeapRegions+0x178>)
 80043da:	681b      	ldr	r3, [r3, #0]
 80043dc:	2b00      	cmp	r3, #0
 80043de:	d109      	bne.n	80043f4 <vPortDefineHeapRegions+0xa4>
 80043e0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80043e4:	f383 8811 	msr	BASEPRI, r3
 80043e8:	f3bf 8f6f 	isb	sy
 80043ec:	f3bf 8f4f 	dsb	sy
 80043f0:	613b      	str	r3, [r7, #16]
 80043f2:	e7fe      	b.n	80043f2 <vPortDefineHeapRegions+0xa2>

			/* Check blocks are passed in with increasing start addresses. */
			configASSERT( xAddress > ( size_t ) pxEnd );
 80043f4:	4b34      	ldr	r3, [pc, #208]	; (80044c8 <vPortDefineHeapRegions+0x178>)
 80043f6:	681b      	ldr	r3, [r3, #0]
 80043f8:	461a      	mov	r2, r3
 80043fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80043fc:	429a      	cmp	r2, r3
 80043fe:	d309      	bcc.n	8004414 <vPortDefineHeapRegions+0xc4>
 8004400:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004404:	f383 8811 	msr	BASEPRI, r3
 8004408:	f3bf 8f6f 	isb	sy
 800440c:	f3bf 8f4f 	dsb	sy
 8004410:	60fb      	str	r3, [r7, #12]
 8004412:	e7fe      	b.n	8004412 <vPortDefineHeapRegions+0xc2>
		}

		/* Remember the location of the end marker in the previous region, if
		any. */
		pxPreviousFreeBlock = pxEnd;
 8004414:	4b2c      	ldr	r3, [pc, #176]	; (80044c8 <vPortDefineHeapRegions+0x178>)
 8004416:	681b      	ldr	r3, [r3, #0]
 8004418:	61bb      	str	r3, [r7, #24]

		/* pxEnd is used to mark the end of the list of free blocks and is
		inserted at the end of the region space. */
		xAddress = xAlignedHeap + xTotalRegionSize;
 800441a:	69fa      	ldr	r2, [r7, #28]
 800441c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800441e:	4413      	add	r3, r2
 8004420:	62bb      	str	r3, [r7, #40]	; 0x28
		xAddress -= xHeapStructSize;
 8004422:	2208      	movs	r2, #8
 8004424:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004426:	1a9b      	subs	r3, r3, r2
 8004428:	62bb      	str	r3, [r7, #40]	; 0x28
		xAddress &= ~portBYTE_ALIGNMENT_MASK;
 800442a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800442c:	f023 0307 	bic.w	r3, r3, #7
 8004430:	62bb      	str	r3, [r7, #40]	; 0x28
		pxEnd = ( BlockLink_t * ) xAddress;
 8004432:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004434:	4a24      	ldr	r2, [pc, #144]	; (80044c8 <vPortDefineHeapRegions+0x178>)
 8004436:	6013      	str	r3, [r2, #0]
		pxEnd->xBlockSize = 0;
 8004438:	4b23      	ldr	r3, [pc, #140]	; (80044c8 <vPortDefineHeapRegions+0x178>)
 800443a:	681b      	ldr	r3, [r3, #0]
 800443c:	2200      	movs	r2, #0
 800443e:	605a      	str	r2, [r3, #4]
		pxEnd->pxNextFreeBlock = NULL;
 8004440:	4b21      	ldr	r3, [pc, #132]	; (80044c8 <vPortDefineHeapRegions+0x178>)
 8004442:	681b      	ldr	r3, [r3, #0]
 8004444:	2200      	movs	r2, #0
 8004446:	601a      	str	r2, [r3, #0]

		/* To start with there is a single free block in this region that is
		sized to take up the entire heap region minus the space taken by the
		free block structure. */
		pxFirstFreeBlockInRegion = ( BlockLink_t * ) xAlignedHeap;
 8004448:	69fb      	ldr	r3, [r7, #28]
 800444a:	623b      	str	r3, [r7, #32]
		pxFirstFreeBlockInRegion->xBlockSize = xAddress - ( size_t ) pxFirstFreeBlockInRegion;
 800444c:	6a3b      	ldr	r3, [r7, #32]
 800444e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004450:	1ad2      	subs	r2, r2, r3
 8004452:	6a3b      	ldr	r3, [r7, #32]
 8004454:	605a      	str	r2, [r3, #4]
		pxFirstFreeBlockInRegion->pxNextFreeBlock = pxEnd;
 8004456:	4b1c      	ldr	r3, [pc, #112]	; (80044c8 <vPortDefineHeapRegions+0x178>)
 8004458:	681a      	ldr	r2, [r3, #0]
 800445a:	6a3b      	ldr	r3, [r7, #32]
 800445c:	601a      	str	r2, [r3, #0]

		/* If this is not the first region that makes up the entire heap space
		then link the previous region to this region. */
		if( pxPreviousFreeBlock != NULL )
 800445e:	69bb      	ldr	r3, [r7, #24]
 8004460:	2b00      	cmp	r3, #0
 8004462:	d002      	beq.n	800446a <vPortDefineHeapRegions+0x11a>
		{
			pxPreviousFreeBlock->pxNextFreeBlock = pxFirstFreeBlockInRegion;
 8004464:	69bb      	ldr	r3, [r7, #24]
 8004466:	6a3a      	ldr	r2, [r7, #32]
 8004468:	601a      	str	r2, [r3, #0]
		}

		xTotalHeapSize += pxFirstFreeBlockInRegion->xBlockSize;
 800446a:	6a3b      	ldr	r3, [r7, #32]
 800446c:	685b      	ldr	r3, [r3, #4]
 800446e:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8004470:	4413      	add	r3, r2
 8004472:	633b      	str	r3, [r7, #48]	; 0x30

		/* Move onto the next HeapRegion_t structure. */
		xDefinedRegions++;
 8004474:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004476:	3301      	adds	r3, #1
 8004478:	62fb      	str	r3, [r7, #44]	; 0x2c
		pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
 800447a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800447c:	00db      	lsls	r3, r3, #3
 800447e:	687a      	ldr	r2, [r7, #4]
 8004480:	4413      	add	r3, r2
 8004482:	627b      	str	r3, [r7, #36]	; 0x24
	/* Can only call once! */
	configASSERT( pxEnd == NULL );

	pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );

	while( pxHeapRegion->xSizeInBytes > 0 )
 8004484:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8004486:	685b      	ldr	r3, [r3, #4]
 8004488:	2b00      	cmp	r3, #0
 800448a:	f47f af7f 	bne.w	800438c <vPortDefineHeapRegions+0x3c>
		/* Move onto the next HeapRegion_t structure. */
		xDefinedRegions++;
		pxHeapRegion = &( pxHeapRegions[ xDefinedRegions ] );
	}

	xMinimumEverFreeBytesRemaining = xTotalHeapSize;
 800448e:	4a10      	ldr	r2, [pc, #64]	; (80044d0 <vPortDefineHeapRegions+0x180>)
 8004490:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004492:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = xTotalHeapSize;
 8004494:	4a0f      	ldr	r2, [pc, #60]	; (80044d4 <vPortDefineHeapRegions+0x184>)
 8004496:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004498:	6013      	str	r3, [r2, #0]

	/* Check something was actually defined before it is accessed. */
	configASSERT( xTotalHeapSize );
 800449a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800449c:	2b00      	cmp	r3, #0
 800449e:	d109      	bne.n	80044b4 <vPortDefineHeapRegions+0x164>
 80044a0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80044a4:	f383 8811 	msr	BASEPRI, r3
 80044a8:	f3bf 8f6f 	isb	sy
 80044ac:	f3bf 8f4f 	dsb	sy
 80044b0:	60bb      	str	r3, [r7, #8]
 80044b2:	e7fe      	b.n	80044b2 <vPortDefineHeapRegions+0x162>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 80044b4:	4b08      	ldr	r3, [pc, #32]	; (80044d8 <vPortDefineHeapRegions+0x188>)
 80044b6:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 80044ba:	601a      	str	r2, [r3, #0]
}
 80044bc:	373c      	adds	r7, #60	; 0x3c
 80044be:	46bd      	mov	sp, r7
 80044c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80044c4:	4770      	bx	lr
 80044c6:	bf00      	nop
 80044c8:	2000bb9c 	.word	0x2000bb9c
 80044cc:	2000bb94 	.word	0x2000bb94
 80044d0:	2000bba4 	.word	0x2000bba4
 80044d4:	2000bba0 	.word	0x2000bba0
 80044d8:	2000bba8 	.word	0x2000bba8

080044dc <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 80044dc:	b580      	push	{r7, lr}
 80044de:	b084      	sub	sp, #16
 80044e0:	af00      	add	r7, sp, #0
 80044e2:	6078      	str	r0, [r7, #4]
 80044e4:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 80044e6:	687b      	ldr	r3, [r7, #4]
 80044e8:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
 80044ea:	68fb      	ldr	r3, [r7, #12]
 80044ec:	2b00      	cmp	r3, #0
 80044ee:	d109      	bne.n	8004504 <xQueueGenericReset+0x28>
 80044f0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80044f4:	f383 8811 	msr	BASEPRI, r3
 80044f8:	f3bf 8f6f 	isb	sy
 80044fc:	f3bf 8f4f 	dsb	sy
 8004500:	60bb      	str	r3, [r7, #8]
 8004502:	e7fe      	b.n	8004502 <xQueueGenericReset+0x26>

	taskENTER_CRITICAL();
 8004504:	f7ff fcc2 	bl	8003e8c <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
 8004508:	68fb      	ldr	r3, [r7, #12]
 800450a:	681a      	ldr	r2, [r3, #0]
 800450c:	68fb      	ldr	r3, [r7, #12]
 800450e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004510:	68f9      	ldr	r1, [r7, #12]
 8004512:	6c09      	ldr	r1, [r1, #64]	; 0x40
 8004514:	fb01 f303 	mul.w	r3, r1, r3
 8004518:	441a      	add	r2, r3
 800451a:	68fb      	ldr	r3, [r7, #12]
 800451c:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 800451e:	68fb      	ldr	r3, [r7, #12]
 8004520:	2200      	movs	r2, #0
 8004522:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 8004524:	68fb      	ldr	r3, [r7, #12]
 8004526:	681a      	ldr	r2, [r3, #0]
 8004528:	68fb      	ldr	r3, [r7, #12]
 800452a:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
 800452c:	68fb      	ldr	r3, [r7, #12]
 800452e:	681a      	ldr	r2, [r3, #0]
 8004530:	68fb      	ldr	r3, [r7, #12]
 8004532:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004534:	3b01      	subs	r3, #1
 8004536:	68f9      	ldr	r1, [r7, #12]
 8004538:	6c09      	ldr	r1, [r1, #64]	; 0x40
 800453a:	fb01 f303 	mul.w	r3, r1, r3
 800453e:	441a      	add	r2, r3
 8004540:	68fb      	ldr	r3, [r7, #12]
 8004542:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 8004544:	68fb      	ldr	r3, [r7, #12]
 8004546:	22ff      	movs	r2, #255	; 0xff
 8004548:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 800454c:	68fb      	ldr	r3, [r7, #12]
 800454e:	22ff      	movs	r2, #255	; 0xff
 8004550:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
 8004554:	683b      	ldr	r3, [r7, #0]
 8004556:	2b00      	cmp	r3, #0
 8004558:	d114      	bne.n	8004584 <xQueueGenericReset+0xa8>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800455a:	68fb      	ldr	r3, [r7, #12]
 800455c:	691b      	ldr	r3, [r3, #16]
 800455e:	2b00      	cmp	r3, #0
 8004560:	d01a      	beq.n	8004598 <xQueueGenericReset+0xbc>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004562:	68fb      	ldr	r3, [r7, #12]
 8004564:	3310      	adds	r3, #16
 8004566:	4618      	mov	r0, r3
 8004568:	f001 fa28 	bl	80059bc <xTaskRemoveFromEventList>
 800456c:	4603      	mov	r3, r0
 800456e:	2b00      	cmp	r3, #0
 8004570:	d012      	beq.n	8004598 <xQueueGenericReset+0xbc>
				{
					queueYIELD_IF_USING_PREEMPTION();
 8004572:	4b0d      	ldr	r3, [pc, #52]	; (80045a8 <xQueueGenericReset+0xcc>)
 8004574:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004578:	601a      	str	r2, [r3, #0]
 800457a:	f3bf 8f4f 	dsb	sy
 800457e:	f3bf 8f6f 	isb	sy
 8004582:	e009      	b.n	8004598 <xQueueGenericReset+0xbc>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 8004584:	68fb      	ldr	r3, [r7, #12]
 8004586:	3310      	adds	r3, #16
 8004588:	4618      	mov	r0, r3
 800458a:	f7ff facf 	bl	8003b2c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 800458e:	68fb      	ldr	r3, [r7, #12]
 8004590:	3324      	adds	r3, #36	; 0x24
 8004592:	4618      	mov	r0, r3
 8004594:	f7ff faca 	bl	8003b2c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 8004598:	f7ff fca6 	bl	8003ee8 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 800459c:	2301      	movs	r3, #1
}
 800459e:	4618      	mov	r0, r3
 80045a0:	3710      	adds	r7, #16
 80045a2:	46bd      	mov	sp, r7
 80045a4:	bd80      	pop	{r7, pc}
 80045a6:	bf00      	nop
 80045a8:	e000ed04 	.word	0xe000ed04

080045ac <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 80045ac:	b590      	push	{r4, r7, lr}
 80045ae:	b08b      	sub	sp, #44	; 0x2c
 80045b0:	af02      	add	r7, sp, #8
 80045b2:	60f8      	str	r0, [r7, #12]
 80045b4:	60b9      	str	r1, [r7, #8]
 80045b6:	4613      	mov	r3, r2
 80045b8:	71fb      	strb	r3, [r7, #7]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 80045ba:	68fb      	ldr	r3, [r7, #12]
 80045bc:	2b00      	cmp	r3, #0
 80045be:	d109      	bne.n	80045d4 <xQueueGenericCreate+0x28>
 80045c0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80045c4:	f383 8811 	msr	BASEPRI, r3
 80045c8:	f3bf 8f6f 	isb	sy
 80045cc:	f3bf 8f4f 	dsb	sy
 80045d0:	613b      	str	r3, [r7, #16]
 80045d2:	e7fe      	b.n	80045d2 <xQueueGenericCreate+0x26>

		if( uxItemSize == ( UBaseType_t ) 0 )
 80045d4:	68bb      	ldr	r3, [r7, #8]
 80045d6:	2b00      	cmp	r3, #0
 80045d8:	d102      	bne.n	80045e0 <xQueueGenericCreate+0x34>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
 80045da:	2300      	movs	r3, #0
 80045dc:	61fb      	str	r3, [r7, #28]
 80045de:	e004      	b.n	80045ea <xQueueGenericCreate+0x3e>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 80045e0:	68fb      	ldr	r3, [r7, #12]
 80045e2:	68ba      	ldr	r2, [r7, #8]
 80045e4:	fb02 f303 	mul.w	r3, r2, r3
 80045e8:	61fb      	str	r3, [r7, #28]
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
 80045ea:	69fb      	ldr	r3, [r7, #28]
 80045ec:	3350      	adds	r3, #80	; 0x50
 80045ee:	4618      	mov	r0, r3
 80045f0:	f7ff fd5e 	bl	80040b0 <pvPortMalloc>
 80045f4:	61b8      	str	r0, [r7, #24]

		if( pxNewQueue != NULL )
 80045f6:	69bb      	ldr	r3, [r7, #24]
 80045f8:	2b00      	cmp	r3, #0
 80045fa:	d00b      	beq.n	8004614 <xQueueGenericCreate+0x68>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
 80045fc:	69bb      	ldr	r3, [r7, #24]
 80045fe:	3350      	adds	r3, #80	; 0x50
 8004600:	617b      	str	r3, [r7, #20]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 8004602:	79fc      	ldrb	r4, [r7, #7]
 8004604:	69bb      	ldr	r3, [r7, #24]
 8004606:	9300      	str	r3, [sp, #0]
 8004608:	68f8      	ldr	r0, [r7, #12]
 800460a:	68b9      	ldr	r1, [r7, #8]
 800460c:	697a      	ldr	r2, [r7, #20]
 800460e:	4623      	mov	r3, r4
 8004610:	f000 f806 	bl	8004620 <prvInitialiseNewQueue>
		}

		return pxNewQueue;
 8004614:	69bb      	ldr	r3, [r7, #24]
	}
 8004616:	4618      	mov	r0, r3
 8004618:	3724      	adds	r7, #36	; 0x24
 800461a:	46bd      	mov	sp, r7
 800461c:	bd90      	pop	{r4, r7, pc}
 800461e:	bf00      	nop

08004620 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 8004620:	b580      	push	{r7, lr}
 8004622:	b084      	sub	sp, #16
 8004624:	af00      	add	r7, sp, #0
 8004626:	60f8      	str	r0, [r7, #12]
 8004628:	60b9      	str	r1, [r7, #8]
 800462a:	607a      	str	r2, [r7, #4]
 800462c:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 800462e:	68bb      	ldr	r3, [r7, #8]
 8004630:	2b00      	cmp	r3, #0
 8004632:	d103      	bne.n	800463c <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 8004634:	69bb      	ldr	r3, [r7, #24]
 8004636:	69ba      	ldr	r2, [r7, #24]
 8004638:	601a      	str	r2, [r3, #0]
 800463a:	e002      	b.n	8004642 <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 800463c:	69bb      	ldr	r3, [r7, #24]
 800463e:	687a      	ldr	r2, [r7, #4]
 8004640:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 8004642:	69bb      	ldr	r3, [r7, #24]
 8004644:	68fa      	ldr	r2, [r7, #12]
 8004646:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 8004648:	69bb      	ldr	r3, [r7, #24]
 800464a:	68ba      	ldr	r2, [r7, #8]
 800464c:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 800464e:	69b8      	ldr	r0, [r7, #24]
 8004650:	2101      	movs	r1, #1
 8004652:	f7ff ff43 	bl	80044dc <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
 8004656:	69bb      	ldr	r3, [r7, #24]
 8004658:	78fa      	ldrb	r2, [r7, #3]
 800465a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
	{
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
 800465e:	78fb      	ldrb	r3, [r7, #3]
 8004660:	2073      	movs	r0, #115	; 0x73
 8004662:	68f9      	ldr	r1, [r7, #12]
 8004664:	68ba      	ldr	r2, [r7, #8]
 8004666:	f00c fe71 	bl	801134c <SEGGER_SYSVIEW_RecordU32x3>
}
 800466a:	3710      	adds	r7, #16
 800466c:	46bd      	mov	sp, r7
 800466e:	bd80      	pop	{r7, pc}

08004670 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 8004670:	b580      	push	{r7, lr}
 8004672:	b086      	sub	sp, #24
 8004674:	af00      	add	r7, sp, #0
 8004676:	6078      	str	r0, [r7, #4]
 8004678:	6039      	str	r1, [r7, #0]
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
 800467a:	687b      	ldr	r3, [r7, #4]
 800467c:	2b00      	cmp	r3, #0
 800467e:	d109      	bne.n	8004694 <xQueueCreateCountingSemaphore+0x24>
 8004680:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004684:	f383 8811 	msr	BASEPRI, r3
 8004688:	f3bf 8f6f 	isb	sy
 800468c:	f3bf 8f4f 	dsb	sy
 8004690:	613b      	str	r3, [r7, #16]
 8004692:	e7fe      	b.n	8004692 <xQueueCreateCountingSemaphore+0x22>
		configASSERT( uxInitialCount <= uxMaxCount );
 8004694:	683a      	ldr	r2, [r7, #0]
 8004696:	687b      	ldr	r3, [r7, #4]
 8004698:	429a      	cmp	r2, r3
 800469a:	d909      	bls.n	80046b0 <xQueueCreateCountingSemaphore+0x40>
 800469c:	f04f 0350 	mov.w	r3, #80	; 0x50
 80046a0:	f383 8811 	msr	BASEPRI, r3
 80046a4:	f3bf 8f6f 	isb	sy
 80046a8:	f3bf 8f4f 	dsb	sy
 80046ac:	60fb      	str	r3, [r7, #12]
 80046ae:	e7fe      	b.n	80046ae <xQueueCreateCountingSemaphore+0x3e>

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 80046b0:	6878      	ldr	r0, [r7, #4]
 80046b2:	2100      	movs	r1, #0
 80046b4:	2202      	movs	r2, #2
 80046b6:	f7ff ff79 	bl	80045ac <xQueueGenericCreate>
 80046ba:	6178      	str	r0, [r7, #20]

		if( xHandle != NULL )
 80046bc:	697b      	ldr	r3, [r7, #20]
 80046be:	2b00      	cmp	r3, #0
 80046c0:	d002      	beq.n	80046c8 <xQueueCreateCountingSemaphore+0x58>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 80046c2:	697b      	ldr	r3, [r7, #20]
 80046c4:	683a      	ldr	r2, [r7, #0]
 80046c6:	639a      	str	r2, [r3, #56]	; 0x38
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
 80046c8:	697b      	ldr	r3, [r7, #20]
	}
 80046ca:	4618      	mov	r0, r3
 80046cc:	3718      	adds	r7, #24
 80046ce:	46bd      	mov	sp, r7
 80046d0:	bd80      	pop	{r7, pc}
 80046d2:	bf00      	nop

080046d4 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 80046d4:	b590      	push	{r4, r7, lr}
 80046d6:	b091      	sub	sp, #68	; 0x44
 80046d8:	af02      	add	r7, sp, #8
 80046da:	60f8      	str	r0, [r7, #12]
 80046dc:	60b9      	str	r1, [r7, #8]
 80046de:	607a      	str	r2, [r7, #4]
 80046e0:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 80046e2:	2300      	movs	r3, #0
 80046e4:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 80046e6:	68fb      	ldr	r3, [r7, #12]
 80046e8:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
 80046ea:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80046ec:	2b00      	cmp	r3, #0
 80046ee:	d109      	bne.n	8004704 <xQueueGenericSend+0x30>
 80046f0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80046f4:	f383 8811 	msr	BASEPRI, r3
 80046f8:	f3bf 8f6f 	isb	sy
 80046fc:	f3bf 8f4f 	dsb	sy
 8004700:	62bb      	str	r3, [r7, #40]	; 0x28
 8004702:	e7fe      	b.n	8004702 <xQueueGenericSend+0x2e>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004704:	68bb      	ldr	r3, [r7, #8]
 8004706:	2b00      	cmp	r3, #0
 8004708:	d103      	bne.n	8004712 <xQueueGenericSend+0x3e>
 800470a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800470c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800470e:	2b00      	cmp	r3, #0
 8004710:	d101      	bne.n	8004716 <xQueueGenericSend+0x42>
 8004712:	2301      	movs	r3, #1
 8004714:	e000      	b.n	8004718 <xQueueGenericSend+0x44>
 8004716:	2300      	movs	r3, #0
 8004718:	2b00      	cmp	r3, #0
 800471a:	d109      	bne.n	8004730 <xQueueGenericSend+0x5c>
 800471c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004720:	f383 8811 	msr	BASEPRI, r3
 8004724:	f3bf 8f6f 	isb	sy
 8004728:	f3bf 8f4f 	dsb	sy
 800472c:	627b      	str	r3, [r7, #36]	; 0x24
 800472e:	e7fe      	b.n	800472e <xQueueGenericSend+0x5a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 8004730:	683b      	ldr	r3, [r7, #0]
 8004732:	2b02      	cmp	r3, #2
 8004734:	d103      	bne.n	800473e <xQueueGenericSend+0x6a>
 8004736:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004738:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800473a:	2b01      	cmp	r3, #1
 800473c:	d101      	bne.n	8004742 <xQueueGenericSend+0x6e>
 800473e:	2301      	movs	r3, #1
 8004740:	e000      	b.n	8004744 <xQueueGenericSend+0x70>
 8004742:	2300      	movs	r3, #0
 8004744:	2b00      	cmp	r3, #0
 8004746:	d109      	bne.n	800475c <xQueueGenericSend+0x88>
 8004748:	f04f 0350 	mov.w	r3, #80	; 0x50
 800474c:	f383 8811 	msr	BASEPRI, r3
 8004750:	f3bf 8f6f 	isb	sy
 8004754:	f3bf 8f4f 	dsb	sy
 8004758:	623b      	str	r3, [r7, #32]
 800475a:	e7fe      	b.n	800475a <xQueueGenericSend+0x86>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800475c:	f001 fb64 	bl	8005e28 <xTaskGetSchedulerState>
 8004760:	4603      	mov	r3, r0
 8004762:	2b00      	cmp	r3, #0
 8004764:	d102      	bne.n	800476c <xQueueGenericSend+0x98>
 8004766:	687b      	ldr	r3, [r7, #4]
 8004768:	2b00      	cmp	r3, #0
 800476a:	d101      	bne.n	8004770 <xQueueGenericSend+0x9c>
 800476c:	2301      	movs	r3, #1
 800476e:	e000      	b.n	8004772 <xQueueGenericSend+0x9e>
 8004770:	2300      	movs	r3, #0
 8004772:	2b00      	cmp	r3, #0
 8004774:	d109      	bne.n	800478a <xQueueGenericSend+0xb6>
 8004776:	f04f 0350 	mov.w	r3, #80	; 0x50
 800477a:	f383 8811 	msr	BASEPRI, r3
 800477e:	f3bf 8f6f 	isb	sy
 8004782:	f3bf 8f4f 	dsb	sy
 8004786:	61fb      	str	r3, [r7, #28]
 8004788:	e7fe      	b.n	8004788 <xQueueGenericSend+0xb4>
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 800478a:	f7ff fb7f 	bl	8003e8c <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 800478e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004790:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004792:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004794:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004796:	429a      	cmp	r2, r3
 8004798:	d302      	bcc.n	80047a0 <xQueueGenericSend+0xcc>
 800479a:	683b      	ldr	r3, [r7, #0]
 800479c:	2b02      	cmp	r3, #2
 800479e:	d136      	bne.n	800480e <xQueueGenericSend+0x13a>
			{
				traceQUEUE_SEND( pxQueue );
 80047a0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80047a2:	4618      	mov	r0, r3
 80047a4:	f00d fb02 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 80047a8:	4601      	mov	r1, r0
 80047aa:	68ba      	ldr	r2, [r7, #8]
 80047ac:	687c      	ldr	r4, [r7, #4]
 80047ae:	683b      	ldr	r3, [r7, #0]
 80047b0:	9300      	str	r3, [sp, #0]
 80047b2:	205a      	movs	r0, #90	; 0x5a
 80047b4:	4623      	mov	r3, r4
 80047b6:	f00d fd3b 	bl	8012230 <SYSVIEW_RecordU32x4>
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 80047ba:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80047bc:	68b9      	ldr	r1, [r7, #8]
 80047be:	683a      	ldr	r2, [r7, #0]
 80047c0:	f000 fa50 	bl	8004c64 <prvCopyDataToQueue>
 80047c4:	62f8      	str	r0, [r7, #44]	; 0x2c
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 80047c6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80047c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80047ca:	2b00      	cmp	r3, #0
 80047cc:	d010      	beq.n	80047f0 <xQueueGenericSend+0x11c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80047ce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80047d0:	3324      	adds	r3, #36	; 0x24
 80047d2:	4618      	mov	r0, r3
 80047d4:	f001 f8f2 	bl	80059bc <xTaskRemoveFromEventList>
 80047d8:	4603      	mov	r3, r0
 80047da:	2b00      	cmp	r3, #0
 80047dc:	d013      	beq.n	8004806 <xQueueGenericSend+0x132>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 80047de:	4b4f      	ldr	r3, [pc, #316]	; (800491c <xQueueGenericSend+0x248>)
 80047e0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80047e4:	601a      	str	r2, [r3, #0]
 80047e6:	f3bf 8f4f 	dsb	sy
 80047ea:	f3bf 8f6f 	isb	sy
 80047ee:	e00a      	b.n	8004806 <xQueueGenericSend+0x132>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 80047f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80047f2:	2b00      	cmp	r3, #0
 80047f4:	d007      	beq.n	8004806 <xQueueGenericSend+0x132>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 80047f6:	4b49      	ldr	r3, [pc, #292]	; (800491c <xQueueGenericSend+0x248>)
 80047f8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80047fc:	601a      	str	r2, [r3, #0]
 80047fe:	f3bf 8f4f 	dsb	sy
 8004802:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 8004806:	f7ff fb6f 	bl	8003ee8 <vPortExitCritical>
				return pdPASS;
 800480a:	2301      	movs	r3, #1
 800480c:	e081      	b.n	8004912 <xQueueGenericSend+0x23e>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 800480e:	687b      	ldr	r3, [r7, #4]
 8004810:	2b00      	cmp	r3, #0
 8004812:	d110      	bne.n	8004836 <xQueueGenericSend+0x162>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8004814:	f7ff fb68 	bl	8003ee8 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
 8004818:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800481a:	4618      	mov	r0, r3
 800481c:	f00d fac6 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 8004820:	4601      	mov	r1, r0
 8004822:	68ba      	ldr	r2, [r7, #8]
 8004824:	687c      	ldr	r4, [r7, #4]
 8004826:	683b      	ldr	r3, [r7, #0]
 8004828:	9300      	str	r3, [sp, #0]
 800482a:	205a      	movs	r0, #90	; 0x5a
 800482c:	4623      	mov	r3, r4
 800482e:	f00d fcff 	bl	8012230 <SYSVIEW_RecordU32x4>
					return errQUEUE_FULL;
 8004832:	2300      	movs	r3, #0
 8004834:	e06d      	b.n	8004912 <xQueueGenericSend+0x23e>
				}
				else if( xEntryTimeSet == pdFALSE )
 8004836:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004838:	2b00      	cmp	r3, #0
 800483a:	d106      	bne.n	800484a <xQueueGenericSend+0x176>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 800483c:	f107 0314 	add.w	r3, r7, #20
 8004840:	4618      	mov	r0, r3
 8004842:	f001 f98f 	bl	8005b64 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8004846:	2301      	movs	r3, #1
 8004848:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 800484a:	f7ff fb4d 	bl	8003ee8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 800484e:	f000 fde9 	bl	8005424 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8004852:	f7ff fb1b 	bl	8003e8c <vPortEnterCritical>
 8004856:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004858:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 800485c:	b2db      	uxtb	r3, r3
 800485e:	b25b      	sxtb	r3, r3
 8004860:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8004864:	d103      	bne.n	800486e <xQueueGenericSend+0x19a>
 8004866:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004868:	2200      	movs	r2, #0
 800486a:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 800486e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004870:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8004874:	b2db      	uxtb	r3, r3
 8004876:	b25b      	sxtb	r3, r3
 8004878:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800487c:	d103      	bne.n	8004886 <xQueueGenericSend+0x1b2>
 800487e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004880:	2200      	movs	r2, #0
 8004882:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 8004886:	f7ff fb2f 	bl	8003ee8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 800488a:	f107 0214 	add.w	r2, r7, #20
 800488e:	1d3b      	adds	r3, r7, #4
 8004890:	4610      	mov	r0, r2
 8004892:	4619      	mov	r1, r3
 8004894:	f001 f988 	bl	8005ba8 <xTaskCheckForTimeOut>
 8004898:	4603      	mov	r3, r0
 800489a:	2b00      	cmp	r3, #0
 800489c:	d124      	bne.n	80048e8 <xQueueGenericSend+0x214>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 800489e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80048a0:	f000 fada 	bl	8004e58 <prvIsQueueFull>
 80048a4:	4603      	mov	r3, r0
 80048a6:	2b00      	cmp	r3, #0
 80048a8:	d018      	beq.n	80048dc <xQueueGenericSend+0x208>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 80048aa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80048ac:	f103 0210 	add.w	r2, r3, #16
 80048b0:	687b      	ldr	r3, [r7, #4]
 80048b2:	4610      	mov	r0, r2
 80048b4:	4619      	mov	r1, r3
 80048b6:	f001 f825 	bl	8005904 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 80048ba:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80048bc:	f000 fa64 	bl	8004d88 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 80048c0:	f000 fdbe 	bl	8005440 <xTaskResumeAll>
 80048c4:	4603      	mov	r3, r0
 80048c6:	2b00      	cmp	r3, #0
 80048c8:	d122      	bne.n	8004910 <xQueueGenericSend+0x23c>
				{
					portYIELD_WITHIN_API();
 80048ca:	4b14      	ldr	r3, [pc, #80]	; (800491c <xQueueGenericSend+0x248>)
 80048cc:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80048d0:	601a      	str	r2, [r3, #0]
 80048d2:	f3bf 8f4f 	dsb	sy
 80048d6:	f3bf 8f6f 	isb	sy
 80048da:	e019      	b.n	8004910 <xQueueGenericSend+0x23c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 80048dc:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80048de:	f000 fa53 	bl	8004d88 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 80048e2:	f000 fdad 	bl	8005440 <xTaskResumeAll>
 80048e6:	e750      	b.n	800478a <xQueueGenericSend+0xb6>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 80048e8:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80048ea:	f000 fa4d 	bl	8004d88 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 80048ee:	f000 fda7 	bl	8005440 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
 80048f2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80048f4:	4618      	mov	r0, r3
 80048f6:	f00d fa59 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 80048fa:	4601      	mov	r1, r0
 80048fc:	68ba      	ldr	r2, [r7, #8]
 80048fe:	687c      	ldr	r4, [r7, #4]
 8004900:	683b      	ldr	r3, [r7, #0]
 8004902:	9300      	str	r3, [sp, #0]
 8004904:	205a      	movs	r0, #90	; 0x5a
 8004906:	4623      	mov	r3, r4
 8004908:	f00d fc92 	bl	8012230 <SYSVIEW_RecordU32x4>
			return errQUEUE_FULL;
 800490c:	2300      	movs	r3, #0
 800490e:	e000      	b.n	8004912 <xQueueGenericSend+0x23e>
		}
	}
 8004910:	e73b      	b.n	800478a <xQueueGenericSend+0xb6>
}
 8004912:	4618      	mov	r0, r3
 8004914:	373c      	adds	r7, #60	; 0x3c
 8004916:	46bd      	mov	sp, r7
 8004918:	bd90      	pop	{r4, r7, pc}
 800491a:	bf00      	nop
 800491c:	e000ed04 	.word	0xe000ed04

08004920 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
 8004920:	b5b0      	push	{r4, r5, r7, lr}
 8004922:	b090      	sub	sp, #64	; 0x40
 8004924:	af02      	add	r7, sp, #8
 8004926:	60f8      	str	r0, [r7, #12]
 8004928:	60b9      	str	r1, [r7, #8]
 800492a:	607a      	str	r2, [r7, #4]
 800492c:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
 800492e:	2300      	movs	r3, #0
 8004930:	637b      	str	r3, [r7, #52]	; 0x34
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 8004932:	68fb      	ldr	r3, [r7, #12]
 8004934:	633b      	str	r3, [r7, #48]	; 0x30

	configASSERT( pxQueue );
 8004936:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004938:	2b00      	cmp	r3, #0
 800493a:	d109      	bne.n	8004950 <xQueueGenericReceive+0x30>
 800493c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004940:	f383 8811 	msr	BASEPRI, r3
 8004944:	f3bf 8f6f 	isb	sy
 8004948:	f3bf 8f4f 	dsb	sy
 800494c:	627b      	str	r3, [r7, #36]	; 0x24
 800494e:	e7fe      	b.n	800494e <xQueueGenericReceive+0x2e>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 8004950:	68bb      	ldr	r3, [r7, #8]
 8004952:	2b00      	cmp	r3, #0
 8004954:	d103      	bne.n	800495e <xQueueGenericReceive+0x3e>
 8004956:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004958:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800495a:	2b00      	cmp	r3, #0
 800495c:	d101      	bne.n	8004962 <xQueueGenericReceive+0x42>
 800495e:	2301      	movs	r3, #1
 8004960:	e000      	b.n	8004964 <xQueueGenericReceive+0x44>
 8004962:	2300      	movs	r3, #0
 8004964:	2b00      	cmp	r3, #0
 8004966:	d109      	bne.n	800497c <xQueueGenericReceive+0x5c>
 8004968:	f04f 0350 	mov.w	r3, #80	; 0x50
 800496c:	f383 8811 	msr	BASEPRI, r3
 8004970:	f3bf 8f6f 	isb	sy
 8004974:	f3bf 8f4f 	dsb	sy
 8004978:	623b      	str	r3, [r7, #32]
 800497a:	e7fe      	b.n	800497a <xQueueGenericReceive+0x5a>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 800497c:	f001 fa54 	bl	8005e28 <xTaskGetSchedulerState>
 8004980:	4603      	mov	r3, r0
 8004982:	2b00      	cmp	r3, #0
 8004984:	d102      	bne.n	800498c <xQueueGenericReceive+0x6c>
 8004986:	687b      	ldr	r3, [r7, #4]
 8004988:	2b00      	cmp	r3, #0
 800498a:	d101      	bne.n	8004990 <xQueueGenericReceive+0x70>
 800498c:	2301      	movs	r3, #1
 800498e:	e000      	b.n	8004992 <xQueueGenericReceive+0x72>
 8004990:	2300      	movs	r3, #0
 8004992:	2b00      	cmp	r3, #0
 8004994:	d109      	bne.n	80049aa <xQueueGenericReceive+0x8a>
 8004996:	f04f 0350 	mov.w	r3, #80	; 0x50
 800499a:	f383 8811 	msr	BASEPRI, r3
 800499e:	f3bf 8f6f 	isb	sy
 80049a2:	f3bf 8f4f 	dsb	sy
 80049a6:	61fb      	str	r3, [r7, #28]
 80049a8:	e7fe      	b.n	80049a8 <xQueueGenericReceive+0x88>
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 80049aa:	f7ff fa6f 	bl	8003e8c <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 80049ae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049b0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80049b2:	62fb      	str	r3, [r7, #44]	; 0x2c

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 80049b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80049b6:	2b00      	cmp	r3, #0
 80049b8:	d06a      	beq.n	8004a90 <xQueueGenericReceive+0x170>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
 80049ba:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049bc:	68db      	ldr	r3, [r3, #12]
 80049be:	62bb      	str	r3, [r7, #40]	; 0x28

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 80049c0:	6b38      	ldr	r0, [r7, #48]	; 0x30
 80049c2:	68b9      	ldr	r1, [r7, #8]
 80049c4:	f000 f9ba 	bl	8004d3c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
 80049c8:	683b      	ldr	r3, [r7, #0]
 80049ca:	2b00      	cmp	r3, #0
 80049cc:	d133      	bne.n	8004a36 <xQueueGenericReceive+0x116>
				{
					traceQUEUE_RECEIVE( pxQueue );
 80049ce:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049d0:	4618      	mov	r0, r3
 80049d2:	f00d f9eb 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 80049d6:	4605      	mov	r5, r0
 80049d8:	68bb      	ldr	r3, [r7, #8]
 80049da:	4618      	mov	r0, r3
 80049dc:	f00d f9e6 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 80049e0:	4602      	mov	r2, r0
 80049e2:	687c      	ldr	r4, [r7, #4]
 80049e4:	683b      	ldr	r3, [r7, #0]
 80049e6:	9300      	str	r3, [sp, #0]
 80049e8:	205c      	movs	r0, #92	; 0x5c
 80049ea:	4629      	mov	r1, r5
 80049ec:	4623      	mov	r3, r4
 80049ee:	f00d fc1f 	bl	8012230 <SYSVIEW_RecordU32x4>

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
 80049f2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80049f4:	1e5a      	subs	r2, r3, #1
 80049f6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049f8:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80049fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80049fc:	681b      	ldr	r3, [r3, #0]
 80049fe:	2b00      	cmp	r3, #0
 8004a00:	d104      	bne.n	8004a0c <xQueueGenericReceive+0xec>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
 8004a02:	f001 fb4d 	bl	80060a0 <pvTaskIncrementMutexHeldCount>
 8004a06:	4602      	mov	r2, r0
 8004a08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a0a:	605a      	str	r2, [r3, #4]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8004a0c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a0e:	691b      	ldr	r3, [r3, #16]
 8004a10:	2b00      	cmp	r3, #0
 8004a12:	d039      	beq.n	8004a88 <xQueueGenericReceive+0x168>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004a14:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a16:	3310      	adds	r3, #16
 8004a18:	4618      	mov	r0, r3
 8004a1a:	f000 ffcf 	bl	80059bc <xTaskRemoveFromEventList>
 8004a1e:	4603      	mov	r3, r0
 8004a20:	2b00      	cmp	r3, #0
 8004a22:	d031      	beq.n	8004a88 <xQueueGenericReceive+0x168>
						{
							queueYIELD_IF_USING_PREEMPTION();
 8004a24:	4b6c      	ldr	r3, [pc, #432]	; (8004bd8 <xQueueGenericReceive+0x2b8>)
 8004a26:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004a2a:	601a      	str	r2, [r3, #0]
 8004a2c:	f3bf 8f4f 	dsb	sy
 8004a30:	f3bf 8f6f 	isb	sy
 8004a34:	e028      	b.n	8004a88 <xQueueGenericReceive+0x168>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					traceQUEUE_PEEK( pxQueue );
 8004a36:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a38:	4618      	mov	r0, r3
 8004a3a:	f00d f9b7 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 8004a3e:	4605      	mov	r5, r0
 8004a40:	68bb      	ldr	r3, [r7, #8]
 8004a42:	4618      	mov	r0, r3
 8004a44:	f00d f9b2 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 8004a48:	4602      	mov	r2, r0
 8004a4a:	687c      	ldr	r4, [r7, #4]
 8004a4c:	683b      	ldr	r3, [r7, #0]
 8004a4e:	9300      	str	r3, [sp, #0]
 8004a50:	205c      	movs	r0, #92	; 0x5c
 8004a52:	4629      	mov	r1, r5
 8004a54:	4623      	mov	r3, r4
 8004a56:	f00d fbeb 	bl	8012230 <SYSVIEW_RecordU32x4>

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
 8004a5a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a5c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8004a5e:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004a60:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004a64:	2b00      	cmp	r3, #0
 8004a66:	d00f      	beq.n	8004a88 <xQueueGenericReceive+0x168>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004a68:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a6a:	3324      	adds	r3, #36	; 0x24
 8004a6c:	4618      	mov	r0, r3
 8004a6e:	f000 ffa5 	bl	80059bc <xTaskRemoveFromEventList>
 8004a72:	4603      	mov	r3, r0
 8004a74:	2b00      	cmp	r3, #0
 8004a76:	d007      	beq.n	8004a88 <xQueueGenericReceive+0x168>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
 8004a78:	4b57      	ldr	r3, [pc, #348]	; (8004bd8 <xQueueGenericReceive+0x2b8>)
 8004a7a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004a7e:	601a      	str	r2, [r3, #0]
 8004a80:	f3bf 8f4f 	dsb	sy
 8004a84:	f3bf 8f6f 	isb	sy
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
 8004a88:	f7ff fa2e 	bl	8003ee8 <vPortExitCritical>
				return pdPASS;
 8004a8c:	2301      	movs	r3, #1
 8004a8e:	e09e      	b.n	8004bce <xQueueGenericReceive+0x2ae>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 8004a90:	687b      	ldr	r3, [r7, #4]
 8004a92:	2b00      	cmp	r3, #0
 8004a94:	d115      	bne.n	8004ac2 <xQueueGenericReceive+0x1a2>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8004a96:	f7ff fa27 	bl	8003ee8 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
 8004a9a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004a9c:	4618      	mov	r0, r3
 8004a9e:	f00d f985 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 8004aa2:	4605      	mov	r5, r0
 8004aa4:	68bb      	ldr	r3, [r7, #8]
 8004aa6:	4618      	mov	r0, r3
 8004aa8:	f00d f980 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 8004aac:	4602      	mov	r2, r0
 8004aae:	687c      	ldr	r4, [r7, #4]
 8004ab0:	683b      	ldr	r3, [r7, #0]
 8004ab2:	9300      	str	r3, [sp, #0]
 8004ab4:	205c      	movs	r0, #92	; 0x5c
 8004ab6:	4629      	mov	r1, r5
 8004ab8:	4623      	mov	r3, r4
 8004aba:	f00d fbb9 	bl	8012230 <SYSVIEW_RecordU32x4>
					return errQUEUE_EMPTY;
 8004abe:	2300      	movs	r3, #0
 8004ac0:	e085      	b.n	8004bce <xQueueGenericReceive+0x2ae>
				}
				else if( xEntryTimeSet == pdFALSE )
 8004ac2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8004ac4:	2b00      	cmp	r3, #0
 8004ac6:	d106      	bne.n	8004ad6 <xQueueGenericReceive+0x1b6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8004ac8:	f107 0314 	add.w	r3, r7, #20
 8004acc:	4618      	mov	r0, r3
 8004ace:	f001 f849 	bl	8005b64 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 8004ad2:	2301      	movs	r3, #1
 8004ad4:	637b      	str	r3, [r7, #52]	; 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 8004ad6:	f7ff fa07 	bl	8003ee8 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8004ada:	f000 fca3 	bl	8005424 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 8004ade:	f7ff f9d5 	bl	8003e8c <vPortEnterCritical>
 8004ae2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004ae4:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8004ae8:	b2db      	uxtb	r3, r3
 8004aea:	b25b      	sxtb	r3, r3
 8004aec:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8004af0:	d103      	bne.n	8004afa <xQueueGenericReceive+0x1da>
 8004af2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004af4:	2200      	movs	r2, #0
 8004af6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
 8004afa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004afc:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8004b00:	b2db      	uxtb	r3, r3
 8004b02:	b25b      	sxtb	r3, r3
 8004b04:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8004b08:	d103      	bne.n	8004b12 <xQueueGenericReceive+0x1f2>
 8004b0a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004b0c:	2200      	movs	r2, #0
 8004b0e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
 8004b12:	f7ff f9e9 	bl	8003ee8 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8004b16:	f107 0214 	add.w	r2, r7, #20
 8004b1a:	1d3b      	adds	r3, r7, #4
 8004b1c:	4610      	mov	r0, r2
 8004b1e:	4619      	mov	r1, r3
 8004b20:	f001 f842 	bl	8005ba8 <xTaskCheckForTimeOut>
 8004b24:	4603      	mov	r3, r0
 8004b26:	2b00      	cmp	r3, #0
 8004b28:	d131      	bne.n	8004b8e <xQueueGenericReceive+0x26e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8004b2a:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8004b2c:	f000 f97e 	bl	8004e2c <prvIsQueueEmpty>
 8004b30:	4603      	mov	r3, r0
 8004b32:	2b00      	cmp	r3, #0
 8004b34:	d025      	beq.n	8004b82 <xQueueGenericReceive+0x262>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8004b36:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004b38:	681b      	ldr	r3, [r3, #0]
 8004b3a:	2b00      	cmp	r3, #0
 8004b3c:	d108      	bne.n	8004b50 <xQueueGenericReceive+0x230>
					{
						taskENTER_CRITICAL();
 8004b3e:	f7ff f9a5 	bl	8003e8c <vPortEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8004b42:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004b44:	685b      	ldr	r3, [r3, #4]
 8004b46:	4618      	mov	r0, r3
 8004b48:	f001 f98c 	bl	8005e64 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
 8004b4c:	f7ff f9cc 	bl	8003ee8 <vPortExitCritical>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8004b50:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004b52:	f103 0224 	add.w	r2, r3, #36	; 0x24
 8004b56:	687b      	ldr	r3, [r7, #4]
 8004b58:	4610      	mov	r0, r2
 8004b5a:	4619      	mov	r1, r3
 8004b5c:	f000 fed2 	bl	8005904 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 8004b60:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8004b62:	f000 f911 	bl	8004d88 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 8004b66:	f000 fc6b 	bl	8005440 <xTaskResumeAll>
 8004b6a:	4603      	mov	r3, r0
 8004b6c:	2b00      	cmp	r3, #0
 8004b6e:	d12d      	bne.n	8004bcc <xQueueGenericReceive+0x2ac>
				{
					portYIELD_WITHIN_API();
 8004b70:	4b19      	ldr	r3, [pc, #100]	; (8004bd8 <xQueueGenericReceive+0x2b8>)
 8004b72:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8004b76:	601a      	str	r2, [r3, #0]
 8004b78:	f3bf 8f4f 	dsb	sy
 8004b7c:	f3bf 8f6f 	isb	sy
 8004b80:	e024      	b.n	8004bcc <xQueueGenericReceive+0x2ac>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8004b82:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8004b84:	f000 f900 	bl	8004d88 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 8004b88:	f000 fc5a 	bl	8005440 <xTaskResumeAll>
 8004b8c:	e70d      	b.n	80049aa <xQueueGenericReceive+0x8a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 8004b8e:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8004b90:	f000 f8fa 	bl	8004d88 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 8004b94:	f000 fc54 	bl	8005440 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 8004b98:	6b38      	ldr	r0, [r7, #48]	; 0x30
 8004b9a:	f000 f947 	bl	8004e2c <prvIsQueueEmpty>
 8004b9e:	4603      	mov	r3, r0
 8004ba0:	2b00      	cmp	r3, #0
 8004ba2:	d013      	beq.n	8004bcc <xQueueGenericReceive+0x2ac>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
 8004ba4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004ba6:	4618      	mov	r0, r3
 8004ba8:	f00d f900 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 8004bac:	4605      	mov	r5, r0
 8004bae:	68bb      	ldr	r3, [r7, #8]
 8004bb0:	4618      	mov	r0, r3
 8004bb2:	f00d f8fb 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 8004bb6:	4602      	mov	r2, r0
 8004bb8:	687c      	ldr	r4, [r7, #4]
 8004bba:	683b      	ldr	r3, [r7, #0]
 8004bbc:	9300      	str	r3, [sp, #0]
 8004bbe:	205c      	movs	r0, #92	; 0x5c
 8004bc0:	4629      	mov	r1, r5
 8004bc2:	4623      	mov	r3, r4
 8004bc4:	f00d fb34 	bl	8012230 <SYSVIEW_RecordU32x4>
				return errQUEUE_EMPTY;
 8004bc8:	2300      	movs	r3, #0
 8004bca:	e000      	b.n	8004bce <xQueueGenericReceive+0x2ae>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 8004bcc:	e6ed      	b.n	80049aa <xQueueGenericReceive+0x8a>
}
 8004bce:	4618      	mov	r0, r3
 8004bd0:	3738      	adds	r7, #56	; 0x38
 8004bd2:	46bd      	mov	sp, r7
 8004bd4:	bdb0      	pop	{r4, r5, r7, pc}
 8004bd6:	bf00      	nop
 8004bd8:	e000ed04 	.word	0xe000ed04

08004bdc <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
 8004bdc:	b580      	push	{r7, lr}
 8004bde:	b084      	sub	sp, #16
 8004be0:	af00      	add	r7, sp, #0
 8004be2:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;

	configASSERT( xQueue );
 8004be4:	687b      	ldr	r3, [r7, #4]
 8004be6:	2b00      	cmp	r3, #0
 8004be8:	d109      	bne.n	8004bfe <uxQueueMessagesWaiting+0x22>
 8004bea:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004bee:	f383 8811 	msr	BASEPRI, r3
 8004bf2:	f3bf 8f6f 	isb	sy
 8004bf6:	f3bf 8f4f 	dsb	sy
 8004bfa:	60bb      	str	r3, [r7, #8]
 8004bfc:	e7fe      	b.n	8004bfc <uxQueueMessagesWaiting+0x20>

	taskENTER_CRITICAL();
 8004bfe:	f7ff f945 	bl	8003e8c <vPortEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
 8004c02:	687b      	ldr	r3, [r7, #4]
 8004c04:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004c06:	60fb      	str	r3, [r7, #12]
	}
	taskEXIT_CRITICAL();
 8004c08:	f7ff f96e 	bl	8003ee8 <vPortExitCritical>

	return uxReturn;
 8004c0c:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
 8004c0e:	4618      	mov	r0, r3
 8004c10:	3710      	adds	r7, #16
 8004c12:	46bd      	mov	sp, r7
 8004c14:	bd80      	pop	{r7, pc}
 8004c16:	bf00      	nop

08004c18 <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 8004c18:	b580      	push	{r7, lr}
 8004c1a:	b084      	sub	sp, #16
 8004c1c:	af00      	add	r7, sp, #0
 8004c1e:	6078      	str	r0, [r7, #4]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
 8004c20:	687b      	ldr	r3, [r7, #4]
 8004c22:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
 8004c24:	68fb      	ldr	r3, [r7, #12]
 8004c26:	2b00      	cmp	r3, #0
 8004c28:	d109      	bne.n	8004c3e <vQueueDelete+0x26>
 8004c2a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8004c2e:	f383 8811 	msr	BASEPRI, r3
 8004c32:	f3bf 8f6f 	isb	sy
 8004c36:	f3bf 8f4f 	dsb	sy
 8004c3a:	60bb      	str	r3, [r7, #8]
 8004c3c:	e7fe      	b.n	8004c3c <vQueueDelete+0x24>
	traceQUEUE_DELETE( pxQueue );
 8004c3e:	68fb      	ldr	r3, [r7, #12]
 8004c40:	4618      	mov	r0, r3
 8004c42:	f00d f8b3 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 8004c46:	4603      	mov	r3, r0
 8004c48:	205f      	movs	r0, #95	; 0x5f
 8004c4a:	4619      	mov	r1, r3
 8004c4c:	f00c faea 	bl	8011224 <SEGGER_SYSVIEW_RecordU32>

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
 8004c50:	68f8      	ldr	r0, [r7, #12]
 8004c52:	f000 f949 	bl	8004ee8 <vQueueUnregisterQueue>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
 8004c56:	68f8      	ldr	r0, [r7, #12]
 8004c58:	f7ff faca 	bl	80041f0 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 8004c5c:	3710      	adds	r7, #16
 8004c5e:	46bd      	mov	sp, r7
 8004c60:	bd80      	pop	{r7, pc}
 8004c62:	bf00      	nop

08004c64 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 8004c64:	b580      	push	{r7, lr}
 8004c66:	b086      	sub	sp, #24
 8004c68:	af00      	add	r7, sp, #0
 8004c6a:	60f8      	str	r0, [r7, #12]
 8004c6c:	60b9      	str	r1, [r7, #8]
 8004c6e:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
 8004c70:	2300      	movs	r3, #0
 8004c72:	617b      	str	r3, [r7, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 8004c74:	68fb      	ldr	r3, [r7, #12]
 8004c76:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004c78:	613b      	str	r3, [r7, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 8004c7a:	68fb      	ldr	r3, [r7, #12]
 8004c7c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004c7e:	2b00      	cmp	r3, #0
 8004c80:	d10d      	bne.n	8004c9e <prvCopyDataToQueue+0x3a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 8004c82:	68fb      	ldr	r3, [r7, #12]
 8004c84:	681b      	ldr	r3, [r3, #0]
 8004c86:	2b00      	cmp	r3, #0
 8004c88:	d14f      	bne.n	8004d2a <prvCopyDataToQueue+0xc6>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 8004c8a:	68fb      	ldr	r3, [r7, #12]
 8004c8c:	685b      	ldr	r3, [r3, #4]
 8004c8e:	4618      	mov	r0, r3
 8004c90:	f001 f964 	bl	8005f5c <xTaskPriorityDisinherit>
 8004c94:	6178      	str	r0, [r7, #20]
				pxQueue->pxMutexHolder = NULL;
 8004c96:	68fb      	ldr	r3, [r7, #12]
 8004c98:	2200      	movs	r2, #0
 8004c9a:	605a      	str	r2, [r3, #4]
 8004c9c:	e045      	b.n	8004d2a <prvCopyDataToQueue+0xc6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 8004c9e:	687b      	ldr	r3, [r7, #4]
 8004ca0:	2b00      	cmp	r3, #0
 8004ca2:	d11a      	bne.n	8004cda <prvCopyDataToQueue+0x76>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
 8004ca4:	68fb      	ldr	r3, [r7, #12]
 8004ca6:	689a      	ldr	r2, [r3, #8]
 8004ca8:	68fb      	ldr	r3, [r7, #12]
 8004caa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004cac:	4610      	mov	r0, r2
 8004cae:	68b9      	ldr	r1, [r7, #8]
 8004cb0:	461a      	mov	r2, r3
 8004cb2:	f00b f9f9 	bl	80100a8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 8004cb6:	68fb      	ldr	r3, [r7, #12]
 8004cb8:	689a      	ldr	r2, [r3, #8]
 8004cba:	68fb      	ldr	r3, [r7, #12]
 8004cbc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004cbe:	441a      	add	r2, r3
 8004cc0:	68fb      	ldr	r3, [r7, #12]
 8004cc2:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8004cc4:	68fb      	ldr	r3, [r7, #12]
 8004cc6:	689a      	ldr	r2, [r3, #8]
 8004cc8:	68fb      	ldr	r3, [r7, #12]
 8004cca:	685b      	ldr	r3, [r3, #4]
 8004ccc:	429a      	cmp	r2, r3
 8004cce:	d32c      	bcc.n	8004d2a <prvCopyDataToQueue+0xc6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 8004cd0:	68fb      	ldr	r3, [r7, #12]
 8004cd2:	681a      	ldr	r2, [r3, #0]
 8004cd4:	68fb      	ldr	r3, [r7, #12]
 8004cd6:	609a      	str	r2, [r3, #8]
 8004cd8:	e027      	b.n	8004d2a <prvCopyDataToQueue+0xc6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004cda:	68fb      	ldr	r3, [r7, #12]
 8004cdc:	68da      	ldr	r2, [r3, #12]
 8004cde:	68fb      	ldr	r3, [r7, #12]
 8004ce0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004ce2:	4610      	mov	r0, r2
 8004ce4:	68b9      	ldr	r1, [r7, #8]
 8004ce6:	461a      	mov	r2, r3
 8004ce8:	f00b f9de 	bl	80100a8 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
 8004cec:	68fb      	ldr	r3, [r7, #12]
 8004cee:	68da      	ldr	r2, [r3, #12]
 8004cf0:	68fb      	ldr	r3, [r7, #12]
 8004cf2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004cf4:	425b      	negs	r3, r3
 8004cf6:	441a      	add	r2, r3
 8004cf8:	68fb      	ldr	r3, [r7, #12]
 8004cfa:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 8004cfc:	68fb      	ldr	r3, [r7, #12]
 8004cfe:	68da      	ldr	r2, [r3, #12]
 8004d00:	68fb      	ldr	r3, [r7, #12]
 8004d02:	681b      	ldr	r3, [r3, #0]
 8004d04:	429a      	cmp	r2, r3
 8004d06:	d207      	bcs.n	8004d18 <prvCopyDataToQueue+0xb4>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8004d08:	68fb      	ldr	r3, [r7, #12]
 8004d0a:	685a      	ldr	r2, [r3, #4]
 8004d0c:	68fb      	ldr	r3, [r7, #12]
 8004d0e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004d10:	425b      	negs	r3, r3
 8004d12:	441a      	add	r2, r3
 8004d14:	68fb      	ldr	r3, [r7, #12]
 8004d16:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 8004d18:	687b      	ldr	r3, [r7, #4]
 8004d1a:	2b02      	cmp	r3, #2
 8004d1c:	d105      	bne.n	8004d2a <prvCopyDataToQueue+0xc6>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 8004d1e:	693b      	ldr	r3, [r7, #16]
 8004d20:	2b00      	cmp	r3, #0
 8004d22:	d002      	beq.n	8004d2a <prvCopyDataToQueue+0xc6>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 8004d24:	693b      	ldr	r3, [r7, #16]
 8004d26:	3b01      	subs	r3, #1
 8004d28:	613b      	str	r3, [r7, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
 8004d2a:	693b      	ldr	r3, [r7, #16]
 8004d2c:	1c5a      	adds	r2, r3, #1
 8004d2e:	68fb      	ldr	r3, [r7, #12]
 8004d30:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
 8004d32:	697b      	ldr	r3, [r7, #20]
}
 8004d34:	4618      	mov	r0, r3
 8004d36:	3718      	adds	r7, #24
 8004d38:	46bd      	mov	sp, r7
 8004d3a:	bd80      	pop	{r7, pc}

08004d3c <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 8004d3c:	b580      	push	{r7, lr}
 8004d3e:	b082      	sub	sp, #8
 8004d40:	af00      	add	r7, sp, #0
 8004d42:	6078      	str	r0, [r7, #4]
 8004d44:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 8004d46:	687b      	ldr	r3, [r7, #4]
 8004d48:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004d4a:	2b00      	cmp	r3, #0
 8004d4c:	d019      	beq.n	8004d82 <prvCopyDataFromQueue+0x46>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
 8004d4e:	687b      	ldr	r3, [r7, #4]
 8004d50:	68da      	ldr	r2, [r3, #12]
 8004d52:	687b      	ldr	r3, [r7, #4]
 8004d54:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004d56:	441a      	add	r2, r3
 8004d58:	687b      	ldr	r3, [r7, #4]
 8004d5a:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 8004d5c:	687b      	ldr	r3, [r7, #4]
 8004d5e:	68da      	ldr	r2, [r3, #12]
 8004d60:	687b      	ldr	r3, [r7, #4]
 8004d62:	685b      	ldr	r3, [r3, #4]
 8004d64:	429a      	cmp	r2, r3
 8004d66:	d303      	bcc.n	8004d70 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
 8004d68:	687b      	ldr	r3, [r7, #4]
 8004d6a:	681a      	ldr	r2, [r3, #0]
 8004d6c:	687b      	ldr	r3, [r7, #4]
 8004d6e:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
 8004d70:	687b      	ldr	r3, [r7, #4]
 8004d72:	68da      	ldr	r2, [r3, #12]
 8004d74:	687b      	ldr	r3, [r7, #4]
 8004d76:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8004d78:	6838      	ldr	r0, [r7, #0]
 8004d7a:	4611      	mov	r1, r2
 8004d7c:	461a      	mov	r2, r3
 8004d7e:	f00b f993 	bl	80100a8 <memcpy>
	}
}
 8004d82:	3708      	adds	r7, #8
 8004d84:	46bd      	mov	sp, r7
 8004d86:	bd80      	pop	{r7, pc}

08004d88 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 8004d88:	b580      	push	{r7, lr}
 8004d8a:	b084      	sub	sp, #16
 8004d8c:	af00      	add	r7, sp, #0
 8004d8e:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 8004d90:	f7ff f87c 	bl	8003e8c <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 8004d94:	687b      	ldr	r3, [r7, #4]
 8004d96:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
 8004d9a:	73fb      	strb	r3, [r7, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8004d9c:	e013      	b.n	8004dc6 <prvUnlockQueue+0x3e>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8004d9e:	687b      	ldr	r3, [r7, #4]
 8004da0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004da2:	2b00      	cmp	r3, #0
 8004da4:	d00a      	beq.n	8004dbc <prvUnlockQueue+0x34>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 8004da6:	687b      	ldr	r3, [r7, #4]
 8004da8:	3324      	adds	r3, #36	; 0x24
 8004daa:	4618      	mov	r0, r3
 8004dac:	f000 fe06 	bl	80059bc <xTaskRemoveFromEventList>
 8004db0:	4603      	mov	r3, r0
 8004db2:	2b00      	cmp	r3, #0
 8004db4:	d003      	beq.n	8004dbe <prvUnlockQueue+0x36>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 8004db6:	f000 ff55 	bl	8005c64 <vTaskMissedYield>
 8004dba:	e000      	b.n	8004dbe <prvUnlockQueue+0x36>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
 8004dbc:	e007      	b.n	8004dce <prvUnlockQueue+0x46>
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 8004dbe:	7bfb      	ldrb	r3, [r7, #15]
 8004dc0:	3b01      	subs	r3, #1
 8004dc2:	b2db      	uxtb	r3, r3
 8004dc4:	73fb      	strb	r3, [r7, #15]
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 8004dc6:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8004dca:	2b00      	cmp	r3, #0
 8004dcc:	dce7      	bgt.n	8004d9e <prvUnlockQueue+0x16>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
 8004dce:	687b      	ldr	r3, [r7, #4]
 8004dd0:	22ff      	movs	r2, #255	; 0xff
 8004dd2:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
 8004dd6:	f7ff f887 	bl	8003ee8 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 8004dda:	f7ff f857 	bl	8003e8c <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 8004dde:	687b      	ldr	r3, [r7, #4]
 8004de0:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
 8004de4:	73bb      	strb	r3, [r7, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
 8004de6:	e013      	b.n	8004e10 <prvUnlockQueue+0x88>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 8004de8:	687b      	ldr	r3, [r7, #4]
 8004dea:	691b      	ldr	r3, [r3, #16]
 8004dec:	2b00      	cmp	r3, #0
 8004dee:	d00e      	beq.n	8004e0e <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 8004df0:	687b      	ldr	r3, [r7, #4]
 8004df2:	3310      	adds	r3, #16
 8004df4:	4618      	mov	r0, r3
 8004df6:	f000 fde1 	bl	80059bc <xTaskRemoveFromEventList>
 8004dfa:	4603      	mov	r3, r0
 8004dfc:	2b00      	cmp	r3, #0
 8004dfe:	d001      	beq.n	8004e04 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
 8004e00:	f000 ff30 	bl	8005c64 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 8004e04:	7bbb      	ldrb	r3, [r7, #14]
 8004e06:	3b01      	subs	r3, #1
 8004e08:	b2db      	uxtb	r3, r3
 8004e0a:	73bb      	strb	r3, [r7, #14]
 8004e0c:	e000      	b.n	8004e10 <prvUnlockQueue+0x88>
			}
			else
			{
				break;
 8004e0e:	e003      	b.n	8004e18 <prvUnlockQueue+0x90>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
 8004e10:	f997 300e 	ldrsb.w	r3, [r7, #14]
 8004e14:	2b00      	cmp	r3, #0
 8004e16:	dce7      	bgt.n	8004de8 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 8004e18:	687b      	ldr	r3, [r7, #4]
 8004e1a:	22ff      	movs	r2, #255	; 0xff
 8004e1c:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 8004e20:	f7ff f862 	bl	8003ee8 <vPortExitCritical>
}
 8004e24:	3710      	adds	r7, #16
 8004e26:	46bd      	mov	sp, r7
 8004e28:	bd80      	pop	{r7, pc}
 8004e2a:	bf00      	nop

08004e2c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 8004e2c:	b580      	push	{r7, lr}
 8004e2e:	b084      	sub	sp, #16
 8004e30:	af00      	add	r7, sp, #0
 8004e32:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8004e34:	f7ff f82a 	bl	8003e8c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 8004e38:	687b      	ldr	r3, [r7, #4]
 8004e3a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8004e3c:	2b00      	cmp	r3, #0
 8004e3e:	d102      	bne.n	8004e46 <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
 8004e40:	2301      	movs	r3, #1
 8004e42:	60fb      	str	r3, [r7, #12]
 8004e44:	e001      	b.n	8004e4a <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
 8004e46:	2300      	movs	r3, #0
 8004e48:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 8004e4a:	f7ff f84d 	bl	8003ee8 <vPortExitCritical>

	return xReturn;
 8004e4e:	68fb      	ldr	r3, [r7, #12]
}
 8004e50:	4618      	mov	r0, r3
 8004e52:	3710      	adds	r7, #16
 8004e54:	46bd      	mov	sp, r7
 8004e56:	bd80      	pop	{r7, pc}

08004e58 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 8004e58:	b580      	push	{r7, lr}
 8004e5a:	b084      	sub	sp, #16
 8004e5c:	af00      	add	r7, sp, #0
 8004e5e:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 8004e60:	f7ff f814 	bl	8003e8c <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 8004e64:	687b      	ldr	r3, [r7, #4]
 8004e66:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8004e68:	687b      	ldr	r3, [r7, #4]
 8004e6a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004e6c:	429a      	cmp	r2, r3
 8004e6e:	d102      	bne.n	8004e76 <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
 8004e70:	2301      	movs	r3, #1
 8004e72:	60fb      	str	r3, [r7, #12]
 8004e74:	e001      	b.n	8004e7a <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
 8004e76:	2300      	movs	r3, #0
 8004e78:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 8004e7a:	f7ff f835 	bl	8003ee8 <vPortExitCritical>

	return xReturn;
 8004e7e:	68fb      	ldr	r3, [r7, #12]
}
 8004e80:	4618      	mov	r0, r3
 8004e82:	3710      	adds	r7, #16
 8004e84:	46bd      	mov	sp, r7
 8004e86:	bd80      	pop	{r7, pc}

08004e88 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8004e88:	b580      	push	{r7, lr}
 8004e8a:	b084      	sub	sp, #16
 8004e8c:	af00      	add	r7, sp, #0
 8004e8e:	6078      	str	r0, [r7, #4]
 8004e90:	6039      	str	r1, [r7, #0]
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8004e92:	2300      	movs	r3, #0
 8004e94:	60fb      	str	r3, [r7, #12]
 8004e96:	e01f      	b.n	8004ed8 <vQueueAddToRegistry+0x50>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 8004e98:	4a12      	ldr	r2, [pc, #72]	; (8004ee4 <vQueueAddToRegistry+0x5c>)
 8004e9a:	68fb      	ldr	r3, [r7, #12]
 8004e9c:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 8004ea0:	2b00      	cmp	r3, #0
 8004ea2:	d116      	bne.n	8004ed2 <vQueueAddToRegistry+0x4a>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 8004ea4:	490f      	ldr	r1, [pc, #60]	; (8004ee4 <vQueueAddToRegistry+0x5c>)
 8004ea6:	68fb      	ldr	r3, [r7, #12]
 8004ea8:	683a      	ldr	r2, [r7, #0]
 8004eaa:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 8004eae:	4a0d      	ldr	r2, [pc, #52]	; (8004ee4 <vQueueAddToRegistry+0x5c>)
 8004eb0:	68fb      	ldr	r3, [r7, #12]
 8004eb2:	00db      	lsls	r3, r3, #3
 8004eb4:	4413      	add	r3, r2
 8004eb6:	687a      	ldr	r2, [r7, #4]
 8004eb8:	605a      	str	r2, [r3, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
 8004eba:	687b      	ldr	r3, [r7, #4]
 8004ebc:	4618      	mov	r0, r3
 8004ebe:	f00c ff75 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 8004ec2:	4602      	mov	r2, r0
 8004ec4:	683b      	ldr	r3, [r7, #0]
 8004ec6:	2071      	movs	r0, #113	; 0x71
 8004ec8:	4611      	mov	r1, r2
 8004eca:	461a      	mov	r2, r3
 8004ecc:	f00c f9e6 	bl	801129c <SEGGER_SYSVIEW_RecordU32x2>
				break;
 8004ed0:	e005      	b.n	8004ede <vQueueAddToRegistry+0x56>
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8004ed2:	68fb      	ldr	r3, [r7, #12]
 8004ed4:	3301      	adds	r3, #1
 8004ed6:	60fb      	str	r3, [r7, #12]
 8004ed8:	68fb      	ldr	r3, [r7, #12]
 8004eda:	2b07      	cmp	r3, #7
 8004edc:	d9dc      	bls.n	8004e98 <vQueueAddToRegistry+0x10>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 8004ede:	3710      	adds	r7, #16
 8004ee0:	46bd      	mov	sp, r7
 8004ee2:	bd80      	pop	{r7, pc}
 8004ee4:	2000ced0 	.word	0x2000ced0

08004ee8 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
 8004ee8:	b480      	push	{r7}
 8004eea:	b085      	sub	sp, #20
 8004eec:	af00      	add	r7, sp, #0
 8004eee:	6078      	str	r0, [r7, #4]
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8004ef0:	2300      	movs	r3, #0
 8004ef2:	60fb      	str	r3, [r7, #12]
 8004ef4:	e016      	b.n	8004f24 <vQueueUnregisterQueue+0x3c>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 8004ef6:	4a0f      	ldr	r2, [pc, #60]	; (8004f34 <vQueueUnregisterQueue+0x4c>)
 8004ef8:	68fb      	ldr	r3, [r7, #12]
 8004efa:	00db      	lsls	r3, r3, #3
 8004efc:	4413      	add	r3, r2
 8004efe:	685a      	ldr	r2, [r3, #4]
 8004f00:	687b      	ldr	r3, [r7, #4]
 8004f02:	429a      	cmp	r2, r3
 8004f04:	d10b      	bne.n	8004f1e <vQueueUnregisterQueue+0x36>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 8004f06:	4a0b      	ldr	r2, [pc, #44]	; (8004f34 <vQueueUnregisterQueue+0x4c>)
 8004f08:	68fb      	ldr	r3, [r7, #12]
 8004f0a:	2100      	movs	r1, #0
 8004f0c:	f842 1033 	str.w	r1, [r2, r3, lsl #3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 8004f10:	4a08      	ldr	r2, [pc, #32]	; (8004f34 <vQueueUnregisterQueue+0x4c>)
 8004f12:	68fb      	ldr	r3, [r7, #12]
 8004f14:	00db      	lsls	r3, r3, #3
 8004f16:	4413      	add	r3, r2
 8004f18:	2200      	movs	r2, #0
 8004f1a:	605a      	str	r2, [r3, #4]
				break;
 8004f1c:	e005      	b.n	8004f2a <vQueueUnregisterQueue+0x42>
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 8004f1e:	68fb      	ldr	r3, [r7, #12]
 8004f20:	3301      	adds	r3, #1
 8004f22:	60fb      	str	r3, [r7, #12]
 8004f24:	68fb      	ldr	r3, [r7, #12]
 8004f26:	2b07      	cmp	r3, #7
 8004f28:	d9e5      	bls.n	8004ef6 <vQueueUnregisterQueue+0xe>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 8004f2a:	3714      	adds	r7, #20
 8004f2c:	46bd      	mov	sp, r7
 8004f2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8004f32:	4770      	bx	lr
 8004f34:	2000ced0 	.word	0x2000ced0

08004f38 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 8004f38:	b580      	push	{r7, lr}
 8004f3a:	b08c      	sub	sp, #48	; 0x30
 8004f3c:	af04      	add	r7, sp, #16
 8004f3e:	60f8      	str	r0, [r7, #12]
 8004f40:	60b9      	str	r1, [r7, #8]
 8004f42:	603b      	str	r3, [r7, #0]
 8004f44:	4613      	mov	r3, r2
 8004f46:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8004f48:	88fb      	ldrh	r3, [r7, #6]
 8004f4a:	009b      	lsls	r3, r3, #2
 8004f4c:	4618      	mov	r0, r3
 8004f4e:	f7ff f8af 	bl	80040b0 <pvPortMalloc>
 8004f52:	6178      	str	r0, [r7, #20]

			if( pxStack != NULL )
 8004f54:	697b      	ldr	r3, [r7, #20]
 8004f56:	2b00      	cmp	r3, #0
 8004f58:	d00e      	beq.n	8004f78 <xTaskCreate+0x40>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8004f5a:	206c      	movs	r0, #108	; 0x6c
 8004f5c:	f7ff f8a8 	bl	80040b0 <pvPortMalloc>
 8004f60:	61f8      	str	r0, [r7, #28]

				if( pxNewTCB != NULL )
 8004f62:	69fb      	ldr	r3, [r7, #28]
 8004f64:	2b00      	cmp	r3, #0
 8004f66:	d003      	beq.n	8004f70 <xTaskCreate+0x38>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 8004f68:	69fb      	ldr	r3, [r7, #28]
 8004f6a:	697a      	ldr	r2, [r7, #20]
 8004f6c:	631a      	str	r2, [r3, #48]	; 0x30
 8004f6e:	e005      	b.n	8004f7c <xTaskCreate+0x44>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 8004f70:	6978      	ldr	r0, [r7, #20]
 8004f72:	f7ff f93d 	bl	80041f0 <vPortFree>
 8004f76:	e001      	b.n	8004f7c <xTaskCreate+0x44>
				}
			}
			else
			{
				pxNewTCB = NULL;
 8004f78:	2300      	movs	r3, #0
 8004f7a:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 8004f7c:	69fb      	ldr	r3, [r7, #28]
 8004f7e:	2b00      	cmp	r3, #0
 8004f80:	d013      	beq.n	8004faa <xTaskCreate+0x72>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 8004f82:	88fa      	ldrh	r2, [r7, #6]
 8004f84:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8004f86:	9300      	str	r3, [sp, #0]
 8004f88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8004f8a:	9301      	str	r3, [sp, #4]
 8004f8c:	69fb      	ldr	r3, [r7, #28]
 8004f8e:	9302      	str	r3, [sp, #8]
 8004f90:	2300      	movs	r3, #0
 8004f92:	9303      	str	r3, [sp, #12]
 8004f94:	68f8      	ldr	r0, [r7, #12]
 8004f96:	68b9      	ldr	r1, [r7, #8]
 8004f98:	683b      	ldr	r3, [r7, #0]
 8004f9a:	f000 f80f 	bl	8004fbc <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 8004f9e:	69f8      	ldr	r0, [r7, #28]
 8004fa0:	f000 f8a4 	bl	80050ec <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 8004fa4:	2301      	movs	r3, #1
 8004fa6:	61bb      	str	r3, [r7, #24]
 8004fa8:	e002      	b.n	8004fb0 <xTaskCreate+0x78>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8004faa:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8004fae:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
 8004fb0:	69bb      	ldr	r3, [r7, #24]
	}
 8004fb2:	4618      	mov	r0, r3
 8004fb4:	3720      	adds	r7, #32
 8004fb6:	46bd      	mov	sp, r7
 8004fb8:	bd80      	pop	{r7, pc}
 8004fba:	bf00      	nop

08004fbc <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 8004fbc:	b580      	push	{r7, lr}
 8004fbe:	b088      	sub	sp, #32
 8004fc0:	af00      	add	r7, sp, #0
 8004fc2:	60f8      	str	r0, [r7, #12]
 8004fc4:	60b9      	str	r1, [r7, #8]
 8004fc6:	607a      	str	r2, [r7, #4]
 8004fc8:	603b      	str	r3, [r7, #0]

	/* Avoid dependency on memset() if it is not required. */
	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 8004fca:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004fcc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004fce:	687b      	ldr	r3, [r7, #4]
 8004fd0:	009b      	lsls	r3, r3, #2
 8004fd2:	4610      	mov	r0, r2
 8004fd4:	21a5      	movs	r1, #165	; 0xa5
 8004fd6:	461a      	mov	r2, r3
 8004fd8:	f00b f966 	bl	80102a8 <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8004fdc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8004fde:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004fe0:	6879      	ldr	r1, [r7, #4]
 8004fe2:	f06f 4340 	mvn.w	r3, #3221225472	; 0xc0000000
 8004fe6:	440b      	add	r3, r1
 8004fe8:	009b      	lsls	r3, r3, #2
 8004fea:	4413      	add	r3, r2
 8004fec:	61bb      	str	r3, [r7, #24]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8004fee:	69bb      	ldr	r3, [r7, #24]
 8004ff0:	f023 0307 	bic.w	r3, r3, #7
 8004ff4:	61bb      	str	r3, [r7, #24]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 8004ff6:	69bb      	ldr	r3, [r7, #24]
 8004ff8:	f003 0307 	and.w	r3, r3, #7
 8004ffc:	2b00      	cmp	r3, #0
 8004ffe:	d009      	beq.n	8005014 <prvInitialiseNewTask+0x58>
 8005000:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005004:	f383 8811 	msr	BASEPRI, r3
 8005008:	f3bf 8f6f 	isb	sy
 800500c:	f3bf 8f4f 	dsb	sy
 8005010:	617b      	str	r3, [r7, #20]
 8005012:	e7fe      	b.n	8005012 <prvInitialiseNewTask+0x56>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8005014:	2300      	movs	r3, #0
 8005016:	61fb      	str	r3, [r7, #28]
 8005018:	e013      	b.n	8005042 <prvInitialiseNewTask+0x86>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 800501a:	68ba      	ldr	r2, [r7, #8]
 800501c:	69fb      	ldr	r3, [r7, #28]
 800501e:	4413      	add	r3, r2
 8005020:	7819      	ldrb	r1, [r3, #0]
 8005022:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8005024:	69fb      	ldr	r3, [r7, #28]
 8005026:	4413      	add	r3, r2
 8005028:	3330      	adds	r3, #48	; 0x30
 800502a:	460a      	mov	r2, r1
 800502c:	711a      	strb	r2, [r3, #4]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 800502e:	68ba      	ldr	r2, [r7, #8]
 8005030:	69fb      	ldr	r3, [r7, #28]
 8005032:	4413      	add	r3, r2
 8005034:	781b      	ldrb	r3, [r3, #0]
 8005036:	2b00      	cmp	r3, #0
 8005038:	d100      	bne.n	800503c <prvInitialiseNewTask+0x80>
		{
			break;
 800503a:	e005      	b.n	8005048 <prvInitialiseNewTask+0x8c>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 800503c:	69fb      	ldr	r3, [r7, #28]
 800503e:	3301      	adds	r3, #1
 8005040:	61fb      	str	r3, [r7, #28]
 8005042:	69fb      	ldr	r3, [r7, #28]
 8005044:	2b0f      	cmp	r3, #15
 8005046:	d9e8      	bls.n	800501a <prvInitialiseNewTask+0x5e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8005048:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800504a:	2200      	movs	r2, #0
 800504c:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 8005050:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005052:	2b06      	cmp	r3, #6
 8005054:	d901      	bls.n	800505a <prvInitialiseNewTask+0x9e>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 8005056:	2306      	movs	r3, #6
 8005058:	62bb      	str	r3, [r7, #40]	; 0x28
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 800505a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800505c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800505e:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 8005060:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005062:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8005064:	64da      	str	r2, [r3, #76]	; 0x4c
		pxNewTCB->uxMutexesHeld = 0;
 8005066:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005068:	2200      	movs	r2, #0
 800506a:	651a      	str	r2, [r3, #80]	; 0x50
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 800506c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800506e:	3304      	adds	r3, #4
 8005070:	4618      	mov	r0, r3
 8005072:	f7fe fd7b 	bl	8003b6c <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8005076:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005078:	3318      	adds	r3, #24
 800507a:	4618      	mov	r0, r3
 800507c:	f7fe fd76 	bl	8003b6c <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8005080:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005082:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8005084:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005086:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8005088:	f1c3 0207 	rsb	r2, r3, #7
 800508c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800508e:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8005090:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005092:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8005094:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif /* configUSE_APPLICATION_TASK_TAG */

	#if ( configGENERATE_RUN_TIME_STATS == 1 )
	{
		pxNewTCB->ulRunTimeCounter = 0UL;
 8005096:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8005098:	2200      	movs	r2, #0
 800509a:	661a      	str	r2, [r3, #96]	; 0x60
	}
	#endif

	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
	{
		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 800509c:	2300      	movs	r3, #0
 800509e:	61fb      	str	r3, [r7, #28]
 80050a0:	e009      	b.n	80050b6 <prvInitialiseNewTask+0xfa>
		{
			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
 80050a2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80050a4:	69fb      	ldr	r3, [r7, #28]
 80050a6:	3314      	adds	r3, #20
 80050a8:	009b      	lsls	r3, r3, #2
 80050aa:	4413      	add	r3, r2
 80050ac:	2200      	movs	r2, #0
 80050ae:	605a      	str	r2, [r3, #4]
	}
	#endif

	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
	{
		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
 80050b0:	69fb      	ldr	r3, [r7, #28]
 80050b2:	3301      	adds	r3, #1
 80050b4:	61fb      	str	r3, [r7, #28]
 80050b6:	69fb      	ldr	r3, [r7, #28]
 80050b8:	2b02      	cmp	r3, #2
 80050ba:	d9f2      	bls.n	80050a2 <prvInitialiseNewTask+0xe6>
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 80050bc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80050be:	2200      	movs	r2, #0
 80050c0:	665a      	str	r2, [r3, #100]	; 0x64
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 80050c2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80050c4:	2200      	movs	r2, #0
 80050c6:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 80050ca:	69b8      	ldr	r0, [r7, #24]
 80050cc:	68f9      	ldr	r1, [r7, #12]
 80050ce:	683a      	ldr	r2, [r7, #0]
 80050d0:	f7fe fdde 	bl	8003c90 <pxPortInitialiseStack>
 80050d4:	4602      	mov	r2, r0
 80050d6:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80050d8:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
 80050da:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80050dc:	2b00      	cmp	r3, #0
 80050de:	d002      	beq.n	80050e6 <prvInitialiseNewTask+0x12a>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 80050e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80050e2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80050e4:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 80050e6:	3720      	adds	r7, #32
 80050e8:	46bd      	mov	sp, r7
 80050ea:	bd80      	pop	{r7, pc}

080050ec <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 80050ec:	b5b0      	push	{r4, r5, r7, lr}
 80050ee:	b084      	sub	sp, #16
 80050f0:	af02      	add	r7, sp, #8
 80050f2:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 80050f4:	f7fe feca 	bl	8003e8c <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 80050f8:	4b3c      	ldr	r3, [pc, #240]	; (80051ec <prvAddNewTaskToReadyList+0x100>)
 80050fa:	681b      	ldr	r3, [r3, #0]
 80050fc:	3301      	adds	r3, #1
 80050fe:	4a3b      	ldr	r2, [pc, #236]	; (80051ec <prvAddNewTaskToReadyList+0x100>)
 8005100:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 8005102:	4b3b      	ldr	r3, [pc, #236]	; (80051f0 <prvAddNewTaskToReadyList+0x104>)
 8005104:	681b      	ldr	r3, [r3, #0]
 8005106:	2b00      	cmp	r3, #0
 8005108:	d109      	bne.n	800511e <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 800510a:	4a39      	ldr	r2, [pc, #228]	; (80051f0 <prvAddNewTaskToReadyList+0x104>)
 800510c:	687b      	ldr	r3, [r7, #4]
 800510e:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8005110:	4b36      	ldr	r3, [pc, #216]	; (80051ec <prvAddNewTaskToReadyList+0x100>)
 8005112:	681b      	ldr	r3, [r3, #0]
 8005114:	2b01      	cmp	r3, #1
 8005116:	d110      	bne.n	800513a <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 8005118:	f000 fdca 	bl	8005cb0 <prvInitialiseTaskLists>
 800511c:	e00d      	b.n	800513a <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 800511e:	4b35      	ldr	r3, [pc, #212]	; (80051f4 <prvAddNewTaskToReadyList+0x108>)
 8005120:	681b      	ldr	r3, [r3, #0]
 8005122:	2b00      	cmp	r3, #0
 8005124:	d109      	bne.n	800513a <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8005126:	4b32      	ldr	r3, [pc, #200]	; (80051f0 <prvAddNewTaskToReadyList+0x104>)
 8005128:	681b      	ldr	r3, [r3, #0]
 800512a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800512c:	687b      	ldr	r3, [r7, #4]
 800512e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005130:	429a      	cmp	r2, r3
 8005132:	d802      	bhi.n	800513a <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
 8005134:	4a2e      	ldr	r2, [pc, #184]	; (80051f0 <prvAddNewTaskToReadyList+0x104>)
 8005136:	687b      	ldr	r3, [r7, #4]
 8005138:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 800513a:	4b2f      	ldr	r3, [pc, #188]	; (80051f8 <prvAddNewTaskToReadyList+0x10c>)
 800513c:	681b      	ldr	r3, [r3, #0]
 800513e:	3301      	adds	r3, #1
 8005140:	4a2d      	ldr	r2, [pc, #180]	; (80051f8 <prvAddNewTaskToReadyList+0x10c>)
 8005142:	6013      	str	r3, [r2, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 8005144:	4b2c      	ldr	r3, [pc, #176]	; (80051f8 <prvAddNewTaskToReadyList+0x10c>)
 8005146:	681a      	ldr	r2, [r3, #0]
 8005148:	687b      	ldr	r3, [r7, #4]
 800514a:	645a      	str	r2, [r3, #68]	; 0x44
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );
 800514c:	687b      	ldr	r3, [r7, #4]
 800514e:	2b00      	cmp	r3, #0
 8005150:	d016      	beq.n	8005180 <prvAddNewTaskToReadyList+0x94>
 8005152:	687b      	ldr	r3, [r7, #4]
 8005154:	4618      	mov	r0, r3
 8005156:	f00c fcbf 	bl	8011ad8 <SEGGER_SYSVIEW_OnTaskCreate>
 800515a:	6878      	ldr	r0, [r7, #4]
 800515c:	687b      	ldr	r3, [r7, #4]
 800515e:	f103 0134 	add.w	r1, r3, #52	; 0x34
 8005162:	687b      	ldr	r3, [r7, #4]
 8005164:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005166:	687b      	ldr	r3, [r7, #4]
 8005168:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800516a:	461d      	mov	r5, r3
 800516c:	687b      	ldr	r3, [r7, #4]
 800516e:	681b      	ldr	r3, [r3, #0]
 8005170:	461c      	mov	r4, r3
 8005172:	687b      	ldr	r3, [r7, #4]
 8005174:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005176:	1ae3      	subs	r3, r4, r3
 8005178:	9300      	str	r3, [sp, #0]
 800517a:	462b      	mov	r3, r5
 800517c:	f00c ffd2 	bl	8012124 <SYSVIEW_AddTask>

		prvAddTaskToReadyList( pxNewTCB );
 8005180:	687b      	ldr	r3, [r7, #4]
 8005182:	4618      	mov	r0, r3
 8005184:	f00c fd2c 	bl	8011be0 <SEGGER_SYSVIEW_OnTaskStartReady>
 8005188:	687b      	ldr	r3, [r7, #4]
 800518a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800518c:	461a      	mov	r2, r3
 800518e:	2301      	movs	r3, #1
 8005190:	fa03 f202 	lsl.w	r2, r3, r2
 8005194:	4b19      	ldr	r3, [pc, #100]	; (80051fc <prvAddNewTaskToReadyList+0x110>)
 8005196:	681b      	ldr	r3, [r3, #0]
 8005198:	4313      	orrs	r3, r2
 800519a:	4a18      	ldr	r2, [pc, #96]	; (80051fc <prvAddNewTaskToReadyList+0x110>)
 800519c:	6013      	str	r3, [r2, #0]
 800519e:	687b      	ldr	r3, [r7, #4]
 80051a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80051a2:	4613      	mov	r3, r2
 80051a4:	009b      	lsls	r3, r3, #2
 80051a6:	4413      	add	r3, r2
 80051a8:	009b      	lsls	r3, r3, #2
 80051aa:	4a15      	ldr	r2, [pc, #84]	; (8005200 <prvAddNewTaskToReadyList+0x114>)
 80051ac:	441a      	add	r2, r3
 80051ae:	687b      	ldr	r3, [r7, #4]
 80051b0:	3304      	adds	r3, #4
 80051b2:	4610      	mov	r0, r2
 80051b4:	4619      	mov	r1, r3
 80051b6:	f7fe fce5 	bl	8003b84 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 80051ba:	f7fe fe95 	bl	8003ee8 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 80051be:	4b0d      	ldr	r3, [pc, #52]	; (80051f4 <prvAddNewTaskToReadyList+0x108>)
 80051c0:	681b      	ldr	r3, [r3, #0]
 80051c2:	2b00      	cmp	r3, #0
 80051c4:	d00e      	beq.n	80051e4 <prvAddNewTaskToReadyList+0xf8>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 80051c6:	4b0a      	ldr	r3, [pc, #40]	; (80051f0 <prvAddNewTaskToReadyList+0x104>)
 80051c8:	681b      	ldr	r3, [r3, #0]
 80051ca:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80051cc:	687b      	ldr	r3, [r7, #4]
 80051ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80051d0:	429a      	cmp	r2, r3
 80051d2:	d207      	bcs.n	80051e4 <prvAddNewTaskToReadyList+0xf8>
		{
			taskYIELD_IF_USING_PREEMPTION();
 80051d4:	4b0b      	ldr	r3, [pc, #44]	; (8005204 <prvAddNewTaskToReadyList+0x118>)
 80051d6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80051da:	601a      	str	r2, [r3, #0]
 80051dc:	f3bf 8f4f 	dsb	sy
 80051e0:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 80051e4:	3708      	adds	r7, #8
 80051e6:	46bd      	mov	sp, r7
 80051e8:	bdb0      	pop	{r4, r5, r7, pc}
 80051ea:	bf00      	nop
 80051ec:	2000bcac 	.word	0x2000bcac
 80051f0:	2000bbac 	.word	0x2000bbac
 80051f4:	2000bcb8 	.word	0x2000bcb8
 80051f8:	2000bcc8 	.word	0x2000bcc8
 80051fc:	2000bcb4 	.word	0x2000bcb4
 8005200:	2000bbb0 	.word	0x2000bbb0
 8005204:	e000ed04 	.word	0xe000ed04

08005208 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 8005208:	b580      	push	{r7, lr}
 800520a:	b084      	sub	sp, #16
 800520c:	af00      	add	r7, sp, #0
 800520e:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
 8005210:	2300      	movs	r3, #0
 8005212:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 8005214:	687b      	ldr	r3, [r7, #4]
 8005216:	2b00      	cmp	r3, #0
 8005218:	d01a      	beq.n	8005250 <vTaskDelay+0x48>
		{
			configASSERT( uxSchedulerSuspended == 0 );
 800521a:	4b14      	ldr	r3, [pc, #80]	; (800526c <vTaskDelay+0x64>)
 800521c:	681b      	ldr	r3, [r3, #0]
 800521e:	2b00      	cmp	r3, #0
 8005220:	d009      	beq.n	8005236 <vTaskDelay+0x2e>
 8005222:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005226:	f383 8811 	msr	BASEPRI, r3
 800522a:	f3bf 8f6f 	isb	sy
 800522e:	f3bf 8f4f 	dsb	sy
 8005232:	60bb      	str	r3, [r7, #8]
 8005234:	e7fe      	b.n	8005234 <vTaskDelay+0x2c>
			vTaskSuspendAll();
 8005236:	f000 f8f5 	bl	8005424 <vTaskSuspendAll>
			{
				traceTASK_DELAY();
 800523a:	2023      	movs	r0, #35	; 0x23
 800523c:	6879      	ldr	r1, [r7, #4]
 800523e:	f00b fff1 	bl	8011224 <SEGGER_SYSVIEW_RecordU32>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8005242:	6878      	ldr	r0, [r7, #4]
 8005244:	2100      	movs	r1, #0
 8005246:	f001 f8e1 	bl	800640c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 800524a:	f000 f8f9 	bl	8005440 <xTaskResumeAll>
 800524e:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 8005250:	68fb      	ldr	r3, [r7, #12]
 8005252:	2b00      	cmp	r3, #0
 8005254:	d107      	bne.n	8005266 <vTaskDelay+0x5e>
		{
			portYIELD_WITHIN_API();
 8005256:	4b06      	ldr	r3, [pc, #24]	; (8005270 <vTaskDelay+0x68>)
 8005258:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800525c:	601a      	str	r2, [r3, #0]
 800525e:	f3bf 8f4f 	dsb	sy
 8005262:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8005266:	3710      	adds	r7, #16
 8005268:	46bd      	mov	sp, r7
 800526a:	bd80      	pop	{r7, pc}
 800526c:	2000bcd4 	.word	0x2000bcd4
 8005270:	e000ed04 	.word	0xe000ed04

08005274 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
 8005274:	b580      	push	{r7, lr}
 8005276:	b084      	sub	sp, #16
 8005278:	af00      	add	r7, sp, #0
 800527a:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
 800527c:	f7fe fe06 	bl	8003e8c <vPortEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
 8005280:	687b      	ldr	r3, [r7, #4]
 8005282:	2b00      	cmp	r3, #0
 8005284:	d102      	bne.n	800528c <vTaskSuspend+0x18>
 8005286:	4b3d      	ldr	r3, [pc, #244]	; (800537c <vTaskSuspend+0x108>)
 8005288:	681b      	ldr	r3, [r3, #0]
 800528a:	e000      	b.n	800528e <vTaskSuspend+0x1a>
 800528c:	687b      	ldr	r3, [r7, #4]
 800528e:	60fb      	str	r3, [r7, #12]

			traceTASK_SUSPEND( pxTCB );
 8005290:	68fb      	ldr	r3, [r7, #12]
 8005292:	4618      	mov	r0, r3
 8005294:	f00c fd8a 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 8005298:	4603      	mov	r3, r0
 800529a:	2029      	movs	r0, #41	; 0x29
 800529c:	4619      	mov	r1, r3
 800529e:	f00b ffc1 	bl	8011224 <SEGGER_SYSVIEW_RecordU32>

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 80052a2:	68fb      	ldr	r3, [r7, #12]
 80052a4:	3304      	adds	r3, #4
 80052a6:	4618      	mov	r0, r3
 80052a8:	f7fe fcc8 	bl	8003c3c <uxListRemove>
 80052ac:	4603      	mov	r3, r0
 80052ae:	2b00      	cmp	r3, #0
 80052b0:	d115      	bne.n	80052de <vTaskSuspend+0x6a>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 80052b2:	68fb      	ldr	r3, [r7, #12]
 80052b4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80052b6:	4932      	ldr	r1, [pc, #200]	; (8005380 <vTaskSuspend+0x10c>)
 80052b8:	4613      	mov	r3, r2
 80052ba:	009b      	lsls	r3, r3, #2
 80052bc:	4413      	add	r3, r2
 80052be:	009b      	lsls	r3, r3, #2
 80052c0:	440b      	add	r3, r1
 80052c2:	681b      	ldr	r3, [r3, #0]
 80052c4:	2b00      	cmp	r3, #0
 80052c6:	d10a      	bne.n	80052de <vTaskSuspend+0x6a>
 80052c8:	68fb      	ldr	r3, [r7, #12]
 80052ca:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80052cc:	461a      	mov	r2, r3
 80052ce:	2301      	movs	r3, #1
 80052d0:	4093      	lsls	r3, r2
 80052d2:	43da      	mvns	r2, r3
 80052d4:	4b2b      	ldr	r3, [pc, #172]	; (8005384 <vTaskSuspend+0x110>)
 80052d6:	681b      	ldr	r3, [r3, #0]
 80052d8:	4013      	ands	r3, r2
 80052da:	4a2a      	ldr	r2, [pc, #168]	; (8005384 <vTaskSuspend+0x110>)
 80052dc:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80052de:	68fb      	ldr	r3, [r7, #12]
 80052e0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80052e2:	2b00      	cmp	r3, #0
 80052e4:	d004      	beq.n	80052f0 <vTaskSuspend+0x7c>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80052e6:	68fb      	ldr	r3, [r7, #12]
 80052e8:	3318      	adds	r3, #24
 80052ea:	4618      	mov	r0, r3
 80052ec:	f7fe fca6 	bl	8003c3c <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			traceMOVED_TASK_TO_SUSPENDED_LIST(pxTCB);
 80052f0:	68fb      	ldr	r3, [r7, #12]
 80052f2:	4618      	mov	r0, r3
 80052f4:	211b      	movs	r1, #27
 80052f6:	f00c fcb5 	bl	8011c64 <SEGGER_SYSVIEW_OnTaskStopReady>
			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
 80052fa:	68fb      	ldr	r3, [r7, #12]
 80052fc:	3304      	adds	r3, #4
 80052fe:	4822      	ldr	r0, [pc, #136]	; (8005388 <vTaskSuspend+0x114>)
 8005300:	4619      	mov	r1, r3
 8005302:	f7fe fc3f 	bl	8003b84 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
 8005306:	f7fe fdef 	bl	8003ee8 <vPortExitCritical>

		if( xSchedulerRunning != pdFALSE )
 800530a:	4b20      	ldr	r3, [pc, #128]	; (800538c <vTaskSuspend+0x118>)
 800530c:	681b      	ldr	r3, [r3, #0]
 800530e:	2b00      	cmp	r3, #0
 8005310:	d005      	beq.n	800531e <vTaskSuspend+0xaa>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
 8005312:	f7fe fdbb 	bl	8003e8c <vPortEnterCritical>
			{
				prvResetNextTaskUnblockTime();
 8005316:	f000 fd53 	bl	8005dc0 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
 800531a:	f7fe fde5 	bl	8003ee8 <vPortExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
 800531e:	4b17      	ldr	r3, [pc, #92]	; (800537c <vTaskSuspend+0x108>)
 8005320:	681b      	ldr	r3, [r3, #0]
 8005322:	68fa      	ldr	r2, [r7, #12]
 8005324:	429a      	cmp	r2, r3
 8005326:	d126      	bne.n	8005376 <vTaskSuspend+0x102>
		{
			if( xSchedulerRunning != pdFALSE )
 8005328:	4b18      	ldr	r3, [pc, #96]	; (800538c <vTaskSuspend+0x118>)
 800532a:	681b      	ldr	r3, [r3, #0]
 800532c:	2b00      	cmp	r3, #0
 800532e:	d016      	beq.n	800535e <vTaskSuspend+0xea>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
 8005330:	4b17      	ldr	r3, [pc, #92]	; (8005390 <vTaskSuspend+0x11c>)
 8005332:	681b      	ldr	r3, [r3, #0]
 8005334:	2b00      	cmp	r3, #0
 8005336:	d009      	beq.n	800534c <vTaskSuspend+0xd8>
 8005338:	f04f 0350 	mov.w	r3, #80	; 0x50
 800533c:	f383 8811 	msr	BASEPRI, r3
 8005340:	f3bf 8f6f 	isb	sy
 8005344:	f3bf 8f4f 	dsb	sy
 8005348:	60bb      	str	r3, [r7, #8]
 800534a:	e7fe      	b.n	800534a <vTaskSuspend+0xd6>
				portYIELD_WITHIN_API();
 800534c:	4b11      	ldr	r3, [pc, #68]	; (8005394 <vTaskSuspend+0x120>)
 800534e:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005352:	601a      	str	r2, [r3, #0]
 8005354:	f3bf 8f4f 	dsb	sy
 8005358:	f3bf 8f6f 	isb	sy
 800535c:	e00b      	b.n	8005376 <vTaskSuspend+0x102>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
 800535e:	4b0a      	ldr	r3, [pc, #40]	; (8005388 <vTaskSuspend+0x114>)
 8005360:	681a      	ldr	r2, [r3, #0]
 8005362:	4b0d      	ldr	r3, [pc, #52]	; (8005398 <vTaskSuspend+0x124>)
 8005364:	681b      	ldr	r3, [r3, #0]
 8005366:	429a      	cmp	r2, r3
 8005368:	d103      	bne.n	8005372 <vTaskSuspend+0xfe>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
 800536a:	4b04      	ldr	r3, [pc, #16]	; (800537c <vTaskSuspend+0x108>)
 800536c:	2200      	movs	r2, #0
 800536e:	601a      	str	r2, [r3, #0]
 8005370:	e001      	b.n	8005376 <vTaskSuspend+0x102>
				}
				else
				{
					vTaskSwitchContext();
 8005372:	f000 fa17 	bl	80057a4 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8005376:	3710      	adds	r7, #16
 8005378:	46bd      	mov	sp, r7
 800537a:	bd80      	pop	{r7, pc}
 800537c:	2000bbac 	.word	0x2000bbac
 8005380:	2000bbb0 	.word	0x2000bbb0
 8005384:	2000bcb4 	.word	0x2000bcb4
 8005388:	2000bc98 	.word	0x2000bc98
 800538c:	2000bcb8 	.word	0x2000bcb8
 8005390:	2000bcd4 	.word	0x2000bcd4
 8005394:	e000ed04 	.word	0xe000ed04
 8005398:	2000bcac 	.word	0x2000bcac

0800539c <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 800539c:	b580      	push	{r7, lr}
 800539e:	b086      	sub	sp, #24
 80053a0:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
 80053a2:	2300      	movs	r3, #0
 80053a4:	9300      	str	r3, [sp, #0]
 80053a6:	4b19      	ldr	r3, [pc, #100]	; (800540c <vTaskStartScheduler+0x70>)
 80053a8:	9301      	str	r3, [sp, #4]
 80053aa:	4819      	ldr	r0, [pc, #100]	; (8005410 <vTaskStartScheduler+0x74>)
 80053ac:	4919      	ldr	r1, [pc, #100]	; (8005414 <vTaskStartScheduler+0x78>)
 80053ae:	2280      	movs	r2, #128	; 0x80
 80053b0:	2300      	movs	r3, #0
 80053b2:	f7ff fdc1 	bl	8004f38 <xTaskCreate>
 80053b6:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 80053b8:	68fb      	ldr	r3, [r7, #12]
 80053ba:	2b01      	cmp	r3, #1
 80053bc:	d115      	bne.n	80053ea <vTaskStartScheduler+0x4e>
 80053be:	f04f 0350 	mov.w	r3, #80	; 0x50
 80053c2:	f383 8811 	msr	BASEPRI, r3
 80053c6:	f3bf 8f6f 	isb	sy
 80053ca:	f3bf 8f4f 	dsb	sy
 80053ce:	60bb      	str	r3, [r7, #8]
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 80053d0:	4b11      	ldr	r3, [pc, #68]	; (8005418 <vTaskStartScheduler+0x7c>)
 80053d2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80053d6:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 80053d8:	4b10      	ldr	r3, [pc, #64]	; (800541c <vTaskStartScheduler+0x80>)
 80053da:	2201      	movs	r2, #1
 80053dc:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 80053de:	4b10      	ldr	r3, [pc, #64]	; (8005420 <vTaskStartScheduler+0x84>)
 80053e0:	2200      	movs	r2, #0
 80053e2:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 80053e4:	f7fe fcc6 	bl	8003d74 <xPortStartScheduler>
 80053e8:	e00d      	b.n	8005406 <vTaskStartScheduler+0x6a>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 80053ea:	68fb      	ldr	r3, [r7, #12]
 80053ec:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80053f0:	d109      	bne.n	8005406 <vTaskStartScheduler+0x6a>
 80053f2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80053f6:	f383 8811 	msr	BASEPRI, r3
 80053fa:	f3bf 8f6f 	isb	sy
 80053fe:	f3bf 8f4f 	dsb	sy
 8005402:	607b      	str	r3, [r7, #4]
 8005404:	e7fe      	b.n	8005404 <vTaskStartScheduler+0x68>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 8005406:	3710      	adds	r7, #16
 8005408:	46bd      	mov	sp, r7
 800540a:	bd80      	pop	{r7, pc}
 800540c:	2000bcd0 	.word	0x2000bcd0
 8005410:	08005c7d 	.word	0x08005c7d
 8005414:	08012468 	.word	0x08012468
 8005418:	2000bccc 	.word	0x2000bccc
 800541c:	2000bcb8 	.word	0x2000bcb8
 8005420:	2000bcb0 	.word	0x2000bcb0

08005424 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 8005424:	b480      	push	{r7}
 8005426:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 8005428:	4b04      	ldr	r3, [pc, #16]	; (800543c <vTaskSuspendAll+0x18>)
 800542a:	681b      	ldr	r3, [r3, #0]
 800542c:	3301      	adds	r3, #1
 800542e:	4a03      	ldr	r2, [pc, #12]	; (800543c <vTaskSuspendAll+0x18>)
 8005430:	6013      	str	r3, [r2, #0]
}
 8005432:	46bd      	mov	sp, r7
 8005434:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005438:	4770      	bx	lr
 800543a:	bf00      	nop
 800543c:	2000bcd4 	.word	0x2000bcd4

08005440 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 8005440:	b580      	push	{r7, lr}
 8005442:	b084      	sub	sp, #16
 8005444:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
 8005446:	2300      	movs	r3, #0
 8005448:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
 800544a:	2300      	movs	r3, #0
 800544c:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 800544e:	4b44      	ldr	r3, [pc, #272]	; (8005560 <xTaskResumeAll+0x120>)
 8005450:	681b      	ldr	r3, [r3, #0]
 8005452:	2b00      	cmp	r3, #0
 8005454:	d109      	bne.n	800546a <xTaskResumeAll+0x2a>
 8005456:	f04f 0350 	mov.w	r3, #80	; 0x50
 800545a:	f383 8811 	msr	BASEPRI, r3
 800545e:	f3bf 8f6f 	isb	sy
 8005462:	f3bf 8f4f 	dsb	sy
 8005466:	603b      	str	r3, [r7, #0]
 8005468:	e7fe      	b.n	8005468 <xTaskResumeAll+0x28>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 800546a:	f7fe fd0f 	bl	8003e8c <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 800546e:	4b3c      	ldr	r3, [pc, #240]	; (8005560 <xTaskResumeAll+0x120>)
 8005470:	681b      	ldr	r3, [r3, #0]
 8005472:	3b01      	subs	r3, #1
 8005474:	4a3a      	ldr	r2, [pc, #232]	; (8005560 <xTaskResumeAll+0x120>)
 8005476:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8005478:	4b39      	ldr	r3, [pc, #228]	; (8005560 <xTaskResumeAll+0x120>)
 800547a:	681b      	ldr	r3, [r3, #0]
 800547c:	2b00      	cmp	r3, #0
 800547e:	d167      	bne.n	8005550 <xTaskResumeAll+0x110>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 8005480:	4b38      	ldr	r3, [pc, #224]	; (8005564 <xTaskResumeAll+0x124>)
 8005482:	681b      	ldr	r3, [r3, #0]
 8005484:	2b00      	cmp	r3, #0
 8005486:	d063      	beq.n	8005550 <xTaskResumeAll+0x110>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8005488:	e034      	b.n	80054f4 <xTaskResumeAll+0xb4>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800548a:	4b37      	ldr	r3, [pc, #220]	; (8005568 <xTaskResumeAll+0x128>)
 800548c:	68db      	ldr	r3, [r3, #12]
 800548e:	68db      	ldr	r3, [r3, #12]
 8005490:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8005492:	68fb      	ldr	r3, [r7, #12]
 8005494:	3318      	adds	r3, #24
 8005496:	4618      	mov	r0, r3
 8005498:	f7fe fbd0 	bl	8003c3c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800549c:	68fb      	ldr	r3, [r7, #12]
 800549e:	3304      	adds	r3, #4
 80054a0:	4618      	mov	r0, r3
 80054a2:	f7fe fbcb 	bl	8003c3c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80054a6:	68fb      	ldr	r3, [r7, #12]
 80054a8:	4618      	mov	r0, r3
 80054aa:	f00c fb99 	bl	8011be0 <SEGGER_SYSVIEW_OnTaskStartReady>
 80054ae:	68fb      	ldr	r3, [r7, #12]
 80054b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80054b2:	461a      	mov	r2, r3
 80054b4:	2301      	movs	r3, #1
 80054b6:	fa03 f202 	lsl.w	r2, r3, r2
 80054ba:	4b2c      	ldr	r3, [pc, #176]	; (800556c <xTaskResumeAll+0x12c>)
 80054bc:	681b      	ldr	r3, [r3, #0]
 80054be:	4313      	orrs	r3, r2
 80054c0:	4a2a      	ldr	r2, [pc, #168]	; (800556c <xTaskResumeAll+0x12c>)
 80054c2:	6013      	str	r3, [r2, #0]
 80054c4:	68fb      	ldr	r3, [r7, #12]
 80054c6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80054c8:	4613      	mov	r3, r2
 80054ca:	009b      	lsls	r3, r3, #2
 80054cc:	4413      	add	r3, r2
 80054ce:	009b      	lsls	r3, r3, #2
 80054d0:	4a27      	ldr	r2, [pc, #156]	; (8005570 <xTaskResumeAll+0x130>)
 80054d2:	441a      	add	r2, r3
 80054d4:	68fb      	ldr	r3, [r7, #12]
 80054d6:	3304      	adds	r3, #4
 80054d8:	4610      	mov	r0, r2
 80054da:	4619      	mov	r1, r3
 80054dc:	f7fe fb52 	bl	8003b84 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80054e0:	68fb      	ldr	r3, [r7, #12]
 80054e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80054e4:	4b23      	ldr	r3, [pc, #140]	; (8005574 <xTaskResumeAll+0x134>)
 80054e6:	681b      	ldr	r3, [r3, #0]
 80054e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80054ea:	429a      	cmp	r2, r3
 80054ec:	d302      	bcc.n	80054f4 <xTaskResumeAll+0xb4>
					{
						xYieldPending = pdTRUE;
 80054ee:	4b22      	ldr	r3, [pc, #136]	; (8005578 <xTaskResumeAll+0x138>)
 80054f0:	2201      	movs	r2, #1
 80054f2:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 80054f4:	4b1c      	ldr	r3, [pc, #112]	; (8005568 <xTaskResumeAll+0x128>)
 80054f6:	681b      	ldr	r3, [r3, #0]
 80054f8:	2b00      	cmp	r3, #0
 80054fa:	d1c6      	bne.n	800548a <xTaskResumeAll+0x4a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 80054fc:	68fb      	ldr	r3, [r7, #12]
 80054fe:	2b00      	cmp	r3, #0
 8005500:	d001      	beq.n	8005506 <xTaskResumeAll+0xc6>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 8005502:	f000 fc5d 	bl	8005dc0 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8005506:	4b1d      	ldr	r3, [pc, #116]	; (800557c <xTaskResumeAll+0x13c>)
 8005508:	681b      	ldr	r3, [r3, #0]
 800550a:	607b      	str	r3, [r7, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 800550c:	687b      	ldr	r3, [r7, #4]
 800550e:	2b00      	cmp	r3, #0
 8005510:	d010      	beq.n	8005534 <xTaskResumeAll+0xf4>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 8005512:	f000 f87d 	bl	8005610 <xTaskIncrementTick>
 8005516:	4603      	mov	r3, r0
 8005518:	2b00      	cmp	r3, #0
 800551a:	d002      	beq.n	8005522 <xTaskResumeAll+0xe2>
							{
								xYieldPending = pdTRUE;
 800551c:	4b16      	ldr	r3, [pc, #88]	; (8005578 <xTaskResumeAll+0x138>)
 800551e:	2201      	movs	r2, #1
 8005520:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
 8005522:	687b      	ldr	r3, [r7, #4]
 8005524:	3b01      	subs	r3, #1
 8005526:	607b      	str	r3, [r7, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 8005528:	687b      	ldr	r3, [r7, #4]
 800552a:	2b00      	cmp	r3, #0
 800552c:	d1f1      	bne.n	8005512 <xTaskResumeAll+0xd2>

						uxPendedTicks = 0;
 800552e:	4b13      	ldr	r3, [pc, #76]	; (800557c <xTaskResumeAll+0x13c>)
 8005530:	2200      	movs	r2, #0
 8005532:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 8005534:	4b10      	ldr	r3, [pc, #64]	; (8005578 <xTaskResumeAll+0x138>)
 8005536:	681b      	ldr	r3, [r3, #0]
 8005538:	2b00      	cmp	r3, #0
 800553a:	d009      	beq.n	8005550 <xTaskResumeAll+0x110>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 800553c:	2301      	movs	r3, #1
 800553e:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 8005540:	4b0f      	ldr	r3, [pc, #60]	; (8005580 <xTaskResumeAll+0x140>)
 8005542:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005546:	601a      	str	r2, [r3, #0]
 8005548:	f3bf 8f4f 	dsb	sy
 800554c:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 8005550:	f7fe fcca 	bl	8003ee8 <vPortExitCritical>

	return xAlreadyYielded;
 8005554:	68bb      	ldr	r3, [r7, #8]
}
 8005556:	4618      	mov	r0, r3
 8005558:	3710      	adds	r7, #16
 800555a:	46bd      	mov	sp, r7
 800555c:	bd80      	pop	{r7, pc}
 800555e:	bf00      	nop
 8005560:	2000bcd4 	.word	0x2000bcd4
 8005564:	2000bcac 	.word	0x2000bcac
 8005568:	2000bc6c 	.word	0x2000bc6c
 800556c:	2000bcb4 	.word	0x2000bcb4
 8005570:	2000bbb0 	.word	0x2000bbb0
 8005574:	2000bbac 	.word	0x2000bbac
 8005578:	2000bcc0 	.word	0x2000bcc0
 800557c:	2000bcbc 	.word	0x2000bcbc
 8005580:	e000ed04 	.word	0xe000ed04

08005584 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 8005584:	b480      	push	{r7}
 8005586:	b083      	sub	sp, #12
 8005588:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 800558a:	4b05      	ldr	r3, [pc, #20]	; (80055a0 <xTaskGetTickCount+0x1c>)
 800558c:	681b      	ldr	r3, [r3, #0]
 800558e:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 8005590:	687b      	ldr	r3, [r7, #4]
}
 8005592:	4618      	mov	r0, r3
 8005594:	370c      	adds	r7, #12
 8005596:	46bd      	mov	sp, r7
 8005598:	f85d 7b04 	ldr.w	r7, [sp], #4
 800559c:	4770      	bx	lr
 800559e:	bf00      	nop
 80055a0:	2000bcb0 	.word	0x2000bcb0

080055a4 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
 80055a4:	b580      	push	{r7, lr}
 80055a6:	b082      	sub	sp, #8
 80055a8:	af00      	add	r7, sp, #0
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80055aa:	f7fe fd45 	bl	8004038 <vPortValidateInterruptPriority>

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
 80055ae:	2300      	movs	r3, #0
 80055b0:	607b      	str	r3, [r7, #4]
	{
		xReturn = xTickCount;
 80055b2:	4b04      	ldr	r3, [pc, #16]	; (80055c4 <xTaskGetTickCountFromISR+0x20>)
 80055b4:	681b      	ldr	r3, [r3, #0]
 80055b6:	603b      	str	r3, [r7, #0]
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 80055b8:	683b      	ldr	r3, [r7, #0]
}
 80055ba:	4618      	mov	r0, r3
 80055bc:	3708      	adds	r7, #8
 80055be:	46bd      	mov	sp, r7
 80055c0:	bd80      	pop	{r7, pc}
 80055c2:	bf00      	nop
 80055c4:	2000bcb0 	.word	0x2000bcb0

080055c8 <pcTaskGetName>:
	return uxCurrentNumberOfTasks;
}
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 80055c8:	b480      	push	{r7}
 80055ca:	b085      	sub	sp, #20
 80055cc:	af00      	add	r7, sp, #0
 80055ce:	6078      	str	r0, [r7, #4]
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
 80055d0:	687b      	ldr	r3, [r7, #4]
 80055d2:	2b00      	cmp	r3, #0
 80055d4:	d102      	bne.n	80055dc <pcTaskGetName+0x14>
 80055d6:	4b0d      	ldr	r3, [pc, #52]	; (800560c <pcTaskGetName+0x44>)
 80055d8:	681b      	ldr	r3, [r3, #0]
 80055da:	e000      	b.n	80055de <pcTaskGetName+0x16>
 80055dc:	687b      	ldr	r3, [r7, #4]
 80055de:	60fb      	str	r3, [r7, #12]
	configASSERT( pxTCB );
 80055e0:	68fb      	ldr	r3, [r7, #12]
 80055e2:	2b00      	cmp	r3, #0
 80055e4:	d109      	bne.n	80055fa <pcTaskGetName+0x32>
 80055e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80055ea:	f383 8811 	msr	BASEPRI, r3
 80055ee:	f3bf 8f6f 	isb	sy
 80055f2:	f3bf 8f4f 	dsb	sy
 80055f6:	60bb      	str	r3, [r7, #8]
 80055f8:	e7fe      	b.n	80055f8 <pcTaskGetName+0x30>
	return &( pxTCB->pcTaskName[ 0 ] );
 80055fa:	68fb      	ldr	r3, [r7, #12]
 80055fc:	3334      	adds	r3, #52	; 0x34
}
 80055fe:	4618      	mov	r0, r3
 8005600:	3714      	adds	r7, #20
 8005602:	46bd      	mov	sp, r7
 8005604:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005608:	4770      	bx	lr
 800560a:	bf00      	nop
 800560c:	2000bbac 	.word	0x2000bbac

08005610 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 8005610:	b580      	push	{r7, lr}
 8005612:	b086      	sub	sp, #24
 8005614:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 8005616:	2300      	movs	r3, #0
 8005618:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800561a:	4b57      	ldr	r3, [pc, #348]	; (8005778 <xTaskIncrementTick+0x168>)
 800561c:	681b      	ldr	r3, [r3, #0]
 800561e:	2b00      	cmp	r3, #0
 8005620:	f040 8098 	bne.w	8005754 <xTaskIncrementTick+0x144>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
 8005624:	4b55      	ldr	r3, [pc, #340]	; (800577c <xTaskIncrementTick+0x16c>)
 8005626:	681b      	ldr	r3, [r3, #0]
 8005628:	3301      	adds	r3, #1
 800562a:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 800562c:	4a53      	ldr	r2, [pc, #332]	; (800577c <xTaskIncrementTick+0x16c>)
 800562e:	693b      	ldr	r3, [r7, #16]
 8005630:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U )
 8005632:	693b      	ldr	r3, [r7, #16]
 8005634:	2b00      	cmp	r3, #0
 8005636:	d11f      	bne.n	8005678 <xTaskIncrementTick+0x68>
		{
			taskSWITCH_DELAYED_LISTS();
 8005638:	4b51      	ldr	r3, [pc, #324]	; (8005780 <xTaskIncrementTick+0x170>)
 800563a:	681b      	ldr	r3, [r3, #0]
 800563c:	681b      	ldr	r3, [r3, #0]
 800563e:	2b00      	cmp	r3, #0
 8005640:	d009      	beq.n	8005656 <xTaskIncrementTick+0x46>
 8005642:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005646:	f383 8811 	msr	BASEPRI, r3
 800564a:	f3bf 8f6f 	isb	sy
 800564e:	f3bf 8f4f 	dsb	sy
 8005652:	603b      	str	r3, [r7, #0]
 8005654:	e7fe      	b.n	8005654 <xTaskIncrementTick+0x44>
 8005656:	4b4a      	ldr	r3, [pc, #296]	; (8005780 <xTaskIncrementTick+0x170>)
 8005658:	681b      	ldr	r3, [r3, #0]
 800565a:	60fb      	str	r3, [r7, #12]
 800565c:	4b49      	ldr	r3, [pc, #292]	; (8005784 <xTaskIncrementTick+0x174>)
 800565e:	681b      	ldr	r3, [r3, #0]
 8005660:	4a47      	ldr	r2, [pc, #284]	; (8005780 <xTaskIncrementTick+0x170>)
 8005662:	6013      	str	r3, [r2, #0]
 8005664:	4a47      	ldr	r2, [pc, #284]	; (8005784 <xTaskIncrementTick+0x174>)
 8005666:	68fb      	ldr	r3, [r7, #12]
 8005668:	6013      	str	r3, [r2, #0]
 800566a:	4b47      	ldr	r3, [pc, #284]	; (8005788 <xTaskIncrementTick+0x178>)
 800566c:	681b      	ldr	r3, [r3, #0]
 800566e:	3301      	adds	r3, #1
 8005670:	4a45      	ldr	r2, [pc, #276]	; (8005788 <xTaskIncrementTick+0x178>)
 8005672:	6013      	str	r3, [r2, #0]
 8005674:	f000 fba4 	bl	8005dc0 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 8005678:	4b44      	ldr	r3, [pc, #272]	; (800578c <xTaskIncrementTick+0x17c>)
 800567a:	681b      	ldr	r3, [r3, #0]
 800567c:	693a      	ldr	r2, [r7, #16]
 800567e:	429a      	cmp	r2, r3
 8005680:	d353      	bcc.n	800572a <xTaskIncrementTick+0x11a>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8005682:	4b3f      	ldr	r3, [pc, #252]	; (8005780 <xTaskIncrementTick+0x170>)
 8005684:	681b      	ldr	r3, [r3, #0]
 8005686:	681b      	ldr	r3, [r3, #0]
 8005688:	2b00      	cmp	r3, #0
 800568a:	d101      	bne.n	8005690 <xTaskIncrementTick+0x80>
 800568c:	2301      	movs	r3, #1
 800568e:	e000      	b.n	8005692 <xTaskIncrementTick+0x82>
 8005690:	2300      	movs	r3, #0
 8005692:	2b00      	cmp	r3, #0
 8005694:	d004      	beq.n	80056a0 <xTaskIncrementTick+0x90>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005696:	4b3d      	ldr	r3, [pc, #244]	; (800578c <xTaskIncrementTick+0x17c>)
 8005698:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800569c:	601a      	str	r2, [r3, #0]
					break;
 800569e:	e044      	b.n	800572a <xTaskIncrementTick+0x11a>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 80056a0:	4b37      	ldr	r3, [pc, #220]	; (8005780 <xTaskIncrementTick+0x170>)
 80056a2:	681b      	ldr	r3, [r3, #0]
 80056a4:	68db      	ldr	r3, [r3, #12]
 80056a6:	68db      	ldr	r3, [r3, #12]
 80056a8:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 80056aa:	68bb      	ldr	r3, [r7, #8]
 80056ac:	685b      	ldr	r3, [r3, #4]
 80056ae:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
 80056b0:	693a      	ldr	r2, [r7, #16]
 80056b2:	687b      	ldr	r3, [r7, #4]
 80056b4:	429a      	cmp	r2, r3
 80056b6:	d203      	bcs.n	80056c0 <xTaskIncrementTick+0xb0>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 80056b8:	4a34      	ldr	r2, [pc, #208]	; (800578c <xTaskIncrementTick+0x17c>)
 80056ba:	687b      	ldr	r3, [r7, #4]
 80056bc:	6013      	str	r3, [r2, #0]
						break;
 80056be:	e034      	b.n	800572a <xTaskIncrementTick+0x11a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80056c0:	68bb      	ldr	r3, [r7, #8]
 80056c2:	3304      	adds	r3, #4
 80056c4:	4618      	mov	r0, r3
 80056c6:	f7fe fab9 	bl	8003c3c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80056ca:	68bb      	ldr	r3, [r7, #8]
 80056cc:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80056ce:	2b00      	cmp	r3, #0
 80056d0:	d004      	beq.n	80056dc <xTaskIncrementTick+0xcc>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80056d2:	68bb      	ldr	r3, [r7, #8]
 80056d4:	3318      	adds	r3, #24
 80056d6:	4618      	mov	r0, r3
 80056d8:	f7fe fab0 	bl	8003c3c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 80056dc:	68bb      	ldr	r3, [r7, #8]
 80056de:	4618      	mov	r0, r3
 80056e0:	f00c fa7e 	bl	8011be0 <SEGGER_SYSVIEW_OnTaskStartReady>
 80056e4:	68bb      	ldr	r3, [r7, #8]
 80056e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80056e8:	461a      	mov	r2, r3
 80056ea:	2301      	movs	r3, #1
 80056ec:	fa03 f202 	lsl.w	r2, r3, r2
 80056f0:	4b27      	ldr	r3, [pc, #156]	; (8005790 <xTaskIncrementTick+0x180>)
 80056f2:	681b      	ldr	r3, [r3, #0]
 80056f4:	4313      	orrs	r3, r2
 80056f6:	4a26      	ldr	r2, [pc, #152]	; (8005790 <xTaskIncrementTick+0x180>)
 80056f8:	6013      	str	r3, [r2, #0]
 80056fa:	68bb      	ldr	r3, [r7, #8]
 80056fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80056fe:	4613      	mov	r3, r2
 8005700:	009b      	lsls	r3, r3, #2
 8005702:	4413      	add	r3, r2
 8005704:	009b      	lsls	r3, r3, #2
 8005706:	4a23      	ldr	r2, [pc, #140]	; (8005794 <xTaskIncrementTick+0x184>)
 8005708:	441a      	add	r2, r3
 800570a:	68bb      	ldr	r3, [r7, #8]
 800570c:	3304      	adds	r3, #4
 800570e:	4610      	mov	r0, r2
 8005710:	4619      	mov	r1, r3
 8005712:	f7fe fa37 	bl	8003b84 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8005716:	68bb      	ldr	r3, [r7, #8]
 8005718:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800571a:	4b1f      	ldr	r3, [pc, #124]	; (8005798 <xTaskIncrementTick+0x188>)
 800571c:	681b      	ldr	r3, [r3, #0]
 800571e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005720:	429a      	cmp	r2, r3
 8005722:	d301      	bcc.n	8005728 <xTaskIncrementTick+0x118>
						{
							xSwitchRequired = pdTRUE;
 8005724:	2301      	movs	r3, #1
 8005726:	617b      	str	r3, [r7, #20]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
 8005728:	e7ab      	b.n	8005682 <xTaskIncrementTick+0x72>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 800572a:	4b1b      	ldr	r3, [pc, #108]	; (8005798 <xTaskIncrementTick+0x188>)
 800572c:	681b      	ldr	r3, [r3, #0]
 800572e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005730:	4918      	ldr	r1, [pc, #96]	; (8005794 <xTaskIncrementTick+0x184>)
 8005732:	4613      	mov	r3, r2
 8005734:	009b      	lsls	r3, r3, #2
 8005736:	4413      	add	r3, r2
 8005738:	009b      	lsls	r3, r3, #2
 800573a:	440b      	add	r3, r1
 800573c:	681b      	ldr	r3, [r3, #0]
 800573e:	2b01      	cmp	r3, #1
 8005740:	d901      	bls.n	8005746 <xTaskIncrementTick+0x136>
			{
				xSwitchRequired = pdTRUE;
 8005742:	2301      	movs	r3, #1
 8005744:	617b      	str	r3, [r7, #20]

		#if ( configUSE_TICK_HOOK == 1 )
		{
			/* Guard against the tick hook being called when the pended tick
			count is being unwound (when the scheduler is being unlocked). */
			if( uxPendedTicks == ( UBaseType_t ) 0U )
 8005746:	4b15      	ldr	r3, [pc, #84]	; (800579c <xTaskIncrementTick+0x18c>)
 8005748:	681b      	ldr	r3, [r3, #0]
 800574a:	2b00      	cmp	r3, #0
 800574c:	d101      	bne.n	8005752 <xTaskIncrementTick+0x142>
			{
				vApplicationTickHook();
 800574e:	f009 ff1d 	bl	800f58c <vApplicationTickHook>
 8005752:	e006      	b.n	8005762 <xTaskIncrementTick+0x152>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 8005754:	4b11      	ldr	r3, [pc, #68]	; (800579c <xTaskIncrementTick+0x18c>)
 8005756:	681b      	ldr	r3, [r3, #0]
 8005758:	3301      	adds	r3, #1
 800575a:	4a10      	ldr	r2, [pc, #64]	; (800579c <xTaskIncrementTick+0x18c>)
 800575c:	6013      	str	r3, [r2, #0]

		/* The tick hook gets called at regular intervals, even if the
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			vApplicationTickHook();
 800575e:	f009 ff15 	bl	800f58c <vApplicationTickHook>
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8005762:	4b0f      	ldr	r3, [pc, #60]	; (80057a0 <xTaskIncrementTick+0x190>)
 8005764:	681b      	ldr	r3, [r3, #0]
 8005766:	2b00      	cmp	r3, #0
 8005768:	d001      	beq.n	800576e <xTaskIncrementTick+0x15e>
		{
			xSwitchRequired = pdTRUE;
 800576a:	2301      	movs	r3, #1
 800576c:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
 800576e:	697b      	ldr	r3, [r7, #20]
}
 8005770:	4618      	mov	r0, r3
 8005772:	3718      	adds	r7, #24
 8005774:	46bd      	mov	sp, r7
 8005776:	bd80      	pop	{r7, pc}
 8005778:	2000bcd4 	.word	0x2000bcd4
 800577c:	2000bcb0 	.word	0x2000bcb0
 8005780:	2000bc64 	.word	0x2000bc64
 8005784:	2000bc68 	.word	0x2000bc68
 8005788:	2000bcc4 	.word	0x2000bcc4
 800578c:	2000bccc 	.word	0x2000bccc
 8005790:	2000bcb4 	.word	0x2000bcb4
 8005794:	2000bbb0 	.word	0x2000bbb0
 8005798:	2000bbac 	.word	0x2000bbac
 800579c:	2000bcbc 	.word	0x2000bcbc
 80057a0:	2000bcc0 	.word	0x2000bcc0

080057a4 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 80057a4:	b580      	push	{r7, lr}
 80057a6:	b088      	sub	sp, #32
 80057a8:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80057aa:	4b4e      	ldr	r3, [pc, #312]	; (80058e4 <vTaskSwitchContext+0x140>)
 80057ac:	681b      	ldr	r3, [r3, #0]
 80057ae:	2b00      	cmp	r3, #0
 80057b0:	d003      	beq.n	80057ba <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 80057b2:	4b4d      	ldr	r3, [pc, #308]	; (80058e8 <vTaskSwitchContext+0x144>)
 80057b4:	2201      	movs	r2, #1
 80057b6:	601a      	str	r2, [r3, #0]
 80057b8:	e091      	b.n	80058de <vTaskSwitchContext+0x13a>
	}
	else
	{
		xYieldPending = pdFALSE;
 80057ba:	4b4b      	ldr	r3, [pc, #300]	; (80058e8 <vTaskSwitchContext+0x144>)
 80057bc:	2200      	movs	r2, #0
 80057be:	601a      	str	r2, [r3, #0]
		#if ( configGENERATE_RUN_TIME_STATS == 1 )
		{
				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
				#else
					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
 80057c0:	f009 fed4 	bl	800f56c <xGetRunTimeCounterValue>
 80057c4:	4602      	mov	r2, r0
 80057c6:	4b49      	ldr	r3, [pc, #292]	; (80058ec <vTaskSwitchContext+0x148>)
 80057c8:	601a      	str	r2, [r3, #0]
				stored in ulTaskSwitchedInTime.  Note that there is no overflow
				protection here so count values are only valid until the timer
				overflows.  The guard against negative values is to protect
				against suspect run time stat counter implementations - which
				are provided by the application, not the kernel. */
				if( ulTotalRunTime > ulTaskSwitchedInTime )
 80057ca:	4b48      	ldr	r3, [pc, #288]	; (80058ec <vTaskSwitchContext+0x148>)
 80057cc:	681a      	ldr	r2, [r3, #0]
 80057ce:	4b48      	ldr	r3, [pc, #288]	; (80058f0 <vTaskSwitchContext+0x14c>)
 80057d0:	681b      	ldr	r3, [r3, #0]
 80057d2:	429a      	cmp	r2, r3
 80057d4:	d909      	bls.n	80057ea <vTaskSwitchContext+0x46>
				{
					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
 80057d6:	4b47      	ldr	r3, [pc, #284]	; (80058f4 <vTaskSwitchContext+0x150>)
 80057d8:	681b      	ldr	r3, [r3, #0]
 80057da:	6e19      	ldr	r1, [r3, #96]	; 0x60
 80057dc:	4a43      	ldr	r2, [pc, #268]	; (80058ec <vTaskSwitchContext+0x148>)
 80057de:	6810      	ldr	r0, [r2, #0]
 80057e0:	4a43      	ldr	r2, [pc, #268]	; (80058f0 <vTaskSwitchContext+0x14c>)
 80057e2:	6812      	ldr	r2, [r2, #0]
 80057e4:	1a82      	subs	r2, r0, r2
 80057e6:	440a      	add	r2, r1
 80057e8:	661a      	str	r2, [r3, #96]	; 0x60
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				ulTaskSwitchedInTime = ulTotalRunTime;
 80057ea:	4b40      	ldr	r3, [pc, #256]	; (80058ec <vTaskSwitchContext+0x148>)
 80057ec:	681b      	ldr	r3, [r3, #0]
 80057ee:	4a40      	ldr	r2, [pc, #256]	; (80058f0 <vTaskSwitchContext+0x14c>)
 80057f0:	6013      	str	r3, [r2, #0]
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
 80057f2:	4b40      	ldr	r3, [pc, #256]	; (80058f4 <vTaskSwitchContext+0x150>)
 80057f4:	681b      	ldr	r3, [r3, #0]
 80057f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80057f8:	61fb      	str	r3, [r7, #28]
 80057fa:	f04f 33a5 	mov.w	r3, #2779096485	; 0xa5a5a5a5
 80057fe:	61bb      	str	r3, [r7, #24]
 8005800:	69fb      	ldr	r3, [r7, #28]
 8005802:	681a      	ldr	r2, [r3, #0]
 8005804:	69bb      	ldr	r3, [r7, #24]
 8005806:	429a      	cmp	r2, r3
 8005808:	d111      	bne.n	800582e <vTaskSwitchContext+0x8a>
 800580a:	69fb      	ldr	r3, [r7, #28]
 800580c:	3304      	adds	r3, #4
 800580e:	681a      	ldr	r2, [r3, #0]
 8005810:	69bb      	ldr	r3, [r7, #24]
 8005812:	429a      	cmp	r2, r3
 8005814:	d10b      	bne.n	800582e <vTaskSwitchContext+0x8a>
 8005816:	69fb      	ldr	r3, [r7, #28]
 8005818:	3308      	adds	r3, #8
 800581a:	681a      	ldr	r2, [r3, #0]
 800581c:	69bb      	ldr	r3, [r7, #24]
 800581e:	429a      	cmp	r2, r3
 8005820:	d105      	bne.n	800582e <vTaskSwitchContext+0x8a>
 8005822:	69fb      	ldr	r3, [r7, #28]
 8005824:	330c      	adds	r3, #12
 8005826:	681a      	ldr	r2, [r3, #0]
 8005828:	69bb      	ldr	r3, [r7, #24]
 800582a:	429a      	cmp	r2, r3
 800582c:	d008      	beq.n	8005840 <vTaskSwitchContext+0x9c>
 800582e:	4b31      	ldr	r3, [pc, #196]	; (80058f4 <vTaskSwitchContext+0x150>)
 8005830:	681a      	ldr	r2, [r3, #0]
 8005832:	4b30      	ldr	r3, [pc, #192]	; (80058f4 <vTaskSwitchContext+0x150>)
 8005834:	681b      	ldr	r3, [r3, #0]
 8005836:	3334      	adds	r3, #52	; 0x34
 8005838:	4610      	mov	r0, r2
 800583a:	4619      	mov	r1, r3
 800583c:	f009 fdca 	bl	800f3d4 <vApplicationStackOverflowHook>

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 8005840:	4b2d      	ldr	r3, [pc, #180]	; (80058f8 <vTaskSwitchContext+0x154>)
 8005842:	681b      	ldr	r3, [r3, #0]
 8005844:	60fb      	str	r3, [r7, #12]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 8005846:	68fb      	ldr	r3, [r7, #12]
 8005848:	fab3 f383 	clz	r3, r3
 800584c:	72fb      	strb	r3, [r7, #11]
		return ucReturn;
 800584e:	7afb      	ldrb	r3, [r7, #11]
 8005850:	f1c3 031f 	rsb	r3, r3, #31
 8005854:	617b      	str	r3, [r7, #20]
 8005856:	4929      	ldr	r1, [pc, #164]	; (80058fc <vTaskSwitchContext+0x158>)
 8005858:	697a      	ldr	r2, [r7, #20]
 800585a:	4613      	mov	r3, r2
 800585c:	009b      	lsls	r3, r3, #2
 800585e:	4413      	add	r3, r2
 8005860:	009b      	lsls	r3, r3, #2
 8005862:	440b      	add	r3, r1
 8005864:	681b      	ldr	r3, [r3, #0]
 8005866:	2b00      	cmp	r3, #0
 8005868:	d109      	bne.n	800587e <vTaskSwitchContext+0xda>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 800586a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800586e:	f383 8811 	msr	BASEPRI, r3
 8005872:	f3bf 8f6f 	isb	sy
 8005876:	f3bf 8f4f 	dsb	sy
 800587a:	607b      	str	r3, [r7, #4]
 800587c:	e7fe      	b.n	800587c <vTaskSwitchContext+0xd8>
 800587e:	697a      	ldr	r2, [r7, #20]
 8005880:	4613      	mov	r3, r2
 8005882:	009b      	lsls	r3, r3, #2
 8005884:	4413      	add	r3, r2
 8005886:	009b      	lsls	r3, r3, #2
 8005888:	4a1c      	ldr	r2, [pc, #112]	; (80058fc <vTaskSwitchContext+0x158>)
 800588a:	4413      	add	r3, r2
 800588c:	613b      	str	r3, [r7, #16]
 800588e:	693b      	ldr	r3, [r7, #16]
 8005890:	685b      	ldr	r3, [r3, #4]
 8005892:	685a      	ldr	r2, [r3, #4]
 8005894:	693b      	ldr	r3, [r7, #16]
 8005896:	605a      	str	r2, [r3, #4]
 8005898:	693b      	ldr	r3, [r7, #16]
 800589a:	685a      	ldr	r2, [r3, #4]
 800589c:	693b      	ldr	r3, [r7, #16]
 800589e:	3308      	adds	r3, #8
 80058a0:	429a      	cmp	r2, r3
 80058a2:	d104      	bne.n	80058ae <vTaskSwitchContext+0x10a>
 80058a4:	693b      	ldr	r3, [r7, #16]
 80058a6:	685b      	ldr	r3, [r3, #4]
 80058a8:	685a      	ldr	r2, [r3, #4]
 80058aa:	693b      	ldr	r3, [r7, #16]
 80058ac:	605a      	str	r2, [r3, #4]
 80058ae:	693b      	ldr	r3, [r7, #16]
 80058b0:	685b      	ldr	r3, [r3, #4]
 80058b2:	68db      	ldr	r3, [r3, #12]
 80058b4:	4a0f      	ldr	r2, [pc, #60]	; (80058f4 <vTaskSwitchContext+0x150>)
 80058b6:	6013      	str	r3, [r2, #0]
		traceTASK_SWITCHED_IN();
 80058b8:	4b0e      	ldr	r3, [pc, #56]	; (80058f4 <vTaskSwitchContext+0x150>)
 80058ba:	681b      	ldr	r3, [r3, #0]
 80058bc:	3334      	adds	r3, #52	; 0x34
 80058be:	4618      	mov	r0, r3
 80058c0:	490f      	ldr	r1, [pc, #60]	; (8005900 <vTaskSwitchContext+0x15c>)
 80058c2:	2205      	movs	r2, #5
 80058c4:	f00c fd2e 	bl	8012324 <memcmp>
 80058c8:	4603      	mov	r3, r0
 80058ca:	2b00      	cmp	r3, #0
 80058cc:	d005      	beq.n	80058da <vTaskSwitchContext+0x136>
 80058ce:	4b09      	ldr	r3, [pc, #36]	; (80058f4 <vTaskSwitchContext+0x150>)
 80058d0:	681b      	ldr	r3, [r3, #0]
 80058d2:	4618      	mov	r0, r3
 80058d4:	f00c f942 	bl	8011b5c <SEGGER_SYSVIEW_OnTaskStartExec>
 80058d8:	e001      	b.n	80058de <vTaskSwitchContext+0x13a>
 80058da:	f00c f8e1 	bl	8011aa0 <SEGGER_SYSVIEW_OnIdle>
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 80058de:	3720      	adds	r7, #32
 80058e0:	46bd      	mov	sp, r7
 80058e2:	bd80      	pop	{r7, pc}
 80058e4:	2000bcd4 	.word	0x2000bcd4
 80058e8:	2000bcc0 	.word	0x2000bcc0
 80058ec:	2000bcdc 	.word	0x2000bcdc
 80058f0:	2000bcd8 	.word	0x2000bcd8
 80058f4:	2000bbac 	.word	0x2000bbac
 80058f8:	2000bcb4 	.word	0x2000bcb4
 80058fc:	2000bbb0 	.word	0x2000bbb0
 8005900:	08012468 	.word	0x08012468

08005904 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 8005904:	b580      	push	{r7, lr}
 8005906:	b084      	sub	sp, #16
 8005908:	af00      	add	r7, sp, #0
 800590a:	6078      	str	r0, [r7, #4]
 800590c:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
 800590e:	687b      	ldr	r3, [r7, #4]
 8005910:	2b00      	cmp	r3, #0
 8005912:	d109      	bne.n	8005928 <vTaskPlaceOnEventList+0x24>
 8005914:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005918:	f383 8811 	msr	BASEPRI, r3
 800591c:	f3bf 8f6f 	isb	sy
 8005920:	f3bf 8f4f 	dsb	sy
 8005924:	60fb      	str	r3, [r7, #12]
 8005926:	e7fe      	b.n	8005926 <vTaskPlaceOnEventList+0x22>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8005928:	4b06      	ldr	r3, [pc, #24]	; (8005944 <vTaskPlaceOnEventList+0x40>)
 800592a:	681b      	ldr	r3, [r3, #0]
 800592c:	3318      	adds	r3, #24
 800592e:	6878      	ldr	r0, [r7, #4]
 8005930:	4619      	mov	r1, r3
 8005932:	f7fe f94b 	bl	8003bcc <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 8005936:	6838      	ldr	r0, [r7, #0]
 8005938:	2101      	movs	r1, #1
 800593a:	f000 fd67 	bl	800640c <prvAddCurrentTaskToDelayedList>
}
 800593e:	3710      	adds	r7, #16
 8005940:	46bd      	mov	sp, r7
 8005942:	bd80      	pop	{r7, pc}
 8005944:	2000bbac 	.word	0x2000bbac

08005948 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
 8005948:	b580      	push	{r7, lr}
 800594a:	b086      	sub	sp, #24
 800594c:	af00      	add	r7, sp, #0
 800594e:	60f8      	str	r0, [r7, #12]
 8005950:	60b9      	str	r1, [r7, #8]
 8005952:	607a      	str	r2, [r7, #4]
	configASSERT( pxEventList );
 8005954:	68fb      	ldr	r3, [r7, #12]
 8005956:	2b00      	cmp	r3, #0
 8005958:	d109      	bne.n	800596e <vTaskPlaceOnUnorderedEventList+0x26>
 800595a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800595e:	f383 8811 	msr	BASEPRI, r3
 8005962:	f3bf 8f6f 	isb	sy
 8005966:	f3bf 8f4f 	dsb	sy
 800596a:	617b      	str	r3, [r7, #20]
 800596c:	e7fe      	b.n	800596c <vTaskPlaceOnUnorderedEventList+0x24>

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event groups implementation. */
	configASSERT( uxSchedulerSuspended != 0 );
 800596e:	4b11      	ldr	r3, [pc, #68]	; (80059b4 <vTaskPlaceOnUnorderedEventList+0x6c>)
 8005970:	681b      	ldr	r3, [r3, #0]
 8005972:	2b00      	cmp	r3, #0
 8005974:	d109      	bne.n	800598a <vTaskPlaceOnUnorderedEventList+0x42>
 8005976:	f04f 0350 	mov.w	r3, #80	; 0x50
 800597a:	f383 8811 	msr	BASEPRI, r3
 800597e:	f3bf 8f6f 	isb	sy
 8005982:	f3bf 8f4f 	dsb	sy
 8005986:	613b      	str	r3, [r7, #16]
 8005988:	e7fe      	b.n	8005988 <vTaskPlaceOnUnorderedEventList+0x40>

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 800598a:	4b0b      	ldr	r3, [pc, #44]	; (80059b8 <vTaskPlaceOnUnorderedEventList+0x70>)
 800598c:	681b      	ldr	r3, [r3, #0]
 800598e:	68ba      	ldr	r2, [r7, #8]
 8005990:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8005994:	619a      	str	r2, [r3, #24]
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 8005996:	4b08      	ldr	r3, [pc, #32]	; (80059b8 <vTaskPlaceOnUnorderedEventList+0x70>)
 8005998:	681b      	ldr	r3, [r3, #0]
 800599a:	3318      	adds	r3, #24
 800599c:	68f8      	ldr	r0, [r7, #12]
 800599e:	4619      	mov	r1, r3
 80059a0:	f7fe f8f0 	bl	8003b84 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80059a4:	6878      	ldr	r0, [r7, #4]
 80059a6:	2101      	movs	r1, #1
 80059a8:	f000 fd30 	bl	800640c <prvAddCurrentTaskToDelayedList>
}
 80059ac:	3718      	adds	r7, #24
 80059ae:	46bd      	mov	sp, r7
 80059b0:	bd80      	pop	{r7, pc}
 80059b2:	bf00      	nop
 80059b4:	2000bcd4 	.word	0x2000bcd4
 80059b8:	2000bbac 	.word	0x2000bbac

080059bc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 80059bc:	b580      	push	{r7, lr}
 80059be:	b086      	sub	sp, #24
 80059c0:	af00      	add	r7, sp, #0
 80059c2:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 80059c4:	687b      	ldr	r3, [r7, #4]
 80059c6:	68db      	ldr	r3, [r3, #12]
 80059c8:	68db      	ldr	r3, [r3, #12]
 80059ca:	613b      	str	r3, [r7, #16]
	configASSERT( pxUnblockedTCB );
 80059cc:	693b      	ldr	r3, [r7, #16]
 80059ce:	2b00      	cmp	r3, #0
 80059d0:	d109      	bne.n	80059e6 <xTaskRemoveFromEventList+0x2a>
 80059d2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80059d6:	f383 8811 	msr	BASEPRI, r3
 80059da:	f3bf 8f6f 	isb	sy
 80059de:	f3bf 8f4f 	dsb	sy
 80059e2:	60fb      	str	r3, [r7, #12]
 80059e4:	e7fe      	b.n	80059e4 <xTaskRemoveFromEventList+0x28>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80059e6:	693b      	ldr	r3, [r7, #16]
 80059e8:	3318      	adds	r3, #24
 80059ea:	4618      	mov	r0, r3
 80059ec:	f7fe f926 	bl	8003c3c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 80059f0:	4b20      	ldr	r3, [pc, #128]	; (8005a74 <xTaskRemoveFromEventList+0xb8>)
 80059f2:	681b      	ldr	r3, [r3, #0]
 80059f4:	2b00      	cmp	r3, #0
 80059f6:	d122      	bne.n	8005a3e <xTaskRemoveFromEventList+0x82>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 80059f8:	693b      	ldr	r3, [r7, #16]
 80059fa:	3304      	adds	r3, #4
 80059fc:	4618      	mov	r0, r3
 80059fe:	f7fe f91d 	bl	8003c3c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 8005a02:	693b      	ldr	r3, [r7, #16]
 8005a04:	4618      	mov	r0, r3
 8005a06:	f00c f8eb 	bl	8011be0 <SEGGER_SYSVIEW_OnTaskStartReady>
 8005a0a:	693b      	ldr	r3, [r7, #16]
 8005a0c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005a0e:	461a      	mov	r2, r3
 8005a10:	2301      	movs	r3, #1
 8005a12:	fa03 f202 	lsl.w	r2, r3, r2
 8005a16:	4b18      	ldr	r3, [pc, #96]	; (8005a78 <xTaskRemoveFromEventList+0xbc>)
 8005a18:	681b      	ldr	r3, [r3, #0]
 8005a1a:	4313      	orrs	r3, r2
 8005a1c:	4a16      	ldr	r2, [pc, #88]	; (8005a78 <xTaskRemoveFromEventList+0xbc>)
 8005a1e:	6013      	str	r3, [r2, #0]
 8005a20:	693b      	ldr	r3, [r7, #16]
 8005a22:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005a24:	4613      	mov	r3, r2
 8005a26:	009b      	lsls	r3, r3, #2
 8005a28:	4413      	add	r3, r2
 8005a2a:	009b      	lsls	r3, r3, #2
 8005a2c:	4a13      	ldr	r2, [pc, #76]	; (8005a7c <xTaskRemoveFromEventList+0xc0>)
 8005a2e:	441a      	add	r2, r3
 8005a30:	693b      	ldr	r3, [r7, #16]
 8005a32:	3304      	adds	r3, #4
 8005a34:	4610      	mov	r0, r2
 8005a36:	4619      	mov	r1, r3
 8005a38:	f7fe f8a4 	bl	8003b84 <vListInsertEnd>
 8005a3c:	e005      	b.n	8005a4a <xTaskRemoveFromEventList+0x8e>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 8005a3e:	693b      	ldr	r3, [r7, #16]
 8005a40:	3318      	adds	r3, #24
 8005a42:	480f      	ldr	r0, [pc, #60]	; (8005a80 <xTaskRemoveFromEventList+0xc4>)
 8005a44:	4619      	mov	r1, r3
 8005a46:	f7fe f89d 	bl	8003b84 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8005a4a:	693b      	ldr	r3, [r7, #16]
 8005a4c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005a4e:	4b0d      	ldr	r3, [pc, #52]	; (8005a84 <xTaskRemoveFromEventList+0xc8>)
 8005a50:	681b      	ldr	r3, [r3, #0]
 8005a52:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005a54:	429a      	cmp	r2, r3
 8005a56:	d905      	bls.n	8005a64 <xTaskRemoveFromEventList+0xa8>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 8005a58:	2301      	movs	r3, #1
 8005a5a:	617b      	str	r3, [r7, #20]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 8005a5c:	4b0a      	ldr	r3, [pc, #40]	; (8005a88 <xTaskRemoveFromEventList+0xcc>)
 8005a5e:	2201      	movs	r2, #1
 8005a60:	601a      	str	r2, [r3, #0]
 8005a62:	e001      	b.n	8005a68 <xTaskRemoveFromEventList+0xac>
	}
	else
	{
		xReturn = pdFALSE;
 8005a64:	2300      	movs	r3, #0
 8005a66:	617b      	str	r3, [r7, #20]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
 8005a68:	697b      	ldr	r3, [r7, #20]
}
 8005a6a:	4618      	mov	r0, r3
 8005a6c:	3718      	adds	r7, #24
 8005a6e:	46bd      	mov	sp, r7
 8005a70:	bd80      	pop	{r7, pc}
 8005a72:	bf00      	nop
 8005a74:	2000bcd4 	.word	0x2000bcd4
 8005a78:	2000bcb4 	.word	0x2000bcb4
 8005a7c:	2000bbb0 	.word	0x2000bbb0
 8005a80:	2000bc6c 	.word	0x2000bc6c
 8005a84:	2000bbac 	.word	0x2000bbac
 8005a88:	2000bcc0 	.word	0x2000bcc0

08005a8c <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
 8005a8c:	b580      	push	{r7, lr}
 8005a8e:	b086      	sub	sp, #24
 8005a90:	af00      	add	r7, sp, #0
 8005a92:	6078      	str	r0, [r7, #4]
 8005a94:	6039      	str	r1, [r7, #0]
TCB_t *pxUnblockedTCB;
BaseType_t xReturn;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );
 8005a96:	4b2e      	ldr	r3, [pc, #184]	; (8005b50 <xTaskRemoveFromUnorderedEventList+0xc4>)
 8005a98:	681b      	ldr	r3, [r3, #0]
 8005a9a:	2b00      	cmp	r3, #0
 8005a9c:	d109      	bne.n	8005ab2 <xTaskRemoveFromUnorderedEventList+0x26>
 8005a9e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005aa2:	f383 8811 	msr	BASEPRI, r3
 8005aa6:	f3bf 8f6f 	isb	sy
 8005aaa:	f3bf 8f4f 	dsb	sy
 8005aae:	60fb      	str	r3, [r7, #12]
 8005ab0:	e7fe      	b.n	8005ab0 <xTaskRemoveFromUnorderedEventList+0x24>

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
 8005ab2:	683b      	ldr	r3, [r7, #0]
 8005ab4:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8005ab8:	687b      	ldr	r3, [r7, #4]
 8005aba:	601a      	str	r2, [r3, #0]

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
 8005abc:	687b      	ldr	r3, [r7, #4]
 8005abe:	68db      	ldr	r3, [r3, #12]
 8005ac0:	613b      	str	r3, [r7, #16]
	configASSERT( pxUnblockedTCB );
 8005ac2:	693b      	ldr	r3, [r7, #16]
 8005ac4:	2b00      	cmp	r3, #0
 8005ac6:	d109      	bne.n	8005adc <xTaskRemoveFromUnorderedEventList+0x50>
 8005ac8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005acc:	f383 8811 	msr	BASEPRI, r3
 8005ad0:	f3bf 8f6f 	isb	sy
 8005ad4:	f3bf 8f4f 	dsb	sy
 8005ad8:	60bb      	str	r3, [r7, #8]
 8005ada:	e7fe      	b.n	8005ada <xTaskRemoveFromUnorderedEventList+0x4e>
	( void ) uxListRemove( pxEventListItem );
 8005adc:	6878      	ldr	r0, [r7, #4]
 8005ade:	f7fe f8ad 	bl	8003c3c <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 8005ae2:	693b      	ldr	r3, [r7, #16]
 8005ae4:	3304      	adds	r3, #4
 8005ae6:	4618      	mov	r0, r3
 8005ae8:	f7fe f8a8 	bl	8003c3c <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
 8005aec:	693b      	ldr	r3, [r7, #16]
 8005aee:	4618      	mov	r0, r3
 8005af0:	f00c f876 	bl	8011be0 <SEGGER_SYSVIEW_OnTaskStartReady>
 8005af4:	693b      	ldr	r3, [r7, #16]
 8005af6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005af8:	461a      	mov	r2, r3
 8005afa:	2301      	movs	r3, #1
 8005afc:	fa03 f202 	lsl.w	r2, r3, r2
 8005b00:	4b14      	ldr	r3, [pc, #80]	; (8005b54 <xTaskRemoveFromUnorderedEventList+0xc8>)
 8005b02:	681b      	ldr	r3, [r3, #0]
 8005b04:	4313      	orrs	r3, r2
 8005b06:	4a13      	ldr	r2, [pc, #76]	; (8005b54 <xTaskRemoveFromUnorderedEventList+0xc8>)
 8005b08:	6013      	str	r3, [r2, #0]
 8005b0a:	693b      	ldr	r3, [r7, #16]
 8005b0c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005b0e:	4613      	mov	r3, r2
 8005b10:	009b      	lsls	r3, r3, #2
 8005b12:	4413      	add	r3, r2
 8005b14:	009b      	lsls	r3, r3, #2
 8005b16:	4a10      	ldr	r2, [pc, #64]	; (8005b58 <xTaskRemoveFromUnorderedEventList+0xcc>)
 8005b18:	441a      	add	r2, r3
 8005b1a:	693b      	ldr	r3, [r7, #16]
 8005b1c:	3304      	adds	r3, #4
 8005b1e:	4610      	mov	r0, r2
 8005b20:	4619      	mov	r1, r3
 8005b22:	f7fe f82f 	bl	8003b84 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 8005b26:	693b      	ldr	r3, [r7, #16]
 8005b28:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005b2a:	4b0c      	ldr	r3, [pc, #48]	; (8005b5c <xTaskRemoveFromUnorderedEventList+0xd0>)
 8005b2c:	681b      	ldr	r3, [r3, #0]
 8005b2e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005b30:	429a      	cmp	r2, r3
 8005b32:	d905      	bls.n	8005b40 <xTaskRemoveFromUnorderedEventList+0xb4>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
 8005b34:	2301      	movs	r3, #1
 8005b36:	617b      	str	r3, [r7, #20]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 8005b38:	4b09      	ldr	r3, [pc, #36]	; (8005b60 <xTaskRemoveFromUnorderedEventList+0xd4>)
 8005b3a:	2201      	movs	r2, #1
 8005b3c:	601a      	str	r2, [r3, #0]
 8005b3e:	e001      	b.n	8005b44 <xTaskRemoveFromUnorderedEventList+0xb8>
	}
	else
	{
		xReturn = pdFALSE;
 8005b40:	2300      	movs	r3, #0
 8005b42:	617b      	str	r3, [r7, #20]
	}

	return xReturn;
 8005b44:	697b      	ldr	r3, [r7, #20]
}
 8005b46:	4618      	mov	r0, r3
 8005b48:	3718      	adds	r7, #24
 8005b4a:	46bd      	mov	sp, r7
 8005b4c:	bd80      	pop	{r7, pc}
 8005b4e:	bf00      	nop
 8005b50:	2000bcd4 	.word	0x2000bcd4
 8005b54:	2000bcb4 	.word	0x2000bcb4
 8005b58:	2000bbb0 	.word	0x2000bbb0
 8005b5c:	2000bbac 	.word	0x2000bbac
 8005b60:	2000bcc0 	.word	0x2000bcc0

08005b64 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 8005b64:	b480      	push	{r7}
 8005b66:	b085      	sub	sp, #20
 8005b68:	af00      	add	r7, sp, #0
 8005b6a:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
 8005b6c:	687b      	ldr	r3, [r7, #4]
 8005b6e:	2b00      	cmp	r3, #0
 8005b70:	d109      	bne.n	8005b86 <vTaskSetTimeOutState+0x22>
 8005b72:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005b76:	f383 8811 	msr	BASEPRI, r3
 8005b7a:	f3bf 8f6f 	isb	sy
 8005b7e:	f3bf 8f4f 	dsb	sy
 8005b82:	60fb      	str	r3, [r7, #12]
 8005b84:	e7fe      	b.n	8005b84 <vTaskSetTimeOutState+0x20>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8005b86:	4b06      	ldr	r3, [pc, #24]	; (8005ba0 <vTaskSetTimeOutState+0x3c>)
 8005b88:	681a      	ldr	r2, [r3, #0]
 8005b8a:	687b      	ldr	r3, [r7, #4]
 8005b8c:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8005b8e:	4b05      	ldr	r3, [pc, #20]	; (8005ba4 <vTaskSetTimeOutState+0x40>)
 8005b90:	681a      	ldr	r2, [r3, #0]
 8005b92:	687b      	ldr	r3, [r7, #4]
 8005b94:	605a      	str	r2, [r3, #4]
}
 8005b96:	3714      	adds	r7, #20
 8005b98:	46bd      	mov	sp, r7
 8005b9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005b9e:	4770      	bx	lr
 8005ba0:	2000bcc4 	.word	0x2000bcc4
 8005ba4:	2000bcb0 	.word	0x2000bcb0

08005ba8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 8005ba8:	b580      	push	{r7, lr}
 8005baa:	b086      	sub	sp, #24
 8005bac:	af00      	add	r7, sp, #0
 8005bae:	6078      	str	r0, [r7, #4]
 8005bb0:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
 8005bb2:	687b      	ldr	r3, [r7, #4]
 8005bb4:	2b00      	cmp	r3, #0
 8005bb6:	d109      	bne.n	8005bcc <xTaskCheckForTimeOut+0x24>
 8005bb8:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005bbc:	f383 8811 	msr	BASEPRI, r3
 8005bc0:	f3bf 8f6f 	isb	sy
 8005bc4:	f3bf 8f4f 	dsb	sy
 8005bc8:	60fb      	str	r3, [r7, #12]
 8005bca:	e7fe      	b.n	8005bca <xTaskCheckForTimeOut+0x22>
	configASSERT( pxTicksToWait );
 8005bcc:	683b      	ldr	r3, [r7, #0]
 8005bce:	2b00      	cmp	r3, #0
 8005bd0:	d109      	bne.n	8005be6 <xTaskCheckForTimeOut+0x3e>
 8005bd2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005bd6:	f383 8811 	msr	BASEPRI, r3
 8005bda:	f3bf 8f6f 	isb	sy
 8005bde:	f3bf 8f4f 	dsb	sy
 8005be2:	60bb      	str	r3, [r7, #8]
 8005be4:	e7fe      	b.n	8005be4 <xTaskCheckForTimeOut+0x3c>

	taskENTER_CRITICAL();
 8005be6:	f7fe f951 	bl	8003e8c <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 8005bea:	4b1c      	ldr	r3, [pc, #112]	; (8005c5c <xTaskCheckForTimeOut+0xb4>)
 8005bec:	681b      	ldr	r3, [r3, #0]
 8005bee:	613b      	str	r3, [r7, #16]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 8005bf0:	683b      	ldr	r3, [r7, #0]
 8005bf2:	681b      	ldr	r3, [r3, #0]
 8005bf4:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8005bf8:	d102      	bne.n	8005c00 <xTaskCheckForTimeOut+0x58>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 8005bfa:	2300      	movs	r3, #0
 8005bfc:	617b      	str	r3, [r7, #20]
 8005bfe:	e026      	b.n	8005c4e <xTaskCheckForTimeOut+0xa6>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 8005c00:	687b      	ldr	r3, [r7, #4]
 8005c02:	681a      	ldr	r2, [r3, #0]
 8005c04:	4b16      	ldr	r3, [pc, #88]	; (8005c60 <xTaskCheckForTimeOut+0xb8>)
 8005c06:	681b      	ldr	r3, [r3, #0]
 8005c08:	429a      	cmp	r2, r3
 8005c0a:	d007      	beq.n	8005c1c <xTaskCheckForTimeOut+0x74>
 8005c0c:	687b      	ldr	r3, [r7, #4]
 8005c0e:	685a      	ldr	r2, [r3, #4]
 8005c10:	693b      	ldr	r3, [r7, #16]
 8005c12:	429a      	cmp	r2, r3
 8005c14:	d802      	bhi.n	8005c1c <xTaskCheckForTimeOut+0x74>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 8005c16:	2301      	movs	r3, #1
 8005c18:	617b      	str	r3, [r7, #20]
 8005c1a:	e018      	b.n	8005c4e <xTaskCheckForTimeOut+0xa6>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 8005c1c:	687b      	ldr	r3, [r7, #4]
 8005c1e:	685b      	ldr	r3, [r3, #4]
 8005c20:	693a      	ldr	r2, [r7, #16]
 8005c22:	1ad2      	subs	r2, r2, r3
 8005c24:	683b      	ldr	r3, [r7, #0]
 8005c26:	681b      	ldr	r3, [r3, #0]
 8005c28:	429a      	cmp	r2, r3
 8005c2a:	d20e      	bcs.n	8005c4a <xTaskCheckForTimeOut+0xa2>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
 8005c2c:	683b      	ldr	r3, [r7, #0]
 8005c2e:	681a      	ldr	r2, [r3, #0]
 8005c30:	687b      	ldr	r3, [r7, #4]
 8005c32:	6859      	ldr	r1, [r3, #4]
 8005c34:	693b      	ldr	r3, [r7, #16]
 8005c36:	1acb      	subs	r3, r1, r3
 8005c38:	441a      	add	r2, r3
 8005c3a:	683b      	ldr	r3, [r7, #0]
 8005c3c:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8005c3e:	6878      	ldr	r0, [r7, #4]
 8005c40:	f7ff ff90 	bl	8005b64 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
 8005c44:	2300      	movs	r3, #0
 8005c46:	617b      	str	r3, [r7, #20]
 8005c48:	e001      	b.n	8005c4e <xTaskCheckForTimeOut+0xa6>
		}
		else
		{
			xReturn = pdTRUE;
 8005c4a:	2301      	movs	r3, #1
 8005c4c:	617b      	str	r3, [r7, #20]
		}
	}
	taskEXIT_CRITICAL();
 8005c4e:	f7fe f94b 	bl	8003ee8 <vPortExitCritical>

	return xReturn;
 8005c52:	697b      	ldr	r3, [r7, #20]
}
 8005c54:	4618      	mov	r0, r3
 8005c56:	3718      	adds	r7, #24
 8005c58:	46bd      	mov	sp, r7
 8005c5a:	bd80      	pop	{r7, pc}
 8005c5c:	2000bcb0 	.word	0x2000bcb0
 8005c60:	2000bcc4 	.word	0x2000bcc4

08005c64 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 8005c64:	b480      	push	{r7}
 8005c66:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
 8005c68:	4b03      	ldr	r3, [pc, #12]	; (8005c78 <vTaskMissedYield+0x14>)
 8005c6a:	2201      	movs	r2, #1
 8005c6c:	601a      	str	r2, [r3, #0]
}
 8005c6e:	46bd      	mov	sp, r7
 8005c70:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005c74:	4770      	bx	lr
 8005c76:	bf00      	nop
 8005c78:	2000bcc0 	.word	0x2000bcc0

08005c7c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8005c7c:	b580      	push	{r7, lr}
 8005c7e:	b082      	sub	sp, #8
 8005c80:	af00      	add	r7, sp, #0
 8005c82:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 8005c84:	f000 f852 	bl	8005d2c <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8005c88:	4b07      	ldr	r3, [pc, #28]	; (8005ca8 <prvIdleTask+0x2c>)
 8005c8a:	681b      	ldr	r3, [r3, #0]
 8005c8c:	2b01      	cmp	r3, #1
 8005c8e:	d907      	bls.n	8005ca0 <prvIdleTask+0x24>
			{
				taskYIELD();
 8005c90:	4b06      	ldr	r3, [pc, #24]	; (8005cac <prvIdleTask+0x30>)
 8005c92:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8005c96:	601a      	str	r2, [r3, #0]
 8005c98:	f3bf 8f4f 	dsb	sy
 8005c9c:	f3bf 8f6f 	isb	sy
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 8005ca0:	f009 facc 	bl	800f23c <vApplicationIdleHook>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
 8005ca4:	e7ee      	b.n	8005c84 <prvIdleTask+0x8>
 8005ca6:	bf00      	nop
 8005ca8:	2000bbb0 	.word	0x2000bbb0
 8005cac:	e000ed04 	.word	0xe000ed04

08005cb0 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 8005cb0:	b580      	push	{r7, lr}
 8005cb2:	b082      	sub	sp, #8
 8005cb4:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8005cb6:	2300      	movs	r3, #0
 8005cb8:	607b      	str	r3, [r7, #4]
 8005cba:	e00c      	b.n	8005cd6 <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8005cbc:	687a      	ldr	r2, [r7, #4]
 8005cbe:	4613      	mov	r3, r2
 8005cc0:	009b      	lsls	r3, r3, #2
 8005cc2:	4413      	add	r3, r2
 8005cc4:	009b      	lsls	r3, r3, #2
 8005cc6:	4a11      	ldr	r2, [pc, #68]	; (8005d0c <prvInitialiseTaskLists+0x5c>)
 8005cc8:	4413      	add	r3, r2
 8005cca:	4618      	mov	r0, r3
 8005ccc:	f7fd ff2e 	bl	8003b2c <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8005cd0:	687b      	ldr	r3, [r7, #4]
 8005cd2:	3301      	adds	r3, #1
 8005cd4:	607b      	str	r3, [r7, #4]
 8005cd6:	687b      	ldr	r3, [r7, #4]
 8005cd8:	2b06      	cmp	r3, #6
 8005cda:	d9ef      	bls.n	8005cbc <prvInitialiseTaskLists+0xc>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
 8005cdc:	480c      	ldr	r0, [pc, #48]	; (8005d10 <prvInitialiseTaskLists+0x60>)
 8005cde:	f7fd ff25 	bl	8003b2c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8005ce2:	480c      	ldr	r0, [pc, #48]	; (8005d14 <prvInitialiseTaskLists+0x64>)
 8005ce4:	f7fd ff22 	bl	8003b2c <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8005ce8:	480b      	ldr	r0, [pc, #44]	; (8005d18 <prvInitialiseTaskLists+0x68>)
 8005cea:	f7fd ff1f 	bl	8003b2c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 8005cee:	480b      	ldr	r0, [pc, #44]	; (8005d1c <prvInitialiseTaskLists+0x6c>)
 8005cf0:	f7fd ff1c 	bl	8003b2c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8005cf4:	480a      	ldr	r0, [pc, #40]	; (8005d20 <prvInitialiseTaskLists+0x70>)
 8005cf6:	f7fd ff19 	bl	8003b2c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8005cfa:	4b0a      	ldr	r3, [pc, #40]	; (8005d24 <prvInitialiseTaskLists+0x74>)
 8005cfc:	4a04      	ldr	r2, [pc, #16]	; (8005d10 <prvInitialiseTaskLists+0x60>)
 8005cfe:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8005d00:	4b09      	ldr	r3, [pc, #36]	; (8005d28 <prvInitialiseTaskLists+0x78>)
 8005d02:	4a04      	ldr	r2, [pc, #16]	; (8005d14 <prvInitialiseTaskLists+0x64>)
 8005d04:	601a      	str	r2, [r3, #0]
}
 8005d06:	3708      	adds	r7, #8
 8005d08:	46bd      	mov	sp, r7
 8005d0a:	bd80      	pop	{r7, pc}
 8005d0c:	2000bbb0 	.word	0x2000bbb0
 8005d10:	2000bc3c 	.word	0x2000bc3c
 8005d14:	2000bc50 	.word	0x2000bc50
 8005d18:	2000bc6c 	.word	0x2000bc6c
 8005d1c:	2000bc80 	.word	0x2000bc80
 8005d20:	2000bc98 	.word	0x2000bc98
 8005d24:	2000bc64 	.word	0x2000bc64
 8005d28:	2000bc68 	.word	0x2000bc68

08005d2c <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 8005d2c:	b580      	push	{r7, lr}
 8005d2e:	b082      	sub	sp, #8
 8005d30:	af00      	add	r7, sp, #0
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8005d32:	e028      	b.n	8005d86 <prvCheckTasksWaitingTermination+0x5a>
		{
			vTaskSuspendAll();
 8005d34:	f7ff fb76 	bl	8005424 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8005d38:	4b16      	ldr	r3, [pc, #88]	; (8005d94 <prvCheckTasksWaitingTermination+0x68>)
 8005d3a:	681b      	ldr	r3, [r3, #0]
 8005d3c:	2b00      	cmp	r3, #0
 8005d3e:	bf0c      	ite	eq
 8005d40:	2301      	moveq	r3, #1
 8005d42:	2300      	movne	r3, #0
 8005d44:	b2db      	uxtb	r3, r3
 8005d46:	607b      	str	r3, [r7, #4]
			}
			( void ) xTaskResumeAll();
 8005d48:	f7ff fb7a 	bl	8005440 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 8005d4c:	687b      	ldr	r3, [r7, #4]
 8005d4e:	2b00      	cmp	r3, #0
 8005d50:	d119      	bne.n	8005d86 <prvCheckTasksWaitingTermination+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 8005d52:	f7fe f89b 	bl	8003e8c <vPortEnterCritical>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8005d56:	4b0f      	ldr	r3, [pc, #60]	; (8005d94 <prvCheckTasksWaitingTermination+0x68>)
 8005d58:	68db      	ldr	r3, [r3, #12]
 8005d5a:	68db      	ldr	r3, [r3, #12]
 8005d5c:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8005d5e:	683b      	ldr	r3, [r7, #0]
 8005d60:	3304      	adds	r3, #4
 8005d62:	4618      	mov	r0, r3
 8005d64:	f7fd ff6a 	bl	8003c3c <uxListRemove>
					--uxCurrentNumberOfTasks;
 8005d68:	4b0b      	ldr	r3, [pc, #44]	; (8005d98 <prvCheckTasksWaitingTermination+0x6c>)
 8005d6a:	681b      	ldr	r3, [r3, #0]
 8005d6c:	3b01      	subs	r3, #1
 8005d6e:	4a0a      	ldr	r2, [pc, #40]	; (8005d98 <prvCheckTasksWaitingTermination+0x6c>)
 8005d70:	6013      	str	r3, [r2, #0]
					--uxDeletedTasksWaitingCleanUp;
 8005d72:	4b0a      	ldr	r3, [pc, #40]	; (8005d9c <prvCheckTasksWaitingTermination+0x70>)
 8005d74:	681b      	ldr	r3, [r3, #0]
 8005d76:	3b01      	subs	r3, #1
 8005d78:	4a08      	ldr	r2, [pc, #32]	; (8005d9c <prvCheckTasksWaitingTermination+0x70>)
 8005d7a:	6013      	str	r3, [r2, #0]
				}
				taskEXIT_CRITICAL();
 8005d7c:	f7fe f8b4 	bl	8003ee8 <vPortExitCritical>

				prvDeleteTCB( pxTCB );
 8005d80:	6838      	ldr	r0, [r7, #0]
 8005d82:	f000 f80d 	bl	8005da0 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8005d86:	4b05      	ldr	r3, [pc, #20]	; (8005d9c <prvCheckTasksWaitingTermination+0x70>)
 8005d88:	681b      	ldr	r3, [r3, #0]
 8005d8a:	2b00      	cmp	r3, #0
 8005d8c:	d1d2      	bne.n	8005d34 <prvCheckTasksWaitingTermination+0x8>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 8005d8e:	3708      	adds	r7, #8
 8005d90:	46bd      	mov	sp, r7
 8005d92:	bd80      	pop	{r7, pc}
 8005d94:	2000bc80 	.word	0x2000bc80
 8005d98:	2000bcac 	.word	0x2000bcac
 8005d9c:	2000bc94 	.word	0x2000bc94

08005da0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 8005da0:	b580      	push	{r7, lr}
 8005da2:	b082      	sub	sp, #8
 8005da4:	af00      	add	r7, sp, #0
 8005da6:	6078      	str	r0, [r7, #4]

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 8005da8:	687b      	ldr	r3, [r7, #4]
 8005daa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005dac:	4618      	mov	r0, r3
 8005dae:	f7fe fa1f 	bl	80041f0 <vPortFree>
			vPortFree( pxTCB );
 8005db2:	6878      	ldr	r0, [r7, #4]
 8005db4:	f7fe fa1c 	bl	80041f0 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 8005db8:	3708      	adds	r7, #8
 8005dba:	46bd      	mov	sp, r7
 8005dbc:	bd80      	pop	{r7, pc}
 8005dbe:	bf00      	nop

08005dc0 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 8005dc0:	b480      	push	{r7}
 8005dc2:	b083      	sub	sp, #12
 8005dc4:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8005dc6:	4b0e      	ldr	r3, [pc, #56]	; (8005e00 <prvResetNextTaskUnblockTime+0x40>)
 8005dc8:	681b      	ldr	r3, [r3, #0]
 8005dca:	681b      	ldr	r3, [r3, #0]
 8005dcc:	2b00      	cmp	r3, #0
 8005dce:	d101      	bne.n	8005dd4 <prvResetNextTaskUnblockTime+0x14>
 8005dd0:	2301      	movs	r3, #1
 8005dd2:	e000      	b.n	8005dd6 <prvResetNextTaskUnblockTime+0x16>
 8005dd4:	2300      	movs	r3, #0
 8005dd6:	2b00      	cmp	r3, #0
 8005dd8:	d004      	beq.n	8005de4 <prvResetNextTaskUnblockTime+0x24>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8005dda:	4b0a      	ldr	r3, [pc, #40]	; (8005e04 <prvResetNextTaskUnblockTime+0x44>)
 8005ddc:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005de0:	601a      	str	r2, [r3, #0]
 8005de2:	e008      	b.n	8005df6 <prvResetNextTaskUnblockTime+0x36>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8005de4:	4b06      	ldr	r3, [pc, #24]	; (8005e00 <prvResetNextTaskUnblockTime+0x40>)
 8005de6:	681b      	ldr	r3, [r3, #0]
 8005de8:	68db      	ldr	r3, [r3, #12]
 8005dea:	68db      	ldr	r3, [r3, #12]
 8005dec:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8005dee:	687b      	ldr	r3, [r7, #4]
 8005df0:	685b      	ldr	r3, [r3, #4]
 8005df2:	4a04      	ldr	r2, [pc, #16]	; (8005e04 <prvResetNextTaskUnblockTime+0x44>)
 8005df4:	6013      	str	r3, [r2, #0]
	}
}
 8005df6:	370c      	adds	r7, #12
 8005df8:	46bd      	mov	sp, r7
 8005dfa:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005dfe:	4770      	bx	lr
 8005e00:	2000bc64 	.word	0x2000bc64
 8005e04:	2000bccc 	.word	0x2000bccc

08005e08 <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
 8005e08:	b480      	push	{r7}
 8005e0a:	b083      	sub	sp, #12
 8005e0c:	af00      	add	r7, sp, #0
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 8005e0e:	4b05      	ldr	r3, [pc, #20]	; (8005e24 <xTaskGetCurrentTaskHandle+0x1c>)
 8005e10:	681b      	ldr	r3, [r3, #0]
 8005e12:	607b      	str	r3, [r7, #4]

		return xReturn;
 8005e14:	687b      	ldr	r3, [r7, #4]
	}
 8005e16:	4618      	mov	r0, r3
 8005e18:	370c      	adds	r7, #12
 8005e1a:	46bd      	mov	sp, r7
 8005e1c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e20:	4770      	bx	lr
 8005e22:	bf00      	nop
 8005e24:	2000bbac 	.word	0x2000bbac

08005e28 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 8005e28:	b480      	push	{r7}
 8005e2a:	b083      	sub	sp, #12
 8005e2c:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 8005e2e:	4b0b      	ldr	r3, [pc, #44]	; (8005e5c <xTaskGetSchedulerState+0x34>)
 8005e30:	681b      	ldr	r3, [r3, #0]
 8005e32:	2b00      	cmp	r3, #0
 8005e34:	d102      	bne.n	8005e3c <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 8005e36:	2301      	movs	r3, #1
 8005e38:	607b      	str	r3, [r7, #4]
 8005e3a:	e008      	b.n	8005e4e <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8005e3c:	4b08      	ldr	r3, [pc, #32]	; (8005e60 <xTaskGetSchedulerState+0x38>)
 8005e3e:	681b      	ldr	r3, [r3, #0]
 8005e40:	2b00      	cmp	r3, #0
 8005e42:	d102      	bne.n	8005e4a <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
 8005e44:	2302      	movs	r3, #2
 8005e46:	607b      	str	r3, [r7, #4]
 8005e48:	e001      	b.n	8005e4e <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 8005e4a:	2300      	movs	r3, #0
 8005e4c:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
 8005e4e:	687b      	ldr	r3, [r7, #4]
	}
 8005e50:	4618      	mov	r0, r3
 8005e52:	370c      	adds	r7, #12
 8005e54:	46bd      	mov	sp, r7
 8005e56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8005e5a:	4770      	bx	lr
 8005e5c:	2000bcb8 	.word	0x2000bcb8
 8005e60:	2000bcd4 	.word	0x2000bcd4

08005e64 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
 8005e64:	b580      	push	{r7, lr}
 8005e66:	b084      	sub	sp, #16
 8005e68:	af00      	add	r7, sp, #0
 8005e6a:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 8005e6c:	687b      	ldr	r3, [r7, #4]
 8005e6e:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
 8005e70:	687b      	ldr	r3, [r7, #4]
 8005e72:	2b00      	cmp	r3, #0
 8005e74:	d069      	beq.n	8005f4a <vTaskPriorityInherit+0xe6>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8005e76:	68fb      	ldr	r3, [r7, #12]
 8005e78:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005e7a:	4b35      	ldr	r3, [pc, #212]	; (8005f50 <vTaskPriorityInherit+0xec>)
 8005e7c:	681b      	ldr	r3, [r3, #0]
 8005e7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005e80:	429a      	cmp	r2, r3
 8005e82:	d262      	bcs.n	8005f4a <vTaskPriorityInherit+0xe6>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
 8005e84:	68fb      	ldr	r3, [r7, #12]
 8005e86:	699b      	ldr	r3, [r3, #24]
 8005e88:	2b00      	cmp	r3, #0
 8005e8a:	db06      	blt.n	8005e9a <vTaskPriorityInherit+0x36>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8005e8c:	4b30      	ldr	r3, [pc, #192]	; (8005f50 <vTaskPriorityInherit+0xec>)
 8005e8e:	681b      	ldr	r3, [r3, #0]
 8005e90:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005e92:	f1c3 0207 	rsb	r2, r3, #7
 8005e96:	68fb      	ldr	r3, [r7, #12]
 8005e98:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
 8005e9a:	68fb      	ldr	r3, [r7, #12]
 8005e9c:	6959      	ldr	r1, [r3, #20]
 8005e9e:	68fb      	ldr	r3, [r7, #12]
 8005ea0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005ea2:	4613      	mov	r3, r2
 8005ea4:	009b      	lsls	r3, r3, #2
 8005ea6:	4413      	add	r3, r2
 8005ea8:	009b      	lsls	r3, r3, #2
 8005eaa:	4a2a      	ldr	r2, [pc, #168]	; (8005f54 <vTaskPriorityInherit+0xf0>)
 8005eac:	4413      	add	r3, r2
 8005eae:	4299      	cmp	r1, r3
 8005eb0:	d101      	bne.n	8005eb6 <vTaskPriorityInherit+0x52>
 8005eb2:	2301      	movs	r3, #1
 8005eb4:	e000      	b.n	8005eb8 <vTaskPriorityInherit+0x54>
 8005eb6:	2300      	movs	r3, #0
 8005eb8:	2b00      	cmp	r3, #0
 8005eba:	d03c      	beq.n	8005f36 <vTaskPriorityInherit+0xd2>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005ebc:	68fb      	ldr	r3, [r7, #12]
 8005ebe:	3304      	adds	r3, #4
 8005ec0:	4618      	mov	r0, r3
 8005ec2:	f7fd febb 	bl	8003c3c <uxListRemove>
 8005ec6:	4603      	mov	r3, r0
 8005ec8:	2b00      	cmp	r3, #0
 8005eca:	d115      	bne.n	8005ef8 <vTaskPriorityInherit+0x94>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8005ecc:	68fb      	ldr	r3, [r7, #12]
 8005ece:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005ed0:	4920      	ldr	r1, [pc, #128]	; (8005f54 <vTaskPriorityInherit+0xf0>)
 8005ed2:	4613      	mov	r3, r2
 8005ed4:	009b      	lsls	r3, r3, #2
 8005ed6:	4413      	add	r3, r2
 8005ed8:	009b      	lsls	r3, r3, #2
 8005eda:	440b      	add	r3, r1
 8005edc:	681b      	ldr	r3, [r3, #0]
 8005ede:	2b00      	cmp	r3, #0
 8005ee0:	d10a      	bne.n	8005ef8 <vTaskPriorityInherit+0x94>
 8005ee2:	68fb      	ldr	r3, [r7, #12]
 8005ee4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005ee6:	461a      	mov	r2, r3
 8005ee8:	2301      	movs	r3, #1
 8005eea:	4093      	lsls	r3, r2
 8005eec:	43da      	mvns	r2, r3
 8005eee:	4b1a      	ldr	r3, [pc, #104]	; (8005f58 <vTaskPriorityInherit+0xf4>)
 8005ef0:	681b      	ldr	r3, [r3, #0]
 8005ef2:	4013      	ands	r3, r2
 8005ef4:	4a18      	ldr	r2, [pc, #96]	; (8005f58 <vTaskPriorityInherit+0xf4>)
 8005ef6:	6013      	str	r3, [r2, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8005ef8:	4b15      	ldr	r3, [pc, #84]	; (8005f50 <vTaskPriorityInherit+0xec>)
 8005efa:	681b      	ldr	r3, [r3, #0]
 8005efc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005efe:	68fb      	ldr	r3, [r7, #12]
 8005f00:	62da      	str	r2, [r3, #44]	; 0x2c
					prvReaddTaskToReadyList( pxTCB );
 8005f02:	68fb      	ldr	r3, [r7, #12]
 8005f04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005f06:	461a      	mov	r2, r3
 8005f08:	2301      	movs	r3, #1
 8005f0a:	fa03 f202 	lsl.w	r2, r3, r2
 8005f0e:	4b12      	ldr	r3, [pc, #72]	; (8005f58 <vTaskPriorityInherit+0xf4>)
 8005f10:	681b      	ldr	r3, [r3, #0]
 8005f12:	4313      	orrs	r3, r2
 8005f14:	4a10      	ldr	r2, [pc, #64]	; (8005f58 <vTaskPriorityInherit+0xf4>)
 8005f16:	6013      	str	r3, [r2, #0]
 8005f18:	68fb      	ldr	r3, [r7, #12]
 8005f1a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005f1c:	4613      	mov	r3, r2
 8005f1e:	009b      	lsls	r3, r3, #2
 8005f20:	4413      	add	r3, r2
 8005f22:	009b      	lsls	r3, r3, #2
 8005f24:	4a0b      	ldr	r2, [pc, #44]	; (8005f54 <vTaskPriorityInherit+0xf0>)
 8005f26:	441a      	add	r2, r3
 8005f28:	68fb      	ldr	r3, [r7, #12]
 8005f2a:	3304      	adds	r3, #4
 8005f2c:	4610      	mov	r0, r2
 8005f2e:	4619      	mov	r1, r3
 8005f30:	f7fd fe28 	bl	8003b84 <vListInsertEnd>
 8005f34:	e004      	b.n	8005f40 <vTaskPriorityInherit+0xdc>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8005f36:	4b06      	ldr	r3, [pc, #24]	; (8005f50 <vTaskPriorityInherit+0xec>)
 8005f38:	681b      	ldr	r3, [r3, #0]
 8005f3a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005f3c:	68fb      	ldr	r3, [r7, #12]
 8005f3e:	62da      	str	r2, [r3, #44]	; 0x2c
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
 8005f40:	687b      	ldr	r3, [r7, #4]
 8005f42:	2049      	movs	r0, #73	; 0x49
 8005f44:	4619      	mov	r1, r3
 8005f46:	f00b f96d 	bl	8011224 <SEGGER_SYSVIEW_RecordU32>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 8005f4a:	3710      	adds	r7, #16
 8005f4c:	46bd      	mov	sp, r7
 8005f4e:	bd80      	pop	{r7, pc}
 8005f50:	2000bbac 	.word	0x2000bbac
 8005f54:	2000bbb0 	.word	0x2000bbb0
 8005f58:	2000bcb4 	.word	0x2000bcb4

08005f5c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 8005f5c:	b580      	push	{r7, lr}
 8005f5e:	b086      	sub	sp, #24
 8005f60:	af00      	add	r7, sp, #0
 8005f62:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
 8005f64:	687b      	ldr	r3, [r7, #4]
 8005f66:	613b      	str	r3, [r7, #16]
	BaseType_t xReturn = pdFALSE;
 8005f68:	2300      	movs	r3, #0
 8005f6a:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
 8005f6c:	687b      	ldr	r3, [r7, #4]
 8005f6e:	2b00      	cmp	r3, #0
 8005f70:	d073      	beq.n	800605a <xTaskPriorityDisinherit+0xfe>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
 8005f72:	4b3c      	ldr	r3, [pc, #240]	; (8006064 <xTaskPriorityDisinherit+0x108>)
 8005f74:	681b      	ldr	r3, [r3, #0]
 8005f76:	693a      	ldr	r2, [r7, #16]
 8005f78:	429a      	cmp	r2, r3
 8005f7a:	d009      	beq.n	8005f90 <xTaskPriorityDisinherit+0x34>
 8005f7c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005f80:	f383 8811 	msr	BASEPRI, r3
 8005f84:	f3bf 8f6f 	isb	sy
 8005f88:	f3bf 8f4f 	dsb	sy
 8005f8c:	60fb      	str	r3, [r7, #12]
 8005f8e:	e7fe      	b.n	8005f8e <xTaskPriorityDisinherit+0x32>

			configASSERT( pxTCB->uxMutexesHeld );
 8005f90:	693b      	ldr	r3, [r7, #16]
 8005f92:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005f94:	2b00      	cmp	r3, #0
 8005f96:	d109      	bne.n	8005fac <xTaskPriorityDisinherit+0x50>
 8005f98:	f04f 0350 	mov.w	r3, #80	; 0x50
 8005f9c:	f383 8811 	msr	BASEPRI, r3
 8005fa0:	f3bf 8f6f 	isb	sy
 8005fa4:	f3bf 8f4f 	dsb	sy
 8005fa8:	60bb      	str	r3, [r7, #8]
 8005faa:	e7fe      	b.n	8005faa <xTaskPriorityDisinherit+0x4e>
			( pxTCB->uxMutexesHeld )--;
 8005fac:	693b      	ldr	r3, [r7, #16]
 8005fae:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005fb0:	1e5a      	subs	r2, r3, #1
 8005fb2:	693b      	ldr	r3, [r7, #16]
 8005fb4:	651a      	str	r2, [r3, #80]	; 0x50

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8005fb6:	693b      	ldr	r3, [r7, #16]
 8005fb8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005fba:	693b      	ldr	r3, [r7, #16]
 8005fbc:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8005fbe:	429a      	cmp	r2, r3
 8005fc0:	d04b      	beq.n	800605a <xTaskPriorityDisinherit+0xfe>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 8005fc2:	693b      	ldr	r3, [r7, #16]
 8005fc4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8005fc6:	2b00      	cmp	r3, #0
 8005fc8:	d147      	bne.n	800605a <xTaskPriorityDisinherit+0xfe>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8005fca:	693b      	ldr	r3, [r7, #16]
 8005fcc:	3304      	adds	r3, #4
 8005fce:	4618      	mov	r0, r3
 8005fd0:	f7fd fe34 	bl	8003c3c <uxListRemove>
 8005fd4:	4603      	mov	r3, r0
 8005fd6:	2b00      	cmp	r3, #0
 8005fd8:	d115      	bne.n	8006006 <xTaskPriorityDisinherit+0xaa>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
 8005fda:	693b      	ldr	r3, [r7, #16]
 8005fdc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8005fde:	4922      	ldr	r1, [pc, #136]	; (8006068 <xTaskPriorityDisinherit+0x10c>)
 8005fe0:	4613      	mov	r3, r2
 8005fe2:	009b      	lsls	r3, r3, #2
 8005fe4:	4413      	add	r3, r2
 8005fe6:	009b      	lsls	r3, r3, #2
 8005fe8:	440b      	add	r3, r1
 8005fea:	681b      	ldr	r3, [r3, #0]
 8005fec:	2b00      	cmp	r3, #0
 8005fee:	d10a      	bne.n	8006006 <xTaskPriorityDisinherit+0xaa>
 8005ff0:	693b      	ldr	r3, [r7, #16]
 8005ff2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005ff4:	461a      	mov	r2, r3
 8005ff6:	2301      	movs	r3, #1
 8005ff8:	4093      	lsls	r3, r2
 8005ffa:	43da      	mvns	r2, r3
 8005ffc:	4b1b      	ldr	r3, [pc, #108]	; (800606c <xTaskPriorityDisinherit+0x110>)
 8005ffe:	681b      	ldr	r3, [r3, #0]
 8006000:	4013      	ands	r3, r2
 8006002:	4a1a      	ldr	r2, [pc, #104]	; (800606c <xTaskPriorityDisinherit+0x110>)
 8006004:	6013      	str	r3, [r2, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
 8006006:	687b      	ldr	r3, [r7, #4]
 8006008:	204a      	movs	r0, #74	; 0x4a
 800600a:	4619      	mov	r1, r3
 800600c:	f00b f90a 	bl	8011224 <SEGGER_SYSVIEW_RecordU32>
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 8006010:	693b      	ldr	r3, [r7, #16]
 8006012:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8006014:	693b      	ldr	r3, [r7, #16]
 8006016:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8006018:	693b      	ldr	r3, [r7, #16]
 800601a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800601c:	f1c3 0207 	rsb	r2, r3, #7
 8006020:	693b      	ldr	r3, [r7, #16]
 8006022:	619a      	str	r2, [r3, #24]
					prvReaddTaskToReadyList( pxTCB );
 8006024:	693b      	ldr	r3, [r7, #16]
 8006026:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006028:	461a      	mov	r2, r3
 800602a:	2301      	movs	r3, #1
 800602c:	fa03 f202 	lsl.w	r2, r3, r2
 8006030:	4b0e      	ldr	r3, [pc, #56]	; (800606c <xTaskPriorityDisinherit+0x110>)
 8006032:	681b      	ldr	r3, [r3, #0]
 8006034:	4313      	orrs	r3, r2
 8006036:	4a0d      	ldr	r2, [pc, #52]	; (800606c <xTaskPriorityDisinherit+0x110>)
 8006038:	6013      	str	r3, [r2, #0]
 800603a:	693b      	ldr	r3, [r7, #16]
 800603c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800603e:	4613      	mov	r3, r2
 8006040:	009b      	lsls	r3, r3, #2
 8006042:	4413      	add	r3, r2
 8006044:	009b      	lsls	r3, r3, #2
 8006046:	4a08      	ldr	r2, [pc, #32]	; (8006068 <xTaskPriorityDisinherit+0x10c>)
 8006048:	441a      	add	r2, r3
 800604a:	693b      	ldr	r3, [r7, #16]
 800604c:	3304      	adds	r3, #4
 800604e:	4610      	mov	r0, r2
 8006050:	4619      	mov	r1, r3
 8006052:	f7fd fd97 	bl	8003b84 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 8006056:	2301      	movs	r3, #1
 8006058:	617b      	str	r3, [r7, #20]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 800605a:	697b      	ldr	r3, [r7, #20]
	}
 800605c:	4618      	mov	r0, r3
 800605e:	3718      	adds	r7, #24
 8006060:	46bd      	mov	sp, r7
 8006062:	bd80      	pop	{r7, pc}
 8006064:	2000bbac 	.word	0x2000bbac
 8006068:	2000bbb0 	.word	0x2000bbb0
 800606c:	2000bcb4 	.word	0x2000bcb4

08006070 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
 8006070:	b480      	push	{r7}
 8006072:	b083      	sub	sp, #12
 8006074:	af00      	add	r7, sp, #0
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
 8006076:	4b09      	ldr	r3, [pc, #36]	; (800609c <uxTaskResetEventItemValue+0x2c>)
 8006078:	681b      	ldr	r3, [r3, #0]
 800607a:	699b      	ldr	r3, [r3, #24]
 800607c:	607b      	str	r3, [r7, #4]

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800607e:	4b07      	ldr	r3, [pc, #28]	; (800609c <uxTaskResetEventItemValue+0x2c>)
 8006080:	681b      	ldr	r3, [r3, #0]
 8006082:	4a06      	ldr	r2, [pc, #24]	; (800609c <uxTaskResetEventItemValue+0x2c>)
 8006084:	6812      	ldr	r2, [r2, #0]
 8006086:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8006088:	f1c2 0207 	rsb	r2, r2, #7
 800608c:	619a      	str	r2, [r3, #24]

	return uxReturn;
 800608e:	687b      	ldr	r3, [r7, #4]
}
 8006090:	4618      	mov	r0, r3
 8006092:	370c      	adds	r7, #12
 8006094:	46bd      	mov	sp, r7
 8006096:	f85d 7b04 	ldr.w	r7, [sp], #4
 800609a:	4770      	bx	lr
 800609c:	2000bbac 	.word	0x2000bbac

080060a0 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
 80060a0:	b480      	push	{r7}
 80060a2:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
 80060a4:	4b07      	ldr	r3, [pc, #28]	; (80060c4 <pvTaskIncrementMutexHeldCount+0x24>)
 80060a6:	681b      	ldr	r3, [r3, #0]
 80060a8:	2b00      	cmp	r3, #0
 80060aa:	d004      	beq.n	80060b6 <pvTaskIncrementMutexHeldCount+0x16>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
 80060ac:	4b05      	ldr	r3, [pc, #20]	; (80060c4 <pvTaskIncrementMutexHeldCount+0x24>)
 80060ae:	681b      	ldr	r3, [r3, #0]
 80060b0:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80060b2:	3201      	adds	r2, #1
 80060b4:	651a      	str	r2, [r3, #80]	; 0x50
		}

		return pxCurrentTCB;
 80060b6:	4b03      	ldr	r3, [pc, #12]	; (80060c4 <pvTaskIncrementMutexHeldCount+0x24>)
 80060b8:	681b      	ldr	r3, [r3, #0]
	}
 80060ba:	4618      	mov	r0, r3
 80060bc:	46bd      	mov	sp, r7
 80060be:	f85d 7b04 	ldr.w	r7, [sp], #4
 80060c2:	4770      	bx	lr
 80060c4:	2000bbac 	.word	0x2000bbac

080060c8 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
 80060c8:	b580      	push	{r7, lr}
 80060ca:	b084      	sub	sp, #16
 80060cc:	af00      	add	r7, sp, #0
 80060ce:	6078      	str	r0, [r7, #4]
 80060d0:	6039      	str	r1, [r7, #0]
	uint32_t ulReturn;

		taskENTER_CRITICAL();
 80060d2:	f7fd fedb 	bl	8003e8c <vPortEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
 80060d6:	4b21      	ldr	r3, [pc, #132]	; (800615c <ulTaskNotifyTake+0x94>)
 80060d8:	681b      	ldr	r3, [r3, #0]
 80060da:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80060dc:	2b00      	cmp	r3, #0
 80060de:	d113      	bne.n	8006108 <ulTaskNotifyTake+0x40>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
 80060e0:	4b1e      	ldr	r3, [pc, #120]	; (800615c <ulTaskNotifyTake+0x94>)
 80060e2:	681b      	ldr	r3, [r3, #0]
 80060e4:	2201      	movs	r2, #1
 80060e6:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68

				if( xTicksToWait > ( TickType_t ) 0 )
 80060ea:	683b      	ldr	r3, [r7, #0]
 80060ec:	2b00      	cmp	r3, #0
 80060ee:	d00b      	beq.n	8006108 <ulTaskNotifyTake+0x40>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 80060f0:	6838      	ldr	r0, [r7, #0]
 80060f2:	2101      	movs	r1, #1
 80060f4:	f000 f98a 	bl	800640c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
 80060f8:	4b19      	ldr	r3, [pc, #100]	; (8006160 <ulTaskNotifyTake+0x98>)
 80060fa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80060fe:	601a      	str	r2, [r3, #0]
 8006100:	f3bf 8f4f 	dsb	sy
 8006104:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 8006108:	f7fd feee 	bl	8003ee8 <vPortExitCritical>

		taskENTER_CRITICAL();
 800610c:	f7fd febe 	bl	8003e8c <vPortEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
 8006110:	687b      	ldr	r3, [r7, #4]
 8006112:	2042      	movs	r0, #66	; 0x42
 8006114:	4619      	mov	r1, r3
 8006116:	683a      	ldr	r2, [r7, #0]
 8006118:	f00b f8c0 	bl	801129c <SEGGER_SYSVIEW_RecordU32x2>
			ulReturn = pxCurrentTCB->ulNotifiedValue;
 800611c:	4b0f      	ldr	r3, [pc, #60]	; (800615c <ulTaskNotifyTake+0x94>)
 800611e:	681b      	ldr	r3, [r3, #0]
 8006120:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006122:	60fb      	str	r3, [r7, #12]

			if( ulReturn != 0UL )
 8006124:	68fb      	ldr	r3, [r7, #12]
 8006126:	2b00      	cmp	r3, #0
 8006128:	d00c      	beq.n	8006144 <ulTaskNotifyTake+0x7c>
			{
				if( xClearCountOnExit != pdFALSE )
 800612a:	687b      	ldr	r3, [r7, #4]
 800612c:	2b00      	cmp	r3, #0
 800612e:	d004      	beq.n	800613a <ulTaskNotifyTake+0x72>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
 8006130:	4b0a      	ldr	r3, [pc, #40]	; (800615c <ulTaskNotifyTake+0x94>)
 8006132:	681b      	ldr	r3, [r3, #0]
 8006134:	2200      	movs	r2, #0
 8006136:	665a      	str	r2, [r3, #100]	; 0x64
 8006138:	e004      	b.n	8006144 <ulTaskNotifyTake+0x7c>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
 800613a:	4b08      	ldr	r3, [pc, #32]	; (800615c <ulTaskNotifyTake+0x94>)
 800613c:	681b      	ldr	r3, [r3, #0]
 800613e:	68fa      	ldr	r2, [r7, #12]
 8006140:	3a01      	subs	r2, #1
 8006142:	665a      	str	r2, [r3, #100]	; 0x64
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8006144:	4b05      	ldr	r3, [pc, #20]	; (800615c <ulTaskNotifyTake+0x94>)
 8006146:	681b      	ldr	r3, [r3, #0]
 8006148:	2200      	movs	r2, #0
 800614a:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
		}
		taskEXIT_CRITICAL();
 800614e:	f7fd fecb 	bl	8003ee8 <vPortExitCritical>

		return ulReturn;
 8006152:	68fb      	ldr	r3, [r7, #12]
	}
 8006154:	4618      	mov	r0, r3
 8006156:	3710      	adds	r7, #16
 8006158:	46bd      	mov	sp, r7
 800615a:	bd80      	pop	{r7, pc}
 800615c:	2000bbac 	.word	0x2000bbac
 8006160:	e000ed04 	.word	0xe000ed04

08006164 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
 8006164:	b590      	push	{r4, r7, lr}
 8006166:	b08d      	sub	sp, #52	; 0x34
 8006168:	af02      	add	r7, sp, #8
 800616a:	60f8      	str	r0, [r7, #12]
 800616c:	60b9      	str	r1, [r7, #8]
 800616e:	603b      	str	r3, [r7, #0]
 8006170:	4613      	mov	r3, r2
 8006172:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
 8006174:	2301      	movs	r3, #1
 8006176:	627b      	str	r3, [r7, #36]	; 0x24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
 8006178:	68fb      	ldr	r3, [r7, #12]
 800617a:	2b00      	cmp	r3, #0
 800617c:	d109      	bne.n	8006192 <xTaskGenericNotify+0x2e>
 800617e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006182:	f383 8811 	msr	BASEPRI, r3
 8006186:	f3bf 8f6f 	isb	sy
 800618a:	f3bf 8f4f 	dsb	sy
 800618e:	61bb      	str	r3, [r7, #24]
 8006190:	e7fe      	b.n	8006190 <xTaskGenericNotify+0x2c>
		pxTCB = ( TCB_t * ) xTaskToNotify;
 8006192:	68fb      	ldr	r3, [r7, #12]
 8006194:	623b      	str	r3, [r7, #32]

		taskENTER_CRITICAL();
 8006196:	f7fd fe79 	bl	8003e8c <vPortEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
 800619a:	683b      	ldr	r3, [r7, #0]
 800619c:	2b00      	cmp	r3, #0
 800619e:	d003      	beq.n	80061a8 <xTaskGenericNotify+0x44>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
 80061a0:	6a3b      	ldr	r3, [r7, #32]
 80061a2:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 80061a4:	683b      	ldr	r3, [r7, #0]
 80061a6:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
 80061a8:	6a3b      	ldr	r3, [r7, #32]
 80061aa:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 80061ae:	77fb      	strb	r3, [r7, #31]

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 80061b0:	6a3b      	ldr	r3, [r7, #32]
 80061b2:	2202      	movs	r2, #2
 80061b4:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68

			switch( eAction )
 80061b8:	79fb      	ldrb	r3, [r7, #7]
 80061ba:	2b04      	cmp	r3, #4
 80061bc:	d827      	bhi.n	800620e <xTaskGenericNotify+0xaa>
 80061be:	a201      	add	r2, pc, #4	; (adr r2, 80061c4 <xTaskGenericNotify+0x60>)
 80061c0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80061c4:	0800620f 	.word	0x0800620f
 80061c8:	080061d9 	.word	0x080061d9
 80061cc:	080061e7 	.word	0x080061e7
 80061d0:	080061f3 	.word	0x080061f3
 80061d4:	080061fb 	.word	0x080061fb
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
 80061d8:	6a3b      	ldr	r3, [r7, #32]
 80061da:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 80061dc:	68bb      	ldr	r3, [r7, #8]
 80061de:	431a      	orrs	r2, r3
 80061e0:	6a3b      	ldr	r3, [r7, #32]
 80061e2:	665a      	str	r2, [r3, #100]	; 0x64
					break;
 80061e4:	e013      	b.n	800620e <xTaskGenericNotify+0xaa>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
 80061e6:	6a3b      	ldr	r3, [r7, #32]
 80061e8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80061ea:	1c5a      	adds	r2, r3, #1
 80061ec:	6a3b      	ldr	r3, [r7, #32]
 80061ee:	665a      	str	r2, [r3, #100]	; 0x64
					break;
 80061f0:	e00d      	b.n	800620e <xTaskGenericNotify+0xaa>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
 80061f2:	6a3b      	ldr	r3, [r7, #32]
 80061f4:	68ba      	ldr	r2, [r7, #8]
 80061f6:	665a      	str	r2, [r3, #100]	; 0x64
					break;
 80061f8:	e009      	b.n	800620e <xTaskGenericNotify+0xaa>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
 80061fa:	7ffb      	ldrb	r3, [r7, #31]
 80061fc:	2b02      	cmp	r3, #2
 80061fe:	d003      	beq.n	8006208 <xTaskGenericNotify+0xa4>
					{
						pxTCB->ulNotifiedValue = ulValue;
 8006200:	6a3b      	ldr	r3, [r7, #32]
 8006202:	68ba      	ldr	r2, [r7, #8]
 8006204:	665a      	str	r2, [r3, #100]	; 0x64
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
 8006206:	e001      	b.n	800620c <xTaskGenericNotify+0xa8>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
 8006208:	2300      	movs	r3, #0
 800620a:	627b      	str	r3, [r7, #36]	; 0x24
					}
					break;
 800620c:	bf00      	nop
					/* The task is being notified without its notify value being
					updated. */
					break;
			}

			traceTASK_NOTIFY();
 800620e:	6a3b      	ldr	r3, [r7, #32]
 8006210:	4618      	mov	r0, r3
 8006212:	f00b fdcb 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 8006216:	4602      	mov	r2, r0
 8006218:	79fc      	ldrb	r4, [r7, #7]
 800621a:	683b      	ldr	r3, [r7, #0]
 800621c:	9300      	str	r3, [sp, #0]
 800621e:	203e      	movs	r0, #62	; 0x3e
 8006220:	4611      	mov	r1, r2
 8006222:	68ba      	ldr	r2, [r7, #8]
 8006224:	4623      	mov	r3, r4
 8006226:	f00c f803 	bl	8012230 <SYSVIEW_RecordU32x4>

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 800622a:	7ffb      	ldrb	r3, [r7, #31]
 800622c:	2b01      	cmp	r3, #1
 800622e:	d13e      	bne.n	80062ae <xTaskGenericNotify+0x14a>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8006230:	6a3b      	ldr	r3, [r7, #32]
 8006232:	3304      	adds	r3, #4
 8006234:	4618      	mov	r0, r3
 8006236:	f7fd fd01 	bl	8003c3c <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
 800623a:	6a3b      	ldr	r3, [r7, #32]
 800623c:	4618      	mov	r0, r3
 800623e:	f00b fccf 	bl	8011be0 <SEGGER_SYSVIEW_OnTaskStartReady>
 8006242:	6a3b      	ldr	r3, [r7, #32]
 8006244:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006246:	461a      	mov	r2, r3
 8006248:	2301      	movs	r3, #1
 800624a:	fa03 f202 	lsl.w	r2, r3, r2
 800624e:	4b1b      	ldr	r3, [pc, #108]	; (80062bc <xTaskGenericNotify+0x158>)
 8006250:	681b      	ldr	r3, [r3, #0]
 8006252:	4313      	orrs	r3, r2
 8006254:	4a19      	ldr	r2, [pc, #100]	; (80062bc <xTaskGenericNotify+0x158>)
 8006256:	6013      	str	r3, [r2, #0]
 8006258:	6a3b      	ldr	r3, [r7, #32]
 800625a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800625c:	4613      	mov	r3, r2
 800625e:	009b      	lsls	r3, r3, #2
 8006260:	4413      	add	r3, r2
 8006262:	009b      	lsls	r3, r3, #2
 8006264:	4a16      	ldr	r2, [pc, #88]	; (80062c0 <xTaskGenericNotify+0x15c>)
 8006266:	441a      	add	r2, r3
 8006268:	6a3b      	ldr	r3, [r7, #32]
 800626a:	3304      	adds	r3, #4
 800626c:	4610      	mov	r0, r2
 800626e:	4619      	mov	r1, r3
 8006270:	f7fd fc88 	bl	8003b84 <vListInsertEnd>

				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 8006274:	6a3b      	ldr	r3, [r7, #32]
 8006276:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006278:	2b00      	cmp	r3, #0
 800627a:	d009      	beq.n	8006290 <xTaskGenericNotify+0x12c>
 800627c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006280:	f383 8811 	msr	BASEPRI, r3
 8006284:	f3bf 8f6f 	isb	sy
 8006288:	f3bf 8f4f 	dsb	sy
 800628c:	617b      	str	r3, [r7, #20]
 800628e:	e7fe      	b.n	800628e <xTaskGenericNotify+0x12a>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 8006290:	6a3b      	ldr	r3, [r7, #32]
 8006292:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8006294:	4b0b      	ldr	r3, [pc, #44]	; (80062c4 <xTaskGenericNotify+0x160>)
 8006296:	681b      	ldr	r3, [r3, #0]
 8006298:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800629a:	429a      	cmp	r2, r3
 800629c:	d907      	bls.n	80062ae <xTaskGenericNotify+0x14a>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
 800629e:	4b0a      	ldr	r3, [pc, #40]	; (80062c8 <xTaskGenericNotify+0x164>)
 80062a0:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80062a4:	601a      	str	r2, [r3, #0]
 80062a6:	f3bf 8f4f 	dsb	sy
 80062aa:	f3bf 8f6f 	isb	sy
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
 80062ae:	f7fd fe1b 	bl	8003ee8 <vPortExitCritical>

		return xReturn;
 80062b2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	}
 80062b4:	4618      	mov	r0, r3
 80062b6:	372c      	adds	r7, #44	; 0x2c
 80062b8:	46bd      	mov	sp, r7
 80062ba:	bd90      	pop	{r4, r7, pc}
 80062bc:	2000bcb4 	.word	0x2000bcb4
 80062c0:	2000bbb0 	.word	0x2000bbb0
 80062c4:	2000bbac 	.word	0x2000bbac
 80062c8:	e000ed04 	.word	0xe000ed04

080062cc <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
 80062cc:	b580      	push	{r7, lr}
 80062ce:	b08a      	sub	sp, #40	; 0x28
 80062d0:	af00      	add	r7, sp, #0
 80062d2:	6078      	str	r0, [r7, #4]
 80062d4:	6039      	str	r1, [r7, #0]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
 80062d6:	687b      	ldr	r3, [r7, #4]
 80062d8:	2b00      	cmp	r3, #0
 80062da:	d109      	bne.n	80062f0 <vTaskNotifyGiveFromISR+0x24>
 80062dc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80062e0:	f383 8811 	msr	BASEPRI, r3
 80062e4:	f3bf 8f6f 	isb	sy
 80062e8:	f3bf 8f4f 	dsb	sy
 80062ec:	61bb      	str	r3, [r7, #24]
 80062ee:	e7fe      	b.n	80062ee <vTaskNotifyGiveFromISR+0x22>
		below the maximum system call interrupt priority.  FreeRTOS maintains a
		separate interrupt safe API to ensure interrupt entry is as fast and as
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 80062f0:	f7fd fea2 	bl	8004038 <vPortValidateInterruptPriority>

		pxTCB = ( TCB_t * ) xTaskToNotify;
 80062f4:	687b      	ldr	r3, [r7, #4]
 80062f6:	627b      	str	r3, [r7, #36]	; 0x24

portFORCE_INLINE static uint32_t ulPortRaiseBASEPRI( void )
{
uint32_t ulOriginalBASEPRI, ulNewBASEPRI;

	__asm volatile
 80062f8:	f3ef 8211 	mrs	r2, BASEPRI
 80062fc:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006300:	f383 8811 	msr	BASEPRI, r3
 8006304:	f3bf 8f6f 	isb	sy
 8006308:	f3bf 8f4f 	dsb	sy
 800630c:	617a      	str	r2, [r7, #20]
 800630e:	613b      	str	r3, [r7, #16]
		:"=r" (ulOriginalBASEPRI), "=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY )
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return ulOriginalBASEPRI;
 8006310:	697b      	ldr	r3, [r7, #20]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 8006312:	623b      	str	r3, [r7, #32]
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
 8006314:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006316:	f893 3068 	ldrb.w	r3, [r3, #104]	; 0x68
 800631a:	77fb      	strb	r3, [r7, #31]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
 800631c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800631e:	2202      	movs	r2, #2
 8006320:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
 8006324:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006326:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8006328:	1c5a      	adds	r2, r3, #1
 800632a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800632c:	665a      	str	r2, [r3, #100]	; 0x64

			traceTASK_NOTIFY_GIVE_FROM_ISR();
 800632e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006330:	4618      	mov	r0, r3
 8006332:	f00b fd3b 	bl	8011dac <SEGGER_SYSVIEW_ShrinkId>
 8006336:	4602      	mov	r2, r0
 8006338:	683b      	ldr	r3, [r7, #0]
 800633a:	2041      	movs	r0, #65	; 0x41
 800633c:	4611      	mov	r1, r2
 800633e:	461a      	mov	r2, r3
 8006340:	f00a ffac 	bl	801129c <SEGGER_SYSVIEW_RecordU32x2>

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
 8006344:	7ffb      	ldrb	r3, [r7, #31]
 8006346:	2b01      	cmp	r3, #1
 8006348:	d14b      	bne.n	80063e2 <vTaskNotifyGiveFromISR+0x116>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
 800634a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800634c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800634e:	2b00      	cmp	r3, #0
 8006350:	d009      	beq.n	8006366 <vTaskNotifyGiveFromISR+0x9a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8006352:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006356:	f383 8811 	msr	BASEPRI, r3
 800635a:	f3bf 8f6f 	isb	sy
 800635e:	f3bf 8f4f 	dsb	sy
 8006362:	60fb      	str	r3, [r7, #12]
 8006364:	e7fe      	b.n	8006364 <vTaskNotifyGiveFromISR+0x98>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8006366:	4b23      	ldr	r3, [pc, #140]	; (80063f4 <vTaskNotifyGiveFromISR+0x128>)
 8006368:	681b      	ldr	r3, [r3, #0]
 800636a:	2b00      	cmp	r3, #0
 800636c:	d122      	bne.n	80063b4 <vTaskNotifyGiveFromISR+0xe8>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800636e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006370:	3304      	adds	r3, #4
 8006372:	4618      	mov	r0, r3
 8006374:	f7fd fc62 	bl	8003c3c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8006378:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800637a:	4618      	mov	r0, r3
 800637c:	f00b fc30 	bl	8011be0 <SEGGER_SYSVIEW_OnTaskStartReady>
 8006380:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006382:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006384:	461a      	mov	r2, r3
 8006386:	2301      	movs	r3, #1
 8006388:	fa03 f202 	lsl.w	r2, r3, r2
 800638c:	4b1a      	ldr	r3, [pc, #104]	; (80063f8 <vTaskNotifyGiveFromISR+0x12c>)
 800638e:	681b      	ldr	r3, [r3, #0]
 8006390:	4313      	orrs	r3, r2
 8006392:	4a19      	ldr	r2, [pc, #100]	; (80063f8 <vTaskNotifyGiveFromISR+0x12c>)
 8006394:	6013      	str	r3, [r2, #0]
 8006396:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006398:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800639a:	4613      	mov	r3, r2
 800639c:	009b      	lsls	r3, r3, #2
 800639e:	4413      	add	r3, r2
 80063a0:	009b      	lsls	r3, r3, #2
 80063a2:	4a16      	ldr	r2, [pc, #88]	; (80063fc <vTaskNotifyGiveFromISR+0x130>)
 80063a4:	441a      	add	r2, r3
 80063a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80063a8:	3304      	adds	r3, #4
 80063aa:	4610      	mov	r0, r2
 80063ac:	4619      	mov	r1, r3
 80063ae:	f7fd fbe9 	bl	8003b84 <vListInsertEnd>
 80063b2:	e005      	b.n	80063c0 <vTaskNotifyGiveFromISR+0xf4>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 80063b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80063b6:	3318      	adds	r3, #24
 80063b8:	4811      	ldr	r0, [pc, #68]	; (8006400 <vTaskNotifyGiveFromISR+0x134>)
 80063ba:	4619      	mov	r1, r3
 80063bc:	f7fd fbe2 	bl	8003b84 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
 80063c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80063c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80063c4:	4b0f      	ldr	r3, [pc, #60]	; (8006404 <vTaskNotifyGiveFromISR+0x138>)
 80063c6:	681b      	ldr	r3, [r3, #0]
 80063c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80063ca:	429a      	cmp	r2, r3
 80063cc:	d909      	bls.n	80063e2 <vTaskNotifyGiveFromISR+0x116>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
 80063ce:	683b      	ldr	r3, [r7, #0]
 80063d0:	2b00      	cmp	r3, #0
 80063d2:	d003      	beq.n	80063dc <vTaskNotifyGiveFromISR+0x110>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
 80063d4:	683b      	ldr	r3, [r7, #0]
 80063d6:	2201      	movs	r2, #1
 80063d8:	601a      	str	r2, [r3, #0]
 80063da:	e002      	b.n	80063e2 <vTaskNotifyGiveFromISR+0x116>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
 80063dc:	4b0a      	ldr	r3, [pc, #40]	; (8006408 <vTaskNotifyGiveFromISR+0x13c>)
 80063de:	2201      	movs	r2, #1
 80063e0:	601a      	str	r2, [r3, #0]
 80063e2:	6a3b      	ldr	r3, [r7, #32]
 80063e4:	60bb      	str	r3, [r7, #8]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 80063e6:	68bb      	ldr	r3, [r7, #8]
 80063e8:	f383 8811 	msr	BASEPRI, r3
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
 80063ec:	3728      	adds	r7, #40	; 0x28
 80063ee:	46bd      	mov	sp, r7
 80063f0:	bd80      	pop	{r7, pc}
 80063f2:	bf00      	nop
 80063f4:	2000bcd4 	.word	0x2000bcd4
 80063f8:	2000bcb4 	.word	0x2000bcb4
 80063fc:	2000bbb0 	.word	0x2000bbb0
 8006400:	2000bc6c 	.word	0x2000bc6c
 8006404:	2000bbac 	.word	0x2000bbac
 8006408:	2000bcc0 	.word	0x2000bcc0

0800640c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 800640c:	b580      	push	{r7, lr}
 800640e:	b084      	sub	sp, #16
 8006410:	af00      	add	r7, sp, #0
 8006412:	6078      	str	r0, [r7, #4]
 8006414:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8006416:	4b31      	ldr	r3, [pc, #196]	; (80064dc <prvAddCurrentTaskToDelayedList+0xd0>)
 8006418:	681b      	ldr	r3, [r3, #0]
 800641a:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 800641c:	4b30      	ldr	r3, [pc, #192]	; (80064e0 <prvAddCurrentTaskToDelayedList+0xd4>)
 800641e:	681b      	ldr	r3, [r3, #0]
 8006420:	3304      	adds	r3, #4
 8006422:	4618      	mov	r0, r3
 8006424:	f7fd fc0a 	bl	8003c3c <uxListRemove>
 8006428:	4603      	mov	r3, r0
 800642a:	2b00      	cmp	r3, #0
 800642c:	d10b      	bne.n	8006446 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 800642e:	4b2c      	ldr	r3, [pc, #176]	; (80064e0 <prvAddCurrentTaskToDelayedList+0xd4>)
 8006430:	681b      	ldr	r3, [r3, #0]
 8006432:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006434:	461a      	mov	r2, r3
 8006436:	2301      	movs	r3, #1
 8006438:	4093      	lsls	r3, r2
 800643a:	43da      	mvns	r2, r3
 800643c:	4b29      	ldr	r3, [pc, #164]	; (80064e4 <prvAddCurrentTaskToDelayedList+0xd8>)
 800643e:	681b      	ldr	r3, [r3, #0]
 8006440:	4013      	ands	r3, r2
 8006442:	4a28      	ldr	r2, [pc, #160]	; (80064e4 <prvAddCurrentTaskToDelayedList+0xd8>)
 8006444:	6013      	str	r3, [r2, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8006446:	687b      	ldr	r3, [r7, #4]
 8006448:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800644c:	d110      	bne.n	8006470 <prvAddCurrentTaskToDelayedList+0x64>
 800644e:	683b      	ldr	r3, [r7, #0]
 8006450:	2b00      	cmp	r3, #0
 8006452:	d00d      	beq.n	8006470 <prvAddCurrentTaskToDelayedList+0x64>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			traceMOVED_TASK_TO_SUSPENDED_LIST(pxCurrentTCB);
 8006454:	4b22      	ldr	r3, [pc, #136]	; (80064e0 <prvAddCurrentTaskToDelayedList+0xd4>)
 8006456:	681b      	ldr	r3, [r3, #0]
 8006458:	4618      	mov	r0, r3
 800645a:	211b      	movs	r1, #27
 800645c:	f00b fc02 	bl	8011c64 <SEGGER_SYSVIEW_OnTaskStopReady>
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8006460:	4b1f      	ldr	r3, [pc, #124]	; (80064e0 <prvAddCurrentTaskToDelayedList+0xd4>)
 8006462:	681b      	ldr	r3, [r3, #0]
 8006464:	3304      	adds	r3, #4
 8006466:	4820      	ldr	r0, [pc, #128]	; (80064e8 <prvAddCurrentTaskToDelayedList+0xdc>)
 8006468:	4619      	mov	r1, r3
 800646a:	f7fd fb8b 	bl	8003b84 <vListInsertEnd>
 800646e:	e032      	b.n	80064d6 <prvAddCurrentTaskToDelayedList+0xca>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
 8006470:	68fa      	ldr	r2, [r7, #12]
 8006472:	687b      	ldr	r3, [r7, #4]
 8006474:	4413      	add	r3, r2
 8006476:	60bb      	str	r3, [r7, #8]

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8006478:	4b19      	ldr	r3, [pc, #100]	; (80064e0 <prvAddCurrentTaskToDelayedList+0xd4>)
 800647a:	681b      	ldr	r3, [r3, #0]
 800647c:	68ba      	ldr	r2, [r7, #8]
 800647e:	605a      	str	r2, [r3, #4]

			if( xTimeToWake < xConstTickCount )
 8006480:	68ba      	ldr	r2, [r7, #8]
 8006482:	68fb      	ldr	r3, [r7, #12]
 8006484:	429a      	cmp	r2, r3
 8006486:	d20f      	bcs.n	80064a8 <prvAddCurrentTaskToDelayedList+0x9c>
			{
                traceMOVED_TASK_TO_OVERFLOW_DELAYED_LIST();
 8006488:	4b15      	ldr	r3, [pc, #84]	; (80064e0 <prvAddCurrentTaskToDelayedList+0xd4>)
 800648a:	681b      	ldr	r3, [r3, #0]
 800648c:	4618      	mov	r0, r3
 800648e:	2104      	movs	r1, #4
 8006490:	f00b fbe8 	bl	8011c64 <SEGGER_SYSVIEW_OnTaskStopReady>
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8006494:	4b15      	ldr	r3, [pc, #84]	; (80064ec <prvAddCurrentTaskToDelayedList+0xe0>)
 8006496:	681a      	ldr	r2, [r3, #0]
 8006498:	4b11      	ldr	r3, [pc, #68]	; (80064e0 <prvAddCurrentTaskToDelayedList+0xd4>)
 800649a:	681b      	ldr	r3, [r3, #0]
 800649c:	3304      	adds	r3, #4
 800649e:	4610      	mov	r0, r2
 80064a0:	4619      	mov	r1, r3
 80064a2:	f7fd fb93 	bl	8003bcc <vListInsert>
 80064a6:	e016      	b.n	80064d6 <prvAddCurrentTaskToDelayedList+0xca>
			}
			else
			{
                traceMOVED_TASK_TO_DELAYED_LIST();
 80064a8:	4b0d      	ldr	r3, [pc, #52]	; (80064e0 <prvAddCurrentTaskToDelayedList+0xd4>)
 80064aa:	681b      	ldr	r3, [r3, #0]
 80064ac:	4618      	mov	r0, r3
 80064ae:	2104      	movs	r1, #4
 80064b0:	f00b fbd8 	bl	8011c64 <SEGGER_SYSVIEW_OnTaskStopReady>
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 80064b4:	4b0e      	ldr	r3, [pc, #56]	; (80064f0 <prvAddCurrentTaskToDelayedList+0xe4>)
 80064b6:	681a      	ldr	r2, [r3, #0]
 80064b8:	4b09      	ldr	r3, [pc, #36]	; (80064e0 <prvAddCurrentTaskToDelayedList+0xd4>)
 80064ba:	681b      	ldr	r3, [r3, #0]
 80064bc:	3304      	adds	r3, #4
 80064be:	4610      	mov	r0, r2
 80064c0:	4619      	mov	r1, r3
 80064c2:	f7fd fb83 	bl	8003bcc <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
 80064c6:	4b0b      	ldr	r3, [pc, #44]	; (80064f4 <prvAddCurrentTaskToDelayedList+0xe8>)
 80064c8:	681b      	ldr	r3, [r3, #0]
 80064ca:	68ba      	ldr	r2, [r7, #8]
 80064cc:	429a      	cmp	r2, r3
 80064ce:	d202      	bcs.n	80064d6 <prvAddCurrentTaskToDelayedList+0xca>
				{
					xNextTaskUnblockTime = xTimeToWake;
 80064d0:	4a08      	ldr	r2, [pc, #32]	; (80064f4 <prvAddCurrentTaskToDelayedList+0xe8>)
 80064d2:	68bb      	ldr	r3, [r7, #8]
 80064d4:	6013      	str	r3, [r2, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 80064d6:	3710      	adds	r7, #16
 80064d8:	46bd      	mov	sp, r7
 80064da:	bd80      	pop	{r7, pc}
 80064dc:	2000bcb0 	.word	0x2000bcb0
 80064e0:	2000bbac 	.word	0x2000bbac
 80064e4:	2000bcb4 	.word	0x2000bcb4
 80064e8:	2000bc98 	.word	0x2000bc98
 80064ec:	2000bc68 	.word	0x2000bc68
 80064f0:	2000bc64 	.word	0x2000bc64
 80064f4:	2000bccc 	.word	0x2000bccc

080064f8 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
 80064f8:	b580      	push	{r7, lr}
 80064fa:	b082      	sub	sp, #8
 80064fc:	af00      	add	r7, sp, #0
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
 80064fe:	201c      	movs	r0, #28
 8006500:	f7fd fdd6 	bl	80040b0 <pvPortMalloc>
 8006504:	6078      	str	r0, [r7, #4]

		if( pxEventBits != NULL )
 8006506:	687b      	ldr	r3, [r7, #4]
 8006508:	2b00      	cmp	r3, #0
 800650a:	d007      	beq.n	800651c <xEventGroupCreate+0x24>
		{
			pxEventBits->uxEventBits = 0;
 800650c:	687b      	ldr	r3, [r7, #4]
 800650e:	2200      	movs	r2, #0
 8006510:	601a      	str	r2, [r3, #0]
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
 8006512:	687b      	ldr	r3, [r7, #4]
 8006514:	3304      	adds	r3, #4
 8006516:	4618      	mov	r0, r3
 8006518:	f7fd fb08 	bl	8003b2c <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
 800651c:	687b      	ldr	r3, [r7, #4]
	}
 800651e:	4618      	mov	r0, r3
 8006520:	3708      	adds	r7, #8
 8006522:	46bd      	mov	sp, r7
 8006524:	bd80      	pop	{r7, pc}
 8006526:	bf00      	nop

08006528 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
 8006528:	b580      	push	{r7, lr}
 800652a:	b090      	sub	sp, #64	; 0x40
 800652c:	af00      	add	r7, sp, #0
 800652e:	60f8      	str	r0, [r7, #12]
 8006530:	60b9      	str	r1, [r7, #8]
 8006532:	607a      	str	r2, [r7, #4]
 8006534:	603b      	str	r3, [r7, #0]
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
 8006536:	68fb      	ldr	r3, [r7, #12]
 8006538:	637b      	str	r3, [r7, #52]	; 0x34
EventBits_t uxReturn, uxControlBits = 0;
 800653a:	2300      	movs	r3, #0
 800653c:	63bb      	str	r3, [r7, #56]	; 0x38
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
 800653e:	2300      	movs	r3, #0
 8006540:	633b      	str	r3, [r7, #48]	; 0x30

	/* Check the user is not attempting to wait on the bits used by the kernel
	itself, and that at least one bit is being requested. */
	configASSERT( xEventGroup );
 8006542:	68fb      	ldr	r3, [r7, #12]
 8006544:	2b00      	cmp	r3, #0
 8006546:	d109      	bne.n	800655c <xEventGroupWaitBits+0x34>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8006548:	f04f 0350 	mov.w	r3, #80	; 0x50
 800654c:	f383 8811 	msr	BASEPRI, r3
 8006550:	f3bf 8f6f 	isb	sy
 8006554:	f3bf 8f4f 	dsb	sy
 8006558:	623b      	str	r3, [r7, #32]
 800655a:	e7fe      	b.n	800655a <xEventGroupWaitBits+0x32>
	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 800655c:	68bb      	ldr	r3, [r7, #8]
 800655e:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 8006562:	2b00      	cmp	r3, #0
 8006564:	d009      	beq.n	800657a <xEventGroupWaitBits+0x52>
 8006566:	f04f 0350 	mov.w	r3, #80	; 0x50
 800656a:	f383 8811 	msr	BASEPRI, r3
 800656e:	f3bf 8f6f 	isb	sy
 8006572:	f3bf 8f4f 	dsb	sy
 8006576:	61fb      	str	r3, [r7, #28]
 8006578:	e7fe      	b.n	8006578 <xEventGroupWaitBits+0x50>
	configASSERT( uxBitsToWaitFor != 0 );
 800657a:	68bb      	ldr	r3, [r7, #8]
 800657c:	2b00      	cmp	r3, #0
 800657e:	d109      	bne.n	8006594 <xEventGroupWaitBits+0x6c>
 8006580:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006584:	f383 8811 	msr	BASEPRI, r3
 8006588:	f3bf 8f6f 	isb	sy
 800658c:	f3bf 8f4f 	dsb	sy
 8006590:	61bb      	str	r3, [r7, #24]
 8006592:	e7fe      	b.n	8006592 <xEventGroupWaitBits+0x6a>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 8006594:	f7ff fc48 	bl	8005e28 <xTaskGetSchedulerState>
 8006598:	4603      	mov	r3, r0
 800659a:	2b00      	cmp	r3, #0
 800659c:	d102      	bne.n	80065a4 <xEventGroupWaitBits+0x7c>
 800659e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80065a0:	2b00      	cmp	r3, #0
 80065a2:	d101      	bne.n	80065a8 <xEventGroupWaitBits+0x80>
 80065a4:	2301      	movs	r3, #1
 80065a6:	e000      	b.n	80065aa <xEventGroupWaitBits+0x82>
 80065a8:	2300      	movs	r3, #0
 80065aa:	2b00      	cmp	r3, #0
 80065ac:	d109      	bne.n	80065c2 <xEventGroupWaitBits+0x9a>
 80065ae:	f04f 0350 	mov.w	r3, #80	; 0x50
 80065b2:	f383 8811 	msr	BASEPRI, r3
 80065b6:	f3bf 8f6f 	isb	sy
 80065ba:	f3bf 8f4f 	dsb	sy
 80065be:	617b      	str	r3, [r7, #20]
 80065c0:	e7fe      	b.n	80065c0 <xEventGroupWaitBits+0x98>
	}
	#endif

	vTaskSuspendAll();
 80065c2:	f7fe ff2f 	bl	8005424 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
 80065c6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80065c8:	681b      	ldr	r3, [r3, #0]
 80065ca:	62fb      	str	r3, [r7, #44]	; 0x2c

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
 80065cc:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 80065ce:	68b9      	ldr	r1, [r7, #8]
 80065d0:	683a      	ldr	r2, [r7, #0]
 80065d2:	f000 f963 	bl	800689c <prvTestWaitCondition>
 80065d6:	62b8      	str	r0, [r7, #40]	; 0x28

		if( xWaitConditionMet != pdFALSE )
 80065d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80065da:	2b00      	cmp	r3, #0
 80065dc:	d00e      	beq.n	80065fc <xEventGroupWaitBits+0xd4>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
 80065de:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80065e0:	63fb      	str	r3, [r7, #60]	; 0x3c
			xTicksToWait = ( TickType_t ) 0;
 80065e2:	2300      	movs	r3, #0
 80065e4:	64bb      	str	r3, [r7, #72]	; 0x48

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
 80065e6:	687b      	ldr	r3, [r7, #4]
 80065e8:	2b00      	cmp	r3, #0
 80065ea:	d027      	beq.n	800663c <xEventGroupWaitBits+0x114>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 80065ec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80065ee:	681a      	ldr	r2, [r3, #0]
 80065f0:	68bb      	ldr	r3, [r7, #8]
 80065f2:	43db      	mvns	r3, r3
 80065f4:	401a      	ands	r2, r3
 80065f6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80065f8:	601a      	str	r2, [r3, #0]
 80065fa:	e01f      	b.n	800663c <xEventGroupWaitBits+0x114>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
 80065fc:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 80065fe:	2b00      	cmp	r3, #0
 8006600:	d102      	bne.n	8006608 <xEventGroupWaitBits+0xe0>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
 8006602:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006604:	63fb      	str	r3, [r7, #60]	; 0x3c
 8006606:	e019      	b.n	800663c <xEventGroupWaitBits+0x114>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
 8006608:	687b      	ldr	r3, [r7, #4]
 800660a:	2b00      	cmp	r3, #0
 800660c:	d003      	beq.n	8006616 <xEventGroupWaitBits+0xee>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
 800660e:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 8006610:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8006614:	63bb      	str	r3, [r7, #56]	; 0x38
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
 8006616:	683b      	ldr	r3, [r7, #0]
 8006618:	2b00      	cmp	r3, #0
 800661a:	d003      	beq.n	8006624 <xEventGroupWaitBits+0xfc>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
 800661c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800661e:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8006622:	63bb      	str	r3, [r7, #56]	; 0x38
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
 8006624:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006626:	1d19      	adds	r1, r3, #4
 8006628:	68ba      	ldr	r2, [r7, #8]
 800662a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800662c:	4313      	orrs	r3, r2
 800662e:	4608      	mov	r0, r1
 8006630:	4619      	mov	r1, r3
 8006632:	6cba      	ldr	r2, [r7, #72]	; 0x48
 8006634:	f7ff f988 	bl	8005948 <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
 8006638:	2300      	movs	r3, #0
 800663a:	63fb      	str	r3, [r7, #60]	; 0x3c

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
 800663c:	f7fe ff00 	bl	8005440 <xTaskResumeAll>
 8006640:	6278      	str	r0, [r7, #36]	; 0x24

	if( xTicksToWait != ( TickType_t ) 0 )
 8006642:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 8006644:	2b00      	cmp	r3, #0
 8006646:	d031      	beq.n	80066ac <xEventGroupWaitBits+0x184>
	{
		if( xAlreadyYielded == pdFALSE )
 8006648:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800664a:	2b00      	cmp	r3, #0
 800664c:	d107      	bne.n	800665e <xEventGroupWaitBits+0x136>
		{
			portYIELD_WITHIN_API();
 800664e:	4b1a      	ldr	r3, [pc, #104]	; (80066b8 <xEventGroupWaitBits+0x190>)
 8006650:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8006654:	601a      	str	r2, [r3, #0]
 8006656:	f3bf 8f4f 	dsb	sy
 800665a:	f3bf 8f6f 	isb	sy

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
 800665e:	f7ff fd07 	bl	8006070 <uxTaskResetEventItemValue>
 8006662:	63f8      	str	r0, [r7, #60]	; 0x3c

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
 8006664:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8006666:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800666a:	2b00      	cmp	r3, #0
 800666c:	d11a      	bne.n	80066a4 <xEventGroupWaitBits+0x17c>
		{
			taskENTER_CRITICAL();
 800666e:	f7fd fc0d 	bl	8003e8c <vPortEnterCritical>
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
 8006672:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006674:	681b      	ldr	r3, [r3, #0]
 8006676:	63fb      	str	r3, [r7, #60]	; 0x3c

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
 8006678:	6bf8      	ldr	r0, [r7, #60]	; 0x3c
 800667a:	68b9      	ldr	r1, [r7, #8]
 800667c:	683a      	ldr	r2, [r7, #0]
 800667e:	f000 f90d 	bl	800689c <prvTestWaitCondition>
 8006682:	4603      	mov	r3, r0
 8006684:	2b00      	cmp	r3, #0
 8006686:	d009      	beq.n	800669c <xEventGroupWaitBits+0x174>
				{
					if( xClearOnExit != pdFALSE )
 8006688:	687b      	ldr	r3, [r7, #4]
 800668a:	2b00      	cmp	r3, #0
 800668c:	d006      	beq.n	800669c <xEventGroupWaitBits+0x174>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
 800668e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8006690:	681a      	ldr	r2, [r3, #0]
 8006692:	68bb      	ldr	r3, [r7, #8]
 8006694:	43db      	mvns	r3, r3
 8006696:	401a      	ands	r2, r3
 8006698:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800669a:	601a      	str	r2, [r3, #0]
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
 800669c:	f7fd fc24 	bl	8003ee8 <vPortExitCritical>

			/* Prevent compiler warnings when trace macros are not used. */
			xTimeoutOccurred = pdFALSE;
 80066a0:	2300      	movs	r3, #0
 80066a2:	633b      	str	r3, [r7, #48]	; 0x30
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
 80066a4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80066a6:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80066aa:	63fb      	str	r3, [r7, #60]	; 0x3c
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
 80066ac:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
 80066ae:	4618      	mov	r0, r3
 80066b0:	3740      	adds	r7, #64	; 0x40
 80066b2:	46bd      	mov	sp, r7
 80066b4:	bd80      	pop	{r7, pc}
 80066b6:	bf00      	nop
 80066b8:	e000ed04 	.word	0xe000ed04

080066bc <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
 80066bc:	b580      	push	{r7, lr}
 80066be:	b086      	sub	sp, #24
 80066c0:	af00      	add	r7, sp, #0
 80066c2:	6078      	str	r0, [r7, #4]
 80066c4:	6039      	str	r1, [r7, #0]
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
 80066c6:	687b      	ldr	r3, [r7, #4]
 80066c8:	617b      	str	r3, [r7, #20]
EventBits_t uxReturn;

	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
 80066ca:	687b      	ldr	r3, [r7, #4]
 80066cc:	2b00      	cmp	r3, #0
 80066ce:	d109      	bne.n	80066e4 <xEventGroupClearBits+0x28>
 80066d0:	f04f 0350 	mov.w	r3, #80	; 0x50
 80066d4:	f383 8811 	msr	BASEPRI, r3
 80066d8:	f3bf 8f6f 	isb	sy
 80066dc:	f3bf 8f4f 	dsb	sy
 80066e0:	60fb      	str	r3, [r7, #12]
 80066e2:	e7fe      	b.n	80066e2 <xEventGroupClearBits+0x26>
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 80066e4:	683b      	ldr	r3, [r7, #0]
 80066e6:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 80066ea:	2b00      	cmp	r3, #0
 80066ec:	d009      	beq.n	8006702 <xEventGroupClearBits+0x46>
 80066ee:	f04f 0350 	mov.w	r3, #80	; 0x50
 80066f2:	f383 8811 	msr	BASEPRI, r3
 80066f6:	f3bf 8f6f 	isb	sy
 80066fa:	f3bf 8f4f 	dsb	sy
 80066fe:	60bb      	str	r3, [r7, #8]
 8006700:	e7fe      	b.n	8006700 <xEventGroupClearBits+0x44>

	taskENTER_CRITICAL();
 8006702:	f7fd fbc3 	bl	8003e8c <vPortEnterCritical>
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
 8006706:	697b      	ldr	r3, [r7, #20]
 8006708:	681b      	ldr	r3, [r3, #0]
 800670a:	613b      	str	r3, [r7, #16]

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 800670c:	697b      	ldr	r3, [r7, #20]
 800670e:	681a      	ldr	r2, [r3, #0]
 8006710:	683b      	ldr	r3, [r7, #0]
 8006712:	43db      	mvns	r3, r3
 8006714:	401a      	ands	r2, r3
 8006716:	697b      	ldr	r3, [r7, #20]
 8006718:	601a      	str	r2, [r3, #0]
	}
	taskEXIT_CRITICAL();
 800671a:	f7fd fbe5 	bl	8003ee8 <vPortExitCritical>

	return uxReturn;
 800671e:	693b      	ldr	r3, [r7, #16]
}
 8006720:	4618      	mov	r0, r3
 8006722:	3718      	adds	r7, #24
 8006724:	46bd      	mov	sp, r7
 8006726:	bd80      	pop	{r7, pc}

08006728 <xEventGroupSetBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
 8006728:	b580      	push	{r7, lr}
 800672a:	b08e      	sub	sp, #56	; 0x38
 800672c:	af00      	add	r7, sp, #0
 800672e:	6078      	str	r0, [r7, #4]
 8006730:	6039      	str	r1, [r7, #0]
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
 8006732:	2300      	movs	r3, #0
 8006734:	633b      	str	r3, [r7, #48]	; 0x30
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
 8006736:	687b      	ldr	r3, [r7, #4]
 8006738:	62bb      	str	r3, [r7, #40]	; 0x28
BaseType_t xMatchFound = pdFALSE;
 800673a:	2300      	movs	r3, #0
 800673c:	62fb      	str	r3, [r7, #44]	; 0x2c

	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
 800673e:	687b      	ldr	r3, [r7, #4]
 8006740:	2b00      	cmp	r3, #0
 8006742:	d109      	bne.n	8006758 <xEventGroupSetBits+0x30>
 8006744:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006748:	f383 8811 	msr	BASEPRI, r3
 800674c:	f3bf 8f6f 	isb	sy
 8006750:	f3bf 8f4f 	dsb	sy
 8006754:	613b      	str	r3, [r7, #16]
 8006756:	e7fe      	b.n	8006756 <xEventGroupSetBits+0x2e>
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
 8006758:	683b      	ldr	r3, [r7, #0]
 800675a:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 800675e:	2b00      	cmp	r3, #0
 8006760:	d009      	beq.n	8006776 <xEventGroupSetBits+0x4e>
 8006762:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006766:	f383 8811 	msr	BASEPRI, r3
 800676a:	f3bf 8f6f 	isb	sy
 800676e:	f3bf 8f4f 	dsb	sy
 8006772:	60fb      	str	r3, [r7, #12]
 8006774:	e7fe      	b.n	8006774 <xEventGroupSetBits+0x4c>

	pxList = &( pxEventBits->xTasksWaitingForBits );
 8006776:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006778:	3304      	adds	r3, #4
 800677a:	627b      	str	r3, [r7, #36]	; 0x24
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 800677c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800677e:	3308      	adds	r3, #8
 8006780:	623b      	str	r3, [r7, #32]
	vTaskSuspendAll();
 8006782:	f7fe fe4f 	bl	8005424 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
 8006786:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006788:	68db      	ldr	r3, [r3, #12]
 800678a:	637b      	str	r3, [r7, #52]	; 0x34

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
 800678c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800678e:	681a      	ldr	r2, [r3, #0]
 8006790:	683b      	ldr	r3, [r7, #0]
 8006792:	431a      	orrs	r2, r3
 8006794:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006796:	601a      	str	r2, [r3, #0]

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
 8006798:	e03c      	b.n	8006814 <xEventGroupSetBits+0xec>
		{
			pxNext = listGET_NEXT( pxListItem );
 800679a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800679c:	685b      	ldr	r3, [r3, #4]
 800679e:	61fb      	str	r3, [r7, #28]
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
 80067a0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80067a2:	681b      	ldr	r3, [r3, #0]
 80067a4:	61bb      	str	r3, [r7, #24]
			xMatchFound = pdFALSE;
 80067a6:	2300      	movs	r3, #0
 80067a8:	62fb      	str	r3, [r7, #44]	; 0x2c

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
 80067aa:	69bb      	ldr	r3, [r7, #24]
 80067ac:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 80067b0:	617b      	str	r3, [r7, #20]
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
 80067b2:	69bb      	ldr	r3, [r7, #24]
 80067b4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80067b8:	61bb      	str	r3, [r7, #24]

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
 80067ba:	697b      	ldr	r3, [r7, #20]
 80067bc:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 80067c0:	2b00      	cmp	r3, #0
 80067c2:	d108      	bne.n	80067d6 <xEventGroupSetBits+0xae>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
 80067c4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80067c6:	681a      	ldr	r2, [r3, #0]
 80067c8:	69bb      	ldr	r3, [r7, #24]
 80067ca:	4013      	ands	r3, r2
 80067cc:	2b00      	cmp	r3, #0
 80067ce:	d00b      	beq.n	80067e8 <xEventGroupSetBits+0xc0>
				{
					xMatchFound = pdTRUE;
 80067d0:	2301      	movs	r3, #1
 80067d2:	62fb      	str	r3, [r7, #44]	; 0x2c
 80067d4:	e008      	b.n	80067e8 <xEventGroupSetBits+0xc0>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
 80067d6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80067d8:	681a      	ldr	r2, [r3, #0]
 80067da:	69bb      	ldr	r3, [r7, #24]
 80067dc:	401a      	ands	r2, r3
 80067de:	69bb      	ldr	r3, [r7, #24]
 80067e0:	429a      	cmp	r2, r3
 80067e2:	d101      	bne.n	80067e8 <xEventGroupSetBits+0xc0>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
 80067e4:	2301      	movs	r3, #1
 80067e6:	62fb      	str	r3, [r7, #44]	; 0x2c
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
 80067e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80067ea:	2b00      	cmp	r3, #0
 80067ec:	d010      	beq.n	8006810 <xEventGroupSetBits+0xe8>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
 80067ee:	697b      	ldr	r3, [r7, #20]
 80067f0:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
 80067f4:	2b00      	cmp	r3, #0
 80067f6:	d003      	beq.n	8006800 <xEventGroupSetBits+0xd8>
				{
					uxBitsToClear |= uxBitsWaitedFor;
 80067f8:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80067fa:	69bb      	ldr	r3, [r7, #24]
 80067fc:	4313      	orrs	r3, r2
 80067fe:	633b      	str	r3, [r7, #48]	; 0x30
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
 8006800:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006802:	681b      	ldr	r3, [r3, #0]
 8006804:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8006808:	6b78      	ldr	r0, [r7, #52]	; 0x34
 800680a:	4619      	mov	r1, r3
 800680c:	f7ff f93e 	bl	8005a8c <xTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
 8006810:	69fb      	ldr	r3, [r7, #28]
 8006812:	637b      	str	r3, [r7, #52]	; 0x34

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
 8006814:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 8006816:	6a3b      	ldr	r3, [r7, #32]
 8006818:	429a      	cmp	r2, r3
 800681a:	d1be      	bne.n	800679a <xEventGroupSetBits+0x72>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
 800681c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800681e:	681a      	ldr	r2, [r3, #0]
 8006820:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8006822:	43db      	mvns	r3, r3
 8006824:	401a      	ands	r2, r3
 8006826:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006828:	601a      	str	r2, [r3, #0]
	}
	( void ) xTaskResumeAll();
 800682a:	f7fe fe09 	bl	8005440 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
 800682e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006830:	681b      	ldr	r3, [r3, #0]
}
 8006832:	4618      	mov	r0, r3
 8006834:	3738      	adds	r7, #56	; 0x38
 8006836:	46bd      	mov	sp, r7
 8006838:	bd80      	pop	{r7, pc}
 800683a:	bf00      	nop

0800683c <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
 800683c:	b580      	push	{r7, lr}
 800683e:	b086      	sub	sp, #24
 8006840:	af00      	add	r7, sp, #0
 8006842:	6078      	str	r0, [r7, #4]
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
 8006844:	687b      	ldr	r3, [r7, #4]
 8006846:	617b      	str	r3, [r7, #20]
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
 8006848:	697b      	ldr	r3, [r7, #20]
 800684a:	3304      	adds	r3, #4
 800684c:	613b      	str	r3, [r7, #16]

	vTaskSuspendAll();
 800684e:	f7fe fde9 	bl	8005424 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 8006852:	e016      	b.n	8006882 <vEventGroupDelete+0x46>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
 8006854:	693b      	ldr	r3, [r7, #16]
 8006856:	68da      	ldr	r2, [r3, #12]
 8006858:	693b      	ldr	r3, [r7, #16]
 800685a:	3308      	adds	r3, #8
 800685c:	429a      	cmp	r2, r3
 800685e:	d109      	bne.n	8006874 <vEventGroupDelete+0x38>
 8006860:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006864:	f383 8811 	msr	BASEPRI, r3
 8006868:	f3bf 8f6f 	isb	sy
 800686c:	f3bf 8f4f 	dsb	sy
 8006870:	60fb      	str	r3, [r7, #12]
 8006872:	e7fe      	b.n	8006872 <vEventGroupDelete+0x36>
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
 8006874:	693b      	ldr	r3, [r7, #16]
 8006876:	68db      	ldr	r3, [r3, #12]
 8006878:	4618      	mov	r0, r3
 800687a:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
 800687e:	f7ff f905 	bl	8005a8c <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
 8006882:	693b      	ldr	r3, [r7, #16]
 8006884:	681b      	ldr	r3, [r3, #0]
 8006886:	2b00      	cmp	r3, #0
 8006888:	d1e4      	bne.n	8006854 <vEventGroupDelete+0x18>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
 800688a:	6978      	ldr	r0, [r7, #20]
 800688c:	f7fd fcb0 	bl	80041f0 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
 8006890:	f7fe fdd6 	bl	8005440 <xTaskResumeAll>
}
 8006894:	3718      	adds	r7, #24
 8006896:	46bd      	mov	sp, r7
 8006898:	bd80      	pop	{r7, pc}
 800689a:	bf00      	nop

0800689c <prvTestWaitCondition>:
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
}
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
 800689c:	b480      	push	{r7}
 800689e:	b087      	sub	sp, #28
 80068a0:	af00      	add	r7, sp, #0
 80068a2:	60f8      	str	r0, [r7, #12]
 80068a4:	60b9      	str	r1, [r7, #8]
 80068a6:	607a      	str	r2, [r7, #4]
BaseType_t xWaitConditionMet = pdFALSE;
 80068a8:	2300      	movs	r3, #0
 80068aa:	617b      	str	r3, [r7, #20]

	if( xWaitForAllBits == pdFALSE )
 80068ac:	687b      	ldr	r3, [r7, #4]
 80068ae:	2b00      	cmp	r3, #0
 80068b0:	d107      	bne.n	80068c2 <prvTestWaitCondition+0x26>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
 80068b2:	68fa      	ldr	r2, [r7, #12]
 80068b4:	68bb      	ldr	r3, [r7, #8]
 80068b6:	4013      	ands	r3, r2
 80068b8:	2b00      	cmp	r3, #0
 80068ba:	d00a      	beq.n	80068d2 <prvTestWaitCondition+0x36>
		{
			xWaitConditionMet = pdTRUE;
 80068bc:	2301      	movs	r3, #1
 80068be:	617b      	str	r3, [r7, #20]
 80068c0:	e007      	b.n	80068d2 <prvTestWaitCondition+0x36>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
 80068c2:	68fa      	ldr	r2, [r7, #12]
 80068c4:	68bb      	ldr	r3, [r7, #8]
 80068c6:	401a      	ands	r2, r3
 80068c8:	68bb      	ldr	r3, [r7, #8]
 80068ca:	429a      	cmp	r2, r3
 80068cc:	d101      	bne.n	80068d2 <prvTestWaitCondition+0x36>
		{
			xWaitConditionMet = pdTRUE;
 80068ce:	2301      	movs	r3, #1
 80068d0:	617b      	str	r3, [r7, #20]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
 80068d2:	697b      	ldr	r3, [r7, #20]
}
 80068d4:	4618      	mov	r0, r3
 80068d6:	371c      	adds	r7, #28
 80068d8:	46bd      	mov	sp, r7
 80068da:	f85d 7b04 	ldr.w	r7, [sp], #4
 80068de:	4770      	bx	lr

080068e0 <HAL_ETH_RxCpltCallback>:
};

/*-----------------------------------------------------------*/

void HAL_ETH_RxCpltCallback( ETH_HandleTypeDef *heth )
{
 80068e0:	b580      	push	{r7, lr}
 80068e2:	b084      	sub	sp, #16
 80068e4:	af00      	add	r7, sp, #0
 80068e6:	6078      	str	r0, [r7, #4]
BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 80068e8:	2300      	movs	r3, #0
 80068ea:	60fb      	str	r3, [r7, #12]

	/* Ethernet RX-Complete callback function, elsewhere declared as weak. */
    ulISREvents |= EMAC_IF_RX_EVENT;
 80068ec:	4b12      	ldr	r3, [pc, #72]	; (8006938 <HAL_ETH_RxCpltCallback+0x58>)
 80068ee:	681b      	ldr	r3, [r3, #0]
 80068f0:	f043 0301 	orr.w	r3, r3, #1
 80068f4:	4a10      	ldr	r2, [pc, #64]	; (8006938 <HAL_ETH_RxCpltCallback+0x58>)
 80068f6:	6013      	str	r3, [r2, #0]
	/* Wakeup the prvEMACHandlerTask. */
	if( xEMACTaskHandle != NULL )
 80068f8:	4b10      	ldr	r3, [pc, #64]	; (800693c <HAL_ETH_RxCpltCallback+0x5c>)
 80068fa:	681b      	ldr	r3, [r3, #0]
 80068fc:	2b00      	cmp	r3, #0
 80068fe:	d017      	beq.n	8006930 <HAL_ETH_RxCpltCallback+0x50>
	{
		vTaskNotifyGiveFromISR( xEMACTaskHandle, &xHigherPriorityTaskWoken );
 8006900:	4b0e      	ldr	r3, [pc, #56]	; (800693c <HAL_ETH_RxCpltCallback+0x5c>)
 8006902:	681a      	ldr	r2, [r3, #0]
 8006904:	f107 030c 	add.w	r3, r7, #12
 8006908:	4610      	mov	r0, r2
 800690a:	4619      	mov	r1, r3
 800690c:	f7ff fcde 	bl	80062cc <vTaskNotifyGiveFromISR>
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 8006910:	68fb      	ldr	r3, [r7, #12]
 8006912:	2b00      	cmp	r3, #0
 8006914:	d00a      	beq.n	800692c <HAL_ETH_RxCpltCallback+0x4c>
 8006916:	f00b f8a7 	bl	8011a68 <SEGGER_SYSVIEW_RecordExitISRToScheduler>
 800691a:	4b09      	ldr	r3, [pc, #36]	; (8006940 <HAL_ETH_RxCpltCallback+0x60>)
 800691c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8006920:	601a      	str	r2, [r3, #0]
 8006922:	f3bf 8f4f 	dsb	sy
 8006926:	f3bf 8f6f 	isb	sy
 800692a:	e001      	b.n	8006930 <HAL_ETH_RxCpltCallback+0x50>
 800692c:	f00b f880 	bl	8011a30 <SEGGER_SYSVIEW_RecordExitISR>
	}
}
 8006930:	3710      	adds	r7, #16
 8006932:	46bd      	mov	sp, r7
 8006934:	bd80      	pop	{r7, pc}
 8006936:	bf00      	nop
 8006938:	2000bce0 	.word	0x2000bce0
 800693c:	2000bd40 	.word	0x2000bd40
 8006940:	e000ed04 	.word	0xe000ed04

08006944 <HAL_ETH_TxCpltCallback>:
/*-----------------------------------------------------------*/

void HAL_ETH_TxCpltCallback( ETH_HandleTypeDef *heth )
{
 8006944:	b580      	push	{r7, lr}
 8006946:	b084      	sub	sp, #16
 8006948:	af00      	add	r7, sp, #0
 800694a:	6078      	str	r0, [r7, #4]
BaseType_t xHigherPriorityTaskWoken = pdFALSE;
 800694c:	2300      	movs	r3, #0
 800694e:	60fb      	str	r3, [r7, #12]

	/* This call-back is only useful in case packets are being sent
	zero-copy.  Once they're sent, the buffers will be released
	by the function vClearTXBuffers(). */
	ulISREvents |= EMAC_IF_TX_EVENT;
 8006950:	4b12      	ldr	r3, [pc, #72]	; (800699c <HAL_ETH_TxCpltCallback+0x58>)
 8006952:	681b      	ldr	r3, [r3, #0]
 8006954:	f043 0302 	orr.w	r3, r3, #2
 8006958:	4a10      	ldr	r2, [pc, #64]	; (800699c <HAL_ETH_TxCpltCallback+0x58>)
 800695a:	6013      	str	r3, [r2, #0]
	/* Wakeup the prvEMACHandlerTask. */
	if( xEMACTaskHandle != NULL )
 800695c:	4b10      	ldr	r3, [pc, #64]	; (80069a0 <HAL_ETH_TxCpltCallback+0x5c>)
 800695e:	681b      	ldr	r3, [r3, #0]
 8006960:	2b00      	cmp	r3, #0
 8006962:	d017      	beq.n	8006994 <HAL_ETH_TxCpltCallback+0x50>
	{
		vTaskNotifyGiveFromISR( xEMACTaskHandle, &xHigherPriorityTaskWoken );
 8006964:	4b0e      	ldr	r3, [pc, #56]	; (80069a0 <HAL_ETH_TxCpltCallback+0x5c>)
 8006966:	681a      	ldr	r2, [r3, #0]
 8006968:	f107 030c 	add.w	r3, r7, #12
 800696c:	4610      	mov	r0, r2
 800696e:	4619      	mov	r1, r3
 8006970:	f7ff fcac 	bl	80062cc <vTaskNotifyGiveFromISR>
		portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
 8006974:	68fb      	ldr	r3, [r7, #12]
 8006976:	2b00      	cmp	r3, #0
 8006978:	d00a      	beq.n	8006990 <HAL_ETH_TxCpltCallback+0x4c>
 800697a:	f00b f875 	bl	8011a68 <SEGGER_SYSVIEW_RecordExitISRToScheduler>
 800697e:	4b09      	ldr	r3, [pc, #36]	; (80069a4 <HAL_ETH_TxCpltCallback+0x60>)
 8006980:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8006984:	601a      	str	r2, [r3, #0]
 8006986:	f3bf 8f4f 	dsb	sy
 800698a:	f3bf 8f6f 	isb	sy
 800698e:	e001      	b.n	8006994 <HAL_ETH_TxCpltCallback+0x50>
 8006990:	f00b f84e 	bl	8011a30 <SEGGER_SYSVIEW_RecordExitISR>
	}

}
 8006994:	3710      	adds	r7, #16
 8006996:	46bd      	mov	sp, r7
 8006998:	bd80      	pop	{r7, pc}
 800699a:	bf00      	nop
 800699c:	2000bce0 	.word	0x2000bce0
 80069a0:	2000bd40 	.word	0x2000bd40
 80069a4:	e000ed04 	.word	0xe000ed04

080069a8 <vClearTXBuffers>:
/*-----------------------------------------------------------*/

static void vClearTXBuffers()
{
 80069a8:	b580      	push	{r7, lr}
 80069aa:	b084      	sub	sp, #16
 80069ac:	af00      	add	r7, sp, #0
__IO ETH_DMADescTypeDef  *txLastDescriptor = xETH.TxDesc;
 80069ae:	4b23      	ldr	r3, [pc, #140]	; (8006a3c <vClearTXBuffers+0x94>)
 80069b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80069b2:	60bb      	str	r3, [r7, #8]
size_t uxCount = ( ( UBaseType_t ) ETH_TXBUFNB ) - uxSemaphoreGetCount( xTXDescriptorSemaphore );
 80069b4:	4b22      	ldr	r3, [pc, #136]	; (8006a40 <vClearTXBuffers+0x98>)
 80069b6:	681b      	ldr	r3, [r3, #0]
 80069b8:	4618      	mov	r0, r3
 80069ba:	f7fe f90f 	bl	8004bdc <uxQueueMessagesWaiting>
 80069be:	4603      	mov	r3, r0
 80069c0:	f1c3 0304 	rsb	r3, r3, #4
 80069c4:	60fb      	str	r3, [r7, #12]

	/* This function is called after a TX-completion interrupt.
	It will release each Network Buffer used in xNetworkInterfaceOutput().
	'uxCount' represents the number of descriptors given to DMA for transmission.
	After sending a packet, the DMA will clear the 'ETH_DMATXDESC_OWN' bit. */
	while( ( uxCount > 0 ) && ( ( DMATxDescToClear->Status & ETH_DMATXDESC_OWN ) == 0 ) )
 80069c6:	e02e      	b.n	8006a26 <vClearTXBuffers+0x7e>
	{
		if( ( DMATxDescToClear == txLastDescriptor ) && ( uxCount != ETH_TXBUFNB ) )
 80069c8:	4b1e      	ldr	r3, [pc, #120]	; (8006a44 <vClearTXBuffers+0x9c>)
 80069ca:	681a      	ldr	r2, [r3, #0]
 80069cc:	68bb      	ldr	r3, [r7, #8]
 80069ce:	429a      	cmp	r2, r3
 80069d0:	d103      	bne.n	80069da <vClearTXBuffers+0x32>
 80069d2:	68fb      	ldr	r3, [r7, #12]
 80069d4:	2b04      	cmp	r3, #4
 80069d6:	d000      	beq.n	80069da <vClearTXBuffers+0x32>
		{
			break;
 80069d8:	e02d      	b.n	8006a36 <vClearTXBuffers+0x8e>
		}
		#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
		{
			ucPayLoad = ( uint8_t * )DMATxDescToClear->Buffer1Addr;
 80069da:	4b1a      	ldr	r3, [pc, #104]	; (8006a44 <vClearTXBuffers+0x9c>)
 80069dc:	681b      	ldr	r3, [r3, #0]
 80069de:	689b      	ldr	r3, [r3, #8]
 80069e0:	607b      	str	r3, [r7, #4]

			if( ucPayLoad != NULL )
 80069e2:	687b      	ldr	r3, [r7, #4]
 80069e4:	2b00      	cmp	r3, #0
 80069e6:	d00d      	beq.n	8006a04 <vClearTXBuffers+0x5c>
			{
				pxNetworkBuffer = pxPacketBuffer_to_NetworkBuffer( ucPayLoad );
 80069e8:	6878      	ldr	r0, [r7, #4]
 80069ea:	f001 f95b 	bl	8007ca4 <pxPacketBuffer_to_NetworkBuffer>
 80069ee:	6038      	str	r0, [r7, #0]
				if( pxNetworkBuffer != NULL )
 80069f0:	683b      	ldr	r3, [r7, #0]
 80069f2:	2b00      	cmp	r3, #0
 80069f4:	d002      	beq.n	80069fc <vClearTXBuffers+0x54>
				{
					vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer ) ;
 80069f6:	6838      	ldr	r0, [r7, #0]
 80069f8:	f000 fef0 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
				}
				DMATxDescToClear->Buffer1Addr = ( uint32_t )0u;
 80069fc:	4b11      	ldr	r3, [pc, #68]	; (8006a44 <vClearTXBuffers+0x9c>)
 80069fe:	681b      	ldr	r3, [r3, #0]
 8006a00:	2200      	movs	r2, #0
 8006a02:	609a      	str	r2, [r3, #8]
			}
		}
		#endif /* ipconfigZERO_COPY_TX_DRIVER */

		DMATxDescToClear = ( ETH_DMADescTypeDef * )( DMATxDescToClear->Buffer2NextDescAddr );
 8006a04:	4b0f      	ldr	r3, [pc, #60]	; (8006a44 <vClearTXBuffers+0x9c>)
 8006a06:	681b      	ldr	r3, [r3, #0]
 8006a08:	68db      	ldr	r3, [r3, #12]
 8006a0a:	461a      	mov	r2, r3
 8006a0c:	4b0d      	ldr	r3, [pc, #52]	; (8006a44 <vClearTXBuffers+0x9c>)
 8006a0e:	601a      	str	r2, [r3, #0]

		uxCount--;
 8006a10:	68fb      	ldr	r3, [r7, #12]
 8006a12:	3b01      	subs	r3, #1
 8006a14:	60fb      	str	r3, [r7, #12]
		/* Tell the counting semaphore that one more TX descriptor is available. */
		xSemaphoreGive( xTXDescriptorSemaphore );
 8006a16:	4b0a      	ldr	r3, [pc, #40]	; (8006a40 <vClearTXBuffers+0x98>)
 8006a18:	681b      	ldr	r3, [r3, #0]
 8006a1a:	4618      	mov	r0, r3
 8006a1c:	2100      	movs	r1, #0
 8006a1e:	2200      	movs	r2, #0
 8006a20:	2300      	movs	r3, #0
 8006a22:	f7fd fe57 	bl	80046d4 <xQueueGenericSend>

	/* This function is called after a TX-completion interrupt.
	It will release each Network Buffer used in xNetworkInterfaceOutput().
	'uxCount' represents the number of descriptors given to DMA for transmission.
	After sending a packet, the DMA will clear the 'ETH_DMATXDESC_OWN' bit. */
	while( ( uxCount > 0 ) && ( ( DMATxDescToClear->Status & ETH_DMATXDESC_OWN ) == 0 ) )
 8006a26:	68fb      	ldr	r3, [r7, #12]
 8006a28:	2b00      	cmp	r3, #0
 8006a2a:	d004      	beq.n	8006a36 <vClearTXBuffers+0x8e>
 8006a2c:	4b05      	ldr	r3, [pc, #20]	; (8006a44 <vClearTXBuffers+0x9c>)
 8006a2e:	681b      	ldr	r3, [r3, #0]
 8006a30:	681b      	ldr	r3, [r3, #0]
 8006a32:	2b00      	cmp	r3, #0
 8006a34:	dac8      	bge.n	80069c8 <vClearTXBuffers+0x20>

		uxCount--;
		/* Tell the counting semaphore that one more TX descriptor is available. */
		xSemaphoreGive( xTXDescriptorSemaphore );
	}
}
 8006a36:	3710      	adds	r7, #16
 8006a38:	46bd      	mov	sp, r7
 8006a3a:	bd80      	pop	{r7, pc}
 8006a3c:	2000bce8 	.word	0x2000bce8
 8006a40:	2000bd30 	.word	0x2000bd30
 8006a44:	2000bd34 	.word	0x2000bd34

08006a48 <xNetworkInterfaceInitialise>:
/*-----------------------------------------------------------*/

BaseType_t xNetworkInterfaceInitialise( void )
{
 8006a48:	b580      	push	{r7, lr}
 8006a4a:	b086      	sub	sp, #24
 8006a4c:	af02      	add	r7, sp, #8
HAL_StatusTypeDef hal_eth_init_status;
BaseType_t xResult;

	if( xEMACTaskHandle == NULL )
 8006a4e:	4b47      	ldr	r3, [pc, #284]	; (8006b6c <xNetworkInterfaceInitialise+0x124>)
 8006a50:	681b      	ldr	r3, [r3, #0]
 8006a52:	2b00      	cmp	r3, #0
 8006a54:	d165      	bne.n	8006b22 <xNetworkInterfaceInitialise+0xda>
	{
		if( xTXDescriptorSemaphore == NULL )
 8006a56:	4b46      	ldr	r3, [pc, #280]	; (8006b70 <xNetworkInterfaceInitialise+0x128>)
 8006a58:	681b      	ldr	r3, [r3, #0]
 8006a5a:	2b00      	cmp	r3, #0
 8006a5c:	d114      	bne.n	8006a88 <xNetworkInterfaceInitialise+0x40>
		{
			xTXDescriptorSemaphore = xSemaphoreCreateCounting( ( UBaseType_t ) ETH_TXBUFNB, ( UBaseType_t ) ETH_TXBUFNB );
 8006a5e:	2004      	movs	r0, #4
 8006a60:	2104      	movs	r1, #4
 8006a62:	f7fd fe05 	bl	8004670 <xQueueCreateCountingSemaphore>
 8006a66:	4602      	mov	r2, r0
 8006a68:	4b41      	ldr	r3, [pc, #260]	; (8006b70 <xNetworkInterfaceInitialise+0x128>)
 8006a6a:	601a      	str	r2, [r3, #0]
			configASSERT( xTXDescriptorSemaphore );
 8006a6c:	4b40      	ldr	r3, [pc, #256]	; (8006b70 <xNetworkInterfaceInitialise+0x128>)
 8006a6e:	681b      	ldr	r3, [r3, #0]
 8006a70:	2b00      	cmp	r3, #0
 8006a72:	d109      	bne.n	8006a88 <xNetworkInterfaceInitialise+0x40>
 8006a74:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006a78:	f383 8811 	msr	BASEPRI, r3
 8006a7c:	f3bf 8f6f 	isb	sy
 8006a80:	f3bf 8f4f 	dsb	sy
 8006a84:	607b      	str	r3, [r7, #4]
 8006a86:	e7fe      	b.n	8006a86 <xNetworkInterfaceInitialise+0x3e>
		}

		/* Initialise ETH */

		xETH.Instance = ETH;
 8006a88:	4b3a      	ldr	r3, [pc, #232]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006a8a:	4a3b      	ldr	r2, [pc, #236]	; (8006b78 <xNetworkInterfaceInitialise+0x130>)
 8006a8c:	601a      	str	r2, [r3, #0]
		xETH.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
 8006a8e:	4b39      	ldr	r3, [pc, #228]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006a90:	2201      	movs	r2, #1
 8006a92:	605a      	str	r2, [r3, #4]
		xETH.Init.Speed = ETH_SPEED_100M;
 8006a94:	4b37      	ldr	r3, [pc, #220]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006a96:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8006a9a:	609a      	str	r2, [r3, #8]
		xETH.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
 8006a9c:	4b35      	ldr	r3, [pc, #212]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006a9e:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8006aa2:	60da      	str	r2, [r3, #12]
		xETH.Init.PhyAddress = ipconfigPHY_INDEX;
 8006aa4:	4b33      	ldr	r3, [pc, #204]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006aa6:	2200      	movs	r2, #0
 8006aa8:	821a      	strh	r2, [r3, #16]

		xETH.Init.MACAddr = ( uint8_t *) ucMACAddress;
 8006aaa:	4b32      	ldr	r3, [pc, #200]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006aac:	4a33      	ldr	r2, [pc, #204]	; (8006b7c <xNetworkInterfaceInitialise+0x134>)
 8006aae:	615a      	str	r2, [r3, #20]
		xETH.Init.RxMode = ETH_RXINTERRUPT_MODE;
 8006ab0:	4b30      	ldr	r3, [pc, #192]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006ab2:	2201      	movs	r2, #1
 8006ab4:	619a      	str	r2, [r3, #24]

		/* using the ETH_CHECKSUM_BY_HARDWARE option:
		both the IP and the protocol checksums will be calculated
		by the peripheral. */
		xETH.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
 8006ab6:	4b2f      	ldr	r3, [pc, #188]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006ab8:	2200      	movs	r2, #0
 8006aba:	61da      	str	r2, [r3, #28]

		#if( ipconfigUSE_RMII != 0 )
		{
			xETH.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
 8006abc:	4b2d      	ldr	r3, [pc, #180]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006abe:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
 8006ac2:	621a      	str	r2, [r3, #32]
		{
			xETH.Init.MediaInterface = ETH_MEDIA_INTERFACE_MII;
		}
		#endif /* ipconfigUSE_RMII */

		hal_eth_init_status = HAL_ETH_Init( &xETH );
 8006ac4:	482b      	ldr	r0, [pc, #172]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006ac6:	f7fc fa49 	bl	8002f5c <HAL_ETH_Init>
 8006aca:	4603      	mov	r3, r0
 8006acc:	72fb      	strb	r3, [r7, #11]

		/* Only for inspection by debugger. */
		( void ) hal_eth_init_status;

		/* Set the TxDesc and RxDesc pointers. */
		xETH.TxDesc = DMATxDscrTab;
 8006ace:	4b29      	ldr	r3, [pc, #164]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006ad0:	4a2b      	ldr	r2, [pc, #172]	; (8006b80 <xNetworkInterfaceInitialise+0x138>)
 8006ad2:	62da      	str	r2, [r3, #44]	; 0x2c
		xETH.RxDesc = DMARxDscrTab;
 8006ad4:	4b27      	ldr	r3, [pc, #156]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006ad6:	4a2b      	ldr	r2, [pc, #172]	; (8006b84 <xNetworkInterfaceInitialise+0x13c>)
 8006ad8:	629a      	str	r2, [r3, #40]	; 0x28

		/* Make sure that all unused fields are cleared. */
		memset( &DMATxDscrTab, '\0', sizeof( DMATxDscrTab ) );
 8006ada:	4829      	ldr	r0, [pc, #164]	; (8006b80 <xNetworkInterfaceInitialise+0x138>)
 8006adc:	2100      	movs	r1, #0
 8006ade:	2280      	movs	r2, #128	; 0x80
 8006ae0:	f009 fbe2 	bl	80102a8 <memset>
		memset( &DMARxDscrTab, '\0', sizeof( DMARxDscrTab ) );
 8006ae4:	4827      	ldr	r0, [pc, #156]	; (8006b84 <xNetworkInterfaceInitialise+0x13c>)
 8006ae6:	2100      	movs	r1, #0
 8006ae8:	2280      	movs	r2, #128	; 0x80
 8006aea:	f009 fbdd 	bl	80102a8 <memset>

		/* Initialize Tx Descriptors list: Chain Mode */
		DMATxDescToClear = DMATxDscrTab;
 8006aee:	4b26      	ldr	r3, [pc, #152]	; (8006b88 <xNetworkInterfaceInitialise+0x140>)
 8006af0:	4a23      	ldr	r2, [pc, #140]	; (8006b80 <xNetworkInterfaceInitialise+0x138>)
 8006af2:	601a      	str	r2, [r3, #0]

		/* Initialise TX-descriptors. */
		prvDMATxDescListInit();
 8006af4:	f000 f858 	bl	8006ba8 <prvDMATxDescListInit>

		/* Initialise RX-descriptors. */
		prvDMARxDescListInit();
 8006af8:	f000 f892 	bl	8006c20 <prvDMARxDescListInit>

		#if( ipconfigUSE_LLMNR != 0 )
		{
			/* Program the LLMNR address at index 1. */
			prvMACAddressConfig( &xETH, ETH_MAC_ADDRESS1, ( uint8_t *) xLLMNR_MACAddress );
 8006afc:	481d      	ldr	r0, [pc, #116]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006afe:	2108      	movs	r1, #8
 8006b00:	4a22      	ldr	r2, [pc, #136]	; (8006b8c <xNetworkInterfaceInitialise+0x144>)
 8006b02:	f000 f8db 	bl	8006cbc <prvMACAddressConfig>
		}
		#endif

		/* Force a negotiation with the Switch or Router and wait for LS. */
		prvEthernetUpdateConfig( pdTRUE );
 8006b06:	2001      	movs	r0, #1
 8006b08:	f000 fb74 	bl	80071f4 <prvEthernetUpdateConfig>

		/* The deferred interrupt handler task is created at the highest
		possible priority to ensure the interrupt handler can return directly
		to it.  The task's handle is stored in xEMACTaskHandle so interrupts can
		notify the task when there is something to process. */
		xTaskCreate( prvEMACHandlerTask, "EMAC", configEMAC_TASK_STACK_SIZE, NULL, configMAX_PRIORITIES - 1, &xEMACTaskHandle );
 8006b0c:	2306      	movs	r3, #6
 8006b0e:	9300      	str	r3, [sp, #0]
 8006b10:	4b16      	ldr	r3, [pc, #88]	; (8006b6c <xNetworkInterfaceInitialise+0x124>)
 8006b12:	9301      	str	r3, [sp, #4]
 8006b14:	481e      	ldr	r0, [pc, #120]	; (8006b90 <xNetworkInterfaceInitialise+0x148>)
 8006b16:	491f      	ldr	r1, [pc, #124]	; (8006b94 <xNetworkInterfaceInitialise+0x14c>)
 8006b18:	f44f 7280 	mov.w	r2, #256	; 0x100
 8006b1c:	2300      	movs	r3, #0
 8006b1e:	f7fe fa0b 	bl	8004f38 <xTaskCreate>
	} /* if( xEMACTaskHandle == NULL ) */

	if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 )
 8006b22:	4b1d      	ldr	r3, [pc, #116]	; (8006b98 <xNetworkInterfaceInitialise+0x150>)
 8006b24:	681b      	ldr	r3, [r3, #0]
 8006b26:	f003 0304 	and.w	r3, r3, #4
 8006b2a:	2b00      	cmp	r3, #0
 8006b2c:	d013      	beq.n	8006b56 <xNetworkInterfaceInitialise+0x10e>
	{
		xETH.Instance->DMAIER |= ETH_DMA_ALL_INTS;
 8006b2e:	4b11      	ldr	r3, [pc, #68]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006b30:	6819      	ldr	r1, [r3, #0]
 8006b32:	4b10      	ldr	r3, [pc, #64]	; (8006b74 <xNetworkInterfaceInitialise+0x12c>)
 8006b34:	681a      	ldr	r2, [r3, #0]
 8006b36:	f241 031c 	movw	r3, #4124	; 0x101c
 8006b3a:	4413      	add	r3, r2
 8006b3c:	681b      	ldr	r3, [r3, #0]
 8006b3e:	4a17      	ldr	r2, [pc, #92]	; (8006b9c <xNetworkInterfaceInitialise+0x154>)
 8006b40:	431a      	orrs	r2, r3
 8006b42:	f241 031c 	movw	r3, #4124	; 0x101c
 8006b46:	440b      	add	r3, r1
 8006b48:	601a      	str	r2, [r3, #0]
		xResult = pdPASS;
 8006b4a:	2301      	movs	r3, #1
 8006b4c:	60fb      	str	r3, [r7, #12]
		FreeRTOS_printf( ( "Link Status is high\n" ) ) ;
 8006b4e:	4814      	ldr	r0, [pc, #80]	; (8006ba0 <xNetworkInterfaceInitialise+0x158>)
 8006b50:	f008 f9ca 	bl	800eee8 <lUDPLoggingPrintf>
 8006b54:	e004      	b.n	8006b60 <xNetworkInterfaceInitialise+0x118>
	}
	else
	{
		/* For now pdFAIL will be returned. But prvEMACHandlerTask() is running
		and it will keep on checking the PHY and set ulPHYLinkStatus when necessary. */
		xResult = pdFAIL;
 8006b56:	2300      	movs	r3, #0
 8006b58:	60fb      	str	r3, [r7, #12]
		FreeRTOS_printf( ( "Link Status still low\n" ) ) ;
 8006b5a:	4812      	ldr	r0, [pc, #72]	; (8006ba4 <xNetworkInterfaceInitialise+0x15c>)
 8006b5c:	f008 f9c4 	bl	800eee8 <lUDPLoggingPrintf>
	}
	/* When returning non-zero, the stack will become active and
    start DHCP (in configured) */
	return xResult;
 8006b60:	68fb      	ldr	r3, [r7, #12]
}
 8006b62:	4618      	mov	r0, r3
 8006b64:	3710      	adds	r7, #16
 8006b66:	46bd      	mov	sp, r7
 8006b68:	bd80      	pop	{r7, pc}
 8006b6a:	bf00      	nop
 8006b6c:	2000bd40 	.word	0x2000bd40
 8006b70:	2000bd30 	.word	0x2000bd30
 8006b74:	2000bce8 	.word	0x2000bce8
 8006b78:	40028000 	.word	0x40028000
 8006b7c:	08012a5c 	.word	0x08012a5c
 8006b80:	20000080 	.word	0x20000080
 8006b84:	20000000 	.word	0x20000000
 8006b88:	2000bd34 	.word	0x2000bd34
 8006b8c:	08012a00 	.word	0x08012a00
 8006b90:	08007411 	.word	0x08007411
 8006b94:	08012498 	.word	0x08012498
 8006b98:	2000bce4 	.word	0x2000bce4
 8006b9c:	380163fb 	.word	0x380163fb
 8006ba0:	080124a0 	.word	0x080124a0
 8006ba4:	080124b8 	.word	0x080124b8

08006ba8 <prvDMATxDescListInit>:
/*-----------------------------------------------------------*/

static void prvDMATxDescListInit()
{
 8006ba8:	b480      	push	{r7}
 8006baa:	b083      	sub	sp, #12
 8006bac:	af00      	add	r7, sp, #0
ETH_DMADescTypeDef *pxDMADescriptor;
BaseType_t xIndex;

	/* Get the pointer on the first member of the descriptor list */
	pxDMADescriptor = DMATxDscrTab;
 8006bae:	4b1a      	ldr	r3, [pc, #104]	; (8006c18 <prvDMATxDescListInit+0x70>)
 8006bb0:	607b      	str	r3, [r7, #4]

	/* Fill each DMA descriptor with the right values */
	for( xIndex = 0; xIndex < ETH_TXBUFNB; xIndex++, pxDMADescriptor++ )
 8006bb2:	2300      	movs	r3, #0
 8006bb4:	603b      	str	r3, [r7, #0]
 8006bb6:	e01f      	b.n	8006bf8 <prvDMATxDescListInit+0x50>
	{
		/* Set Second Address Chained bit */
		pxDMADescriptor->Status = ETH_DMATXDESC_TCH;
 8006bb8:	687b      	ldr	r3, [r7, #4]
 8006bba:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8006bbe:	601a      	str	r2, [r3, #0]
			/* Set Buffer1 address pointer */
			pxDMADescriptor->Buffer1Addr = ( uint32_t )( Tx_Buff[ xIndex ] );
		}
		#endif

		if( xETH.Init.ChecksumMode == ETH_CHECKSUM_BY_HARDWARE )
 8006bc0:	4b16      	ldr	r3, [pc, #88]	; (8006c1c <prvDMATxDescListInit+0x74>)
 8006bc2:	69db      	ldr	r3, [r3, #28]
 8006bc4:	2b00      	cmp	r3, #0
 8006bc6:	d105      	bne.n	8006bd4 <prvDMATxDescListInit+0x2c>
		{
			/* Set the DMA Tx descriptors checksum insertion for TCP, UDP, and ICMP */
			pxDMADescriptor->Status |= ETH_DMATXDESC_CHECKSUMTCPUDPICMPFULL;
 8006bc8:	687b      	ldr	r3, [r7, #4]
 8006bca:	681b      	ldr	r3, [r3, #0]
 8006bcc:	f443 0240 	orr.w	r2, r3, #12582912	; 0xc00000
 8006bd0:	687b      	ldr	r3, [r7, #4]
 8006bd2:	601a      	str	r2, [r3, #0]
		}

		/* Initialize the next descriptor with the Next Descriptor Polling Enable */
		if( xIndex < ETH_TXBUFNB - 1 )
 8006bd4:	683b      	ldr	r3, [r7, #0]
 8006bd6:	2b02      	cmp	r3, #2
 8006bd8:	d805      	bhi.n	8006be6 <prvDMATxDescListInit+0x3e>
		{
			/* Set next descriptor address register with next descriptor base address */
			pxDMADescriptor->Buffer2NextDescAddr = ( uint32_t ) ( pxDMADescriptor + 1 );
 8006bda:	687b      	ldr	r3, [r7, #4]
 8006bdc:	3320      	adds	r3, #32
 8006bde:	461a      	mov	r2, r3
 8006be0:	687b      	ldr	r3, [r7, #4]
 8006be2:	60da      	str	r2, [r3, #12]
 8006be4:	e002      	b.n	8006bec <prvDMATxDescListInit+0x44>
		}
		else
		{
			/* For last descriptor, set next descriptor address register equal to the first descriptor base address */
			pxDMADescriptor->Buffer2NextDescAddr = ( uint32_t ) DMATxDscrTab;
 8006be6:	4a0c      	ldr	r2, [pc, #48]	; (8006c18 <prvDMATxDescListInit+0x70>)
 8006be8:	687b      	ldr	r3, [r7, #4]
 8006bea:	60da      	str	r2, [r3, #12]

	/* Get the pointer on the first member of the descriptor list */
	pxDMADescriptor = DMATxDscrTab;

	/* Fill each DMA descriptor with the right values */
	for( xIndex = 0; xIndex < ETH_TXBUFNB; xIndex++, pxDMADescriptor++ )
 8006bec:	683b      	ldr	r3, [r7, #0]
 8006bee:	3301      	adds	r3, #1
 8006bf0:	603b      	str	r3, [r7, #0]
 8006bf2:	687b      	ldr	r3, [r7, #4]
 8006bf4:	3320      	adds	r3, #32
 8006bf6:	607b      	str	r3, [r7, #4]
 8006bf8:	683b      	ldr	r3, [r7, #0]
 8006bfa:	2b03      	cmp	r3, #3
 8006bfc:	d9dc      	bls.n	8006bb8 <prvDMATxDescListInit+0x10>
			pxDMADescriptor->Buffer2NextDescAddr = ( uint32_t ) DMATxDscrTab;
		}
	}

	/* Set Transmit Descriptor List Address Register */
	xETH.Instance->DMATDLAR = ( uint32_t ) DMATxDscrTab;
 8006bfe:	4b07      	ldr	r3, [pc, #28]	; (8006c1c <prvDMATxDescListInit+0x74>)
 8006c00:	681a      	ldr	r2, [r3, #0]
 8006c02:	4905      	ldr	r1, [pc, #20]	; (8006c18 <prvDMATxDescListInit+0x70>)
 8006c04:	f241 0310 	movw	r3, #4112	; 0x1010
 8006c08:	4413      	add	r3, r2
 8006c0a:	6019      	str	r1, [r3, #0]
}
 8006c0c:	370c      	adds	r7, #12
 8006c0e:	46bd      	mov	sp, r7
 8006c10:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006c14:	4770      	bx	lr
 8006c16:	bf00      	nop
 8006c18:	20000080 	.word	0x20000080
 8006c1c:	2000bce8 	.word	0x2000bce8

08006c20 <prvDMARxDescListInit>:
/*-----------------------------------------------------------*/

static void prvDMARxDescListInit()
{
 8006c20:	b580      	push	{r7, lr}
 8006c22:	b084      	sub	sp, #16
 8006c24:	af00      	add	r7, sp, #0
	/*
	 * RX-descriptors.
	 */

	/* Get the pointer on the first member of the descriptor list */
	pxDMADescriptor = DMARxDscrTab;
 8006c26:	4b23      	ldr	r3, [pc, #140]	; (8006cb4 <prvDMARxDescListInit+0x94>)
 8006c28:	60fb      	str	r3, [r7, #12]

	/* Fill each DMA descriptor with the right values */
	for( xIndex = 0; xIndex < ETH_RXBUFNB; xIndex++, pxDMADescriptor++ )
 8006c2a:	2300      	movs	r3, #0
 8006c2c:	60bb      	str	r3, [r7, #8]
 8006c2e:	e034      	b.n	8006c9a <prvDMARxDescListInit+0x7a>
	{

		/* Set Buffer1 size and Second Address Chained bit */
		pxDMADescriptor->ControlBufferSize = ETH_DMARXDESC_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
 8006c30:	68fb      	ldr	r3, [r7, #12]
 8006c32:	f244 52f4 	movw	r2, #17908	; 0x45f4
 8006c36:	605a      	str	r2, [r3, #4]
		#if( ipconfigZERO_COPY_RX_DRIVER != 0 )
		{
		/* Set Buffer1 address pointer */
		NetworkBufferDescriptor_t *pxBuffer;

			pxBuffer = pxGetNetworkBufferWithDescriptor( ETH_RX_BUF_SIZE, 100ul );
 8006c38:	f240 50f4 	movw	r0, #1524	; 0x5f4
 8006c3c:	2164      	movs	r1, #100	; 0x64
 8006c3e:	f000 fd53 	bl	80076e8 <pxGetNetworkBufferWithDescriptor>
 8006c42:	6078      	str	r0, [r7, #4]
			/* If the assert below fails, make sure that there are at least 'ETH_RXBUFNB'
			Network Buffers available during start-up ( ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ) */
			configASSERT( pxBuffer != NULL );
 8006c44:	687b      	ldr	r3, [r7, #4]
 8006c46:	2b00      	cmp	r3, #0
 8006c48:	d109      	bne.n	8006c5e <prvDMARxDescListInit+0x3e>
 8006c4a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006c4e:	f383 8811 	msr	BASEPRI, r3
 8006c52:	f3bf 8f6f 	isb	sy
 8006c56:	f3bf 8f4f 	dsb	sy
 8006c5a:	603b      	str	r3, [r7, #0]
 8006c5c:	e7fe      	b.n	8006c5c <prvDMARxDescListInit+0x3c>
			if( pxBuffer != NULL )
 8006c5e:	687b      	ldr	r3, [r7, #4]
 8006c60:	2b00      	cmp	r3, #0
 8006c62:	d008      	beq.n	8006c76 <prvDMARxDescListInit+0x56>
			{
				pxDMADescriptor->Buffer1Addr = (uint32_t)pxBuffer->pucEthernetBuffer;
 8006c64:	687b      	ldr	r3, [r7, #4]
 8006c66:	699b      	ldr	r3, [r3, #24]
 8006c68:	461a      	mov	r2, r3
 8006c6a:	68fb      	ldr	r3, [r7, #12]
 8006c6c:	609a      	str	r2, [r3, #8]
				pxDMADescriptor->Status = ETH_DMARXDESC_OWN;
 8006c6e:	68fb      	ldr	r3, [r7, #12]
 8006c70:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8006c74:	601a      	str	r2, [r3, #0]
			pxDMADescriptor->Status = ETH_DMARXDESC_OWN;
		}
		#endif

		/* Initialize the next descriptor with the Next Descriptor Polling Enable */
		if( xIndex < ETH_RXBUFNB - 1 )
 8006c76:	68bb      	ldr	r3, [r7, #8]
 8006c78:	2b02      	cmp	r3, #2
 8006c7a:	d805      	bhi.n	8006c88 <prvDMARxDescListInit+0x68>
		{
			/* Set next descriptor address register with next descriptor base address */
			pxDMADescriptor->Buffer2NextDescAddr = ( uint32_t )( pxDMADescriptor + 1 );
 8006c7c:	68fb      	ldr	r3, [r7, #12]
 8006c7e:	3320      	adds	r3, #32
 8006c80:	461a      	mov	r2, r3
 8006c82:	68fb      	ldr	r3, [r7, #12]
 8006c84:	60da      	str	r2, [r3, #12]
 8006c86:	e002      	b.n	8006c8e <prvDMARxDescListInit+0x6e>
		}
		else
		{
			/* For last descriptor, set next descriptor address register equal to the first descriptor base address */
			pxDMADescriptor->Buffer2NextDescAddr = ( uint32_t ) DMARxDscrTab;
 8006c88:	4a0a      	ldr	r2, [pc, #40]	; (8006cb4 <prvDMARxDescListInit+0x94>)
 8006c8a:	68fb      	ldr	r3, [r7, #12]
 8006c8c:	60da      	str	r2, [r3, #12]

	/* Get the pointer on the first member of the descriptor list */
	pxDMADescriptor = DMARxDscrTab;

	/* Fill each DMA descriptor with the right values */
	for( xIndex = 0; xIndex < ETH_RXBUFNB; xIndex++, pxDMADescriptor++ )
 8006c8e:	68bb      	ldr	r3, [r7, #8]
 8006c90:	3301      	adds	r3, #1
 8006c92:	60bb      	str	r3, [r7, #8]
 8006c94:	68fb      	ldr	r3, [r7, #12]
 8006c96:	3320      	adds	r3, #32
 8006c98:	60fb      	str	r3, [r7, #12]
 8006c9a:	68bb      	ldr	r3, [r7, #8]
 8006c9c:	2b03      	cmp	r3, #3
 8006c9e:	d9c7      	bls.n	8006c30 <prvDMARxDescListInit+0x10>
			pxDMADescriptor->Buffer2NextDescAddr = ( uint32_t ) DMARxDscrTab;
		}

	}
	/* Set Receive Descriptor List Address Register */
	xETH.Instance->DMARDLAR = ( uint32_t ) DMARxDscrTab;
 8006ca0:	4b05      	ldr	r3, [pc, #20]	; (8006cb8 <prvDMARxDescListInit+0x98>)
 8006ca2:	681a      	ldr	r2, [r3, #0]
 8006ca4:	4903      	ldr	r1, [pc, #12]	; (8006cb4 <prvDMARxDescListInit+0x94>)
 8006ca6:	f241 030c 	movw	r3, #4108	; 0x100c
 8006caa:	4413      	add	r3, r2
 8006cac:	6019      	str	r1, [r3, #0]
}
 8006cae:	3710      	adds	r7, #16
 8006cb0:	46bd      	mov	sp, r7
 8006cb2:	bd80      	pop	{r7, pc}
 8006cb4:	20000000 	.word	0x20000000
 8006cb8:	2000bce8 	.word	0x2000bce8

08006cbc <prvMACAddressConfig>:
/*-----------------------------------------------------------*/

static void prvMACAddressConfig(ETH_HandleTypeDef *heth, uint32_t ulIndex, uint8_t *Addr)
{
 8006cbc:	b480      	push	{r7}
 8006cbe:	b087      	sub	sp, #28
 8006cc0:	af00      	add	r7, sp, #0
 8006cc2:	60f8      	str	r0, [r7, #12]
 8006cc4:	60b9      	str	r1, [r7, #8]
 8006cc6:	607a      	str	r2, [r7, #4]
uint32_t ulTempReg;

	/* Calculate the selected MAC address high register. */
	ulTempReg = 0x80000000ul | ( ( uint32_t ) Addr[ 5 ] << 8 ) | ( uint32_t ) Addr[ 4 ];
 8006cc8:	687b      	ldr	r3, [r7, #4]
 8006cca:	3305      	adds	r3, #5
 8006ccc:	781b      	ldrb	r3, [r3, #0]
 8006cce:	021b      	lsls	r3, r3, #8
 8006cd0:	687a      	ldr	r2, [r7, #4]
 8006cd2:	3204      	adds	r2, #4
 8006cd4:	7812      	ldrb	r2, [r2, #0]
 8006cd6:	4313      	orrs	r3, r2
 8006cd8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8006cdc:	617b      	str	r3, [r7, #20]

	/* Load the selected MAC address high register. */
	( *(__IO uint32_t *)( ( uint32_t ) ( ETH_MAC_ADDR_HBASE + ulIndex ) ) ) = ulTempReg;
 8006cde:	68ba      	ldr	r2, [r7, #8]
 8006ce0:	4b10      	ldr	r3, [pc, #64]	; (8006d24 <prvMACAddressConfig+0x68>)
 8006ce2:	4413      	add	r3, r2
 8006ce4:	461a      	mov	r2, r3
 8006ce6:	697b      	ldr	r3, [r7, #20]
 8006ce8:	6013      	str	r3, [r2, #0]

	/* Calculate the selected MAC address low register. */
	ulTempReg = ( ( uint32_t ) Addr[ 3 ] << 24 ) | ( ( uint32_t ) Addr[ 2 ] << 16 ) | ( ( uint32_t ) Addr[ 1 ] << 8 ) | Addr[ 0 ];
 8006cea:	687b      	ldr	r3, [r7, #4]
 8006cec:	3303      	adds	r3, #3
 8006cee:	781b      	ldrb	r3, [r3, #0]
 8006cf0:	061a      	lsls	r2, r3, #24
 8006cf2:	687b      	ldr	r3, [r7, #4]
 8006cf4:	3302      	adds	r3, #2
 8006cf6:	781b      	ldrb	r3, [r3, #0]
 8006cf8:	041b      	lsls	r3, r3, #16
 8006cfa:	431a      	orrs	r2, r3
 8006cfc:	687b      	ldr	r3, [r7, #4]
 8006cfe:	3301      	adds	r3, #1
 8006d00:	781b      	ldrb	r3, [r3, #0]
 8006d02:	021b      	lsls	r3, r3, #8
 8006d04:	4313      	orrs	r3, r2
 8006d06:	687a      	ldr	r2, [r7, #4]
 8006d08:	7812      	ldrb	r2, [r2, #0]
 8006d0a:	4313      	orrs	r3, r2
 8006d0c:	617b      	str	r3, [r7, #20]

	/* Load the selected MAC address low register */
	( *(__IO uint32_t *) ( ( uint32_t ) ( ETH_MAC_ADDR_LBASE + ulIndex ) ) ) = ulTempReg;
 8006d0e:	68ba      	ldr	r2, [r7, #8]
 8006d10:	4b05      	ldr	r3, [pc, #20]	; (8006d28 <prvMACAddressConfig+0x6c>)
 8006d12:	4413      	add	r3, r2
 8006d14:	461a      	mov	r2, r3
 8006d16:	697b      	ldr	r3, [r7, #20]
 8006d18:	6013      	str	r3, [r2, #0]
}
 8006d1a:	371c      	adds	r7, #28
 8006d1c:	46bd      	mov	sp, r7
 8006d1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006d22:	4770      	bx	lr
 8006d24:	40028040 	.word	0x40028040
 8006d28:	40028044 	.word	0x40028044

08006d2c <xNetworkInterfaceOutput>:
/*-----------------------------------------------------------*/

BaseType_t xNetworkInterfaceOutput( NetworkBufferDescriptor_t * const pxDescriptor, BaseType_t bReleaseAfterSend )
{
 8006d2c:	b580      	push	{r7, lr}
 8006d2e:	b08a      	sub	sp, #40	; 0x28
 8006d30:	af00      	add	r7, sp, #0
 8006d32:	6078      	str	r0, [r7, #4]
 8006d34:	6039      	str	r1, [r7, #0]
BaseType_t xReturn = pdFAIL;
 8006d36:	2300      	movs	r3, #0
 8006d38:	627b      	str	r3, [r7, #36]	; 0x24
uint32_t ulTransmitSize = 0;
 8006d3a:	2300      	movs	r3, #0
 8006d3c:	623b      	str	r3, [r7, #32]
__IO ETH_DMADescTypeDef *pxDmaTxDesc;
/* Do not wait too long for a free TX DMA buffer. */
const TickType_t xBlockTimeTicks = pdMS_TO_TICKS( 50u );
 8006d3e:	2332      	movs	r3, #50	; 0x32
 8006d40:	61fb      	str	r3, [r7, #28]
	{
	ProtocolPacket_t *pxPacket;

		#if( ipconfigZERO_COPY_RX_DRIVER != 0 )
		{
			configASSERT( bReleaseAfterSend != 0 );
 8006d42:	683b      	ldr	r3, [r7, #0]
 8006d44:	2b00      	cmp	r3, #0
 8006d46:	d109      	bne.n	8006d5c <xNetworkInterfaceOutput+0x30>
 8006d48:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006d4c:	f383 8811 	msr	BASEPRI, r3
 8006d50:	f3bf 8f6f 	isb	sy
 8006d54:	f3bf 8f4f 	dsb	sy
 8006d58:	613b      	str	r3, [r7, #16]
 8006d5a:	e7fe      	b.n	8006d5a <xNetworkInterfaceOutput+0x2e>
		}
		#endif /* ipconfigZERO_COPY_RX_DRIVER */

		/* If the peripheral must calculate the checksum, it wants
		the protocol checksum to have a value of zero. */
		pxPacket = ( ProtocolPacket_t * ) ( pxDescriptor->pucEthernetBuffer );
 8006d5c:	687b      	ldr	r3, [r7, #4]
 8006d5e:	699b      	ldr	r3, [r3, #24]
 8006d60:	61bb      	str	r3, [r7, #24]

		if( pxPacket->xICMPPacket.xIPHeader.ucProtocol == ipPROTOCOL_ICMP )
 8006d62:	69bb      	ldr	r3, [r7, #24]
 8006d64:	7ddb      	ldrb	r3, [r3, #23]
 8006d66:	2b01      	cmp	r3, #1
 8006d68:	d106      	bne.n	8006d78 <xNetworkInterfaceOutput+0x4c>
		{
			pxPacket->xICMPPacket.xICMPHeader.usChecksum = ( uint16_t )0u;
 8006d6a:	69bb      	ldr	r3, [r7, #24]
 8006d6c:	2200      	movs	r2, #0
 8006d6e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
 8006d72:	2200      	movs	r2, #0
 8006d74:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
	#endif

	/* Open a do {} while ( 0 ) loop to be able to call break. */
	do
	{
		if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 )
 8006d78:	4b33      	ldr	r3, [pc, #204]	; (8006e48 <xNetworkInterfaceOutput+0x11c>)
 8006d7a:	681b      	ldr	r3, [r3, #0]
 8006d7c:	f003 0304 	and.w	r3, r3, #4
 8006d80:	2b00      	cmp	r3, #0
 8006d82:	d056      	beq.n	8006e32 <xNetworkInterfaceOutput+0x106>
		{
			if( xSemaphoreTake( xTXDescriptorSemaphore, xBlockTimeTicks ) != pdPASS )
 8006d84:	4b31      	ldr	r3, [pc, #196]	; (8006e4c <xNetworkInterfaceOutput+0x120>)
 8006d86:	681b      	ldr	r3, [r3, #0]
 8006d88:	4618      	mov	r0, r3
 8006d8a:	2100      	movs	r1, #0
 8006d8c:	69fa      	ldr	r2, [r7, #28]
 8006d8e:	2300      	movs	r3, #0
 8006d90:	f7fd fdc6 	bl	8004920 <xQueueGenericReceive>
 8006d94:	4603      	mov	r3, r0
 8006d96:	2b01      	cmp	r3, #1
 8006d98:	d000      	beq.n	8006d9c <xNetworkInterfaceOutput+0x70>
			{
				/* Time-out waiting for a free TX descriptor. */
				break;
 8006d9a:	e04a      	b.n	8006e32 <xNetworkInterfaceOutput+0x106>
			}

			/* This function does the actual transmission of the packet. The packet is
			contained in 'pxDescriptor' that is passed to the function. */
			pxDmaTxDesc = xETH.TxDesc;
 8006d9c:	4b2c      	ldr	r3, [pc, #176]	; (8006e50 <xNetworkInterfaceOutput+0x124>)
 8006d9e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006da0:	617b      	str	r3, [r7, #20]

			/* Is this buffer available? */
			configASSERT ( ( pxDmaTxDesc->Status & ETH_DMATXDESC_OWN ) == 0 );
 8006da2:	697b      	ldr	r3, [r7, #20]
 8006da4:	681b      	ldr	r3, [r3, #0]
 8006da6:	2b00      	cmp	r3, #0
 8006da8:	da09      	bge.n	8006dbe <xNetworkInterfaceOutput+0x92>
 8006daa:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006dae:	f383 8811 	msr	BASEPRI, r3
 8006db2:	f3bf 8f6f 	isb	sy
 8006db6:	f3bf 8f4f 	dsb	sy
 8006dba:	60fb      	str	r3, [r7, #12]
 8006dbc:	e7fe      	b.n	8006dbc <xNetworkInterfaceOutput+0x90>

			{
				/* Is this buffer available? */
				/* Get bytes in current buffer. */
				ulTransmitSize = pxDescriptor->xDataLength;
 8006dbe:	687b      	ldr	r3, [r7, #4]
 8006dc0:	69db      	ldr	r3, [r3, #28]
 8006dc2:	623b      	str	r3, [r7, #32]

				if( ulTransmitSize > ETH_TX_BUF_SIZE )
 8006dc4:	6a3b      	ldr	r3, [r7, #32]
 8006dc6:	f240 52f4 	movw	r2, #1524	; 0x5f4
 8006dca:	4293      	cmp	r3, r2
 8006dcc:	d902      	bls.n	8006dd4 <xNetworkInterfaceOutput+0xa8>
				{
					ulTransmitSize = ETH_TX_BUF_SIZE;
 8006dce:	f240 53f4 	movw	r3, #1524	; 0x5f4
 8006dd2:	623b      	str	r3, [r7, #32]
					memcpy( ( void * ) pxDmaTxDesc->Buffer1Addr, pxDescriptor->pucEthernetBuffer, ulTransmitSize );
				}
				#else
				{
					/* Move the buffer. */
					pxDmaTxDesc->Buffer1Addr = ( uint32_t )pxDescriptor->pucEthernetBuffer;
 8006dd4:	687b      	ldr	r3, [r7, #4]
 8006dd6:	699b      	ldr	r3, [r3, #24]
 8006dd8:	461a      	mov	r2, r3
 8006dda:	697b      	ldr	r3, [r7, #20]
 8006ddc:	609a      	str	r2, [r3, #8]
					/* The Network Buffer has been passed to DMA, no need to release it. */
					bReleaseAfterSend = pdFALSE_UNSIGNED;
 8006dde:	2300      	movs	r3, #0
 8006de0:	603b      	str	r3, [r7, #0]
				}
				#endif /* ipconfigZERO_COPY_TX_DRIVER */

				/* Ask to set the IPv4 checksum.
				Also need an Interrupt on Completion so that 'vClearTXBuffers()' will be called.. */
				pxDmaTxDesc->Status |= ETH_DMATXDESC_CIC_TCPUDPICMP_FULL | ETH_DMATXDESC_IC;
 8006de2:	697b      	ldr	r3, [r7, #20]
 8006de4:	681a      	ldr	r2, [r3, #0]
 8006de6:	4b1b      	ldr	r3, [pc, #108]	; (8006e54 <xNetworkInterfaceOutput+0x128>)
 8006de8:	4313      	orrs	r3, r2
 8006dea:	697a      	ldr	r2, [r7, #20]
 8006dec:	6013      	str	r3, [r2, #0]

				/* Prepare transmit descriptors to give to DMA. */

				/* Set LAST and FIRST segment */
				pxDmaTxDesc->Status |= ETH_DMATXDESC_FS | ETH_DMATXDESC_LS;
 8006dee:	697b      	ldr	r3, [r7, #20]
 8006df0:	681b      	ldr	r3, [r3, #0]
 8006df2:	f043 5240 	orr.w	r2, r3, #805306368	; 0x30000000
 8006df6:	697b      	ldr	r3, [r7, #20]
 8006df8:	601a      	str	r2, [r3, #0]
				/* Set frame size */
				pxDmaTxDesc->ControlBufferSize = ( ulTransmitSize & ETH_DMATXDESC_TBS1 );
 8006dfa:	6a3b      	ldr	r3, [r7, #32]
 8006dfc:	f3c3 020c 	ubfx	r2, r3, #0, #13
 8006e00:	697b      	ldr	r3, [r7, #20]
 8006e02:	605a      	str	r2, [r3, #4]
				/* Set Own bit of the Tx descriptor Status: gives the buffer back to ETHERNET DMA */
				pxDmaTxDesc->Status |= ETH_DMATXDESC_OWN;
 8006e04:	697b      	ldr	r3, [r7, #20]
 8006e06:	681b      	ldr	r3, [r3, #0]
 8006e08:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
 8006e0c:	697b      	ldr	r3, [r7, #20]
 8006e0e:	601a      	str	r2, [r3, #0]

				/* Point to next descriptor */
				xETH.TxDesc = ( ETH_DMADescTypeDef * ) ( xETH.TxDesc->Buffer2NextDescAddr );
 8006e10:	4b0f      	ldr	r3, [pc, #60]	; (8006e50 <xNetworkInterfaceOutput+0x124>)
 8006e12:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006e14:	68db      	ldr	r3, [r3, #12]
 8006e16:	461a      	mov	r2, r3
 8006e18:	4b0d      	ldr	r3, [pc, #52]	; (8006e50 <xNetworkInterfaceOutput+0x124>)
 8006e1a:	62da      	str	r2, [r3, #44]	; 0x2c
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8006e1c:	f3bf 8f4f 	dsb	sy
				/* Ensure completion of memory access */
				__DSB();
				/* Resume DMA transmission*/
				xETH.Instance->DMATPDR = 0;
 8006e20:	4b0b      	ldr	r3, [pc, #44]	; (8006e50 <xNetworkInterfaceOutput+0x124>)
 8006e22:	681a      	ldr	r2, [r3, #0]
 8006e24:	f241 0304 	movw	r3, #4100	; 0x1004
 8006e28:	4413      	add	r3, r2
 8006e2a:	2200      	movs	r2, #0
 8006e2c:	601a      	str	r2, [r3, #0]
				iptraceNETWORK_INTERFACE_TRANSMIT();
				xReturn = pdPASS;
 8006e2e:	2301      	movs	r3, #1
 8006e30:	627b      	str	r3, [r7, #36]	; 0x24
		{
			/* The PHY has no Link Status, packet shall be dropped. */
		}
	} while( 0 );
	/* The buffer has been sent so can be released. */
	if( bReleaseAfterSend != pdFALSE )
 8006e32:	683b      	ldr	r3, [r7, #0]
 8006e34:	2b00      	cmp	r3, #0
 8006e36:	d002      	beq.n	8006e3e <xNetworkInterfaceOutput+0x112>
	{
		vReleaseNetworkBufferAndDescriptor( pxDescriptor );
 8006e38:	6878      	ldr	r0, [r7, #4]
 8006e3a:	f000 fccf 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
	}

	return xReturn;
 8006e3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8006e40:	4618      	mov	r0, r3
 8006e42:	3728      	adds	r7, #40	; 0x28
 8006e44:	46bd      	mov	sp, r7
 8006e46:	bd80      	pop	{r7, pc}
 8006e48:	2000bce4 	.word	0x2000bce4
 8006e4c:	2000bd30 	.word	0x2000bd30
 8006e50:	2000bce8 	.word	0x2000bce8
 8006e54:	40c00000 	.word	0x40c00000

08006e58 <xMayAcceptPacket>:
/*-----------------------------------------------------------*/

static BaseType_t xMayAcceptPacket( uint8_t *pcBuffer )
{
 8006e58:	b480      	push	{r7}
 8006e5a:	b085      	sub	sp, #20
 8006e5c:	af00      	add	r7, sp, #0
 8006e5e:	6078      	str	r0, [r7, #4]
const ProtocolPacket_t *pxProtPacket = ( const ProtocolPacket_t * )pcBuffer;
 8006e60:	687b      	ldr	r3, [r7, #4]
 8006e62:	60fb      	str	r3, [r7, #12]

	switch( pxProtPacket->xTCPPacket.xEthernetHeader.usFrameType )
 8006e64:	68fb      	ldr	r3, [r7, #12]
 8006e66:	899b      	ldrh	r3, [r3, #12]
 8006e68:	b29b      	uxth	r3, r3
 8006e6a:	2b08      	cmp	r3, #8
 8006e6c:	d006      	beq.n	8006e7c <xMayAcceptPacket+0x24>
 8006e6e:	f5b3 6fc1 	cmp.w	r3, #1544	; 0x608
 8006e72:	d101      	bne.n	8006e78 <xMayAcceptPacket+0x20>
	{
	case ipARP_FRAME_TYPE:
		/* Check it later. */
		return pdTRUE;
 8006e74:	2301      	movs	r3, #1
 8006e76:	e003      	b.n	8006e80 <xMayAcceptPacket+0x28>
	case ipIPv4_FRAME_TYPE:
		/* Check it here. */
		break;
	default:
		/* Refuse the packet. */
		return pdFALSE;
 8006e78:	2300      	movs	r3, #0
 8006e7a:	e001      	b.n	8006e80 <xMayAcceptPacket+0x28>
	case ipARP_FRAME_TYPE:
		/* Check it later. */
		return pdTRUE;
	case ipIPv4_FRAME_TYPE:
		/* Check it here. */
		break;
 8006e7c:	bf00      	nop
				return pdFALSE;
			}
		}
	}
	#endif	/* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */
	return pdTRUE;
 8006e7e:	2301      	movs	r3, #1
}
 8006e80:	4618      	mov	r0, r3
 8006e82:	3714      	adds	r7, #20
 8006e84:	46bd      	mov	sp, r7
 8006e86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8006e8a:	4770      	bx	lr

08006e8c <prvNetworkInterfaceInput>:
/*-----------------------------------------------------------*/

static BaseType_t prvNetworkInterfaceInput( void )
{
 8006e8c:	b580      	push	{r7, lr}
 8006e8e:	b08c      	sub	sp, #48	; 0x30
 8006e90:	af00      	add	r7, sp, #0
NetworkBufferDescriptor_t *pxCurDescriptor;
NetworkBufferDescriptor_t *pxNewDescriptor = NULL;
 8006e92:	2300      	movs	r3, #0
 8006e94:	62fb      	str	r3, [r7, #44]	; 0x2c
BaseType_t xReceivedLength, xAccepted;
__IO ETH_DMADescTypeDef *pxDMARxDescriptor;
xIPStackEvent_t xRxEvent = { eNetworkRxEvent, NULL };
 8006e96:	2301      	movs	r3, #1
 8006e98:	713b      	strb	r3, [r7, #4]
 8006e9a:	2300      	movs	r3, #0
 8006e9c:	60bb      	str	r3, [r7, #8]
const TickType_t xDescriptorWaitTime = pdMS_TO_TICKS( 250 );
 8006e9e:	23fa      	movs	r3, #250	; 0xfa
 8006ea0:	61fb      	str	r3, [r7, #28]
uint8_t *pucBuffer;

	pxDMARxDescriptor = xETH.RxDesc;
 8006ea2:	4b4f      	ldr	r3, [pc, #316]	; (8006fe0 <prvNetworkInterfaceInput+0x154>)
 8006ea4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006ea6:	61bb      	str	r3, [r7, #24]

	if( ( pxDMARxDescriptor->Status & ETH_DMARXDESC_OWN) == 0 )
 8006ea8:	69bb      	ldr	r3, [r7, #24]
 8006eaa:	681b      	ldr	r3, [r3, #0]
 8006eac:	2b00      	cmp	r3, #0
 8006eae:	db0f      	blt.n	8006ed0 <prvNetworkInterfaceInput+0x44>
	{
		/* Get the Frame Length of the received packet: substruct 4 bytes of the CRC */
		xReceivedLength = ( ( pxDMARxDescriptor->Status & ETH_DMARXDESC_FL ) >> ETH_DMARXDESC_FRAMELENGTHSHIFT ) - 4;
 8006eb0:	69bb      	ldr	r3, [r7, #24]
 8006eb2:	681a      	ldr	r2, [r3, #0]
 8006eb4:	4b4b      	ldr	r3, [pc, #300]	; (8006fe4 <prvNetworkInterfaceInput+0x158>)
 8006eb6:	4013      	ands	r3, r2
 8006eb8:	0c1b      	lsrs	r3, r3, #16
 8006eba:	3b04      	subs	r3, #4
 8006ebc:	62bb      	str	r3, [r7, #40]	; 0x28

		pucBuffer = (uint8_t *) pxDMARxDescriptor->Buffer1Addr;
 8006ebe:	69bb      	ldr	r3, [r7, #24]
 8006ec0:	689b      	ldr	r3, [r3, #8]
 8006ec2:	623b      	str	r3, [r7, #32]

		/* Update the ETHERNET DMA global Rx descriptor with next Rx descriptor */
		/* Chained Mode */    
		/* Selects the next DMA Rx descriptor list for next buffer to read */ 
		xETH.RxDesc = ( ETH_DMADescTypeDef* )pxDMARxDescriptor->Buffer2NextDescAddr;
 8006ec4:	69bb      	ldr	r3, [r7, #24]
 8006ec6:	68db      	ldr	r3, [r3, #12]
 8006ec8:	461a      	mov	r2, r3
 8006eca:	4b45      	ldr	r3, [pc, #276]	; (8006fe0 <prvNetworkInterfaceInput+0x154>)
 8006ecc:	629a      	str	r2, [r3, #40]	; 0x28
 8006ece:	e001      	b.n	8006ed4 <prvNetworkInterfaceInput+0x48>
	}
	else
	{
		xReceivedLength = 0;
 8006ed0:	2300      	movs	r3, #0
 8006ed2:	62bb      	str	r3, [r7, #40]	; 0x28
	}

	/* Obtain the size of the packet and put it into the "usReceivedLength" variable. */

	/* get received frame */
	if( xReceivedLength > 0ul )
 8006ed4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006ed6:	2b00      	cmp	r3, #0
 8006ed8:	d077      	beq.n	8006fca <prvNetworkInterfaceInput+0x13e>
	{
		/* In order to make the code easier and faster, only packets in a single buffer
		will be accepted.  This can be done by making the buffers large enough to
		hold a complete Ethernet packet (1536 bytes).
		Therefore, two sanity checks: */
		configASSERT( xReceivedLength <= ETH_RX_BUF_SIZE );
 8006eda:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006edc:	f240 52f4 	movw	r2, #1524	; 0x5f4
 8006ee0:	4293      	cmp	r3, r2
 8006ee2:	d909      	bls.n	8006ef8 <prvNetworkInterfaceInput+0x6c>
 8006ee4:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006ee8:	f383 8811 	msr	BASEPRI, r3
 8006eec:	f3bf 8f6f 	isb	sy
 8006ef0:	f3bf 8f4f 	dsb	sy
 8006ef4:	613b      	str	r3, [r7, #16]
 8006ef6:	e7fe      	b.n	8006ef6 <prvNetworkInterfaceInput+0x6a>

		if( ( pxDMARxDescriptor->Status & ( ETH_DMARXDESC_CE | ETH_DMARXDESC_IPV4HCE | ETH_DMARXDESC_FT ) ) != ETH_DMARXDESC_FT )
 8006ef8:	69bb      	ldr	r3, [r7, #24]
 8006efa:	681b      	ldr	r3, [r3, #0]
 8006efc:	f003 03a2 	and.w	r3, r3, #162	; 0xa2
 8006f00:	2b20      	cmp	r3, #32
 8006f02:	d002      	beq.n	8006f0a <prvNetworkInterfaceInput+0x7e>
		{
			/* Not an Ethernet frame-type or a checmsum error. */
			xAccepted = pdFALSE;
 8006f04:	2300      	movs	r3, #0
 8006f06:	627b      	str	r3, [r7, #36]	; 0x24
 8006f08:	e003      	b.n	8006f12 <prvNetworkInterfaceInput+0x86>
		}
		else
		{
			/* See if this packet must be handled. */
			xAccepted = xMayAcceptPacket( pucBuffer );
 8006f0a:	6a38      	ldr	r0, [r7, #32]
 8006f0c:	f7ff ffa4 	bl	8006e58 <xMayAcceptPacket>
 8006f10:	6278      	str	r0, [r7, #36]	; 0x24
		}

		if( xAccepted != pdFALSE )
 8006f12:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006f14:	2b00      	cmp	r3, #0
 8006f16:	d00a      	beq.n	8006f2e <prvNetworkInterfaceInput+0xa2>
		{
			/* The packet wil be accepted, but check first if a new Network Buffer can
			be obtained. If not, the packet will still be dropped. */
			pxNewDescriptor = pxGetNetworkBufferWithDescriptor( ETH_RX_BUF_SIZE, xDescriptorWaitTime );
 8006f18:	f240 50f4 	movw	r0, #1524	; 0x5f4
 8006f1c:	69f9      	ldr	r1, [r7, #28]
 8006f1e:	f000 fbe3 	bl	80076e8 <pxGetNetworkBufferWithDescriptor>
 8006f22:	62f8      	str	r0, [r7, #44]	; 0x2c

			if( pxNewDescriptor == NULL )
 8006f24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006f26:	2b00      	cmp	r3, #0
 8006f28:	d101      	bne.n	8006f2e <prvNetworkInterfaceInput+0xa2>
			{
				/* A new descriptor can not be allocated now. This packet will be dropped. */
				xAccepted = pdFALSE;
 8006f2a:	2300      	movs	r3, #0
 8006f2c:	627b      	str	r3, [r7, #36]	; 0x24
			}
		}
		#if( ipconfigZERO_COPY_RX_DRIVER != 0 )
		{
			/* Find out which Network Buffer was originally passed to the descriptor. */
			pxCurDescriptor = pxPacketBuffer_to_NetworkBuffer( pucBuffer );
 8006f2e:	6a38      	ldr	r0, [r7, #32]
 8006f30:	f000 feb8 	bl	8007ca4 <pxPacketBuffer_to_NetworkBuffer>
 8006f34:	6178      	str	r0, [r7, #20]
			configASSERT( pxCurDescriptor != NULL );
 8006f36:	697b      	ldr	r3, [r7, #20]
 8006f38:	2b00      	cmp	r3, #0
 8006f3a:	d109      	bne.n	8006f50 <prvNetworkInterfaceInput+0xc4>
 8006f3c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8006f40:	f383 8811 	msr	BASEPRI, r3
 8006f44:	f3bf 8f6f 	isb	sy
 8006f48:	f3bf 8f4f 	dsb	sy
 8006f4c:	60fb      	str	r3, [r7, #12]
 8006f4e:	e7fe      	b.n	8006f4e <prvNetworkInterfaceInput+0xc2>
				memcpy( pxNewDescriptor->pucEthernetBuffer, pucBuffer, xReceivedLength );
			}
		}
		#endif

		if( xAccepted != pdFALSE )
 8006f50:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8006f52:	2b00      	cmp	r3, #0
 8006f54:	d00f      	beq.n	8006f76 <prvNetworkInterfaceInput+0xea>
		{
			pxCurDescriptor->xDataLength = xReceivedLength;
 8006f56:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8006f58:	697b      	ldr	r3, [r7, #20]
 8006f5a:	61da      	str	r2, [r3, #28]
			xRxEvent.pvData = ( void * ) pxCurDescriptor;
 8006f5c:	697b      	ldr	r3, [r7, #20]
 8006f5e:	60bb      	str	r3, [r7, #8]

			/* Pass the data to the TCP/IP task for processing. */
			if( xSendEventStructToIPTask( &xRxEvent, xDescriptorWaitTime ) == pdFALSE )
 8006f60:	1d3b      	adds	r3, r7, #4
 8006f62:	4618      	mov	r0, r3
 8006f64:	69f9      	ldr	r1, [r7, #28]
 8006f66:	f001 f823 	bl	8007fb0 <xSendEventStructToIPTask>
 8006f6a:	4603      	mov	r3, r0
 8006f6c:	2b00      	cmp	r3, #0
 8006f6e:	d102      	bne.n	8006f76 <prvNetworkInterfaceInput+0xea>
			{
				/* Could not send the descriptor into the TCP/IP stack, it
				must be released. */
				vReleaseNetworkBufferAndDescriptor( pxCurDescriptor );
 8006f70:	6978      	ldr	r0, [r7, #20]
 8006f72:	f000 fc33 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>

		/* Release descriptors to DMA */
		#if( ipconfigZERO_COPY_RX_DRIVER != 0 )
		{
			/* Set Buffer1 address pointer */
			if( pxNewDescriptor != NULL )
 8006f76:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006f78:	2b00      	cmp	r3, #0
 8006f7a:	d004      	beq.n	8006f86 <prvNetworkInterfaceInput+0xfa>
			{
				pxDMARxDescriptor->Buffer1Addr = (uint32_t)pxNewDescriptor->pucEthernetBuffer;
 8006f7c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8006f7e:	699b      	ldr	r3, [r3, #24]
 8006f80:	461a      	mov	r2, r3
 8006f82:	69bb      	ldr	r3, [r7, #24]
 8006f84:	609a      	str	r2, [r3, #8]
			}
		}
		#endif /* ipconfigZERO_COPY_RX_DRIVER */

		/* Set Buffer1 size and Second Address Chained bit */
		pxDMARxDescriptor->ControlBufferSize = ETH_DMARXDESC_RCH | (uint32_t)ETH_RX_BUF_SIZE;  
 8006f86:	69bb      	ldr	r3, [r7, #24]
 8006f88:	f244 52f4 	movw	r2, #17908	; 0x45f4
 8006f8c:	605a      	str	r2, [r3, #4]
		pxDMARxDescriptor->Status = ETH_DMARXDESC_OWN;
 8006f8e:	69bb      	ldr	r3, [r7, #24]
 8006f90:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 8006f94:	601a      	str	r2, [r3, #0]
 8006f96:	f3bf 8f4f 	dsb	sy

		/* Ensure completion of memory access */
		__DSB();
		/* When Rx Buffer unavailable flag is set clear it and resume
		reception. */
		if( ( xETH.Instance->DMASR & ETH_DMASR_RBUS ) != 0 )
 8006f9a:	4b11      	ldr	r3, [pc, #68]	; (8006fe0 <prvNetworkInterfaceInput+0x154>)
 8006f9c:	681a      	ldr	r2, [r3, #0]
 8006f9e:	f241 0314 	movw	r3, #4116	; 0x1014
 8006fa2:	4413      	add	r3, r2
 8006fa4:	681b      	ldr	r3, [r3, #0]
 8006fa6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8006faa:	2b00      	cmp	r3, #0
 8006fac:	d00d      	beq.n	8006fca <prvNetworkInterfaceInput+0x13e>
		{
			/* Clear RBUS ETHERNET DMA flag. */
			xETH.Instance->DMASR = ETH_DMASR_RBUS;
 8006fae:	4b0c      	ldr	r3, [pc, #48]	; (8006fe0 <prvNetworkInterfaceInput+0x154>)
 8006fb0:	681a      	ldr	r2, [r3, #0]
 8006fb2:	f241 0314 	movw	r3, #4116	; 0x1014
 8006fb6:	4413      	add	r3, r2
 8006fb8:	2280      	movs	r2, #128	; 0x80
 8006fba:	601a      	str	r2, [r3, #0]

			/* Resume DMA reception. */
			xETH.Instance->DMARPDR = 0;
 8006fbc:	4b08      	ldr	r3, [pc, #32]	; (8006fe0 <prvNetworkInterfaceInput+0x154>)
 8006fbe:	681a      	ldr	r2, [r3, #0]
 8006fc0:	f241 0308 	movw	r3, #4104	; 0x1008
 8006fc4:	4413      	add	r3, r2
 8006fc6:	2200      	movs	r2, #0
 8006fc8:	601a      	str	r2, [r3, #0]
		}
	}

	return ( xReceivedLength > 0 );
 8006fca:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8006fcc:	2b00      	cmp	r3, #0
 8006fce:	bfcc      	ite	gt
 8006fd0:	2301      	movgt	r3, #1
 8006fd2:	2300      	movle	r3, #0
 8006fd4:	b2db      	uxtb	r3, r3
}
 8006fd6:	4618      	mov	r0, r3
 8006fd8:	3730      	adds	r7, #48	; 0x30
 8006fda:	46bd      	mov	sp, r7
 8006fdc:	bd80      	pop	{r7, pc}
 8006fde:	bf00      	nop
 8006fe0:	2000bce8 	.word	0x2000bce8
 8006fe4:	3fff0000 	.word	0x3fff0000

08006fe8 <vMACBProbePhy>:
/*-----------------------------------------------------------*/

void vMACBProbePhy( void )
{
 8006fe8:	b580      	push	{r7, lr}
 8006fea:	b08a      	sub	sp, #40	; 0x28
 8006fec:	af00      	add	r7, sp, #0
uint32_t ulConfig, ulAdvertise, ulLower, ulUpper, ulMACPhyID, ulValue;
TimeOut_t xPhyTime;
TickType_t xRemTime = 0;
 8006fee:	2300      	movs	r3, #0
 8006ff0:	607b      	str	r3, [r7, #4]
#if( EXPECTED_PHY_ID == PHY_ID_DP83848I )
	uint32_t ulPhyControl;
#endif

	HAL_ETH_ReadPHYRegister(&xETH, PHY_REG_03_PHYSID2, &ulLower);
 8006ff2:	f107 0318 	add.w	r3, r7, #24
 8006ff6:	4875      	ldr	r0, [pc, #468]	; (80071cc <vMACBProbePhy+0x1e4>)
 8006ff8:	2103      	movs	r1, #3
 8006ffa:	461a      	mov	r2, r3
 8006ffc:	f7fc f894 	bl	8003128 <HAL_ETH_ReadPHYRegister>
	HAL_ETH_ReadPHYRegister(&xETH, PHY_REG_02_PHYSID1, &ulUpper);
 8007000:	f107 0314 	add.w	r3, r7, #20
 8007004:	4871      	ldr	r0, [pc, #452]	; (80071cc <vMACBProbePhy+0x1e4>)
 8007006:	2102      	movs	r1, #2
 8007008:	461a      	mov	r2, r3
 800700a:	f7fc f88d 	bl	8003128 <HAL_ETH_ReadPHYRegister>

	ulMACPhyID = ( ( ulUpper << 16 ) & 0xFFFF0000 ) | ( ulLower & 0xFFF0 );
 800700e:	697b      	ldr	r3, [r7, #20]
 8007010:	041a      	lsls	r2, r3, #16
 8007012:	69b9      	ldr	r1, [r7, #24]
 8007014:	f64f 73f0 	movw	r3, #65520	; 0xfff0
 8007018:	400b      	ands	r3, r1
 800701a:	4313      	orrs	r3, r2
 800701c:	623b      	str	r3, [r7, #32]

	/* The expected ID for the 'LAN8742A'  is 0x0007c130. */
	/* The expected ID for the 'LAN8720'   is 0x0007c0f0. */
	/* The expected ID for the 'DP83848I'  is 0x20005C90. */

	FreeRTOS_printf( ( "PHY ID %lX (%s)\n", ulMACPhyID,
 800701e:	6a3b      	ldr	r3, [r7, #32]
 8007020:	4a6b      	ldr	r2, [pc, #428]	; (80071d0 <vMACBProbePhy+0x1e8>)
 8007022:	4293      	cmp	r3, r2
 8007024:	d101      	bne.n	800702a <vMACBProbePhy+0x42>
 8007026:	4b6b      	ldr	r3, [pc, #428]	; (80071d4 <vMACBProbePhy+0x1ec>)
 8007028:	e000      	b.n	800702c <vMACBProbePhy+0x44>
 800702a:	4b6b      	ldr	r3, [pc, #428]	; (80071d8 <vMACBProbePhy+0x1f0>)
 800702c:	486b      	ldr	r0, [pc, #428]	; (80071dc <vMACBProbePhy+0x1f4>)
 800702e:	6a39      	ldr	r1, [r7, #32]
 8007030:	461a      	mov	r2, r3
 8007032:	f007 ff59 	bl	800eee8 <lUDPLoggingPrintf>

	/* Remove compiler warning if FreeRTOS_printf() is not defined. */
	( void ) ulMACPhyID;

    /* Set advertise register. */
	if( ( xPHYProperties.speed == PHY_SPEED_AUTO ) && ( xPHYProperties.duplex == PHY_DUPLEX_AUTO ) )
 8007036:	2303      	movs	r3, #3
 8007038:	2b03      	cmp	r3, #3
 800703a:	d106      	bne.n	800704a <vMACBProbePhy+0x62>
 800703c:	2303      	movs	r3, #3
 800703e:	2b03      	cmp	r3, #3
 8007040:	d103      	bne.n	800704a <vMACBProbePhy+0x62>
	{
		ulAdvertise = ADVERTISE_CSMA | ADVERTISE_ALL;
 8007042:	f240 13e1 	movw	r3, #481	; 0x1e1
 8007046:	627b      	str	r3, [r7, #36]	; 0x24
 8007048:	e03d      	b.n	80070c6 <vMACBProbePhy+0xde>
		/* Reset auto-negotiation capability. */
	}
	else
	{
		ulAdvertise = ADVERTISE_CSMA;
 800704a:	2301      	movs	r3, #1
 800704c:	627b      	str	r3, [r7, #36]	; 0x24

		if( xPHYProperties.speed == PHY_SPEED_AUTO )
 800704e:	2303      	movs	r3, #3
 8007050:	2b03      	cmp	r3, #3
 8007052:	d10c      	bne.n	800706e <vMACBProbePhy+0x86>
		{
			if( xPHYProperties.duplex == PHY_DUPLEX_FULL )
 8007054:	2303      	movs	r3, #3
 8007056:	2b02      	cmp	r3, #2
 8007058:	d104      	bne.n	8007064 <vMACBProbePhy+0x7c>
			{
				ulAdvertise |= ADVERTISE_10FULL | ADVERTISE_100FULL;
 800705a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800705c:	f443 73a0 	orr.w	r3, r3, #320	; 0x140
 8007060:	627b      	str	r3, [r7, #36]	; 0x24
 8007062:	e030      	b.n	80070c6 <vMACBProbePhy+0xde>
			}
			else
			{
				ulAdvertise |= ADVERTISE_10HALF | ADVERTISE_100HALF;
 8007064:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007066:	f043 03a0 	orr.w	r3, r3, #160	; 0xa0
 800706a:	627b      	str	r3, [r7, #36]	; 0x24
 800706c:	e02b      	b.n	80070c6 <vMACBProbePhy+0xde>
			}
		}
		else if( xPHYProperties.duplex == PHY_DUPLEX_AUTO )
 800706e:	2303      	movs	r3, #3
 8007070:	2b03      	cmp	r3, #3
 8007072:	d10c      	bne.n	800708e <vMACBProbePhy+0xa6>
		{
			if( xPHYProperties.speed == PHY_SPEED_10 )
 8007074:	2303      	movs	r3, #3
 8007076:	2b01      	cmp	r3, #1
 8007078:	d104      	bne.n	8007084 <vMACBProbePhy+0x9c>
			{
				ulAdvertise |= ADVERTISE_10FULL | ADVERTISE_10HALF;
 800707a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800707c:	f043 0360 	orr.w	r3, r3, #96	; 0x60
 8007080:	627b      	str	r3, [r7, #36]	; 0x24
 8007082:	e020      	b.n	80070c6 <vMACBProbePhy+0xde>
			}
			else
			{
				ulAdvertise |= ADVERTISE_100FULL | ADVERTISE_100HALF;
 8007084:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8007086:	f443 73c0 	orr.w	r3, r3, #384	; 0x180
 800708a:	627b      	str	r3, [r7, #36]	; 0x24
 800708c:	e01b      	b.n	80070c6 <vMACBProbePhy+0xde>
			}
		}
		else if( xPHYProperties.speed == PHY_SPEED_100 )
 800708e:	2303      	movs	r3, #3
 8007090:	2b02      	cmp	r3, #2
 8007092:	d10c      	bne.n	80070ae <vMACBProbePhy+0xc6>
		{
			if( xPHYProperties.duplex == PHY_DUPLEX_FULL )
 8007094:	2303      	movs	r3, #3
 8007096:	2b02      	cmp	r3, #2
 8007098:	d104      	bne.n	80070a4 <vMACBProbePhy+0xbc>
			{
				ulAdvertise |= ADVERTISE_100FULL;
 800709a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800709c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80070a0:	627b      	str	r3, [r7, #36]	; 0x24
 80070a2:	e010      	b.n	80070c6 <vMACBProbePhy+0xde>
			}
			else
			{
				ulAdvertise |= ADVERTISE_100HALF;
 80070a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80070a6:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80070aa:	627b      	str	r3, [r7, #36]	; 0x24
 80070ac:	e00b      	b.n	80070c6 <vMACBProbePhy+0xde>
			}
		}
		else
		{
			if( xPHYProperties.duplex == PHY_DUPLEX_FULL )
 80070ae:	2303      	movs	r3, #3
 80070b0:	2b02      	cmp	r3, #2
 80070b2:	d104      	bne.n	80070be <vMACBProbePhy+0xd6>
			{
				ulAdvertise |= ADVERTISE_10FULL;
 80070b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80070b6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80070ba:	627b      	str	r3, [r7, #36]	; 0x24
 80070bc:	e003      	b.n	80070c6 <vMACBProbePhy+0xde>
			}
			else
			{
				ulAdvertise |= ADVERTISE_10HALF;
 80070be:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80070c0:	f043 0320 	orr.w	r3, r3, #32
 80070c4:	627b      	str	r3, [r7, #36]	; 0x24
			}
		}
	}

	/* Read Control register. */
	HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_00_BMCR, &ulConfig );
 80070c6:	f107 031c 	add.w	r3, r7, #28
 80070ca:	4840      	ldr	r0, [pc, #256]	; (80071cc <vMACBProbePhy+0x1e4>)
 80070cc:	2100      	movs	r1, #0
 80070ce:	461a      	mov	r2, r3
 80070d0:	f7fc f82a 	bl	8003128 <HAL_ETH_ReadPHYRegister>

	HAL_ETH_WritePHYRegister( &xETH, PHY_REG_00_BMCR, ulConfig | BMCR_RESET );
 80070d4:	69fb      	ldr	r3, [r7, #28]
 80070d6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80070da:	483c      	ldr	r0, [pc, #240]	; (80071cc <vMACBProbePhy+0x1e4>)
 80070dc:	2100      	movs	r1, #0
 80070de:	461a      	mov	r2, r3
 80070e0:	f7fc f89e 	bl	8003220 <HAL_ETH_WritePHYRegister>
	xRemTime = ( TickType_t ) pdMS_TO_TICKS( 1000UL );
 80070e4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80070e8:	607b      	str	r3, [r7, #4]
	vTaskSetTimeOutState( &xPhyTime );
 80070ea:	f107 0308 	add.w	r3, r7, #8
 80070ee:	4618      	mov	r0, r3
 80070f0:	f7fe fd38 	bl	8005b64 <vTaskSetTimeOutState>

	for( ; ; )
	{
		HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_00_BMCR, &ulValue );
 80070f4:	f107 0310 	add.w	r3, r7, #16
 80070f8:	4834      	ldr	r0, [pc, #208]	; (80071cc <vMACBProbePhy+0x1e4>)
 80070fa:	2100      	movs	r1, #0
 80070fc:	461a      	mov	r2, r3
 80070fe:	f7fc f813 	bl	8003128 <HAL_ETH_ReadPHYRegister>
		if( ( ulValue & BMCR_RESET ) == 0 )
 8007102:	693b      	ldr	r3, [r7, #16]
 8007104:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8007108:	2b00      	cmp	r3, #0
 800710a:	d103      	bne.n	8007114 <vMACBProbePhy+0x12c>
		{
			FreeRTOS_printf( ( "BMCR_RESET ready\n" ) );
 800710c:	4834      	ldr	r0, [pc, #208]	; (80071e0 <vMACBProbePhy+0x1f8>)
 800710e:	f007 feeb 	bl	800eee8 <lUDPLoggingPrintf>
			break;
 8007112:	e00e      	b.n	8007132 <vMACBProbePhy+0x14a>
		}
		if( xTaskCheckForTimeOut( &xPhyTime, &xRemTime ) != pdFALSE )
 8007114:	f107 0208 	add.w	r2, r7, #8
 8007118:	1d3b      	adds	r3, r7, #4
 800711a:	4610      	mov	r0, r2
 800711c:	4619      	mov	r1, r3
 800711e:	f7fe fd43 	bl	8005ba8 <xTaskCheckForTimeOut>
 8007122:	4603      	mov	r3, r0
 8007124:	2b00      	cmp	r3, #0
 8007126:	d003      	beq.n	8007130 <vMACBProbePhy+0x148>
		{
			FreeRTOS_printf( ( "BMCR_RESET timed out\n" ) );
 8007128:	482e      	ldr	r0, [pc, #184]	; (80071e4 <vMACBProbePhy+0x1fc>)
 800712a:	f007 fedd 	bl	800eee8 <lUDPLoggingPrintf>
			break;
 800712e:	e000      	b.n	8007132 <vMACBProbePhy+0x14a>
		}
	}
 8007130:	e7e0      	b.n	80070f4 <vMACBProbePhy+0x10c>
	HAL_ETH_WritePHYRegister( &xETH, PHY_REG_00_BMCR, ulConfig & ~BMCR_RESET );
 8007132:	69fb      	ldr	r3, [r7, #28]
 8007134:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8007138:	4824      	ldr	r0, [pc, #144]	; (80071cc <vMACBProbePhy+0x1e4>)
 800713a:	2100      	movs	r1, #0
 800713c:	461a      	mov	r2, r3
 800713e:	f7fc f86f 	bl	8003220 <HAL_ETH_WritePHYRegister>

	vTaskDelay( pdMS_TO_TICKS( 50ul ) );
 8007142:	2032      	movs	r0, #50	; 0x32
 8007144:	f7fe f860 	bl	8005208 <vTaskDelay>

    /* Write advertise register. */
	HAL_ETH_WritePHYRegister( &xETH, PHY_REG_04_ADVERTISE, ulAdvertise );
 8007148:	4820      	ldr	r0, [pc, #128]	; (80071cc <vMACBProbePhy+0x1e4>)
 800714a:	2104      	movs	r1, #4
 800714c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800714e:	f7fc f867 	bl	8003220 <HAL_ETH_WritePHYRegister>
			  1           1           1        10BASE-T, Half/Full-Duplex
											   100BASE-TX, Half/Full-Duplex
	*/

    /* Read Control register. */
	HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_00_BMCR, &ulConfig );
 8007152:	f107 031c 	add.w	r3, r7, #28
 8007156:	481d      	ldr	r0, [pc, #116]	; (80071cc <vMACBProbePhy+0x1e4>)
 8007158:	2100      	movs	r1, #0
 800715a:	461a      	mov	r2, r3
 800715c:	f7fb ffe4 	bl	8003128 <HAL_ETH_ReadPHYRegister>

	ulConfig &= ~( BMCR_ANRESTART | BMCR_ANENABLE | BMCR_SPEED100 | BMCR_FULLDPLX );
 8007160:	69fb      	ldr	r3, [r7, #28]
 8007162:	f423 534c 	bic.w	r3, r3, #13056	; 0x3300
 8007166:	61fb      	str	r3, [r7, #28]

	/* HT 12/9/14: always set AN-restart and AN-enable, even though the choices
	are limited. */
	ulConfig |= (BMCR_ANRESTART | BMCR_ANENABLE);
 8007168:	69fb      	ldr	r3, [r7, #28]
 800716a:	f443 5390 	orr.w	r3, r3, #4608	; 0x1200
 800716e:	61fb      	str	r3, [r7, #28]

	if( xPHYProperties.speed == PHY_SPEED_100 )
 8007170:	2303      	movs	r3, #3
 8007172:	2b02      	cmp	r3, #2
 8007174:	d104      	bne.n	8007180 <vMACBProbePhy+0x198>
	{
		ulConfig |= BMCR_SPEED100;
 8007176:	69fb      	ldr	r3, [r7, #28]
 8007178:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 800717c:	61fb      	str	r3, [r7, #28]
 800717e:	e006      	b.n	800718e <vMACBProbePhy+0x1a6>
	}
	else if( xPHYProperties.speed == PHY_SPEED_10 )
 8007180:	2303      	movs	r3, #3
 8007182:	2b01      	cmp	r3, #1
 8007184:	d103      	bne.n	800718e <vMACBProbePhy+0x1a6>
	{
		ulConfig &= ~BMCR_SPEED100;
 8007186:	69fb      	ldr	r3, [r7, #28]
 8007188:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 800718c:	61fb      	str	r3, [r7, #28]
	}

	if( xPHYProperties.duplex == PHY_DUPLEX_FULL )
 800718e:	2303      	movs	r3, #3
 8007190:	2b02      	cmp	r3, #2
 8007192:	d104      	bne.n	800719e <vMACBProbePhy+0x1b6>
	{
		ulConfig |= BMCR_FULLDPLX;
 8007194:	69fb      	ldr	r3, [r7, #28]
 8007196:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800719a:	61fb      	str	r3, [r7, #28]
 800719c:	e006      	b.n	80071ac <vMACBProbePhy+0x1c4>
	}
	else if( xPHYProperties.duplex == PHY_DUPLEX_HALF )
 800719e:	2303      	movs	r3, #3
 80071a0:	2b01      	cmp	r3, #1
 80071a2:	d103      	bne.n	80071ac <vMACBProbePhy+0x1c4>
	{
		ulConfig &= ~BMCR_FULLDPLX;
 80071a4:	69fb      	ldr	r3, [r7, #28]
 80071a6:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 80071aa:	61fb      	str	r3, [r7, #28]
		}
		/* update PHY Control Register. */
		HAL_ETH_WritePHYRegister( &xETH, PHY_REG_19_PHYCR, ulPhyControl );
	}
	#endif
	FreeRTOS_printf( ( "+TCP: advertise: %lX config %lX\n", ulAdvertise, ulConfig ) );
 80071ac:	69fb      	ldr	r3, [r7, #28]
 80071ae:	480e      	ldr	r0, [pc, #56]	; (80071e8 <vMACBProbePhy+0x200>)
 80071b0:	6a79      	ldr	r1, [r7, #36]	; 0x24
 80071b2:	461a      	mov	r2, r3
 80071b4:	f007 fe98 	bl	800eee8 <lUDPLoggingPrintf>

	/* Now the two values to global values for later use. */
	ulBCRvalue = ulConfig;
 80071b8:	69fb      	ldr	r3, [r7, #28]
 80071ba:	4a0c      	ldr	r2, [pc, #48]	; (80071ec <vMACBProbePhy+0x204>)
 80071bc:	6013      	str	r3, [r2, #0]
	ulACRValue = ulAdvertise;
 80071be:	4a0c      	ldr	r2, [pc, #48]	; (80071f0 <vMACBProbePhy+0x208>)
 80071c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80071c2:	6013      	str	r3, [r2, #0]
}
 80071c4:	3728      	adds	r7, #40	; 0x28
 80071c6:	46bd      	mov	sp, r7
 80071c8:	bd80      	pop	{r7, pc}
 80071ca:	bf00      	nop
 80071cc:	2000bce8 	.word	0x2000bce8
 80071d0:	0007c130 	.word	0x0007c130
 80071d4:	080124d0 	.word	0x080124d0
 80071d8:	080124d4 	.word	0x080124d4
 80071dc:	080124dc 	.word	0x080124dc
 80071e0:	080124f0 	.word	0x080124f0
 80071e4:	08012504 	.word	0x08012504
 80071e8:	0801251c 	.word	0x0801251c
 80071ec:	2000bd38 	.word	0x2000bd38
 80071f0:	2000bd3c 	.word	0x2000bd3c

080071f4 <prvEthernetUpdateConfig>:
/*-----------------------------------------------------------*/

static void prvEthernetUpdateConfig( BaseType_t xForce )
{
 80071f4:	b5b0      	push	{r4, r5, r7, lr}
 80071f6:	b088      	sub	sp, #32
 80071f8:	af02      	add	r7, sp, #8
 80071fa:	6078      	str	r0, [r7, #4]
__IO uint32_t ulTimeout = 0;
 80071fc:	2300      	movs	r3, #0
 80071fe:	613b      	str	r3, [r7, #16]
uint32_t ulRegValue = 0;
 8007200:	2300      	movs	r3, #0
 8007202:	60fb      	str	r3, [r7, #12]

	FreeRTOS_printf( ( "prvEthernetUpdateConfig: LS %d Force %d\n",
 8007204:	4b6d      	ldr	r3, [pc, #436]	; (80073bc <prvEthernetUpdateConfig+0x1c8>)
 8007206:	681b      	ldr	r3, [r3, #0]
 8007208:	f003 0304 	and.w	r3, r3, #4
 800720c:	2b00      	cmp	r3, #0
 800720e:	bf14      	ite	ne
 8007210:	2301      	movne	r3, #1
 8007212:	2300      	moveq	r3, #0
 8007214:	b2db      	uxtb	r3, r3
 8007216:	486a      	ldr	r0, [pc, #424]	; (80073c0 <prvEthernetUpdateConfig+0x1cc>)
 8007218:	4619      	mov	r1, r3
 800721a:	687a      	ldr	r2, [r7, #4]
 800721c:	f007 fe64 	bl	800eee8 <lUDPLoggingPrintf>
		( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 ,
		( int )xForce ) );

	if( ( xForce != pdFALSE ) || ( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 ) )
 8007220:	687b      	ldr	r3, [r7, #4]
 8007222:	2b00      	cmp	r3, #0
 8007224:	d106      	bne.n	8007234 <prvEthernetUpdateConfig+0x40>
 8007226:	4b65      	ldr	r3, [pc, #404]	; (80073bc <prvEthernetUpdateConfig+0x1c8>)
 8007228:	681b      	ldr	r3, [r3, #0]
 800722a:	f003 0304 	and.w	r3, r3, #4
 800722e:	2b00      	cmp	r3, #0
 8007230:	f000 80be 	beq.w	80073b0 <prvEthernetUpdateConfig+0x1bc>
	{
		/* Restart the auto-negotiation. */
		if( xETH.Init.AutoNegotiation != ETH_AUTONEGOTIATION_DISABLE )
 8007234:	4b63      	ldr	r3, [pc, #396]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 8007236:	685b      	ldr	r3, [r3, #4]
 8007238:	2b00      	cmp	r3, #0
 800723a:	f000 80a1 	beq.w	8007380 <prvEthernetUpdateConfig+0x18c>
		{
			/* Enable Auto-Negotiation. */
			HAL_ETH_WritePHYRegister( &xETH, PHY_REG_00_BMCR, ulBCRvalue | BMCR_ANRESTART );
 800723e:	4b62      	ldr	r3, [pc, #392]	; (80073c8 <prvEthernetUpdateConfig+0x1d4>)
 8007240:	681b      	ldr	r3, [r3, #0]
 8007242:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8007246:	485f      	ldr	r0, [pc, #380]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 8007248:	2100      	movs	r1, #0
 800724a:	461a      	mov	r2, r3
 800724c:	f7fb ffe8 	bl	8003220 <HAL_ETH_WritePHYRegister>
			HAL_ETH_WritePHYRegister( &xETH, PHY_REG_04_ADVERTISE, ulACRValue);
 8007250:	4b5e      	ldr	r3, [pc, #376]	; (80073cc <prvEthernetUpdateConfig+0x1d8>)
 8007252:	681b      	ldr	r3, [r3, #0]
 8007254:	485b      	ldr	r0, [pc, #364]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 8007256:	2104      	movs	r1, #4
 8007258:	461a      	mov	r2, r3
 800725a:	f7fb ffe1 	bl	8003220 <HAL_ETH_WritePHYRegister>

			/* Wait until the auto-negotiation will be completed */
			do
			{
				ulTimeout++;
 800725e:	693b      	ldr	r3, [r7, #16]
 8007260:	3301      	adds	r3, #1
 8007262:	613b      	str	r3, [r7, #16]
				HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_01_BMSR, &ulRegValue );
 8007264:	f107 030c 	add.w	r3, r7, #12
 8007268:	4856      	ldr	r0, [pc, #344]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 800726a:	2101      	movs	r1, #1
 800726c:	461a      	mov	r2, r3
 800726e:	f7fb ff5b 	bl	8003128 <HAL_ETH_ReadPHYRegister>
			} while( ( ( ulRegValue & PHY_AUTONEGO_COMPLETE) == 0 ) && ( ulTimeout < PHY_READ_TO ) );
 8007272:	68fb      	ldr	r3, [r7, #12]
 8007274:	f003 0320 	and.w	r3, r3, #32
 8007278:	2b00      	cmp	r3, #0
 800727a:	d104      	bne.n	8007286 <prvEthernetUpdateConfig+0x92>
 800727c:	693b      	ldr	r3, [r7, #16]
 800727e:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 8007282:	4293      	cmp	r3, r2
 8007284:	d9eb      	bls.n	800725e <prvEthernetUpdateConfig+0x6a>

			HAL_ETH_WritePHYRegister( &xETH, PHY_REG_00_BMCR, ulBCRvalue & ~BMCR_ANRESTART );
 8007286:	4b50      	ldr	r3, [pc, #320]	; (80073c8 <prvEthernetUpdateConfig+0x1d4>)
 8007288:	681b      	ldr	r3, [r3, #0]
 800728a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800728e:	484d      	ldr	r0, [pc, #308]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 8007290:	2100      	movs	r1, #0
 8007292:	461a      	mov	r2, r3
 8007294:	f7fb ffc4 	bl	8003220 <HAL_ETH_WritePHYRegister>

			if( ulTimeout < PHY_READ_TO )
 8007298:	693b      	ldr	r3, [r7, #16]
 800729a:	f64f 72fe 	movw	r2, #65534	; 0xfffe
 800729e:	4293      	cmp	r3, r2
 80072a0:	d87e      	bhi.n	80073a0 <prvEthernetUpdateConfig+0x1ac>
			{
				/* Reset Timeout counter. */
				ulTimeout = 0;
 80072a2:	2300      	movs	r3, #0
 80072a4:	613b      	str	r3, [r7, #16]

				HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_01_BMSR, &ulRegValue);
 80072a6:	f107 030c 	add.w	r3, r7, #12
 80072aa:	4846      	ldr	r0, [pc, #280]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 80072ac:	2101      	movs	r1, #1
 80072ae:	461a      	mov	r2, r3
 80072b0:	f7fb ff3a 	bl	8003128 <HAL_ETH_ReadPHYRegister>
				if( ( ulRegValue & BMSR_LINK_STATUS ) != 0 )
 80072b4:	68fb      	ldr	r3, [r7, #12]
 80072b6:	f003 0304 	and.w	r3, r3, #4
 80072ba:	2b00      	cmp	r3, #0
 80072bc:	d006      	beq.n	80072cc <prvEthernetUpdateConfig+0xd8>
				{
					ulPHYLinkStatus |= BMSR_LINK_STATUS;
 80072be:	4b3f      	ldr	r3, [pc, #252]	; (80073bc <prvEthernetUpdateConfig+0x1c8>)
 80072c0:	681b      	ldr	r3, [r3, #0]
 80072c2:	f043 0304 	orr.w	r3, r3, #4
 80072c6:	4a3d      	ldr	r2, [pc, #244]	; (80073bc <prvEthernetUpdateConfig+0x1c8>)
 80072c8:	6013      	str	r3, [r2, #0]
 80072ca:	e005      	b.n	80072d8 <prvEthernetUpdateConfig+0xe4>
				}
				else
				{
					ulPHYLinkStatus &= ~( BMSR_LINK_STATUS );
 80072cc:	4b3b      	ldr	r3, [pc, #236]	; (80073bc <prvEthernetUpdateConfig+0x1c8>)
 80072ce:	681b      	ldr	r3, [r3, #0]
 80072d0:	f023 0304 	bic.w	r3, r3, #4
 80072d4:	4a39      	ldr	r2, [pc, #228]	; (80073bc <prvEthernetUpdateConfig+0x1c8>)
 80072d6:	6013      	str	r3, [r2, #0]
				#if( EXPECTED_PHY_ID == PHY_ID_LAN8720 ) || ( EXPECTED_PHY_ID == PHY_ID_LAN8742A )
				{
				/* 31 RW PHY Special Control Status */
				uint32_t ulControlStatus;

					HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_1F_PHYSPCS, &ulControlStatus);
 80072d8:	f107 0308 	add.w	r3, r7, #8
 80072dc:	4839      	ldr	r0, [pc, #228]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 80072de:	211f      	movs	r1, #31
 80072e0:	461a      	mov	r2, r3
 80072e2:	f7fb ff21 	bl	8003128 <HAL_ETH_ReadPHYRegister>
					ulRegValue = 0;
 80072e6:	2300      	movs	r3, #0
 80072e8:	60fb      	str	r3, [r7, #12]
					if( ( ulControlStatus & PHYSPCS_FULL_DUPLEX ) != 0 )
 80072ea:	68bb      	ldr	r3, [r7, #8]
 80072ec:	f003 0310 	and.w	r3, r3, #16
 80072f0:	2b00      	cmp	r3, #0
 80072f2:	d003      	beq.n	80072fc <prvEthernetUpdateConfig+0x108>
					{
						ulRegValue |= PHY_DUPLEX_STATUS;
 80072f4:	68fb      	ldr	r3, [r7, #12]
 80072f6:	f043 0304 	orr.w	r3, r3, #4
 80072fa:	60fb      	str	r3, [r7, #12]
					}
					if( ( ulControlStatus & PHYSPCS_SPEED_MASK ) == PHYSPCS_SPEED_10 )
 80072fc:	68bb      	ldr	r3, [r7, #8]
 80072fe:	f003 030c 	and.w	r3, r3, #12
 8007302:	2b04      	cmp	r3, #4
 8007304:	d103      	bne.n	800730e <prvEthernetUpdateConfig+0x11a>
					{
						ulRegValue |= PHY_SPEED_STATUS;
 8007306:	68fb      	ldr	r3, [r7, #12]
 8007308:	f043 0302 	orr.w	r3, r3, #2
 800730c:	60fb      	str	r3, [r7, #12]
				{
					/* Read the result of the auto-negotiation. */
					HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_10_PHY_SR, &ulRegValue);
				}
				#endif
				FreeRTOS_printf( ( ">> Autonego ready: %08lx: %s duplex %u mbit %s status\n",
 800730e:	68f9      	ldr	r1, [r7, #12]
 8007310:	68fb      	ldr	r3, [r7, #12]
 8007312:	f003 0304 	and.w	r3, r3, #4
 8007316:	2b00      	cmp	r3, #0
 8007318:	d001      	beq.n	800731e <prvEthernetUpdateConfig+0x12a>
 800731a:	4d2d      	ldr	r5, [pc, #180]	; (80073d0 <prvEthernetUpdateConfig+0x1dc>)
 800731c:	e000      	b.n	8007320 <prvEthernetUpdateConfig+0x12c>
 800731e:	4d2d      	ldr	r5, [pc, #180]	; (80073d4 <prvEthernetUpdateConfig+0x1e0>)
 8007320:	68fb      	ldr	r3, [r7, #12]
 8007322:	f003 0302 	and.w	r3, r3, #2
 8007326:	2b00      	cmp	r3, #0
 8007328:	d001      	beq.n	800732e <prvEthernetUpdateConfig+0x13a>
 800732a:	240a      	movs	r4, #10
 800732c:	e000      	b.n	8007330 <prvEthernetUpdateConfig+0x13c>
 800732e:	2464      	movs	r4, #100	; 0x64
 8007330:	4b22      	ldr	r3, [pc, #136]	; (80073bc <prvEthernetUpdateConfig+0x1c8>)
 8007332:	681b      	ldr	r3, [r3, #0]
 8007334:	f043 0304 	orr.w	r3, r3, #4
 8007338:	4a20      	ldr	r2, [pc, #128]	; (80073bc <prvEthernetUpdateConfig+0x1c8>)
 800733a:	6013      	str	r3, [r2, #0]
 800733c:	4b26      	ldr	r3, [pc, #152]	; (80073d8 <prvEthernetUpdateConfig+0x1e4>)
 800733e:	9300      	str	r3, [sp, #0]
 8007340:	4826      	ldr	r0, [pc, #152]	; (80073dc <prvEthernetUpdateConfig+0x1e8>)
 8007342:	462a      	mov	r2, r5
 8007344:	4623      	mov	r3, r4
 8007346:	f007 fdcf 	bl	800eee8 <lUDPLoggingPrintf>
					(ulRegValue & PHY_SPEED_STATUS) ? 10 : 100,
					((ulPHYLinkStatus |= BMSR_LINK_STATUS) != 0) ? "high" : "low" ) );

				/* Configure the MAC with the Duplex Mode fixed by the
				auto-negotiation process. */
				if( ( ulRegValue & PHY_DUPLEX_STATUS ) != ( uint32_t ) RESET )
 800734a:	68fb      	ldr	r3, [r7, #12]
 800734c:	f003 0304 	and.w	r3, r3, #4
 8007350:	2b00      	cmp	r3, #0
 8007352:	d004      	beq.n	800735e <prvEthernetUpdateConfig+0x16a>
				{
					/* Set Ethernet duplex mode to Full-duplex following the
					auto-negotiation. */
					xETH.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
 8007354:	4b1b      	ldr	r3, [pc, #108]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 8007356:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800735a:	60da      	str	r2, [r3, #12]
 800735c:	e002      	b.n	8007364 <prvEthernetUpdateConfig+0x170>
				}
				else
				{
					/* Set Ethernet duplex mode to Half-duplex following the
					auto-negotiation. */
					xETH.Init.DuplexMode = ETH_MODE_HALFDUPLEX;
 800735e:	4b19      	ldr	r3, [pc, #100]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 8007360:	2200      	movs	r2, #0
 8007362:	60da      	str	r2, [r3, #12]
				}

				/* Configure the MAC with the speed fixed by the
				auto-negotiation process. */
				if( ( ulRegValue & PHY_SPEED_STATUS) != 0 )
 8007364:	68fb      	ldr	r3, [r7, #12]
 8007366:	f003 0302 	and.w	r3, r3, #2
 800736a:	2b00      	cmp	r3, #0
 800736c:	d003      	beq.n	8007376 <prvEthernetUpdateConfig+0x182>
				{
					/* Set Ethernet speed to 10M following the
					auto-negotiation. */
					xETH.Init.Speed = ETH_SPEED_10M;
 800736e:	4b15      	ldr	r3, [pc, #84]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 8007370:	2200      	movs	r2, #0
 8007372:	609a      	str	r2, [r3, #8]
 8007374:	e014      	b.n	80073a0 <prvEthernetUpdateConfig+0x1ac>
				}
				else
				{
					/* Set Ethernet speed to 100M following the
					auto-negotiation. */
					xETH.Init.Speed = ETH_SPEED_100M;
 8007376:	4b13      	ldr	r3, [pc, #76]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 8007378:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800737c:	609a      	str	r2, [r3, #8]
 800737e:	e00f      	b.n	80073a0 <prvEthernetUpdateConfig+0x1ac>
			/* Check parameters */
			assert_param( IS_ETH_SPEED( xETH.Init.Speed ) );
			assert_param( IS_ETH_DUPLEX_MODE( xETH.Init.DuplexMode ) );

			/* Set MAC Speed and Duplex Mode to PHY */
			usValue = ( uint16_t ) ( xETH.Init.DuplexMode >> 3 ) | ( uint16_t ) ( xETH.Init.Speed >> 1 );
 8007380:	4b10      	ldr	r3, [pc, #64]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 8007382:	68db      	ldr	r3, [r3, #12]
 8007384:	08db      	lsrs	r3, r3, #3
 8007386:	b29a      	uxth	r2, r3
 8007388:	4b0e      	ldr	r3, [pc, #56]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 800738a:	689b      	ldr	r3, [r3, #8]
 800738c:	085b      	lsrs	r3, r3, #1
 800738e:	b29b      	uxth	r3, r3
 8007390:	4313      	orrs	r3, r2
 8007392:	82fb      	strh	r3, [r7, #22]
			HAL_ETH_WritePHYRegister( &xETH, PHY_REG_00_BMCR, usValue );
 8007394:	8afb      	ldrh	r3, [r7, #22]
 8007396:	480b      	ldr	r0, [pc, #44]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 8007398:	2100      	movs	r1, #0
 800739a:	461a      	mov	r2, r3
 800739c:	f7fb ff40 	bl	8003220 <HAL_ETH_WritePHYRegister>
		}

		/* ETHERNET MAC Re-Configuration */
		HAL_ETH_ConfigMAC( &xETH, (ETH_MACInitTypeDef *) NULL);
 80073a0:	4808      	ldr	r0, [pc, #32]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 80073a2:	2100      	movs	r1, #0
 80073a4:	f7fc f864 	bl	8003470 <HAL_ETH_ConfigMAC>

		/* Restart MAC interface */
		HAL_ETH_Start( &xETH);
 80073a8:	4806      	ldr	r0, [pc, #24]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 80073aa:	f7fb ffb5 	bl	8003318 <HAL_ETH_Start>
 80073ae:	e002      	b.n	80073b6 <prvEthernetUpdateConfig+0x1c2>
	}
	else
	{
		/* Stop MAC interface */
		HAL_ETH_Stop( &xETH );
 80073b0:	4804      	ldr	r0, [pc, #16]	; (80073c4 <prvEthernetUpdateConfig+0x1d0>)
 80073b2:	f7fb ffe1 	bl	8003378 <HAL_ETH_Stop>
	}
}
 80073b6:	3718      	adds	r7, #24
 80073b8:	46bd      	mov	sp, r7
 80073ba:	bdb0      	pop	{r4, r5, r7, pc}
 80073bc:	2000bce4 	.word	0x2000bce4
 80073c0:	08012540 	.word	0x08012540
 80073c4:	2000bce8 	.word	0x2000bce8
 80073c8:	2000bd38 	.word	0x2000bd38
 80073cc:	2000bd3c 	.word	0x2000bd3c
 80073d0:	0801256c 	.word	0x0801256c
 80073d4:	08012574 	.word	0x08012574
 80073d8:	0801257c 	.word	0x0801257c
 80073dc:	08012584 	.word	0x08012584

080073e0 <xGetPhyLinkStatus>:
/*-----------------------------------------------------------*/

BaseType_t xGetPhyLinkStatus( void )
{
 80073e0:	b480      	push	{r7}
 80073e2:	b083      	sub	sp, #12
 80073e4:	af00      	add	r7, sp, #0
BaseType_t xReturn;

	if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 )
 80073e6:	4b09      	ldr	r3, [pc, #36]	; (800740c <xGetPhyLinkStatus+0x2c>)
 80073e8:	681b      	ldr	r3, [r3, #0]
 80073ea:	f003 0304 	and.w	r3, r3, #4
 80073ee:	2b00      	cmp	r3, #0
 80073f0:	d002      	beq.n	80073f8 <xGetPhyLinkStatus+0x18>
	{
		xReturn = pdPASS;
 80073f2:	2301      	movs	r3, #1
 80073f4:	607b      	str	r3, [r7, #4]
 80073f6:	e001      	b.n	80073fc <xGetPhyLinkStatus+0x1c>
	}
	else
	{
		xReturn = pdFAIL;
 80073f8:	2300      	movs	r3, #0
 80073fa:	607b      	str	r3, [r7, #4]
	}

	return xReturn;
 80073fc:	687b      	ldr	r3, [r7, #4]
}
 80073fe:	4618      	mov	r0, r3
 8007400:	370c      	adds	r7, #12
 8007402:	46bd      	mov	sp, r7
 8007404:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007408:	4770      	bx	lr
 800740a:	bf00      	nop
 800740c:	2000bce4 	.word	0x2000bce4

08007410 <prvEMACHandlerTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvEMACHandlerTask( void *pvParameters )
{
 8007410:	b580      	push	{r7, lr}
 8007412:	b08a      	sub	sp, #40	; 0x28
 8007414:	af00      	add	r7, sp, #0
 8007416:	6078      	str	r0, [r7, #4]
TimeOut_t xPhyTime;
TickType_t xPhyRemTime;
UBaseType_t uxLastMinBufferCount = 0;
 8007418:	2300      	movs	r3, #0
 800741a:	627b      	str	r3, [r7, #36]	; 0x24
#if( ipconfigCHECK_IP_QUEUE_SPACE != 0 )
UBaseType_t uxLastMinQueueSpace = 0;
#endif
UBaseType_t uxCurrentCount;
BaseType_t xResult = 0;
 800741c:	2300      	movs	r3, #0
 800741e:	623b      	str	r3, [r7, #32]
uint32_t xStatus;
const TickType_t ulMaxBlockTime = pdMS_TO_TICKS( 100UL );
 8007420:	2364      	movs	r3, #100	; 0x64
 8007422:	61fb      	str	r3, [r7, #28]

	/* Remove compiler warnings about unused parameters. */
	( void ) pvParameters;

	vTaskSetTimeOutState( &xPhyTime );
 8007424:	f107 0310 	add.w	r3, r7, #16
 8007428:	4618      	mov	r0, r3
 800742a:	f7fe fb9b 	bl	8005b64 <vTaskSetTimeOutState>
	xPhyRemTime = pdMS_TO_TICKS( PHY_LS_LOW_CHECK_TIME_MS );
 800742e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8007432:	60fb      	str	r3, [r7, #12]

	for( ;; )
	{
		uxCurrentCount = uxGetMinimumFreeNetworkBuffers();
 8007434:	f000 fa12 	bl	800785c <uxGetMinimumFreeNetworkBuffers>
 8007438:	61b8      	str	r0, [r7, #24]
		if( uxLastMinBufferCount != uxCurrentCount )
 800743a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800743c:	69bb      	ldr	r3, [r7, #24]
 800743e:	429a      	cmp	r2, r3
 8007440:	d009      	beq.n	8007456 <prvEMACHandlerTask+0x46>
		{
			/* The logging produced below may be helpful
			while tuning +TCP: see how many buffers are in use. */
			uxLastMinBufferCount = uxCurrentCount;
 8007442:	69bb      	ldr	r3, [r7, #24]
 8007444:	627b      	str	r3, [r7, #36]	; 0x24
			FreeRTOS_printf( ( "Network buffers: %lu lowest %lu\n",
 8007446:	f000 f9fd 	bl	8007844 <uxGetNumberOfFreeNetworkBuffers>
 800744a:	4603      	mov	r3, r0
 800744c:	4854      	ldr	r0, [pc, #336]	; (80075a0 <prvEMACHandlerTask+0x190>)
 800744e:	4619      	mov	r1, r3
 8007450:	69ba      	ldr	r2, [r7, #24]
 8007452:	f007 fd49 	bl	800eee8 <lUDPLoggingPrintf>
				uxGetNumberOfFreeNetworkBuffers(), uxCurrentCount ) );
		}

		if( xTXDescriptorSemaphore != NULL )
 8007456:	4b53      	ldr	r3, [pc, #332]	; (80075a4 <prvEMACHandlerTask+0x194>)
 8007458:	681b      	ldr	r3, [r3, #0]
 800745a:	2b00      	cmp	r3, #0
 800745c:	d013      	beq.n	8007486 <prvEMACHandlerTask+0x76>
		{
		static UBaseType_t uxLowestSemCount = ( UBaseType_t ) ETH_TXBUFNB - 1;

			uxCurrentCount = uxSemaphoreGetCount( xTXDescriptorSemaphore );
 800745e:	4b51      	ldr	r3, [pc, #324]	; (80075a4 <prvEMACHandlerTask+0x194>)
 8007460:	681b      	ldr	r3, [r3, #0]
 8007462:	4618      	mov	r0, r3
 8007464:	f7fd fbba 	bl	8004bdc <uxQueueMessagesWaiting>
 8007468:	61b8      	str	r0, [r7, #24]
			if( uxLowestSemCount > uxCurrentCount )
 800746a:	4b4f      	ldr	r3, [pc, #316]	; (80075a8 <prvEMACHandlerTask+0x198>)
 800746c:	681a      	ldr	r2, [r3, #0]
 800746e:	69bb      	ldr	r3, [r7, #24]
 8007470:	429a      	cmp	r2, r3
 8007472:	d908      	bls.n	8007486 <prvEMACHandlerTask+0x76>
			{
				uxLowestSemCount = uxCurrentCount;
 8007474:	4a4c      	ldr	r2, [pc, #304]	; (80075a8 <prvEMACHandlerTask+0x198>)
 8007476:	69bb      	ldr	r3, [r7, #24]
 8007478:	6013      	str	r3, [r2, #0]
				FreeRTOS_printf( ( "TX DMA buffers: lowest %lu\n", uxLowestSemCount ) );
 800747a:	4b4b      	ldr	r3, [pc, #300]	; (80075a8 <prvEMACHandlerTask+0x198>)
 800747c:	681b      	ldr	r3, [r3, #0]
 800747e:	484b      	ldr	r0, [pc, #300]	; (80075ac <prvEMACHandlerTask+0x19c>)
 8007480:	4619      	mov	r1, r3
 8007482:	f007 fd31 	bl	800eee8 <lUDPLoggingPrintf>
				FreeRTOS_printf( ( "Queue space: lowest %lu\n", uxCurrentCount ) );
			}
		}
		#endif /* ipconfigCHECK_IP_QUEUE_SPACE */

		if( ( ulISREvents & EMAC_IF_ALL_EVENT ) == 0 )
 8007486:	4b4a      	ldr	r3, [pc, #296]	; (80075b0 <prvEMACHandlerTask+0x1a0>)
 8007488:	681b      	ldr	r3, [r3, #0]
 800748a:	f003 0307 	and.w	r3, r3, #7
 800748e:	2b00      	cmp	r3, #0
 8007490:	d103      	bne.n	800749a <prvEMACHandlerTask+0x8a>
		{
			/* No events to process now, wait for the next. */
			ulTaskNotifyTake( pdFALSE, ulMaxBlockTime );
 8007492:	2000      	movs	r0, #0
 8007494:	69f9      	ldr	r1, [r7, #28]
 8007496:	f7fe fe17 	bl	80060c8 <ulTaskNotifyTake>
		}

		if( ( ulISREvents & EMAC_IF_RX_EVENT ) != 0 )
 800749a:	4b45      	ldr	r3, [pc, #276]	; (80075b0 <prvEMACHandlerTask+0x1a0>)
 800749c:	681b      	ldr	r3, [r3, #0]
 800749e:	f003 0301 	and.w	r3, r3, #1
 80074a2:	2b00      	cmp	r3, #0
 80074a4:	d011      	beq.n	80074ca <prvEMACHandlerTask+0xba>
		{
			ulISREvents &= ~EMAC_IF_RX_EVENT;
 80074a6:	4b42      	ldr	r3, [pc, #264]	; (80075b0 <prvEMACHandlerTask+0x1a0>)
 80074a8:	681b      	ldr	r3, [r3, #0]
 80074aa:	f023 0301 	bic.w	r3, r3, #1
 80074ae:	4a40      	ldr	r2, [pc, #256]	; (80075b0 <prvEMACHandlerTask+0x1a0>)
 80074b0:	6013      	str	r3, [r2, #0]

			xResult = prvNetworkInterfaceInput();
 80074b2:	f7ff fceb 	bl	8006e8c <prvNetworkInterfaceInput>
 80074b6:	6238      	str	r0, [r7, #32]
			if( xResult > 0 )
 80074b8:	6a3b      	ldr	r3, [r7, #32]
 80074ba:	2b00      	cmp	r3, #0
 80074bc:	dd05      	ble.n	80074ca <prvEMACHandlerTask+0xba>
			{
			  	while( prvNetworkInterfaceInput() > 0 )
 80074be:	bf00      	nop
 80074c0:	f7ff fce4 	bl	8006e8c <prvNetworkInterfaceInput>
 80074c4:	4603      	mov	r3, r0
 80074c6:	2b00      	cmp	r3, #0
 80074c8:	dcfa      	bgt.n	80074c0 <prvEMACHandlerTask+0xb0>
				{
				}
			}
		}

		if( ( ulISREvents & EMAC_IF_TX_EVENT ) != 0 )
 80074ca:	4b39      	ldr	r3, [pc, #228]	; (80075b0 <prvEMACHandlerTask+0x1a0>)
 80074cc:	681b      	ldr	r3, [r3, #0]
 80074ce:	f003 0302 	and.w	r3, r3, #2
 80074d2:	2b00      	cmp	r3, #0
 80074d4:	d007      	beq.n	80074e6 <prvEMACHandlerTask+0xd6>
		{
			/* Code to release TX buffers if zero-copy is used. */
			ulISREvents &= ~EMAC_IF_TX_EVENT;
 80074d6:	4b36      	ldr	r3, [pc, #216]	; (80075b0 <prvEMACHandlerTask+0x1a0>)
 80074d8:	681b      	ldr	r3, [r3, #0]
 80074da:	f023 0302 	bic.w	r3, r3, #2
 80074de:	4a34      	ldr	r2, [pc, #208]	; (80075b0 <prvEMACHandlerTask+0x1a0>)
 80074e0:	6013      	str	r3, [r2, #0]
			/* Check if DMA packets have been delivered. */
			vClearTXBuffers();
 80074e2:	f7ff fa61 	bl	80069a8 <vClearTXBuffers>
		}

		if( ( ulISREvents & EMAC_IF_ERR_EVENT ) != 0 )
 80074e6:	4b32      	ldr	r3, [pc, #200]	; (80075b0 <prvEMACHandlerTask+0x1a0>)
 80074e8:	681b      	ldr	r3, [r3, #0]
 80074ea:	f003 0304 	and.w	r3, r3, #4
 80074ee:	2b00      	cmp	r3, #0
 80074f0:	d005      	beq.n	80074fe <prvEMACHandlerTask+0xee>
		{
			/* Future extension: logging about errors that occurred. */
			ulISREvents &= ~EMAC_IF_ERR_EVENT;
 80074f2:	4b2f      	ldr	r3, [pc, #188]	; (80075b0 <prvEMACHandlerTask+0x1a0>)
 80074f4:	681b      	ldr	r3, [r3, #0]
 80074f6:	f023 0304 	bic.w	r3, r3, #4
 80074fa:	4a2d      	ldr	r2, [pc, #180]	; (80075b0 <prvEMACHandlerTask+0x1a0>)
 80074fc:	6013      	str	r3, [r2, #0]
		}

		if( xResult > 0 )
 80074fe:	6a3b      	ldr	r3, [r7, #32]
 8007500:	2b00      	cmp	r3, #0
 8007502:	dd0a      	ble.n	800751a <prvEMACHandlerTask+0x10a>
		{
			/* A packet was received. No need to check for the PHY status now,
			but set a timer to check it later on. */
			vTaskSetTimeOutState( &xPhyTime );
 8007504:	f107 0310 	add.w	r3, r7, #16
 8007508:	4618      	mov	r0, r3
 800750a:	f7fe fb2b 	bl	8005b64 <vTaskSetTimeOutState>
			xPhyRemTime = pdMS_TO_TICKS( PHY_LS_HIGH_CHECK_TIME_MS );
 800750e:	f643 2398 	movw	r3, #15000	; 0x3a98
 8007512:	60fb      	str	r3, [r7, #12]
			xResult = 0;
 8007514:	2300      	movs	r3, #0
 8007516:	623b      	str	r3, [r7, #32]
 8007518:	e041      	b.n	800759e <prvEMACHandlerTask+0x18e>
		}
		else if( xTaskCheckForTimeOut( &xPhyTime, &xPhyRemTime ) != pdFALSE )
 800751a:	f107 0210 	add.w	r2, r7, #16
 800751e:	f107 030c 	add.w	r3, r7, #12
 8007522:	4610      	mov	r0, r2
 8007524:	4619      	mov	r1, r3
 8007526:	f7fe fb3f 	bl	8005ba8 <xTaskCheckForTimeOut>
 800752a:	4603      	mov	r3, r0
 800752c:	2b00      	cmp	r3, #0
 800752e:	d036      	beq.n	800759e <prvEMACHandlerTask+0x18e>
		{
			if( HAL_ETH_ReadPHYRegister( &xETH, PHY_REG_01_BMSR, &xStatus ) == HAL_OK )
 8007530:	f107 0308 	add.w	r3, r7, #8
 8007534:	481f      	ldr	r0, [pc, #124]	; (80075b4 <prvEMACHandlerTask+0x1a4>)
 8007536:	2101      	movs	r1, #1
 8007538:	461a      	mov	r2, r3
 800753a:	f7fb fdf5 	bl	8003128 <HAL_ETH_ReadPHYRegister>
 800753e:	4603      	mov	r3, r0
 8007540:	2b00      	cmp	r3, #0
 8007542:	d11a      	bne.n	800757a <prvEMACHandlerTask+0x16a>
			{
				if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != ( xStatus & BMSR_LINK_STATUS ) )
 8007544:	4b1c      	ldr	r3, [pc, #112]	; (80075b8 <prvEMACHandlerTask+0x1a8>)
 8007546:	681a      	ldr	r2, [r3, #0]
 8007548:	68bb      	ldr	r3, [r7, #8]
 800754a:	4053      	eors	r3, r2
 800754c:	f003 0304 	and.w	r3, r3, #4
 8007550:	2b00      	cmp	r3, #0
 8007552:	d012      	beq.n	800757a <prvEMACHandlerTask+0x16a>
				{
					ulPHYLinkStatus = xStatus;
 8007554:	68bb      	ldr	r3, [r7, #8]
 8007556:	4a18      	ldr	r2, [pc, #96]	; (80075b8 <prvEMACHandlerTask+0x1a8>)
 8007558:	6013      	str	r3, [r2, #0]
					FreeRTOS_printf( ( "prvEMACHandlerTask: PHY LS now %d\n", ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 ) );
 800755a:	4b17      	ldr	r3, [pc, #92]	; (80075b8 <prvEMACHandlerTask+0x1a8>)
 800755c:	681b      	ldr	r3, [r3, #0]
 800755e:	f003 0304 	and.w	r3, r3, #4
 8007562:	2b00      	cmp	r3, #0
 8007564:	bf14      	ite	ne
 8007566:	2301      	movne	r3, #1
 8007568:	2300      	moveq	r3, #0
 800756a:	b2db      	uxtb	r3, r3
 800756c:	4813      	ldr	r0, [pc, #76]	; (80075bc <prvEMACHandlerTask+0x1ac>)
 800756e:	4619      	mov	r1, r3
 8007570:	f007 fcba 	bl	800eee8 <lUDPLoggingPrintf>
					prvEthernetUpdateConfig( pdFALSE );
 8007574:	2000      	movs	r0, #0
 8007576:	f7ff fe3d 	bl	80071f4 <prvEthernetUpdateConfig>
				}
			}
			vTaskSetTimeOutState( &xPhyTime );
 800757a:	f107 0310 	add.w	r3, r7, #16
 800757e:	4618      	mov	r0, r3
 8007580:	f7fe faf0 	bl	8005b64 <vTaskSetTimeOutState>
			if( ( ulPHYLinkStatus & BMSR_LINK_STATUS ) != 0 )
 8007584:	4b0c      	ldr	r3, [pc, #48]	; (80075b8 <prvEMACHandlerTask+0x1a8>)
 8007586:	681b      	ldr	r3, [r3, #0]
 8007588:	f003 0304 	and.w	r3, r3, #4
 800758c:	2b00      	cmp	r3, #0
 800758e:	d003      	beq.n	8007598 <prvEMACHandlerTask+0x188>
			{
				xPhyRemTime = pdMS_TO_TICKS( PHY_LS_HIGH_CHECK_TIME_MS );
 8007590:	f643 2398 	movw	r3, #15000	; 0x3a98
 8007594:	60fb      	str	r3, [r7, #12]
 8007596:	e002      	b.n	800759e <prvEMACHandlerTask+0x18e>
			}
			else
			{
				xPhyRemTime = pdMS_TO_TICKS( PHY_LS_LOW_CHECK_TIME_MS );
 8007598:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800759c:	60fb      	str	r3, [r7, #12]
			}
		}
	}
 800759e:	e749      	b.n	8007434 <prvEMACHandlerTask+0x24>
 80075a0:	080125bc 	.word	0x080125bc
 80075a4:	2000bd30 	.word	0x2000bd30
 80075a8:	2000bb04 	.word	0x2000bb04
 80075ac:	080125e0 	.word	0x080125e0
 80075b0:	2000bce0 	.word	0x2000bce0
 80075b4:	2000bce8 	.word	0x2000bce8
 80075b8:	2000bce4 	.word	0x2000bce4
 80075bc:	080125fc 	.word	0x080125fc

080075c0 <ETH_IRQHandler>:
}
/*-----------------------------------------------------------*/

void ETH_IRQHandler( void )
{
 80075c0:	b580      	push	{r7, lr}
 80075c2:	af00      	add	r7, sp, #0
	HAL_ETH_IRQHandler( &xETH );
 80075c4:	4801      	ldr	r0, [pc, #4]	; (80075cc <ETH_IRQHandler+0xc>)
 80075c6:	f7fb fd73 	bl	80030b0 <HAL_ETH_IRQHandler>
}
 80075ca:	bd80      	pop	{r7, pc}
 80075cc:	2000bce8 	.word	0x2000bce8

080075d0 <xNetworkBuffersInitialise>:
static SemaphoreHandle_t xNetworkBufferSemaphore = NULL;

/*-----------------------------------------------------------*/

BaseType_t xNetworkBuffersInitialise( void )
{
 80075d0:	b580      	push	{r7, lr}
 80075d2:	b084      	sub	sp, #16
 80075d4:	af00      	add	r7, sp, #0
BaseType_t xReturn, x;

	/* Only initialise the buffers and their associated kernel objects if they
	have not been initialised before. */
	if( xNetworkBufferSemaphore == NULL )
 80075d6:	4b37      	ldr	r3, [pc, #220]	; (80076b4 <xNetworkBuffersInitialise+0xe4>)
 80075d8:	681b      	ldr	r3, [r3, #0]
 80075da:	2b00      	cmp	r3, #0
 80075dc:	d15c      	bne.n	8007698 <xNetworkBuffersInitialise+0xc8>
	{
		xNetworkBufferSemaphore = xSemaphoreCreateCounting( ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS, ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS );
 80075de:	201f      	movs	r0, #31
 80075e0:	211f      	movs	r1, #31
 80075e2:	f7fd f845 	bl	8004670 <xQueueCreateCountingSemaphore>
 80075e6:	4602      	mov	r2, r0
 80075e8:	4b32      	ldr	r3, [pc, #200]	; (80076b4 <xNetworkBuffersInitialise+0xe4>)
 80075ea:	601a      	str	r2, [r3, #0]
		configASSERT( xNetworkBufferSemaphore );
 80075ec:	4b31      	ldr	r3, [pc, #196]	; (80076b4 <xNetworkBuffersInitialise+0xe4>)
 80075ee:	681b      	ldr	r3, [r3, #0]
 80075f0:	2b00      	cmp	r3, #0
 80075f2:	d109      	bne.n	8007608 <xNetworkBuffersInitialise+0x38>
 80075f4:	f04f 0350 	mov.w	r3, #80	; 0x50
 80075f8:	f383 8811 	msr	BASEPRI, r3
 80075fc:	f3bf 8f6f 	isb	sy
 8007600:	f3bf 8f4f 	dsb	sy
 8007604:	607b      	str	r3, [r7, #4]
 8007606:	e7fe      	b.n	8007606 <xNetworkBuffersInitialise+0x36>
		#if ( configQUEUE_REGISTRY_SIZE > 0 )
		{
			vQueueAddToRegistry( xNetworkBufferSemaphore, "NetBufSem" );
 8007608:	4b2a      	ldr	r3, [pc, #168]	; (80076b4 <xNetworkBuffersInitialise+0xe4>)
 800760a:	681b      	ldr	r3, [r3, #0]
 800760c:	4618      	mov	r0, r3
 800760e:	492a      	ldr	r1, [pc, #168]	; (80076b8 <xNetworkBuffersInitialise+0xe8>)
 8007610:	f7fd fc3a 	bl	8004e88 <vQueueAddToRegistry>
			vTraceSetQueueName( xNetworkEventQueue, "IPStackEvent" );
			vTraceSetQueueName( xNetworkBufferSemaphore, "NetworkBufferCount" );
		}
		#endif /*  ipconfigINCLUDE_EXAMPLE_FREERTOS_PLUS_TRACE_CALLS == 1 */

		if( xNetworkBufferSemaphore != NULL )
 8007614:	4b27      	ldr	r3, [pc, #156]	; (80076b4 <xNetworkBuffersInitialise+0xe4>)
 8007616:	681b      	ldr	r3, [r3, #0]
 8007618:	2b00      	cmp	r3, #0
 800761a:	d03d      	beq.n	8007698 <xNetworkBuffersInitialise+0xc8>
		{
			vListInitialise( &xFreeBuffersList );
 800761c:	4827      	ldr	r0, [pc, #156]	; (80076bc <xNetworkBuffersInitialise+0xec>)
 800761e:	f7fc fa85 	bl	8003b2c <vListInitialise>

			/* Initialise all the network buffers.  No storage is allocated to
			the buffers yet. */
			for( x = 0; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; x++ )
 8007622:	2300      	movs	r3, #0
 8007624:	60bb      	str	r3, [r7, #8]
 8007626:	e031      	b.n	800768c <xNetworkBuffersInitialise+0xbc>
			{
				/* Initialise and set the owner of the buffer list items. */
				xNetworkBufferDescriptors[ x ].pucEthernetBuffer = NULL;
 8007628:	4925      	ldr	r1, [pc, #148]	; (80076c0 <xNetworkBuffersInitialise+0xf0>)
 800762a:	68ba      	ldr	r2, [r7, #8]
 800762c:	4613      	mov	r3, r2
 800762e:	00db      	lsls	r3, r3, #3
 8007630:	4413      	add	r3, r2
 8007632:	009b      	lsls	r3, r3, #2
 8007634:	440b      	add	r3, r1
 8007636:	3318      	adds	r3, #24
 8007638:	2200      	movs	r2, #0
 800763a:	601a      	str	r2, [r3, #0]
				vListInitialiseItem( &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 800763c:	68ba      	ldr	r2, [r7, #8]
 800763e:	4613      	mov	r3, r2
 8007640:	00db      	lsls	r3, r3, #3
 8007642:	4413      	add	r3, r2
 8007644:	009b      	lsls	r3, r3, #2
 8007646:	4a1e      	ldr	r2, [pc, #120]	; (80076c0 <xNetworkBuffersInitialise+0xf0>)
 8007648:	4413      	add	r3, r2
 800764a:	4618      	mov	r0, r3
 800764c:	f7fc fa8e 	bl	8003b6c <vListInitialiseItem>
				listSET_LIST_ITEM_OWNER( &( xNetworkBufferDescriptors[ x ].xBufferListItem ), &xNetworkBufferDescriptors[ x ] );
 8007650:	68ba      	ldr	r2, [r7, #8]
 8007652:	4613      	mov	r3, r2
 8007654:	00db      	lsls	r3, r3, #3
 8007656:	4413      	add	r3, r2
 8007658:	009b      	lsls	r3, r3, #2
 800765a:	4a19      	ldr	r2, [pc, #100]	; (80076c0 <xNetworkBuffersInitialise+0xf0>)
 800765c:	1899      	adds	r1, r3, r2
 800765e:	4818      	ldr	r0, [pc, #96]	; (80076c0 <xNetworkBuffersInitialise+0xf0>)
 8007660:	68ba      	ldr	r2, [r7, #8]
 8007662:	4613      	mov	r3, r2
 8007664:	00db      	lsls	r3, r3, #3
 8007666:	4413      	add	r3, r2
 8007668:	009b      	lsls	r3, r3, #2
 800766a:	4403      	add	r3, r0
 800766c:	3308      	adds	r3, #8
 800766e:	6059      	str	r1, [r3, #4]

				/* Currently, all buffers are available for use. */
				vListInsert( &xFreeBuffersList, &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
 8007670:	68ba      	ldr	r2, [r7, #8]
 8007672:	4613      	mov	r3, r2
 8007674:	00db      	lsls	r3, r3, #3
 8007676:	4413      	add	r3, r2
 8007678:	009b      	lsls	r3, r3, #2
 800767a:	4a11      	ldr	r2, [pc, #68]	; (80076c0 <xNetworkBuffersInitialise+0xf0>)
 800767c:	4413      	add	r3, r2
 800767e:	480f      	ldr	r0, [pc, #60]	; (80076bc <xNetworkBuffersInitialise+0xec>)
 8007680:	4619      	mov	r1, r3
 8007682:	f7fc faa3 	bl	8003bcc <vListInsert>
		{
			vListInitialise( &xFreeBuffersList );

			/* Initialise all the network buffers.  No storage is allocated to
			the buffers yet. */
			for( x = 0; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; x++ )
 8007686:	68bb      	ldr	r3, [r7, #8]
 8007688:	3301      	adds	r3, #1
 800768a:	60bb      	str	r3, [r7, #8]
 800768c:	68bb      	ldr	r3, [r7, #8]
 800768e:	2b1e      	cmp	r3, #30
 8007690:	ddca      	ble.n	8007628 <xNetworkBuffersInitialise+0x58>

				/* Currently, all buffers are available for use. */
				vListInsert( &xFreeBuffersList, &( xNetworkBufferDescriptors[ x ].xBufferListItem ) );
			}

			uxMinimumFreeNetworkBuffers = ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS;
 8007692:	4b0c      	ldr	r3, [pc, #48]	; (80076c4 <xNetworkBuffersInitialise+0xf4>)
 8007694:	221f      	movs	r2, #31
 8007696:	601a      	str	r2, [r3, #0]
		}
	}

	if( xNetworkBufferSemaphore == NULL )
 8007698:	4b06      	ldr	r3, [pc, #24]	; (80076b4 <xNetworkBuffersInitialise+0xe4>)
 800769a:	681b      	ldr	r3, [r3, #0]
 800769c:	2b00      	cmp	r3, #0
 800769e:	d102      	bne.n	80076a6 <xNetworkBuffersInitialise+0xd6>
	{
		xReturn = pdFAIL;
 80076a0:	2300      	movs	r3, #0
 80076a2:	60fb      	str	r3, [r7, #12]
 80076a4:	e001      	b.n	80076aa <xNetworkBuffersInitialise+0xda>
	}
	else
	{
		xReturn = pdPASS;
 80076a6:	2301      	movs	r3, #1
 80076a8:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
 80076aa:	68fb      	ldr	r3, [r7, #12]
}
 80076ac:	4618      	mov	r0, r3
 80076ae:	3710      	adds	r7, #16
 80076b0:	46bd      	mov	sp, r7
 80076b2:	bd80      	pop	{r7, pc}
 80076b4:	2000c1b8 	.word	0x2000c1b8
 80076b8:	08012620 	.word	0x08012620
 80076bc:	2000bd44 	.word	0x2000bd44
 80076c0:	2000bd5c 	.word	0x2000bd5c
 80076c4:	2000bd58 	.word	0x2000bd58

080076c8 <vReleaseNetworkBuffer>:
	return pucEthernetBuffer;
}
/*-----------------------------------------------------------*/

void vReleaseNetworkBuffer( uint8_t *pucEthernetBuffer )
{
 80076c8:	b580      	push	{r7, lr}
 80076ca:	b082      	sub	sp, #8
 80076cc:	af00      	add	r7, sp, #0
 80076ce:	6078      	str	r0, [r7, #4]
	/* There is space before the Ethernet buffer in which a pointer to the
	network buffer that references this Ethernet buffer is stored.  Remove the
	space before freeing the buffer. */
	if( pucEthernetBuffer != NULL )
 80076d0:	687b      	ldr	r3, [r7, #4]
 80076d2:	2b00      	cmp	r3, #0
 80076d4:	d005      	beq.n	80076e2 <vReleaseNetworkBuffer+0x1a>
	{
		pucEthernetBuffer -= ipBUFFER_PADDING;
 80076d6:	687b      	ldr	r3, [r7, #4]
 80076d8:	3b0a      	subs	r3, #10
 80076da:	607b      	str	r3, [r7, #4]
		vPortFree( ( void * ) pucEthernetBuffer );
 80076dc:	6878      	ldr	r0, [r7, #4]
 80076de:	f7fc fd87 	bl	80041f0 <vPortFree>
	}
}
 80076e2:	3708      	adds	r7, #8
 80076e4:	46bd      	mov	sp, r7
 80076e6:	bd80      	pop	{r7, pc}

080076e8 <pxGetNetworkBufferWithDescriptor>:
/*-----------------------------------------------------------*/

NetworkBufferDescriptor_t *pxGetNetworkBufferWithDescriptor( size_t xRequestedSizeBytes, TickType_t xBlockTimeTicks )
{
 80076e8:	b580      	push	{r7, lr}
 80076ea:	b086      	sub	sp, #24
 80076ec:	af00      	add	r7, sp, #0
 80076ee:	6078      	str	r0, [r7, #4]
 80076f0:	6039      	str	r1, [r7, #0]
NetworkBufferDescriptor_t *pxReturn = NULL;
 80076f2:	2300      	movs	r3, #0
 80076f4:	617b      	str	r3, [r7, #20]
size_t uxCount;

	if( ( xRequestedSizeBytes != 0u ) && ( xRequestedSizeBytes < ( size_t ) baMINIMAL_BUFFER_SIZE ) )
 80076f6:	687b      	ldr	r3, [r7, #4]
 80076f8:	2b00      	cmp	r3, #0
 80076fa:	d004      	beq.n	8007706 <pxGetNetworkBufferWithDescriptor+0x1e>
 80076fc:	687b      	ldr	r3, [r7, #4]
 80076fe:	2b45      	cmp	r3, #69	; 0x45
 8007700:	d801      	bhi.n	8007706 <pxGetNetworkBufferWithDescriptor+0x1e>
	{
		/* ARP packets can replace application packets, so the storage must be
		at least large enough to hold an ARP. */
		xRequestedSizeBytes = baMINIMAL_BUFFER_SIZE;
 8007702:	2346      	movs	r3, #70	; 0x46
 8007704:	607b      	str	r3, [r7, #4]
	}
	xRequestedSizeBytes += 2u;
 8007706:	687b      	ldr	r3, [r7, #4]
 8007708:	3302      	adds	r3, #2
 800770a:	607b      	str	r3, [r7, #4]
	if( ( xRequestedSizeBytes & ( sizeof( size_t ) - 1u ) ) != 0u )
 800770c:	687b      	ldr	r3, [r7, #4]
 800770e:	f003 0303 	and.w	r3, r3, #3
 8007712:	2b00      	cmp	r3, #0
 8007714:	d004      	beq.n	8007720 <pxGetNetworkBufferWithDescriptor+0x38>
	{
		xRequestedSizeBytes = ( xRequestedSizeBytes | ( sizeof( size_t ) - 1u ) ) + 1u;
 8007716:	687b      	ldr	r3, [r7, #4]
 8007718:	f043 0303 	orr.w	r3, r3, #3
 800771c:	3301      	adds	r3, #1
 800771e:	607b      	str	r3, [r7, #4]
	}

	/* If there is a semaphore available, there is a network buffer available. */
	if( xSemaphoreTake( xNetworkBufferSemaphore, xBlockTimeTicks ) == pdPASS )
 8007720:	4b2b      	ldr	r3, [pc, #172]	; (80077d0 <pxGetNetworkBufferWithDescriptor+0xe8>)
 8007722:	681b      	ldr	r3, [r3, #0]
 8007724:	4618      	mov	r0, r3
 8007726:	2100      	movs	r1, #0
 8007728:	683a      	ldr	r2, [r7, #0]
 800772a:	2300      	movs	r3, #0
 800772c:	f7fd f8f8 	bl	8004920 <xQueueGenericReceive>
 8007730:	4603      	mov	r3, r0
 8007732:	2b01      	cmp	r3, #1
 8007734:	d146      	bne.n	80077c4 <pxGetNetworkBufferWithDescriptor+0xdc>
	{
		/* Protect the structure as it is accessed from tasks and interrupts. */
		taskENTER_CRITICAL();
 8007736:	f7fc fba9 	bl	8003e8c <vPortEnterCritical>
		{
			pxReturn = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &xFreeBuffersList );
 800773a:	4b26      	ldr	r3, [pc, #152]	; (80077d4 <pxGetNetworkBufferWithDescriptor+0xec>)
 800773c:	68db      	ldr	r3, [r3, #12]
 800773e:	68db      	ldr	r3, [r3, #12]
 8007740:	617b      	str	r3, [r7, #20]
			uxListRemove( &( pxReturn->xBufferListItem ) );
 8007742:	697b      	ldr	r3, [r7, #20]
 8007744:	4618      	mov	r0, r3
 8007746:	f7fc fa79 	bl	8003c3c <uxListRemove>
		}
		taskEXIT_CRITICAL();
 800774a:	f7fc fbcd 	bl	8003ee8 <vPortExitCritical>

		/* Reading UBaseType_t, no critical section needed. */
		uxCount = listCURRENT_LIST_LENGTH( &xFreeBuffersList );
 800774e:	4b21      	ldr	r3, [pc, #132]	; (80077d4 <pxGetNetworkBufferWithDescriptor+0xec>)
 8007750:	681b      	ldr	r3, [r3, #0]
 8007752:	613b      	str	r3, [r7, #16]

		if( uxMinimumFreeNetworkBuffers > uxCount )
 8007754:	4b20      	ldr	r3, [pc, #128]	; (80077d8 <pxGetNetworkBufferWithDescriptor+0xf0>)
 8007756:	681a      	ldr	r2, [r3, #0]
 8007758:	693b      	ldr	r3, [r7, #16]
 800775a:	429a      	cmp	r2, r3
 800775c:	d902      	bls.n	8007764 <pxGetNetworkBufferWithDescriptor+0x7c>
		{
			uxMinimumFreeNetworkBuffers = uxCount;
 800775e:	4a1e      	ldr	r2, [pc, #120]	; (80077d8 <pxGetNetworkBufferWithDescriptor+0xf0>)
 8007760:	693b      	ldr	r3, [r7, #16]
 8007762:	6013      	str	r3, [r2, #0]
		}

		/* Allocate storage of exactly the requested size to the buffer. */
		configASSERT( pxReturn->pucEthernetBuffer == NULL );
 8007764:	697b      	ldr	r3, [r7, #20]
 8007766:	699b      	ldr	r3, [r3, #24]
 8007768:	2b00      	cmp	r3, #0
 800776a:	d009      	beq.n	8007780 <pxGetNetworkBufferWithDescriptor+0x98>
 800776c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007770:	f383 8811 	msr	BASEPRI, r3
 8007774:	f3bf 8f6f 	isb	sy
 8007778:	f3bf 8f4f 	dsb	sy
 800777c:	60fb      	str	r3, [r7, #12]
 800777e:	e7fe      	b.n	800777e <pxGetNetworkBufferWithDescriptor+0x96>
		if( xRequestedSizeBytes > 0 )
 8007780:	687b      	ldr	r3, [r7, #4]
 8007782:	2b00      	cmp	r3, #0
 8007784:	d01e      	beq.n	80077c4 <pxGetNetworkBufferWithDescriptor+0xdc>
		{
			/* Extra space is obtained so a pointer to the network buffer can
			be stored at the beginning of the buffer. */
			pxReturn->pucEthernetBuffer = ( uint8_t * ) pvPortMalloc( xRequestedSizeBytes + ipBUFFER_PADDING );
 8007786:	687b      	ldr	r3, [r7, #4]
 8007788:	330a      	adds	r3, #10
 800778a:	4618      	mov	r0, r3
 800778c:	f7fc fc90 	bl	80040b0 <pvPortMalloc>
 8007790:	4602      	mov	r2, r0
 8007792:	697b      	ldr	r3, [r7, #20]
 8007794:	619a      	str	r2, [r3, #24]

			if( pxReturn->pucEthernetBuffer == NULL )
 8007796:	697b      	ldr	r3, [r7, #20]
 8007798:	699b      	ldr	r3, [r3, #24]
 800779a:	2b00      	cmp	r3, #0
 800779c:	d105      	bne.n	80077aa <pxGetNetworkBufferWithDescriptor+0xc2>
			{
				/* The attempt to allocate storage for the buffer payload failed,
				so the network buffer structure cannot be used and must be
				released. */
				vReleaseNetworkBufferAndDescriptor( pxReturn );
 800779e:	6978      	ldr	r0, [r7, #20]
 80077a0:	f000 f81c 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
				pxReturn = NULL;
 80077a4:	2300      	movs	r3, #0
 80077a6:	617b      	str	r3, [r7, #20]
 80077a8:	e00c      	b.n	80077c4 <pxGetNetworkBufferWithDescriptor+0xdc>
			{
				/* Store a pointer to the network buffer structure in the
				buffer storage area, then move the buffer pointer on past the
				stored pointer so the pointer value is not overwritten by the
				application when the buffer is used. */
				*( ( NetworkBufferDescriptor_t ** ) ( pxReturn->pucEthernetBuffer ) ) = pxReturn;
 80077aa:	697b      	ldr	r3, [r7, #20]
 80077ac:	699b      	ldr	r3, [r3, #24]
 80077ae:	697a      	ldr	r2, [r7, #20]
 80077b0:	601a      	str	r2, [r3, #0]
				pxReturn->pucEthernetBuffer += ipBUFFER_PADDING;
 80077b2:	697b      	ldr	r3, [r7, #20]
 80077b4:	699b      	ldr	r3, [r3, #24]
 80077b6:	f103 020a 	add.w	r2, r3, #10
 80077ba:	697b      	ldr	r3, [r7, #20]
 80077bc:	619a      	str	r2, [r3, #24]

				/* Store the actual size of the allocated buffer, which may be
				greater than the original requested size. */
				pxReturn->xDataLength = xRequestedSizeBytes;
 80077be:	697b      	ldr	r3, [r7, #20]
 80077c0:	687a      	ldr	r2, [r7, #4]
 80077c2:	61da      	str	r2, [r3, #28]
	else
	{
		iptraceNETWORK_BUFFER_OBTAINED( pxReturn );
	}

	return pxReturn;
 80077c4:	697b      	ldr	r3, [r7, #20]
}
 80077c6:	4618      	mov	r0, r3
 80077c8:	3718      	adds	r7, #24
 80077ca:	46bd      	mov	sp, r7
 80077cc:	bd80      	pop	{r7, pc}
 80077ce:	bf00      	nop
 80077d0:	2000c1b8 	.word	0x2000c1b8
 80077d4:	2000bd44 	.word	0x2000bd44
 80077d8:	2000bd58 	.word	0x2000bd58

080077dc <vReleaseNetworkBufferAndDescriptor>:
/*-----------------------------------------------------------*/

void vReleaseNetworkBufferAndDescriptor( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 80077dc:	b580      	push	{r7, lr}
 80077de:	b084      	sub	sp, #16
 80077e0:	af00      	add	r7, sp, #0
 80077e2:	6078      	str	r0, [r7, #4]
	/* Ensure the buffer is returned to the list of free buffers before the
	counting semaphore is 'given' to say a buffer is available.  Release the
	storage allocated to the buffer payload.  THIS FILE SHOULD NOT BE USED
	IF THE PROJECT INCLUDES A MEMORY ALLOCATOR THAT WILL FRAGMENT THE HEAP
	MEMORY.  For example, heap_2 must not be used, heap_4 can be used. */
	vReleaseNetworkBuffer( pxNetworkBuffer->pucEthernetBuffer );
 80077e4:	687b      	ldr	r3, [r7, #4]
 80077e6:	699b      	ldr	r3, [r3, #24]
 80077e8:	4618      	mov	r0, r3
 80077ea:	f7ff ff6d 	bl	80076c8 <vReleaseNetworkBuffer>
	pxNetworkBuffer->pucEthernetBuffer = NULL;
 80077ee:	687b      	ldr	r3, [r7, #4]
 80077f0:	2200      	movs	r2, #0
 80077f2:	619a      	str	r2, [r3, #24]

	taskENTER_CRITICAL();
 80077f4:	f7fc fb4a 	bl	8003e8c <vPortEnterCritical>
	{
		xListItemAlreadyInFreeList = listIS_CONTAINED_WITHIN( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );
 80077f8:	687b      	ldr	r3, [r7, #4]
 80077fa:	691b      	ldr	r3, [r3, #16]
 80077fc:	4a0f      	ldr	r2, [pc, #60]	; (800783c <vReleaseNetworkBufferAndDescriptor+0x60>)
 80077fe:	4293      	cmp	r3, r2
 8007800:	bf0c      	ite	eq
 8007802:	2301      	moveq	r3, #1
 8007804:	2300      	movne	r3, #0
 8007806:	b2db      	uxtb	r3, r3
 8007808:	60fb      	str	r3, [r7, #12]

		if( xListItemAlreadyInFreeList == pdFALSE )
 800780a:	68fb      	ldr	r3, [r7, #12]
 800780c:	2b00      	cmp	r3, #0
 800780e:	d104      	bne.n	800781a <vReleaseNetworkBufferAndDescriptor+0x3e>
		{
			vListInsertEnd( &xFreeBuffersList, &( pxNetworkBuffer->xBufferListItem ) );
 8007810:	687b      	ldr	r3, [r7, #4]
 8007812:	480a      	ldr	r0, [pc, #40]	; (800783c <vReleaseNetworkBufferAndDescriptor+0x60>)
 8007814:	4619      	mov	r1, r3
 8007816:	f7fc f9b5 	bl	8003b84 <vListInsertEnd>
		}
	}
	taskEXIT_CRITICAL();
 800781a:	f7fc fb65 	bl	8003ee8 <vPortExitCritical>

	if( xListItemAlreadyInFreeList == pdFALSE )
 800781e:	68fb      	ldr	r3, [r7, #12]
 8007820:	2b00      	cmp	r3, #0
 8007822:	d107      	bne.n	8007834 <vReleaseNetworkBufferAndDescriptor+0x58>
	{
		xSemaphoreGive( xNetworkBufferSemaphore );
 8007824:	4b06      	ldr	r3, [pc, #24]	; (8007840 <vReleaseNetworkBufferAndDescriptor+0x64>)
 8007826:	681b      	ldr	r3, [r3, #0]
 8007828:	4618      	mov	r0, r3
 800782a:	2100      	movs	r1, #0
 800782c:	2200      	movs	r2, #0
 800782e:	2300      	movs	r3, #0
 8007830:	f7fc ff50 	bl	80046d4 <xQueueGenericSend>
	}

	iptraceNETWORK_BUFFER_RELEASED( pxNetworkBuffer );
}
 8007834:	3710      	adds	r7, #16
 8007836:	46bd      	mov	sp, r7
 8007838:	bd80      	pop	{r7, pc}
 800783a:	bf00      	nop
 800783c:	2000bd44 	.word	0x2000bd44
 8007840:	2000c1b8 	.word	0x2000c1b8

08007844 <uxGetNumberOfFreeNetworkBuffers>:

/*
 * Returns the number of free network buffers
 */
UBaseType_t uxGetNumberOfFreeNetworkBuffers( void )
{
 8007844:	b480      	push	{r7}
 8007846:	af00      	add	r7, sp, #0
	return listCURRENT_LIST_LENGTH( &xFreeBuffersList );
 8007848:	4b03      	ldr	r3, [pc, #12]	; (8007858 <uxGetNumberOfFreeNetworkBuffers+0x14>)
 800784a:	681b      	ldr	r3, [r3, #0]
}
 800784c:	4618      	mov	r0, r3
 800784e:	46bd      	mov	sp, r7
 8007850:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007854:	4770      	bx	lr
 8007856:	bf00      	nop
 8007858:	2000bd44 	.word	0x2000bd44

0800785c <uxGetMinimumFreeNetworkBuffers>:
/*-----------------------------------------------------------*/

UBaseType_t uxGetMinimumFreeNetworkBuffers( void )
{
 800785c:	b480      	push	{r7}
 800785e:	af00      	add	r7, sp, #0
	return uxMinimumFreeNetworkBuffers;
 8007860:	4b03      	ldr	r3, [pc, #12]	; (8007870 <uxGetMinimumFreeNetworkBuffers+0x14>)
 8007862:	681b      	ldr	r3, [r3, #0]
}
 8007864:	4618      	mov	r0, r3
 8007866:	46bd      	mov	sp, r7
 8007868:	f85d 7b04 	ldr.w	r7, [sp], #4
 800786c:	4770      	bx	lr
 800786e:	bf00      	nop
 8007870:	2000bd58 	.word	0x2000bd58

08007874 <prvIPTask>:
#endif

/*-----------------------------------------------------------*/

static void prvIPTask( void *pvParameters )
{
 8007874:	b580      	push	{r7, lr}
 8007876:	b088      	sub	sp, #32
 8007878:	af00      	add	r7, sp, #0
 800787a:	6078      	str	r0, [r7, #4]

	/* Generate a dummy message to say that the network connection has gone
	down.  This will cause this task to initialise the network interface.  After
	this it is the responsibility of the network interface hardware driver to
	send this message if a previously connected network is disconnected. */
	FreeRTOS_NetworkDown();
 800787c:	f000 f9ce 	bl	8007c1c <FreeRTOS_NetworkDown>

	#if( ipconfigUSE_TCP == 1 )
	{
		/* Initialise the TCP timer. */
		prvIPTimerReload( &xTCPTimer, pdMS_TO_TICKS( ipTCP_TIMER_PERIOD_MS ) );
 8007880:	4851      	ldr	r0, [pc, #324]	; (80079c8 <prvIPTask+0x154>)
 8007882:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8007886:	f000 f989 	bl	8007b9c <prvIPTimerReload>
	}
	#endif

	/* Initialisation is complete and events can now be processed. */
	xIPTaskInitialised = pdTRUE;
 800788a:	4b50      	ldr	r3, [pc, #320]	; (80079cc <prvIPTask+0x158>)
 800788c:	2201      	movs	r2, #1
 800788e:	601a      	str	r2, [r3, #0]
	{
		ipconfigWATCHDOG_TIMER();

		/* Check the ARP, DHCP and TCP timers to see if there is any periodic
		or timeout processing to perform. */
		prvCheckNetworkTimers();
 8007890:	f000 f8fe 	bl	8007a90 <prvCheckNetworkTimers>

		/* Calculate the acceptable maximum sleep time. */
		xNextIPSleep = prvCalculateSleepTime();
 8007894:	f000 f8c2 	bl	8007a1c <prvCalculateSleepTime>
 8007898:	61f8      	str	r0, [r7, #28]

		/* Wait until there is something to do.  The event is initialised to "no
		event" in case the following call exits due to a time out rather than a
		message being received. */
		xReceivedEvent.eEventType = eNoEvent;
 800789a:	23ff      	movs	r3, #255	; 0xff
 800789c:	743b      	strb	r3, [r7, #16]
		xQueueReceive( xNetworkEventQueue, ( void * ) &xReceivedEvent, xNextIPSleep );
 800789e:	4b4c      	ldr	r3, [pc, #304]	; (80079d0 <prvIPTask+0x15c>)
 80078a0:	681a      	ldr	r2, [r3, #0]
 80078a2:	f107 0310 	add.w	r3, r7, #16
 80078a6:	4610      	mov	r0, r2
 80078a8:	4619      	mov	r1, r3
 80078aa:	69fa      	ldr	r2, [r7, #28]
 80078ac:	2300      	movs	r3, #0
 80078ae:	f7fd f837 	bl	8004920 <xQueueGenericReceive>
		}
		#endif /* ipconfigCHECK_IP_QUEUE_SPACE */

		iptraceNETWORK_EVENT_RECEIVED( xReceivedEvent.eEventType );

		switch( xReceivedEvent.eEventType )
 80078b2:	7c3b      	ldrb	r3, [r7, #16]
 80078b4:	b25b      	sxtb	r3, r3
 80078b6:	2b0b      	cmp	r3, #11
 80078b8:	d87e      	bhi.n	80079b8 <prvIPTask+0x144>
 80078ba:	a201      	add	r2, pc, #4	; (adr r2, 80078c0 <prvIPTask+0x4c>)
 80078bc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80078c0:	080078f1 	.word	0x080078f1
 80078c4:	080078fd 	.word	0x080078fd
 80078c8:	08007907 	.word	0x08007907
 80078cc:	08007963 	.word	0x08007963
 80078d0:	080079b9 	.word	0x080079b9
 80078d4:	08007981 	.word	0x08007981
 80078d8:	0800798d 	.word	0x0800798d
 80078dc:	080079b3 	.word	0x080079b3
 80078e0:	0800790d 	.word	0x0800790d
 80078e4:	08007959 	.word	0x08007959
 80078e8:	0800796d 	.word	0x0800796d
 80078ec:	08007977 	.word	0x08007977
		{
			case eNetworkDownEvent :
				/* Attempt to establish a connection. */
				xNetworkUp = pdFALSE;
 80078f0:	4b38      	ldr	r3, [pc, #224]	; (80079d4 <prvIPTask+0x160>)
 80078f2:	2200      	movs	r2, #0
 80078f4:	601a      	str	r2, [r3, #0]
				prvProcessNetworkDownEvent();
 80078f6:	f000 fba5 	bl	8008044 <prvProcessNetworkDownEvent>
				break;
 80078fa:	e05e      	b.n	80079ba <prvIPTask+0x146>

			case eNetworkRxEvent:
				/* The network hardware driver has received a new packet.  A
				pointer to the received buffer is located in the pvData member
				of the received event structure. */
				prvHandleEthernetPacket( ( NetworkBufferDescriptor_t * ) ( xReceivedEvent.pvData ) );
 80078fc:	697b      	ldr	r3, [r7, #20]
 80078fe:	4618      	mov	r0, r3
 8007900:	f000 f882 	bl	8007a08 <prvHandleEthernetPacket>
				break;
 8007904:	e059      	b.n	80079ba <prvIPTask+0x146>

			case eARPTimerEvent :
				/* The ARP timer has expired, process the ARP cache. */
				vARPAgeCache();
 8007906:	f001 f853 	bl	80089b0 <vARPAgeCache>
				break;
 800790a:	e056      	b.n	80079ba <prvIPTask+0x146>
				/* FreeRTOS_bind (a user API) wants the IP-task to bind a socket
				to a port. The port number is communicated in the socket field
				usLocalPort. vSocketBind() will actually bind the socket and the
				API will unblock as soon as the eSOCKET_BOUND event is
				triggered. */
				pxSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );
 800790c:	697b      	ldr	r3, [r7, #20]
 800790e:	61bb      	str	r3, [r7, #24]
				xAddress.sin_addr = 0u;	/* For the moment. */
 8007910:	2300      	movs	r3, #0
 8007912:	60fb      	str	r3, [r7, #12]
				xAddress.sin_port = FreeRTOS_ntohs( pxSocket->usLocalPort );
 8007914:	69bb      	ldr	r3, [r7, #24]
 8007916:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8007918:	021b      	lsls	r3, r3, #8
 800791a:	b29a      	uxth	r2, r3
 800791c:	69bb      	ldr	r3, [r7, #24]
 800791e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8007920:	0a1b      	lsrs	r3, r3, #8
 8007922:	b29b      	uxth	r3, r3
 8007924:	b29b      	uxth	r3, r3
 8007926:	4313      	orrs	r3, r2
 8007928:	b29b      	uxth	r3, r3
 800792a:	b29b      	uxth	r3, r3
 800792c:	817b      	strh	r3, [r7, #10]
				pxSocket->usLocalPort = 0u;
 800792e:	69bb      	ldr	r3, [r7, #24]
 8007930:	2200      	movs	r2, #0
 8007932:	849a      	strh	r2, [r3, #36]	; 0x24
				vSocketBind( pxSocket, &xAddress, sizeof( xAddress ), pdFALSE );
 8007934:	f107 0308 	add.w	r3, r7, #8
 8007938:	69b8      	ldr	r0, [r7, #24]
 800793a:	4619      	mov	r1, r3
 800793c:	2208      	movs	r2, #8
 800793e:	2300      	movs	r3, #0
 8007940:	f001 fbe8 	bl	8009114 <vSocketBind>

				/* Before 'eSocketBindEvent' was sent it was tested that
				( xEventGroup != NULL ) so it can be used now to wake up the
				user. */
				pxSocket->xEventBits |= eSOCKET_BOUND;
 8007944:	69bb      	ldr	r3, [r7, #24]
 8007946:	681b      	ldr	r3, [r3, #0]
 8007948:	f043 0210 	orr.w	r2, r3, #16
 800794c:	69bb      	ldr	r3, [r7, #24]
 800794e:	601a      	str	r2, [r3, #0]
				vSocketWakeUpUser( pxSocket );
 8007950:	69b8      	ldr	r0, [r7, #24]
 8007952:	f001 ff63 	bl	800981c <vSocketWakeUpUser>
				break;
 8007956:	e030      	b.n	80079ba <prvIPTask+0x146>
			case eSocketCloseEvent :
				/* The user API FreeRTOS_closesocket() has sent a message to the
				IP-task to actually close a socket. This is handled in
				vSocketClose().  As the socket gets closed, there is no way to
				report back to the API, so the API won't wait for the result */
				vSocketClose( ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData ) );
 8007958:	697b      	ldr	r3, [r7, #20]
 800795a:	4618      	mov	r0, r3
 800795c:	f001 fc90 	bl	8009280 <vSocketClose>
				break;
 8007960:	e02b      	b.n	80079ba <prvIPTask+0x146>

			case eStackTxEvent :
				/* The network stack has generated a packet to send.  A
				pointer to the generated buffer is located in the pvData
				member of the received event structure. */
				vProcessGeneratedUDPPacket( ( NetworkBufferDescriptor_t * ) ( xReceivedEvent.pvData ) );
 8007962:	697b      	ldr	r3, [r7, #20]
 8007964:	4618      	mov	r0, r3
 8007966:	f002 fb7d 	bl	800a064 <vProcessGeneratedUDPPacket>
				break;
 800796a:	e026      	b.n	80079ba <prvIPTask+0x146>
				/* FreeRTOS_select() has got unblocked by a socket event,
				vSocketSelect() will check which sockets actually have an event
				and update the socket field xSocketBits. */
				#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
				{
					vSocketSelect( ( SocketSelect_t * ) ( xReceivedEvent.pvData ) );
 800796c:	697b      	ldr	r3, [r7, #20]
 800796e:	4618      	mov	r0, r3
 8007970:	f002 fa38 	bl	8009de4 <vSocketSelect>
				}
				#endif /* ipconfigSUPPORT_SELECT_FUNCTION == 1 */
				break;
 8007974:	e021      	b.n	80079ba <prvIPTask+0x146>
			case eSocketSignalEvent :
				#if( ipconfigSUPPORT_SIGNALS != 0 )
				{
					/* Some task wants to signal the user of this socket in
					order to interrupt a call to recv() or a call to select(). */
					FreeRTOS_SignalSocket( ( Socket_t ) xReceivedEvent.pvData );
 8007976:	697b      	ldr	r3, [r7, #20]
 8007978:	4618      	mov	r0, r3
 800797a:	f002 fb3d 	bl	8009ff8 <FreeRTOS_SignalSocket>
				}
				#endif /* ipconfigSUPPORT_SIGNALS */
				break;
 800797e:	e01c      	b.n	80079ba <prvIPTask+0x146>
			case eTCPTimerEvent :
				#if( ipconfigUSE_TCP == 1 )
				{
					/* Simply mark the TCP timer as expired so it gets processed
					the next time prvCheckNetworkTimers() is called. */
					xTCPTimer.bExpired = pdTRUE_UNSIGNED;
 8007980:	4a11      	ldr	r2, [pc, #68]	; (80079c8 <prvIPTask+0x154>)
 8007982:	7813      	ldrb	r3, [r2, #0]
 8007984:	f043 0302 	orr.w	r3, r3, #2
 8007988:	7013      	strb	r3, [r2, #0]
				}
				#endif /* ipconfigUSE_TCP */
				break;
 800798a:	e016      	b.n	80079ba <prvIPTask+0x146>
				/* The API FreeRTOS_accept() was called, the IP-task will now
				check if the listening socket (communicated in pvData) actually
				received a new connection. */
				#if( ipconfigUSE_TCP == 1 )
				{
					pxSocket = ( FreeRTOS_Socket_t * ) ( xReceivedEvent.pvData );
 800798c:	697b      	ldr	r3, [r7, #20]
 800798e:	61bb      	str	r3, [r7, #24]

					if( xTCPCheckNewClient( pxSocket ) != pdFALSE )
 8007990:	69b8      	ldr	r0, [r7, #24]
 8007992:	f004 ff1b 	bl	800c7cc <xTCPCheckNewClient>
 8007996:	4603      	mov	r3, r0
 8007998:	2b00      	cmp	r3, #0
 800799a:	d009      	beq.n	80079b0 <prvIPTask+0x13c>
					{
						pxSocket->xEventBits |= eSOCKET_ACCEPT;
 800799c:	69bb      	ldr	r3, [r7, #24]
 800799e:	681b      	ldr	r3, [r3, #0]
 80079a0:	f043 0204 	orr.w	r2, r3, #4
 80079a4:	69bb      	ldr	r3, [r7, #24]
 80079a6:	601a      	str	r2, [r3, #0]
						vSocketWakeUpUser( pxSocket );
 80079a8:	69b8      	ldr	r0, [r7, #24]
 80079aa:	f001 ff37 	bl	800981c <vSocketWakeUpUser>
					}
				}
				#endif /* ipconfigUSE_TCP */
				break;
 80079ae:	e004      	b.n	80079ba <prvIPTask+0x146>
 80079b0:	e003      	b.n	80079ba <prvIPTask+0x146>
			case eTCPNetStat:
				/* FreeRTOS_netstat() was called to have the IP-task print an
				overview of all sockets and their connections */
				#if( ( ipconfigUSE_TCP == 1 ) && ( ipconfigHAS_PRINTF == 1 ) )
				{
					vTCPNetStat();
 80079b2:	f002 f94d 	bl	8009c50 <vTCPNetStat>
				}
				#endif /* ipconfigUSE_TCP */
				break;
 80079b6:	e000      	b.n	80079ba <prvIPTask+0x146>

			default :
				/* Should not get here. */
				break;
 80079b8:	bf00      	nop
		}

		if( xNetworkDownEventPending != pdFALSE )
 80079ba:	4b07      	ldr	r3, [pc, #28]	; (80079d8 <prvIPTask+0x164>)
 80079bc:	681b      	ldr	r3, [r3, #0]
 80079be:	2b00      	cmp	r3, #0
 80079c0:	d001      	beq.n	80079c6 <prvIPTask+0x152>
		{
			/* A network down event could not be posted to the network event
			queue because the queue was full.  Try posting again. */
			FreeRTOS_NetworkDown();
 80079c2:	f000 f92b 	bl	8007c1c <FreeRTOS_NetworkDown>
		}
	}
 80079c6:	e763      	b.n	8007890 <prvIPTask+0x1c>
 80079c8:	2000c210 	.word	0x2000c210
 80079cc:	2000c238 	.word	0x2000c238
 80079d0:	2000c1bc 	.word	0x2000c1bc
 80079d4:	2000c1f8 	.word	0x2000c1f8
 80079d8:	2000c1ec 	.word	0x2000c1ec

080079dc <xIsCallingFromIPTask>:
}
/*-----------------------------------------------------------*/

BaseType_t xIsCallingFromIPTask( void )
{
 80079dc:	b580      	push	{r7, lr}
 80079de:	b082      	sub	sp, #8
 80079e0:	af00      	add	r7, sp, #0
BaseType_t xReturn;

	if( xTaskGetCurrentTaskHandle() == xIPTaskHandle )
 80079e2:	f7fe fa11 	bl	8005e08 <xTaskGetCurrentTaskHandle>
 80079e6:	4602      	mov	r2, r0
 80079e8:	4b06      	ldr	r3, [pc, #24]	; (8007a04 <xIsCallingFromIPTask+0x28>)
 80079ea:	681b      	ldr	r3, [r3, #0]
 80079ec:	429a      	cmp	r2, r3
 80079ee:	d102      	bne.n	80079f6 <xIsCallingFromIPTask+0x1a>
	{
		xReturn = pdTRUE;
 80079f0:	2301      	movs	r3, #1
 80079f2:	607b      	str	r3, [r7, #4]
 80079f4:	e001      	b.n	80079fa <xIsCallingFromIPTask+0x1e>
	}
	else
	{
		xReturn = pdFALSE;
 80079f6:	2300      	movs	r3, #0
 80079f8:	607b      	str	r3, [r7, #4]
	}

	return xReturn;
 80079fa:	687b      	ldr	r3, [r7, #4]
}
 80079fc:	4618      	mov	r0, r3
 80079fe:	3708      	adds	r7, #8
 8007a00:	46bd      	mov	sp, r7
 8007a02:	bd80      	pop	{r7, pc}
 8007a04:	2000c1f0 	.word	0x2000c1f0

08007a08 <prvHandleEthernetPacket>:
/*-----------------------------------------------------------*/

static void prvHandleEthernetPacket( NetworkBufferDescriptor_t *pxBuffer )
{
 8007a08:	b580      	push	{r7, lr}
 8007a0a:	b082      	sub	sp, #8
 8007a0c:	af00      	add	r7, sp, #0
 8007a0e:	6078      	str	r0, [r7, #4]
	#if( ipconfigUSE_LINKED_RX_MESSAGES == 0 )
	{
		/* When ipconfigUSE_LINKED_RX_MESSAGES is not set to 0 then only one
		buffer will be sent at a time.  This is the default way for +TCP to pass
		messages from the MAC to the TCP/IP stack. */
		prvProcessEthernetPacket( pxBuffer );
 8007a10:	6878      	ldr	r0, [r7, #4]
 8007a12:	f000 fb4f 	bl	80080b4 <prvProcessEthernetPacket>

		/* While there is another packet in the chain. */
		} while( pxBuffer != NULL );
	}
	#endif /* ipconfigUSE_LINKED_RX_MESSAGES */
}
 8007a16:	3708      	adds	r7, #8
 8007a18:	46bd      	mov	sp, r7
 8007a1a:	bd80      	pop	{r7, pc}

08007a1c <prvCalculateSleepTime>:
/*-----------------------------------------------------------*/

static TickType_t prvCalculateSleepTime( void )
{
 8007a1c:	b480      	push	{r7}
 8007a1e:	b083      	sub	sp, #12
 8007a20:	af00      	add	r7, sp, #0
TickType_t xMaximumSleepTime;

	/* Start with the maximum sleep time, then check this against the remaining
	time in any other timers that are active. */
	xMaximumSleepTime = ipconfigMAX_IP_TASK_SLEEP_TIME;
 8007a22:	f242 7310 	movw	r3, #10000	; 0x2710
 8007a26:	607b      	str	r3, [r7, #4]

	if( xARPTimer.bActive != pdFALSE_UNSIGNED )
 8007a28:	4b16      	ldr	r3, [pc, #88]	; (8007a84 <prvCalculateSleepTime+0x68>)
 8007a2a:	781b      	ldrb	r3, [r3, #0]
 8007a2c:	f003 0301 	and.w	r3, r3, #1
 8007a30:	b2db      	uxtb	r3, r3
 8007a32:	2b00      	cmp	r3, #0
 8007a34:	d007      	beq.n	8007a46 <prvCalculateSleepTime+0x2a>
	{
		if( xARPTimer.ulRemainingTime < xMaximumSleepTime )
 8007a36:	4b13      	ldr	r3, [pc, #76]	; (8007a84 <prvCalculateSleepTime+0x68>)
 8007a38:	68da      	ldr	r2, [r3, #12]
 8007a3a:	687b      	ldr	r3, [r7, #4]
 8007a3c:	429a      	cmp	r2, r3
 8007a3e:	d202      	bcs.n	8007a46 <prvCalculateSleepTime+0x2a>
		{
			xMaximumSleepTime = xARPTimer.ulReloadTime;
 8007a40:	4b10      	ldr	r3, [pc, #64]	; (8007a84 <prvCalculateSleepTime+0x68>)
 8007a42:	691b      	ldr	r3, [r3, #16]
 8007a44:	607b      	str	r3, [r7, #4]
	}
	#endif /* ipconfigUSE_DHCP */

	#if( ipconfigUSE_TCP == 1 )
	{
		if( xTCPTimer.ulRemainingTime < xMaximumSleepTime )
 8007a46:	4b10      	ldr	r3, [pc, #64]	; (8007a88 <prvCalculateSleepTime+0x6c>)
 8007a48:	68da      	ldr	r2, [r3, #12]
 8007a4a:	687b      	ldr	r3, [r7, #4]
 8007a4c:	429a      	cmp	r2, r3
 8007a4e:	d202      	bcs.n	8007a56 <prvCalculateSleepTime+0x3a>
		{
			xMaximumSleepTime = xTCPTimer.ulRemainingTime;
 8007a50:	4b0d      	ldr	r3, [pc, #52]	; (8007a88 <prvCalculateSleepTime+0x6c>)
 8007a52:	68db      	ldr	r3, [r3, #12]
 8007a54:	607b      	str	r3, [r7, #4]
	}
	#endif

	#if( ipconfigDNS_USE_CALLBACKS != 0 )
	{
		if( xDNSTimer.bActive != pdFALSE )
 8007a56:	4b0d      	ldr	r3, [pc, #52]	; (8007a8c <prvCalculateSleepTime+0x70>)
 8007a58:	781b      	ldrb	r3, [r3, #0]
 8007a5a:	f003 0301 	and.w	r3, r3, #1
 8007a5e:	b2db      	uxtb	r3, r3
 8007a60:	2b00      	cmp	r3, #0
 8007a62:	d007      	beq.n	8007a74 <prvCalculateSleepTime+0x58>
		{
			if( xDNSTimer.ulRemainingTime < xMaximumSleepTime )
 8007a64:	4b09      	ldr	r3, [pc, #36]	; (8007a8c <prvCalculateSleepTime+0x70>)
 8007a66:	68da      	ldr	r2, [r3, #12]
 8007a68:	687b      	ldr	r3, [r7, #4]
 8007a6a:	429a      	cmp	r2, r3
 8007a6c:	d202      	bcs.n	8007a74 <prvCalculateSleepTime+0x58>
			{
				xMaximumSleepTime = xDNSTimer.ulRemainingTime;
 8007a6e:	4b07      	ldr	r3, [pc, #28]	; (8007a8c <prvCalculateSleepTime+0x70>)
 8007a70:	68db      	ldr	r3, [r3, #12]
 8007a72:	607b      	str	r3, [r7, #4]
			}
		}
	}
	#endif

	return xMaximumSleepTime;
 8007a74:	687b      	ldr	r3, [r7, #4]
}
 8007a76:	4618      	mov	r0, r3
 8007a78:	370c      	adds	r7, #12
 8007a7a:	46bd      	mov	sp, r7
 8007a7c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a80:	4770      	bx	lr
 8007a82:	bf00      	nop
 8007a84:	2000c1fc 	.word	0x2000c1fc
 8007a88:	2000c210 	.word	0x2000c210
 8007a8c:	2000c224 	.word	0x2000c224

08007a90 <prvCheckNetworkTimers>:
/*-----------------------------------------------------------*/

static void prvCheckNetworkTimers( void )
{
 8007a90:	b580      	push	{r7, lr}
 8007a92:	b084      	sub	sp, #16
 8007a94:	af00      	add	r7, sp, #0
	/* Is it time for ARP processing? */
	if( prvIPTimerCheck( &xARPTimer ) != pdFALSE )
 8007a96:	4828      	ldr	r0, [pc, #160]	; (8007b38 <prvCheckNetworkTimers+0xa8>)
 8007a98:	f000 f890 	bl	8007bbc <prvIPTimerCheck>
 8007a9c:	4603      	mov	r3, r0
 8007a9e:	2b00      	cmp	r3, #0
 8007aa0:	d002      	beq.n	8007aa8 <prvCheckNetworkTimers+0x18>
	{
		xSendEventToIPTask( eARPTimerEvent );
 8007aa2:	2002      	movs	r0, #2
 8007aa4:	f000 fa6e 	bl	8007f84 <xSendEventToIPTask>
	#if( ipconfigDNS_USE_CALLBACKS != 0 )
	{
	extern void vDNSCheckCallBack( void *pvSearchID );

		/* Is it time for DNS processing? */
		if( prvIPTimerCheck( &xDNSTimer ) != pdFALSE )
 8007aa8:	4824      	ldr	r0, [pc, #144]	; (8007b3c <prvCheckNetworkTimers+0xac>)
 8007aaa:	f000 f887 	bl	8007bbc <prvIPTimerCheck>
 8007aae:	4603      	mov	r3, r0
 8007ab0:	2b00      	cmp	r3, #0
 8007ab2:	d002      	beq.n	8007aba <prvCheckNetworkTimers+0x2a>
		{
			vDNSCheckCallBack( NULL );
 8007ab4:	2000      	movs	r0, #0
 8007ab6:	f006 f843 	bl	800db40 <vDNSCheckCallBack>
	static TickType_t xStart = ( TickType_t ) 0;
	TickType_t xTimeNow, xNextTime;
	BaseType_t xCheckTCPSockets;
	extern uint32_t ulNextInitialSequenceNumber;

		if( uxQueueMessagesWaiting( xNetworkEventQueue ) == 0u )
 8007aba:	4b21      	ldr	r3, [pc, #132]	; (8007b40 <prvCheckNetworkTimers+0xb0>)
 8007abc:	681b      	ldr	r3, [r3, #0]
 8007abe:	4618      	mov	r0, r3
 8007ac0:	f7fd f88c 	bl	8004bdc <uxQueueMessagesWaiting>
 8007ac4:	4603      	mov	r3, r0
 8007ac6:	2b00      	cmp	r3, #0
 8007ac8:	d102      	bne.n	8007ad0 <prvCheckNetworkTimers+0x40>
		{
			xWillSleep = pdTRUE;
 8007aca:	2301      	movs	r3, #1
 8007acc:	60fb      	str	r3, [r7, #12]
 8007ace:	e001      	b.n	8007ad4 <prvCheckNetworkTimers+0x44>
		}
		else
		{
			xWillSleep = pdFALSE;
 8007ad0:	2300      	movs	r3, #0
 8007ad2:	60fb      	str	r3, [r7, #12]
		}

		xTimeNow = xTaskGetTickCount();
 8007ad4:	f7fd fd56 	bl	8005584 <xTaskGetTickCount>
 8007ad8:	6078      	str	r0, [r7, #4]

		if( xStart != ( TickType_t ) 0 )
 8007ada:	4b1a      	ldr	r3, [pc, #104]	; (8007b44 <prvCheckNetworkTimers+0xb4>)
 8007adc:	681b      	ldr	r3, [r3, #0]
 8007ade:	2b00      	cmp	r3, #0
 8007ae0:	d009      	beq.n	8007af6 <prvCheckNetworkTimers+0x66>
		{
			/* It is advised to increment the Initial Sequence Number every 4
			microseconds which makes 250 times per ms.  This will make it harder
			for a third party to 'guess' our sequence number and 'take over'
			a TCP connection */
			ulNextInitialSequenceNumber += ipINITIAL_SEQUENCE_NUMBER_FACTOR * ( ( xTimeNow - xStart ) * portTICK_PERIOD_MS );
 8007ae2:	4b18      	ldr	r3, [pc, #96]	; (8007b44 <prvCheckNetworkTimers+0xb4>)
 8007ae4:	681b      	ldr	r3, [r3, #0]
 8007ae6:	687a      	ldr	r2, [r7, #4]
 8007ae8:	1ad3      	subs	r3, r2, r3
 8007aea:	021a      	lsls	r2, r3, #8
 8007aec:	4b16      	ldr	r3, [pc, #88]	; (8007b48 <prvCheckNetworkTimers+0xb8>)
 8007aee:	681b      	ldr	r3, [r3, #0]
 8007af0:	4413      	add	r3, r2
 8007af2:	4a15      	ldr	r2, [pc, #84]	; (8007b48 <prvCheckNetworkTimers+0xb8>)
 8007af4:	6013      	str	r3, [r2, #0]
		}

		xStart = xTimeNow;
 8007af6:	4a13      	ldr	r2, [pc, #76]	; (8007b44 <prvCheckNetworkTimers+0xb4>)
 8007af8:	687b      	ldr	r3, [r7, #4]
 8007afa:	6013      	str	r3, [r2, #0]

		/* Sockets need to be checked if the TCP timer has expired. */
		xCheckTCPSockets = prvIPTimerCheck( &xTCPTimer );
 8007afc:	4813      	ldr	r0, [pc, #76]	; (8007b4c <prvCheckNetworkTimers+0xbc>)
 8007afe:	f000 f85d 	bl	8007bbc <prvIPTimerCheck>
 8007b02:	60b8      	str	r0, [r7, #8]

		/* Sockets will also be checked if there are TCP messages but the
		message queue is empty (indicated by xWillSleep being true). */
		if( ( xProcessedTCPMessage != pdFALSE ) && ( xWillSleep != pdFALSE ) )
 8007b04:	4b12      	ldr	r3, [pc, #72]	; (8007b50 <prvCheckNetworkTimers+0xc0>)
 8007b06:	681b      	ldr	r3, [r3, #0]
 8007b08:	2b00      	cmp	r3, #0
 8007b0a:	d004      	beq.n	8007b16 <prvCheckNetworkTimers+0x86>
 8007b0c:	68fb      	ldr	r3, [r7, #12]
 8007b0e:	2b00      	cmp	r3, #0
 8007b10:	d001      	beq.n	8007b16 <prvCheckNetworkTimers+0x86>
		{
			xCheckTCPSockets = pdTRUE;
 8007b12:	2301      	movs	r3, #1
 8007b14:	60bb      	str	r3, [r7, #8]
		}

		if( xCheckTCPSockets != pdFALSE )
 8007b16:	68bb      	ldr	r3, [r7, #8]
 8007b18:	2b00      	cmp	r3, #0
 8007b1a:	d00a      	beq.n	8007b32 <prvCheckNetworkTimers+0xa2>
		{
			/* Attend to the sockets, returning the period after which the
			check must be repeated. */
			xNextTime = xTCPTimerCheck( xWillSleep );
 8007b1c:	68f8      	ldr	r0, [r7, #12]
 8007b1e:	f001 feb7 	bl	8009890 <xTCPTimerCheck>
 8007b22:	6038      	str	r0, [r7, #0]
			prvIPTimerStart( &xTCPTimer, xNextTime );
 8007b24:	4809      	ldr	r0, [pc, #36]	; (8007b4c <prvCheckNetworkTimers+0xbc>)
 8007b26:	6839      	ldr	r1, [r7, #0]
 8007b28:	f000 f814 	bl	8007b54 <prvIPTimerStart>
			xProcessedTCPMessage = 0;
 8007b2c:	4b08      	ldr	r3, [pc, #32]	; (8007b50 <prvCheckNetworkTimers+0xc0>)
 8007b2e:	2200      	movs	r2, #0
 8007b30:	601a      	str	r2, [r3, #0]
		}
	}
	#endif /* ipconfigUSE_TCP == 1 */
}
 8007b32:	3710      	adds	r7, #16
 8007b34:	46bd      	mov	sp, r7
 8007b36:	bd80      	pop	{r7, pc}
 8007b38:	2000c1fc 	.word	0x2000c1fc
 8007b3c:	2000c224 	.word	0x2000c224
 8007b40:	2000c1bc 	.word	0x2000c1bc
 8007b44:	2000c23c 	.word	0x2000c23c
 8007b48:	2000c298 	.word	0x2000c298
 8007b4c:	2000c210 	.word	0x2000c210
 8007b50:	2000c1f4 	.word	0x2000c1f4

08007b54 <prvIPTimerStart>:
/*-----------------------------------------------------------*/

static void prvIPTimerStart( IPTimer_t *pxTimer, TickType_t xTime )
{
 8007b54:	b580      	push	{r7, lr}
 8007b56:	b082      	sub	sp, #8
 8007b58:	af00      	add	r7, sp, #0
 8007b5a:	6078      	str	r0, [r7, #4]
 8007b5c:	6039      	str	r1, [r7, #0]
	vTaskSetTimeOutState( &pxTimer->xTimeOut );
 8007b5e:	687b      	ldr	r3, [r7, #4]
 8007b60:	3304      	adds	r3, #4
 8007b62:	4618      	mov	r0, r3
 8007b64:	f7fd fffe 	bl	8005b64 <vTaskSetTimeOutState>
	pxTimer->ulRemainingTime = xTime;
 8007b68:	687b      	ldr	r3, [r7, #4]
 8007b6a:	683a      	ldr	r2, [r7, #0]
 8007b6c:	60da      	str	r2, [r3, #12]

	if( xTime == ( TickType_t ) 0 )
 8007b6e:	683b      	ldr	r3, [r7, #0]
 8007b70:	2b00      	cmp	r3, #0
 8007b72:	d105      	bne.n	8007b80 <prvIPTimerStart+0x2c>
	{
		pxTimer->bExpired = pdTRUE_UNSIGNED;
 8007b74:	687a      	ldr	r2, [r7, #4]
 8007b76:	7813      	ldrb	r3, [r2, #0]
 8007b78:	f043 0302 	orr.w	r3, r3, #2
 8007b7c:	7013      	strb	r3, [r2, #0]
 8007b7e:	e004      	b.n	8007b8a <prvIPTimerStart+0x36>
	}
	else
	{
		pxTimer->bExpired = pdFALSE_UNSIGNED;
 8007b80:	687a      	ldr	r2, [r7, #4]
 8007b82:	7813      	ldrb	r3, [r2, #0]
 8007b84:	f36f 0341 	bfc	r3, #1, #1
 8007b88:	7013      	strb	r3, [r2, #0]
	}

	pxTimer->bActive = pdTRUE_UNSIGNED;
 8007b8a:	687a      	ldr	r2, [r7, #4]
 8007b8c:	7813      	ldrb	r3, [r2, #0]
 8007b8e:	f043 0301 	orr.w	r3, r3, #1
 8007b92:	7013      	strb	r3, [r2, #0]
}
 8007b94:	3708      	adds	r7, #8
 8007b96:	46bd      	mov	sp, r7
 8007b98:	bd80      	pop	{r7, pc}
 8007b9a:	bf00      	nop

08007b9c <prvIPTimerReload>:
/*-----------------------------------------------------------*/

static void prvIPTimerReload( IPTimer_t *pxTimer, TickType_t xTime )
{
 8007b9c:	b580      	push	{r7, lr}
 8007b9e:	b082      	sub	sp, #8
 8007ba0:	af00      	add	r7, sp, #0
 8007ba2:	6078      	str	r0, [r7, #4]
 8007ba4:	6039      	str	r1, [r7, #0]
	pxTimer->ulReloadTime = xTime;
 8007ba6:	687b      	ldr	r3, [r7, #4]
 8007ba8:	683a      	ldr	r2, [r7, #0]
 8007baa:	611a      	str	r2, [r3, #16]
	prvIPTimerStart( pxTimer, xTime );
 8007bac:	6878      	ldr	r0, [r7, #4]
 8007bae:	6839      	ldr	r1, [r7, #0]
 8007bb0:	f7ff ffd0 	bl	8007b54 <prvIPTimerStart>
}
 8007bb4:	3708      	adds	r7, #8
 8007bb6:	46bd      	mov	sp, r7
 8007bb8:	bd80      	pop	{r7, pc}
 8007bba:	bf00      	nop

08007bbc <prvIPTimerCheck>:
/*-----------------------------------------------------------*/

static BaseType_t prvIPTimerCheck( IPTimer_t *pxTimer )
{
 8007bbc:	b580      	push	{r7, lr}
 8007bbe:	b084      	sub	sp, #16
 8007bc0:	af00      	add	r7, sp, #0
 8007bc2:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	if( pxTimer->bActive == pdFALSE_UNSIGNED )
 8007bc4:	687b      	ldr	r3, [r7, #4]
 8007bc6:	781b      	ldrb	r3, [r3, #0]
 8007bc8:	f003 0301 	and.w	r3, r3, #1
 8007bcc:	b2db      	uxtb	r3, r3
 8007bce:	2b00      	cmp	r3, #0
 8007bd0:	d102      	bne.n	8007bd8 <prvIPTimerCheck+0x1c>
	{
		/* The timer is not enabled. */
		xReturn = pdFALSE;
 8007bd2:	2300      	movs	r3, #0
 8007bd4:	60fb      	str	r3, [r7, #12]
 8007bd6:	e01c      	b.n	8007c12 <prvIPTimerCheck+0x56>
	}
	else
	{
		/* The timer might have set the bExpired flag already, if not, check the
		value of xTimeOut against ulRemainingTime. */
		if( ( pxTimer->bExpired != pdFALSE_UNSIGNED ) ||
 8007bd8:	687b      	ldr	r3, [r7, #4]
 8007bda:	781b      	ldrb	r3, [r3, #0]
 8007bdc:	f003 0302 	and.w	r3, r3, #2
 8007be0:	b2db      	uxtb	r3, r3
 8007be2:	2b00      	cmp	r3, #0
 8007be4:	d10a      	bne.n	8007bfc <prvIPTimerCheck+0x40>
			( xTaskCheckForTimeOut( &( pxTimer->xTimeOut ), &( pxTimer->ulRemainingTime ) ) != pdFALSE ) )
 8007be6:	687b      	ldr	r3, [r7, #4]
 8007be8:	1d1a      	adds	r2, r3, #4
 8007bea:	687b      	ldr	r3, [r7, #4]
 8007bec:	330c      	adds	r3, #12
 8007bee:	4610      	mov	r0, r2
 8007bf0:	4619      	mov	r1, r3
 8007bf2:	f7fd ffd9 	bl	8005ba8 <xTaskCheckForTimeOut>
 8007bf6:	4603      	mov	r3, r0
	}
	else
	{
		/* The timer might have set the bExpired flag already, if not, check the
		value of xTimeOut against ulRemainingTime. */
		if( ( pxTimer->bExpired != pdFALSE_UNSIGNED ) ||
 8007bf8:	2b00      	cmp	r3, #0
 8007bfa:	d008      	beq.n	8007c0e <prvIPTimerCheck+0x52>
			( xTaskCheckForTimeOut( &( pxTimer->xTimeOut ), &( pxTimer->ulRemainingTime ) ) != pdFALSE ) )
		{
			prvIPTimerStart( pxTimer, pxTimer->ulReloadTime );
 8007bfc:	687b      	ldr	r3, [r7, #4]
 8007bfe:	691b      	ldr	r3, [r3, #16]
 8007c00:	6878      	ldr	r0, [r7, #4]
 8007c02:	4619      	mov	r1, r3
 8007c04:	f7ff ffa6 	bl	8007b54 <prvIPTimerStart>
			xReturn = pdTRUE;
 8007c08:	2301      	movs	r3, #1
 8007c0a:	60fb      	str	r3, [r7, #12]
 8007c0c:	e001      	b.n	8007c12 <prvIPTimerCheck+0x56>
		}
		else
		{
			xReturn = pdFALSE;
 8007c0e:	2300      	movs	r3, #0
 8007c10:	60fb      	str	r3, [r7, #12]
		}
	}

	return xReturn;
 8007c12:	68fb      	ldr	r3, [r7, #12]
}
 8007c14:	4618      	mov	r0, r3
 8007c16:	3710      	adds	r7, #16
 8007c18:	46bd      	mov	sp, r7
 8007c1a:	bd80      	pop	{r7, pc}

08007c1c <FreeRTOS_NetworkDown>:
/*-----------------------------------------------------------*/

void FreeRTOS_NetworkDown( void )
{
 8007c1c:	b580      	push	{r7, lr}
 8007c1e:	b082      	sub	sp, #8
 8007c20:	af00      	add	r7, sp, #0
static const IPStackEvent_t xNetworkDownEvent = { eNetworkDownEvent, NULL };
const TickType_t xDontBlock = ( TickType_t ) 0;
 8007c22:	2300      	movs	r3, #0
 8007c24:	607b      	str	r3, [r7, #4]

	/* Simply send the network task the appropriate event. */
	if( xSendEventStructToIPTask( &xNetworkDownEvent, xDontBlock ) != pdPASS )
 8007c26:	4808      	ldr	r0, [pc, #32]	; (8007c48 <FreeRTOS_NetworkDown+0x2c>)
 8007c28:	6879      	ldr	r1, [r7, #4]
 8007c2a:	f000 f9c1 	bl	8007fb0 <xSendEventStructToIPTask>
 8007c2e:	4603      	mov	r3, r0
 8007c30:	2b01      	cmp	r3, #1
 8007c32:	d003      	beq.n	8007c3c <FreeRTOS_NetworkDown+0x20>
	{
		/* Could not send the message, so it is still pending. */
		xNetworkDownEventPending = pdTRUE;
 8007c34:	4b05      	ldr	r3, [pc, #20]	; (8007c4c <FreeRTOS_NetworkDown+0x30>)
 8007c36:	2201      	movs	r2, #1
 8007c38:	601a      	str	r2, [r3, #0]
 8007c3a:	e002      	b.n	8007c42 <FreeRTOS_NetworkDown+0x26>
	}
	else
	{
		/* Message was sent so it is not pending. */
		xNetworkDownEventPending = pdFALSE;
 8007c3c:	4b03      	ldr	r3, [pc, #12]	; (8007c4c <FreeRTOS_NetworkDown+0x30>)
 8007c3e:	2200      	movs	r2, #0
 8007c40:	601a      	str	r2, [r3, #0]
	}

	iptraceNETWORK_DOWN();
}
 8007c42:	3708      	adds	r7, #8
 8007c44:	46bd      	mov	sp, r7
 8007c46:	bd80      	pop	{r7, pc}
 8007c48:	08012a14 	.word	0x08012a14
 8007c4c:	2000c1ec 	.word	0x2000c1ec

08007c50 <pxDuplicateNetworkBufferWithDescriptor>:
}
/*-----------------------------------------------------------*/

NetworkBufferDescriptor_t *pxDuplicateNetworkBufferWithDescriptor( NetworkBufferDescriptor_t * const pxNetworkBuffer,
	BaseType_t xNewLength )
{
 8007c50:	b580      	push	{r7, lr}
 8007c52:	b084      	sub	sp, #16
 8007c54:	af00      	add	r7, sp, #0
 8007c56:	6078      	str	r0, [r7, #4]
 8007c58:	6039      	str	r1, [r7, #0]
NetworkBufferDescriptor_t * pxNewBuffer;

	/* This function is only used when 'ipconfigZERO_COPY_TX_DRIVER' is set to 1.
	The transmit routine wants to have ownership of the network buffer
	descriptor, because it will pass the buffer straight to DMA. */
	pxNewBuffer = pxGetNetworkBufferWithDescriptor( ( size_t ) xNewLength, ( TickType_t ) 0 );
 8007c5a:	683b      	ldr	r3, [r7, #0]
 8007c5c:	4618      	mov	r0, r3
 8007c5e:	2100      	movs	r1, #0
 8007c60:	f7ff fd42 	bl	80076e8 <pxGetNetworkBufferWithDescriptor>
 8007c64:	60f8      	str	r0, [r7, #12]

	if( pxNewBuffer != NULL )
 8007c66:	68fb      	ldr	r3, [r7, #12]
 8007c68:	2b00      	cmp	r3, #0
 8007c6a:	d016      	beq.n	8007c9a <pxDuplicateNetworkBufferWithDescriptor+0x4a>
	{
		pxNewBuffer->ulIPAddress = pxNetworkBuffer->ulIPAddress;
 8007c6c:	687b      	ldr	r3, [r7, #4]
 8007c6e:	695a      	ldr	r2, [r3, #20]
 8007c70:	68fb      	ldr	r3, [r7, #12]
 8007c72:	615a      	str	r2, [r3, #20]
		pxNewBuffer->usPort = pxNetworkBuffer->usPort;
 8007c74:	687b      	ldr	r3, [r7, #4]
 8007c76:	8c1a      	ldrh	r2, [r3, #32]
 8007c78:	68fb      	ldr	r3, [r7, #12]
 8007c7a:	841a      	strh	r2, [r3, #32]
		pxNewBuffer->usBoundPort = pxNetworkBuffer->usBoundPort;
 8007c7c:	687b      	ldr	r3, [r7, #4]
 8007c7e:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 8007c80:	68fb      	ldr	r3, [r7, #12]
 8007c82:	845a      	strh	r2, [r3, #34]	; 0x22
		memcpy( pxNewBuffer->pucEthernetBuffer, pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength );
 8007c84:	68fb      	ldr	r3, [r7, #12]
 8007c86:	6999      	ldr	r1, [r3, #24]
 8007c88:	687b      	ldr	r3, [r7, #4]
 8007c8a:	699a      	ldr	r2, [r3, #24]
 8007c8c:	687b      	ldr	r3, [r7, #4]
 8007c8e:	69db      	ldr	r3, [r3, #28]
 8007c90:	4608      	mov	r0, r1
 8007c92:	4611      	mov	r1, r2
 8007c94:	461a      	mov	r2, r3
 8007c96:	f008 fa07 	bl	80100a8 <memcpy>
	}

	return pxNewBuffer;
 8007c9a:	68fb      	ldr	r3, [r7, #12]
}
 8007c9c:	4618      	mov	r0, r3
 8007c9e:	3710      	adds	r7, #16
 8007ca0:	46bd      	mov	sp, r7
 8007ca2:	bd80      	pop	{r7, pc}

08007ca4 <pxPacketBuffer_to_NetworkBuffer>:
/*-----------------------------------------------------------*/

#if( ipconfigZERO_COPY_TX_DRIVER != 0 ) || ( ipconfigZERO_COPY_RX_DRIVER != 0 )

	NetworkBufferDescriptor_t *pxPacketBuffer_to_NetworkBuffer( void *pvBuffer )
	{
 8007ca4:	b480      	push	{r7}
 8007ca6:	b085      	sub	sp, #20
 8007ca8:	af00      	add	r7, sp, #0
 8007caa:	6078      	str	r0, [r7, #4]
	uint8_t *pucBuffer;
	NetworkBufferDescriptor_t *pxResult;

		if( pvBuffer == NULL )
 8007cac:	687b      	ldr	r3, [r7, #4]
 8007cae:	2b00      	cmp	r3, #0
 8007cb0:	d102      	bne.n	8007cb8 <pxPacketBuffer_to_NetworkBuffer+0x14>
		{
			pxResult = NULL;
 8007cb2:	2300      	movs	r3, #0
 8007cb4:	60fb      	str	r3, [r7, #12]
 8007cb6:	e00f      	b.n	8007cd8 <pxPacketBuffer_to_NetworkBuffer+0x34>
		}
		else
		{
			/* Obtain the network buffer from the zero copy pointer. */
			pucBuffer = ( uint8_t * ) pvBuffer;
 8007cb8:	687b      	ldr	r3, [r7, #4]
 8007cba:	60bb      	str	r3, [r7, #8]

			/* The input here is a pointer to a payload buffer.  Subtract the
			size of the header in the network buffer, usually 8 + 2 bytes. */
			pucBuffer -= ipBUFFER_PADDING;
 8007cbc:	68bb      	ldr	r3, [r7, #8]
 8007cbe:	3b0a      	subs	r3, #10
 8007cc0:	60bb      	str	r3, [r7, #8]

			/* Here a pointer was placed to the network descriptor.  As a
			pointer is dereferenced, make sure it is well aligned. */
			if( ( ( ( uint32_t ) pucBuffer ) & ( sizeof( pucBuffer ) - ( size_t ) 1 ) ) == ( uint32_t ) 0 )
 8007cc2:	68bb      	ldr	r3, [r7, #8]
 8007cc4:	f003 0303 	and.w	r3, r3, #3
 8007cc8:	2b00      	cmp	r3, #0
 8007cca:	d103      	bne.n	8007cd4 <pxPacketBuffer_to_NetworkBuffer+0x30>
			{
				pxResult = * ( ( NetworkBufferDescriptor_t ** ) pucBuffer );
 8007ccc:	68bb      	ldr	r3, [r7, #8]
 8007cce:	681b      	ldr	r3, [r3, #0]
 8007cd0:	60fb      	str	r3, [r7, #12]
 8007cd2:	e001      	b.n	8007cd8 <pxPacketBuffer_to_NetworkBuffer+0x34>
			}
			else
			{
				pxResult = NULL;
 8007cd4:	2300      	movs	r3, #0
 8007cd6:	60fb      	str	r3, [r7, #12]
			}
		}

		return pxResult;
 8007cd8:	68fb      	ldr	r3, [r7, #12]
	}
 8007cda:	4618      	mov	r0, r3
 8007cdc:	3714      	adds	r7, #20
 8007cde:	46bd      	mov	sp, r7
 8007ce0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007ce4:	4770      	bx	lr
 8007ce6:	bf00      	nop

08007ce8 <pxUDPPayloadBuffer_to_NetworkBuffer>:

#endif /* ipconfigZERO_COPY_TX_DRIVER != 0 */
/*-----------------------------------------------------------*/

NetworkBufferDescriptor_t *pxUDPPayloadBuffer_to_NetworkBuffer( void *pvBuffer )
{
 8007ce8:	b480      	push	{r7}
 8007cea:	b085      	sub	sp, #20
 8007cec:	af00      	add	r7, sp, #0
 8007cee:	6078      	str	r0, [r7, #4]
uint8_t *pucBuffer;
NetworkBufferDescriptor_t *pxResult;

	if( pvBuffer == NULL )
 8007cf0:	687b      	ldr	r3, [r7, #4]
 8007cf2:	2b00      	cmp	r3, #0
 8007cf4:	d102      	bne.n	8007cfc <pxUDPPayloadBuffer_to_NetworkBuffer+0x14>
	{
		pxResult = NULL;
 8007cf6:	2300      	movs	r3, #0
 8007cf8:	60fb      	str	r3, [r7, #12]
 8007cfa:	e00f      	b.n	8007d1c <pxUDPPayloadBuffer_to_NetworkBuffer+0x34>
	}
	else
	{
		/* Obtain the network buffer from the zero copy pointer. */
		pucBuffer = ( uint8_t * ) pvBuffer;
 8007cfc:	687b      	ldr	r3, [r7, #4]
 8007cfe:	60bb      	str	r3, [r7, #8]

		/* The input here is a pointer to a payload buffer.  Subtract
		the total size of a UDP/IP header plus the size of the header in
		the network buffer, usually 8 + 2 bytes. */
		pucBuffer -= ( sizeof( UDPPacket_t ) + ipBUFFER_PADDING );
 8007d00:	68bb      	ldr	r3, [r7, #8]
 8007d02:	3b34      	subs	r3, #52	; 0x34
 8007d04:	60bb      	str	r3, [r7, #8]

		/* Here a pointer was placed to the network descriptor,
		As a pointer is dereferenced, make sure it is well aligned */
		if( ( ( ( uint32_t ) pucBuffer ) & ( sizeof( pucBuffer ) - 1 ) ) == 0 )
 8007d06:	68bb      	ldr	r3, [r7, #8]
 8007d08:	f003 0303 	and.w	r3, r3, #3
 8007d0c:	2b00      	cmp	r3, #0
 8007d0e:	d103      	bne.n	8007d18 <pxUDPPayloadBuffer_to_NetworkBuffer+0x30>
		{
			/* The following statement may trigger a:
			warning: cast increases required alignment of target type [-Wcast-align].
			It has been confirmed though that the alignment is suitable. */
			pxResult = * ( ( NetworkBufferDescriptor_t ** ) pucBuffer );
 8007d10:	68bb      	ldr	r3, [r7, #8]
 8007d12:	681b      	ldr	r3, [r3, #0]
 8007d14:	60fb      	str	r3, [r7, #12]
 8007d16:	e001      	b.n	8007d1c <pxUDPPayloadBuffer_to_NetworkBuffer+0x34>
		}
		else
		{
			pxResult = NULL;
 8007d18:	2300      	movs	r3, #0
 8007d1a:	60fb      	str	r3, [r7, #12]
		}
	}

	return pxResult;
 8007d1c:	68fb      	ldr	r3, [r7, #12]
}
 8007d1e:	4618      	mov	r0, r3
 8007d20:	3714      	adds	r7, #20
 8007d22:	46bd      	mov	sp, r7
 8007d24:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007d28:	4770      	bx	lr
 8007d2a:	bf00      	nop

08007d2c <FreeRTOS_IPInit>:
/*_RB_ Should we add an error or assert if the task priorities are set such that the servers won't function as expected? */
/*_HT_ There was a bug in FreeRTOS_TCP_IP.c that only occurred when the applications' priority was too high.
 As that bug has been repaired, there is not an urgent reason to warn.
 It is better though to use the advised priority scheme. */
BaseType_t FreeRTOS_IPInit( const uint8_t ucIPAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucNetMask[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucGatewayAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucDNSServerAddress[ ipIP_ADDRESS_LENGTH_BYTES ], const uint8_t ucMACAddress[ ipMAC_ADDRESS_LENGTH_BYTES ] )
{
 8007d2c:	b580      	push	{r7, lr}
 8007d2e:	b08c      	sub	sp, #48	; 0x30
 8007d30:	af02      	add	r7, sp, #8
 8007d32:	60f8      	str	r0, [r7, #12]
 8007d34:	60b9      	str	r1, [r7, #8]
 8007d36:	607a      	str	r2, [r7, #4]
 8007d38:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFALSE;
 8007d3a:	2300      	movs	r3, #0
 8007d3c:	627b      	str	r3, [r7, #36]	; 0x24

	/* This function should only be called once. */
	configASSERT( xIPIsNetworkTaskReady() == pdFALSE );
 8007d3e:	f000 fc07 	bl	8008550 <xIPIsNetworkTaskReady>
 8007d42:	4603      	mov	r3, r0
 8007d44:	2b00      	cmp	r3, #0
 8007d46:	d009      	beq.n	8007d5c <FreeRTOS_IPInit+0x30>
 8007d48:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007d4c:	f383 8811 	msr	BASEPRI, r3
 8007d50:	f3bf 8f6f 	isb	sy
 8007d54:	f3bf 8f4f 	dsb	sy
 8007d58:	623b      	str	r3, [r7, #32]
 8007d5a:	e7fe      	b.n	8007d5a <FreeRTOS_IPInit+0x2e>
	configASSERT( xNetworkEventQueue == NULL );
 8007d5c:	4b6b      	ldr	r3, [pc, #428]	; (8007f0c <FreeRTOS_IPInit+0x1e0>)
 8007d5e:	681b      	ldr	r3, [r3, #0]
 8007d60:	2b00      	cmp	r3, #0
 8007d62:	d009      	beq.n	8007d78 <FreeRTOS_IPInit+0x4c>
 8007d64:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007d68:	f383 8811 	msr	BASEPRI, r3
 8007d6c:	f3bf 8f6f 	isb	sy
 8007d70:	f3bf 8f4f 	dsb	sy
 8007d74:	61fb      	str	r3, [r7, #28]
 8007d76:	e7fe      	b.n	8007d76 <FreeRTOS_IPInit+0x4a>
	configASSERT( xIPTaskHandle == NULL );
 8007d78:	4b65      	ldr	r3, [pc, #404]	; (8007f10 <FreeRTOS_IPInit+0x1e4>)
 8007d7a:	681b      	ldr	r3, [r3, #0]
 8007d7c:	2b00      	cmp	r3, #0
 8007d7e:	d009      	beq.n	8007d94 <FreeRTOS_IPInit+0x68>
 8007d80:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007d84:	f383 8811 	msr	BASEPRI, r3
 8007d88:	f3bf 8f6f 	isb	sy
 8007d8c:	f3bf 8f4f 	dsb	sy
 8007d90:	61bb      	str	r3, [r7, #24]
 8007d92:	e7fe      	b.n	8007d92 <FreeRTOS_IPInit+0x66>
	configASSERT( sizeof( IPHeader_t ) == ipEXPECTED_IPHeader_t_SIZE );
	configASSERT( sizeof( ICMPHeader_t ) == ipEXPECTED_ICMPHeader_t_SIZE );
	configASSERT( sizeof( UDPHeader_t ) == ipEXPECTED_UDPHeader_t_SIZE );

	/* Attempt to create the queue used to communicate with the IP task. */
	xNetworkEventQueue = xQueueCreate( ( UBaseType_t ) ipconfigEVENT_QUEUE_LENGTH, ( UBaseType_t ) sizeof( IPStackEvent_t ) );
 8007d94:	2024      	movs	r0, #36	; 0x24
 8007d96:	2108      	movs	r1, #8
 8007d98:	2200      	movs	r2, #0
 8007d9a:	f7fc fc07 	bl	80045ac <xQueueGenericCreate>
 8007d9e:	4602      	mov	r2, r0
 8007da0:	4b5a      	ldr	r3, [pc, #360]	; (8007f0c <FreeRTOS_IPInit+0x1e0>)
 8007da2:	601a      	str	r2, [r3, #0]
	configASSERT( xNetworkEventQueue );
 8007da4:	4b59      	ldr	r3, [pc, #356]	; (8007f0c <FreeRTOS_IPInit+0x1e0>)
 8007da6:	681b      	ldr	r3, [r3, #0]
 8007da8:	2b00      	cmp	r3, #0
 8007daa:	d109      	bne.n	8007dc0 <FreeRTOS_IPInit+0x94>
 8007dac:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007db0:	f383 8811 	msr	BASEPRI, r3
 8007db4:	f3bf 8f6f 	isb	sy
 8007db8:	f3bf 8f4f 	dsb	sy
 8007dbc:	617b      	str	r3, [r7, #20]
 8007dbe:	e7fe      	b.n	8007dbe <FreeRTOS_IPInit+0x92>

	if( xNetworkEventQueue != NULL )
 8007dc0:	4b52      	ldr	r3, [pc, #328]	; (8007f0c <FreeRTOS_IPInit+0x1e0>)
 8007dc2:	681b      	ldr	r3, [r3, #0]
 8007dc4:	2b00      	cmp	r3, #0
 8007dc6:	f000 809c 	beq.w	8007f02 <FreeRTOS_IPInit+0x1d6>
		#if ( configQUEUE_REGISTRY_SIZE > 0 )
		{
			/* A queue registry is normally used to assist a kernel aware
			debugger.  If one is in use then it will be helpful for the debugger
			to show information about the network event queue. */
			vQueueAddToRegistry( xNetworkEventQueue, "NetEvnt" );
 8007dca:	4b50      	ldr	r3, [pc, #320]	; (8007f0c <FreeRTOS_IPInit+0x1e0>)
 8007dcc:	681b      	ldr	r3, [r3, #0]
 8007dce:	4618      	mov	r0, r3
 8007dd0:	4950      	ldr	r1, [pc, #320]	; (8007f14 <FreeRTOS_IPInit+0x1e8>)
 8007dd2:	f7fd f859 	bl	8004e88 <vQueueAddToRegistry>
		}
		#endif /* configQUEUE_REGISTRY_SIZE */

		if( xNetworkBuffersInitialise() == pdPASS )
 8007dd6:	f7ff fbfb 	bl	80075d0 <xNetworkBuffersInitialise>
 8007dda:	4603      	mov	r3, r0
 8007ddc:	2b01      	cmp	r3, #1
 8007dde:	f040 8088 	bne.w	8007ef2 <FreeRTOS_IPInit+0x1c6>
		{
			/* Store the local IP and MAC address. */
			xNetworkAddressing.ulDefaultIPAddress = FreeRTOS_inet_addr_quick( ucIPAddress[ 0 ], ucIPAddress[ 1 ], ucIPAddress[ 2 ], ucIPAddress[ 3 ] );
 8007de2:	68fb      	ldr	r3, [r7, #12]
 8007de4:	3303      	adds	r3, #3
 8007de6:	781b      	ldrb	r3, [r3, #0]
 8007de8:	061a      	lsls	r2, r3, #24
 8007dea:	68fb      	ldr	r3, [r7, #12]
 8007dec:	3302      	adds	r3, #2
 8007dee:	781b      	ldrb	r3, [r3, #0]
 8007df0:	041b      	lsls	r3, r3, #16
 8007df2:	431a      	orrs	r2, r3
 8007df4:	68fb      	ldr	r3, [r7, #12]
 8007df6:	3301      	adds	r3, #1
 8007df8:	781b      	ldrb	r3, [r3, #0]
 8007dfa:	021b      	lsls	r3, r3, #8
 8007dfc:	4313      	orrs	r3, r2
 8007dfe:	68fa      	ldr	r2, [r7, #12]
 8007e00:	7812      	ldrb	r2, [r2, #0]
 8007e02:	4313      	orrs	r3, r2
 8007e04:	4a44      	ldr	r2, [pc, #272]	; (8007f18 <FreeRTOS_IPInit+0x1ec>)
 8007e06:	6013      	str	r3, [r2, #0]
			xNetworkAddressing.ulNetMask = FreeRTOS_inet_addr_quick( ucNetMask[ 0 ], ucNetMask[ 1 ], ucNetMask[ 2 ], ucNetMask[ 3 ] );
 8007e08:	68bb      	ldr	r3, [r7, #8]
 8007e0a:	3303      	adds	r3, #3
 8007e0c:	781b      	ldrb	r3, [r3, #0]
 8007e0e:	061a      	lsls	r2, r3, #24
 8007e10:	68bb      	ldr	r3, [r7, #8]
 8007e12:	3302      	adds	r3, #2
 8007e14:	781b      	ldrb	r3, [r3, #0]
 8007e16:	041b      	lsls	r3, r3, #16
 8007e18:	431a      	orrs	r2, r3
 8007e1a:	68bb      	ldr	r3, [r7, #8]
 8007e1c:	3301      	adds	r3, #1
 8007e1e:	781b      	ldrb	r3, [r3, #0]
 8007e20:	021b      	lsls	r3, r3, #8
 8007e22:	4313      	orrs	r3, r2
 8007e24:	68ba      	ldr	r2, [r7, #8]
 8007e26:	7812      	ldrb	r2, [r2, #0]
 8007e28:	4313      	orrs	r3, r2
 8007e2a:	4a3b      	ldr	r2, [pc, #236]	; (8007f18 <FreeRTOS_IPInit+0x1ec>)
 8007e2c:	6053      	str	r3, [r2, #4]
			xNetworkAddressing.ulGatewayAddress = FreeRTOS_inet_addr_quick( ucGatewayAddress[ 0 ], ucGatewayAddress[ 1 ], ucGatewayAddress[ 2 ], ucGatewayAddress[ 3 ] );
 8007e2e:	687b      	ldr	r3, [r7, #4]
 8007e30:	3303      	adds	r3, #3
 8007e32:	781b      	ldrb	r3, [r3, #0]
 8007e34:	061a      	lsls	r2, r3, #24
 8007e36:	687b      	ldr	r3, [r7, #4]
 8007e38:	3302      	adds	r3, #2
 8007e3a:	781b      	ldrb	r3, [r3, #0]
 8007e3c:	041b      	lsls	r3, r3, #16
 8007e3e:	431a      	orrs	r2, r3
 8007e40:	687b      	ldr	r3, [r7, #4]
 8007e42:	3301      	adds	r3, #1
 8007e44:	781b      	ldrb	r3, [r3, #0]
 8007e46:	021b      	lsls	r3, r3, #8
 8007e48:	4313      	orrs	r3, r2
 8007e4a:	687a      	ldr	r2, [r7, #4]
 8007e4c:	7812      	ldrb	r2, [r2, #0]
 8007e4e:	4313      	orrs	r3, r2
 8007e50:	4a31      	ldr	r2, [pc, #196]	; (8007f18 <FreeRTOS_IPInit+0x1ec>)
 8007e52:	6093      	str	r3, [r2, #8]
			xNetworkAddressing.ulDNSServerAddress = FreeRTOS_inet_addr_quick( ucDNSServerAddress[ 0 ], ucDNSServerAddress[ 1 ], ucDNSServerAddress[ 2 ], ucDNSServerAddress[ 3 ] );
 8007e54:	683b      	ldr	r3, [r7, #0]
 8007e56:	3303      	adds	r3, #3
 8007e58:	781b      	ldrb	r3, [r3, #0]
 8007e5a:	061a      	lsls	r2, r3, #24
 8007e5c:	683b      	ldr	r3, [r7, #0]
 8007e5e:	3302      	adds	r3, #2
 8007e60:	781b      	ldrb	r3, [r3, #0]
 8007e62:	041b      	lsls	r3, r3, #16
 8007e64:	431a      	orrs	r2, r3
 8007e66:	683b      	ldr	r3, [r7, #0]
 8007e68:	3301      	adds	r3, #1
 8007e6a:	781b      	ldrb	r3, [r3, #0]
 8007e6c:	021b      	lsls	r3, r3, #8
 8007e6e:	4313      	orrs	r3, r2
 8007e70:	683a      	ldr	r2, [r7, #0]
 8007e72:	7812      	ldrb	r2, [r2, #0]
 8007e74:	4313      	orrs	r3, r2
 8007e76:	4a28      	ldr	r2, [pc, #160]	; (8007f18 <FreeRTOS_IPInit+0x1ec>)
 8007e78:	60d3      	str	r3, [r2, #12]
			xNetworkAddressing.ulBroadcastAddress = ( xNetworkAddressing.ulDefaultIPAddress & xNetworkAddressing.ulNetMask ) |  ~xNetworkAddressing.ulNetMask;
 8007e7a:	4b27      	ldr	r3, [pc, #156]	; (8007f18 <FreeRTOS_IPInit+0x1ec>)
 8007e7c:	681a      	ldr	r2, [r3, #0]
 8007e7e:	4b26      	ldr	r3, [pc, #152]	; (8007f18 <FreeRTOS_IPInit+0x1ec>)
 8007e80:	685b      	ldr	r3, [r3, #4]
 8007e82:	401a      	ands	r2, r3
 8007e84:	4b24      	ldr	r3, [pc, #144]	; (8007f18 <FreeRTOS_IPInit+0x1ec>)
 8007e86:	685b      	ldr	r3, [r3, #4]
 8007e88:	43db      	mvns	r3, r3
 8007e8a:	4313      	orrs	r3, r2
 8007e8c:	4a22      	ldr	r2, [pc, #136]	; (8007f18 <FreeRTOS_IPInit+0x1ec>)
 8007e8e:	6113      	str	r3, [r2, #16]

			memcpy( &xDefaultAddressing, &xNetworkAddressing, sizeof( xDefaultAddressing ) );
 8007e90:	4822      	ldr	r0, [pc, #136]	; (8007f1c <FreeRTOS_IPInit+0x1f0>)
 8007e92:	4921      	ldr	r1, [pc, #132]	; (8007f18 <FreeRTOS_IPInit+0x1ec>)
 8007e94:	2214      	movs	r2, #20
 8007e96:	f008 f907 	bl	80100a8 <memcpy>
				*ipLOCAL_IP_ADDRESS_POINTER = 0x00UL;
			}
			#else
			{
				/* The IP address is set from the value passed in. */
				*ipLOCAL_IP_ADDRESS_POINTER = xNetworkAddressing.ulDefaultIPAddress;
 8007e9a:	4b1f      	ldr	r3, [pc, #124]	; (8007f18 <FreeRTOS_IPInit+0x1ec>)
 8007e9c:	681b      	ldr	r3, [r3, #0]
 8007e9e:	4a20      	ldr	r2, [pc, #128]	; (8007f20 <FreeRTOS_IPInit+0x1f4>)
 8007ea0:	6153      	str	r3, [r2, #20]

				/* Added to prevent ARP flood to gateway.  Ensure the
				gateway is on the same subnet as the IP	address. */
				configASSERT( ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) == ( xNetworkAddressing.ulGatewayAddress & xNetworkAddressing.ulNetMask ) );
 8007ea2:	4b1f      	ldr	r3, [pc, #124]	; (8007f20 <FreeRTOS_IPInit+0x1f4>)
 8007ea4:	695a      	ldr	r2, [r3, #20]
 8007ea6:	4b1c      	ldr	r3, [pc, #112]	; (8007f18 <FreeRTOS_IPInit+0x1ec>)
 8007ea8:	689b      	ldr	r3, [r3, #8]
 8007eaa:	405a      	eors	r2, r3
 8007eac:	4b1a      	ldr	r3, [pc, #104]	; (8007f18 <FreeRTOS_IPInit+0x1ec>)
 8007eae:	685b      	ldr	r3, [r3, #4]
 8007eb0:	4013      	ands	r3, r2
 8007eb2:	2b00      	cmp	r3, #0
 8007eb4:	d009      	beq.n	8007eca <FreeRTOS_IPInit+0x19e>
 8007eb6:	f04f 0350 	mov.w	r3, #80	; 0x50
 8007eba:	f383 8811 	msr	BASEPRI, r3
 8007ebe:	f3bf 8f6f 	isb	sy
 8007ec2:	f3bf 8f4f 	dsb	sy
 8007ec6:	613b      	str	r3, [r7, #16]
 8007ec8:	e7fe      	b.n	8007ec8 <FreeRTOS_IPInit+0x19c>
			}
			#endif /* ipconfigUSE_DHCP == 1 */

			/* The MAC address is stored in the start of the default packet
			header fragment, which is used when sending UDP packets. */
			memcpy( ( void * ) ipLOCAL_MAC_ADDRESS, ( void * ) ucMACAddress, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8007eca:	4815      	ldr	r0, [pc, #84]	; (8007f20 <FreeRTOS_IPInit+0x1f4>)
 8007ecc:	6b39      	ldr	r1, [r7, #48]	; 0x30
 8007ece:	2206      	movs	r2, #6
 8007ed0:	f008 f8ea 	bl	80100a8 <memcpy>

			/* Prepare the sockets interface. */
			vNetworkSocketsInit();
 8007ed4:	f000 fee2 	bl	8008c9c <vNetworkSocketsInit>

			/* Create the task that processes Ethernet and stack events. */
			xReturn = xTaskCreate( prvIPTask, "IP-task", ( uint16_t ) ipconfigIP_TASK_STACK_SIZE_WORDS, NULL, ( UBaseType_t ) ipconfigIP_TASK_PRIORITY, &xIPTaskHandle );
 8007ed8:	2305      	movs	r3, #5
 8007eda:	9300      	str	r3, [sp, #0]
 8007edc:	4b0c      	ldr	r3, [pc, #48]	; (8007f10 <FreeRTOS_IPInit+0x1e4>)
 8007ede:	9301      	str	r3, [sp, #4]
 8007ee0:	4810      	ldr	r0, [pc, #64]	; (8007f24 <FreeRTOS_IPInit+0x1f8>)
 8007ee2:	4911      	ldr	r1, [pc, #68]	; (8007f28 <FreeRTOS_IPInit+0x1fc>)
 8007ee4:	f44f 7220 	mov.w	r2, #640	; 0x280
 8007ee8:	2300      	movs	r3, #0
 8007eea:	f7fd f825 	bl	8004f38 <xTaskCreate>
 8007eee:	6278      	str	r0, [r7, #36]	; 0x24
 8007ef0:	e007      	b.n	8007f02 <FreeRTOS_IPInit+0x1d6>
		else
		{
			FreeRTOS_debug_printf( ( "FreeRTOS_IPInit: xNetworkBuffersInitialise() failed\n") );

			/* Clean up. */
			vQueueDelete( xNetworkEventQueue );
 8007ef2:	4b06      	ldr	r3, [pc, #24]	; (8007f0c <FreeRTOS_IPInit+0x1e0>)
 8007ef4:	681b      	ldr	r3, [r3, #0]
 8007ef6:	4618      	mov	r0, r3
 8007ef8:	f7fc fe8e 	bl	8004c18 <vQueueDelete>
			xNetworkEventQueue = NULL;
 8007efc:	4b03      	ldr	r3, [pc, #12]	; (8007f0c <FreeRTOS_IPInit+0x1e0>)
 8007efe:	2200      	movs	r2, #0
 8007f00:	601a      	str	r2, [r3, #0]
	else
	{
		FreeRTOS_debug_printf( ( "FreeRTOS_IPInit: Network event queue could not be created\n") );
	}

	return xReturn;
 8007f02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8007f04:	4618      	mov	r0, r3
 8007f06:	3728      	adds	r7, #40	; 0x28
 8007f08:	46bd      	mov	sp, r7
 8007f0a:	bd80      	pop	{r7, pc}
 8007f0c:	2000c1bc 	.word	0x2000c1bc
 8007f10:	2000c1f0 	.word	0x2000c1f0
 8007f14:	0801262c 	.word	0x0801262c
 8007f18:	2000c1c4 	.word	0x2000c1c4
 8007f1c:	2000c1d8 	.word	0x2000c1d8
 8007f20:	2000bb08 	.word	0x2000bb08
 8007f24:	08007875 	.word	0x08007875
 8007f28:	08012634 	.word	0x08012634

08007f2c <FreeRTOS_GetAddressConfiguration>:
/*-----------------------------------------------------------*/

void FreeRTOS_GetAddressConfiguration( uint32_t *pulIPAddress, uint32_t *pulNetMask, uint32_t *pulGatewayAddress, uint32_t *pulDNSServerAddress )
{
 8007f2c:	b480      	push	{r7}
 8007f2e:	b085      	sub	sp, #20
 8007f30:	af00      	add	r7, sp, #0
 8007f32:	60f8      	str	r0, [r7, #12]
 8007f34:	60b9      	str	r1, [r7, #8]
 8007f36:	607a      	str	r2, [r7, #4]
 8007f38:	603b      	str	r3, [r7, #0]
	/* Return the address configuration to the caller. */

	if( pulIPAddress != NULL )
 8007f3a:	68fb      	ldr	r3, [r7, #12]
 8007f3c:	2b00      	cmp	r3, #0
 8007f3e:	d003      	beq.n	8007f48 <FreeRTOS_GetAddressConfiguration+0x1c>
	{
		*pulIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 8007f40:	4b0e      	ldr	r3, [pc, #56]	; (8007f7c <FreeRTOS_GetAddressConfiguration+0x50>)
 8007f42:	695a      	ldr	r2, [r3, #20]
 8007f44:	68fb      	ldr	r3, [r7, #12]
 8007f46:	601a      	str	r2, [r3, #0]
	}

	if( pulNetMask != NULL )
 8007f48:	68bb      	ldr	r3, [r7, #8]
 8007f4a:	2b00      	cmp	r3, #0
 8007f4c:	d003      	beq.n	8007f56 <FreeRTOS_GetAddressConfiguration+0x2a>
	{
		*pulNetMask = xNetworkAddressing.ulNetMask;
 8007f4e:	4b0c      	ldr	r3, [pc, #48]	; (8007f80 <FreeRTOS_GetAddressConfiguration+0x54>)
 8007f50:	685a      	ldr	r2, [r3, #4]
 8007f52:	68bb      	ldr	r3, [r7, #8]
 8007f54:	601a      	str	r2, [r3, #0]
	}

	if( pulGatewayAddress != NULL )
 8007f56:	687b      	ldr	r3, [r7, #4]
 8007f58:	2b00      	cmp	r3, #0
 8007f5a:	d003      	beq.n	8007f64 <FreeRTOS_GetAddressConfiguration+0x38>
	{
		*pulGatewayAddress = xNetworkAddressing.ulGatewayAddress;
 8007f5c:	4b08      	ldr	r3, [pc, #32]	; (8007f80 <FreeRTOS_GetAddressConfiguration+0x54>)
 8007f5e:	689a      	ldr	r2, [r3, #8]
 8007f60:	687b      	ldr	r3, [r7, #4]
 8007f62:	601a      	str	r2, [r3, #0]
	}

	if( pulDNSServerAddress != NULL )
 8007f64:	683b      	ldr	r3, [r7, #0]
 8007f66:	2b00      	cmp	r3, #0
 8007f68:	d003      	beq.n	8007f72 <FreeRTOS_GetAddressConfiguration+0x46>
	{
		*pulDNSServerAddress = xNetworkAddressing.ulDNSServerAddress;
 8007f6a:	4b05      	ldr	r3, [pc, #20]	; (8007f80 <FreeRTOS_GetAddressConfiguration+0x54>)
 8007f6c:	68da      	ldr	r2, [r3, #12]
 8007f6e:	683b      	ldr	r3, [r7, #0]
 8007f70:	601a      	str	r2, [r3, #0]
	}
}
 8007f72:	3714      	adds	r7, #20
 8007f74:	46bd      	mov	sp, r7
 8007f76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007f7a:	4770      	bx	lr
 8007f7c:	2000bb08 	.word	0x2000bb08
 8007f80:	2000c1c4 	.word	0x2000c1c4

08007f84 <xSendEventToIPTask>:

#endif /* ipconfigSUPPORT_OUTGOING_PINGS == 1 */
/*-----------------------------------------------------------*/

BaseType_t xSendEventToIPTask( eIPEvent_t eEvent )
{
 8007f84:	b580      	push	{r7, lr}
 8007f86:	b086      	sub	sp, #24
 8007f88:	af00      	add	r7, sp, #0
 8007f8a:	4603      	mov	r3, r0
 8007f8c:	71fb      	strb	r3, [r7, #7]
IPStackEvent_t xEventMessage;
const TickType_t xDontBlock = ( TickType_t ) 0;
 8007f8e:	2300      	movs	r3, #0
 8007f90:	617b      	str	r3, [r7, #20]

	xEventMessage.eEventType = eEvent;
 8007f92:	79fb      	ldrb	r3, [r7, #7]
 8007f94:	733b      	strb	r3, [r7, #12]
	xEventMessage.pvData = ( void* )NULL;
 8007f96:	2300      	movs	r3, #0
 8007f98:	613b      	str	r3, [r7, #16]

	return xSendEventStructToIPTask( &xEventMessage, xDontBlock );
 8007f9a:	f107 030c 	add.w	r3, r7, #12
 8007f9e:	4618      	mov	r0, r3
 8007fa0:	6979      	ldr	r1, [r7, #20]
 8007fa2:	f000 f805 	bl	8007fb0 <xSendEventStructToIPTask>
 8007fa6:	4603      	mov	r3, r0
}
 8007fa8:	4618      	mov	r0, r3
 8007faa:	3718      	adds	r7, #24
 8007fac:	46bd      	mov	sp, r7
 8007fae:	bd80      	pop	{r7, pc}

08007fb0 <xSendEventStructToIPTask>:
/*-----------------------------------------------------------*/

BaseType_t xSendEventStructToIPTask( const IPStackEvent_t *pxEvent, TickType_t xTimeout )
{
 8007fb0:	b580      	push	{r7, lr}
 8007fb2:	b084      	sub	sp, #16
 8007fb4:	af00      	add	r7, sp, #0
 8007fb6:	6078      	str	r0, [r7, #4]
 8007fb8:	6039      	str	r1, [r7, #0]
BaseType_t xReturn, xSendMessage;

	if( ( xIPIsNetworkTaskReady() == pdFALSE ) && ( pxEvent->eEventType != eNetworkDownEvent ) )
 8007fba:	f000 fac9 	bl	8008550 <xIPIsNetworkTaskReady>
 8007fbe:	4603      	mov	r3, r0
 8007fc0:	2b00      	cmp	r3, #0
 8007fc2:	d106      	bne.n	8007fd2 <xSendEventStructToIPTask+0x22>
 8007fc4:	687b      	ldr	r3, [r7, #4]
 8007fc6:	781b      	ldrb	r3, [r3, #0]
 8007fc8:	2b00      	cmp	r3, #0
 8007fca:	d002      	beq.n	8007fd2 <xSendEventStructToIPTask+0x22>
	{
		/* Only allow eNetworkDownEvent events if the IP task is not ready
		yet.  Not going to attempt to send the message so the send failed. */
		xReturn = pdFAIL;
 8007fcc:	2300      	movs	r3, #0
 8007fce:	60fb      	str	r3, [r7, #12]
 8007fd0:	e02e      	b.n	8008030 <xSendEventStructToIPTask+0x80>
	}
	else
	{
		xSendMessage = pdTRUE;
 8007fd2:	2301      	movs	r3, #1
 8007fd4:	60bb      	str	r3, [r7, #8]

		#if( ipconfigUSE_TCP == 1 )
		{
			if( pxEvent->eEventType == eTCPTimerEvent )
 8007fd6:	687b      	ldr	r3, [r7, #4]
 8007fd8:	781b      	ldrb	r3, [r3, #0]
 8007fda:	b25b      	sxtb	r3, r3
 8007fdc:	2b05      	cmp	r3, #5
 8007fde:	d10e      	bne.n	8007ffe <xSendEventStructToIPTask+0x4e>
			{
				/* TCP timer events are sent to wake the timer task when
				xTCPTimer has expired, but there is no point sending them if the
				IP task is already awake processing other message. */
				xTCPTimer.bExpired = pdTRUE_UNSIGNED;
 8007fe0:	4a16      	ldr	r2, [pc, #88]	; (800803c <xSendEventStructToIPTask+0x8c>)
 8007fe2:	7813      	ldrb	r3, [r2, #0]
 8007fe4:	f043 0302 	orr.w	r3, r3, #2
 8007fe8:	7013      	strb	r3, [r2, #0]

				if( uxQueueMessagesWaiting( xNetworkEventQueue ) != 0u )
 8007fea:	4b15      	ldr	r3, [pc, #84]	; (8008040 <xSendEventStructToIPTask+0x90>)
 8007fec:	681b      	ldr	r3, [r3, #0]
 8007fee:	4618      	mov	r0, r3
 8007ff0:	f7fc fdf4 	bl	8004bdc <uxQueueMessagesWaiting>
 8007ff4:	4603      	mov	r3, r0
 8007ff6:	2b00      	cmp	r3, #0
 8007ff8:	d001      	beq.n	8007ffe <xSendEventStructToIPTask+0x4e>
				{
					/* Not actually going to send the message but this is not a
					failure as the message didn't need to be sent. */
					xSendMessage = pdFALSE;
 8007ffa:	2300      	movs	r3, #0
 8007ffc:	60bb      	str	r3, [r7, #8]
				}
			}
		}
		#endif /* ipconfigUSE_TCP */

		if( xSendMessage != pdFALSE )
 8007ffe:	68bb      	ldr	r3, [r7, #8]
 8008000:	2b00      	cmp	r3, #0
 8008002:	d013      	beq.n	800802c <xSendEventStructToIPTask+0x7c>
		{
			/* The IP task cannot block itself while waiting for itself to
			respond. */
			if( ( xIsCallingFromIPTask() == pdTRUE ) && ( xTimeout > ( TickType_t ) 0 ) )
 8008004:	f7ff fcea 	bl	80079dc <xIsCallingFromIPTask>
 8008008:	4603      	mov	r3, r0
 800800a:	2b01      	cmp	r3, #1
 800800c:	d104      	bne.n	8008018 <xSendEventStructToIPTask+0x68>
 800800e:	683b      	ldr	r3, [r7, #0]
 8008010:	2b00      	cmp	r3, #0
 8008012:	d001      	beq.n	8008018 <xSendEventStructToIPTask+0x68>
			{
				xTimeout = ( TickType_t ) 0;
 8008014:	2300      	movs	r3, #0
 8008016:	603b      	str	r3, [r7, #0]
			}

			xReturn = xQueueSendToBack( xNetworkEventQueue, pxEvent, xTimeout );
 8008018:	4b09      	ldr	r3, [pc, #36]	; (8008040 <xSendEventStructToIPTask+0x90>)
 800801a:	681b      	ldr	r3, [r3, #0]
 800801c:	4618      	mov	r0, r3
 800801e:	6879      	ldr	r1, [r7, #4]
 8008020:	683a      	ldr	r2, [r7, #0]
 8008022:	2300      	movs	r3, #0
 8008024:	f7fc fb56 	bl	80046d4 <xQueueGenericSend>
 8008028:	60f8      	str	r0, [r7, #12]
 800802a:	e001      	b.n	8008030 <xSendEventStructToIPTask+0x80>
		}
		else
		{
			/* It was not necessary to send the message to process the event so
			even though the message was not sent the call was successful. */
			xReturn = pdPASS;
 800802c:	2301      	movs	r3, #1
 800802e:	60fb      	str	r3, [r7, #12]
		}
	}

	return xReturn;
 8008030:	68fb      	ldr	r3, [r7, #12]
}
 8008032:	4618      	mov	r0, r3
 8008034:	3710      	adds	r7, #16
 8008036:	46bd      	mov	sp, r7
 8008038:	bd80      	pop	{r7, pc}
 800803a:	bf00      	nop
 800803c:	2000c210 	.word	0x2000c210
 8008040:	2000c1bc 	.word	0x2000c1bc

08008044 <prvProcessNetworkDownEvent>:
	return eReturn;
}
/*-----------------------------------------------------------*/

static void prvProcessNetworkDownEvent( void )
{
 8008044:	b580      	push	{r7, lr}
 8008046:	af00      	add	r7, sp, #0
	/* Stop the ARP timer while there is no network. */
	xARPTimer.bActive = pdFALSE_UNSIGNED;
 8008048:	4a0e      	ldr	r2, [pc, #56]	; (8008084 <prvProcessNetworkDownEvent+0x40>)
 800804a:	7813      	ldrb	r3, [r2, #0]
 800804c:	f36f 0300 	bfc	r3, #0, #1
 8008050:	7013      	strb	r3, [r2, #0]
		static BaseType_t xCallEventHook = pdFALSE;

		/* The first network down event is generated by the IP stack itself to
		initialise the network hardware, so do not call the network down event
		the first time through. */
		if( xCallEventHook == pdTRUE )
 8008052:	4b0d      	ldr	r3, [pc, #52]	; (8008088 <prvProcessNetworkDownEvent+0x44>)
 8008054:	681b      	ldr	r3, [r3, #0]
 8008056:	2b01      	cmp	r3, #1
 8008058:	d102      	bne.n	8008060 <prvProcessNetworkDownEvent+0x1c>
		{
			vApplicationIPNetworkEventHook( eNetworkDown );
 800805a:	2001      	movs	r0, #1
 800805c:	f007 f912 	bl	800f284 <vApplicationIPNetworkEventHook>
		}
		xCallEventHook = pdTRUE;
 8008060:	4b09      	ldr	r3, [pc, #36]	; (8008088 <prvProcessNetworkDownEvent+0x44>)
 8008062:	2201      	movs	r2, #1
 8008064:	601a      	str	r2, [r3, #0]
	#endif

	/* The network has been disconnected (or is being initialised for the first
	time).  Perform whatever hardware processing is necessary to bring it up
	again, or wait for it to be available again.  This is hardware dependent. */
	if( xNetworkInterfaceInitialise() != pdPASS )
 8008066:	f7fe fcef 	bl	8006a48 <xNetworkInterfaceInitialise>
 800806a:	4603      	mov	r3, r0
 800806c:	2b01      	cmp	r3, #1
 800806e:	d006      	beq.n	800807e <prvProcessNetworkDownEvent+0x3a>
	{
		/* Ideally the network interface initialisation function will only
		return when the network is available.  In case this is not the case,
		wait a while before retrying the initialisation. */
		vTaskDelay( ipINITIALISATION_RETRY_DELAY );
 8008070:	f640 30b8 	movw	r0, #3000	; 0xbb8
 8008074:	f7fd f8c8 	bl	8005208 <vTaskDelay>
		FreeRTOS_NetworkDown();
 8008078:	f7ff fdd0 	bl	8007c1c <FreeRTOS_NetworkDown>
 800807c:	e001      	b.n	8008082 <prvProcessNetworkDownEvent+0x3e>
			xSendEventToIPTask( eDHCPEvent );
		}
		#else
		{
			/* Perform any necessary 'network up' processing. */
			vIPNetworkUpCalls();
 800807e:	f000 f805 	bl	800808c <vIPNetworkUpCalls>
		}
		#endif
	}
}
 8008082:	bd80      	pop	{r7, pc}
 8008084:	2000c1fc 	.word	0x2000c1fc
 8008088:	2000c240 	.word	0x2000c240

0800808c <vIPNetworkUpCalls>:
/*-----------------------------------------------------------*/

void vIPNetworkUpCalls( void )
{
 800808c:	b580      	push	{r7, lr}
 800808e:	af00      	add	r7, sp, #0
	xNetworkUp = pdTRUE;
 8008090:	4b06      	ldr	r3, [pc, #24]	; (80080ac <vIPNetworkUpCalls+0x20>)
 8008092:	2201      	movs	r2, #1
 8008094:	601a      	str	r2, [r3, #0]

	#if( ipconfigUSE_NETWORK_EVENT_HOOK == 1 )
	{
		vApplicationIPNetworkEventHook( eNetworkUp );
 8008096:	2000      	movs	r0, #0
 8008098:	f007 f8f4 	bl	800f284 <vApplicationIPNetworkEventHook>
	#if( ipconfigDNS_USE_CALLBACKS != 0 )
	{
		/* The following function is declared in FreeRTOS_DNS.c	and 'private' to
		this library */
		extern void vDNSInitialise( void );
		vDNSInitialise();
 800809c:	f005 fd48 	bl	800db30 <vDNSInitialise>
	}
	#endif /* ipconfigDNS_USE_CALLBACKS != 0 */

	/* Set remaining time to 0 so it will become active immediately. */
	prvIPTimerReload( &xARPTimer, pdMS_TO_TICKS( ipARP_TIMER_PERIOD_MS ) );
 80080a0:	4803      	ldr	r0, [pc, #12]	; (80080b0 <vIPNetworkUpCalls+0x24>)
 80080a2:	f242 7110 	movw	r1, #10000	; 0x2710
 80080a6:	f7ff fd79 	bl	8007b9c <prvIPTimerReload>
}
 80080aa:	bd80      	pop	{r7, pc}
 80080ac:	2000c1f8 	.word	0x2000c1f8
 80080b0:	2000c1fc 	.word	0x2000c1fc

080080b4 <prvProcessEthernetPacket>:
/*-----------------------------------------------------------*/

static void prvProcessEthernetPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 80080b4:	b580      	push	{r7, lr}
 80080b6:	b086      	sub	sp, #24
 80080b8:	af00      	add	r7, sp, #0
 80080ba:	6078      	str	r0, [r7, #4]
EthernetHeader_t *pxEthernetHeader;
volatile eFrameProcessingResult_t eReturned; /* Volatile to prevent complier warnings when ipCONSIDER_FRAME_FOR_PROCESSING just sets it to eProcessBuffer. */

	configASSERT( pxNetworkBuffer );
 80080bc:	687b      	ldr	r3, [r7, #4]
 80080be:	2b00      	cmp	r3, #0
 80080c0:	d109      	bne.n	80080d6 <prvProcessEthernetPacket+0x22>
 80080c2:	f04f 0350 	mov.w	r3, #80	; 0x50
 80080c6:	f383 8811 	msr	BASEPRI, r3
 80080ca:	f3bf 8f6f 	isb	sy
 80080ce:	f3bf 8f4f 	dsb	sy
 80080d2:	613b      	str	r3, [r7, #16]
 80080d4:	e7fe      	b.n	80080d4 <prvProcessEthernetPacket+0x20>

	/* Interpret the Ethernet frame. */
	eReturned = ipCONSIDER_FRAME_FOR_PROCESSING( pxNetworkBuffer->pucEthernetBuffer );
 80080d6:	2301      	movs	r3, #1
 80080d8:	73fb      	strb	r3, [r7, #15]
	pxEthernetHeader = ( EthernetHeader_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 80080da:	687b      	ldr	r3, [r7, #4]
 80080dc:	699b      	ldr	r3, [r3, #24]
 80080de:	617b      	str	r3, [r7, #20]

	if( eReturned == eProcessBuffer )
 80080e0:	7bfb      	ldrb	r3, [r7, #15]
 80080e2:	b2db      	uxtb	r3, r3
 80080e4:	2b01      	cmp	r3, #1
 80080e6:	d11b      	bne.n	8008120 <prvProcessEthernetPacket+0x6c>
	{
		/* Interpret the received Ethernet packet. */
		switch( pxEthernetHeader->usFrameType )
 80080e8:	697b      	ldr	r3, [r7, #20]
 80080ea:	899b      	ldrh	r3, [r3, #12]
 80080ec:	b29b      	uxth	r3, r3
 80080ee:	2b08      	cmp	r3, #8
 80080f0:	d00a      	beq.n	8008108 <prvProcessEthernetPacket+0x54>
 80080f2:	f5b3 6fc1 	cmp.w	r3, #1544	; 0x608
 80080f6:	d110      	bne.n	800811a <prvProcessEthernetPacket+0x66>
		{
			case ipARP_FRAME_TYPE :
				/* The Ethernet frame contains an ARP packet. */
				eReturned = eARPProcessPacket( ( ARPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer );
 80080f8:	687b      	ldr	r3, [r7, #4]
 80080fa:	699b      	ldr	r3, [r3, #24]
 80080fc:	4618      	mov	r0, r3
 80080fe:	f000 fa33 	bl	8008568 <eARPProcessPacket>
 8008102:	4603      	mov	r3, r0
 8008104:	73fb      	strb	r3, [r7, #15]
				break;
 8008106:	e00b      	b.n	8008120 <prvProcessEthernetPacket+0x6c>

			case ipIPv4_FRAME_TYPE :
				/* The Ethernet frame contains an IP packet. */
				eReturned = prvProcessIPPacket( ( IPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer );
 8008108:	687b      	ldr	r3, [r7, #4]
 800810a:	699b      	ldr	r3, [r3, #24]
 800810c:	4618      	mov	r0, r3
 800810e:	6879      	ldr	r1, [r7, #4]
 8008110:	f000 f866 	bl	80081e0 <prvProcessIPPacket>
 8008114:	4603      	mov	r3, r0
 8008116:	73fb      	strb	r3, [r7, #15]
				break;
 8008118:	e002      	b.n	8008120 <prvProcessEthernetPacket+0x6c>

			default :
				/* No other packet types are handled.  Nothing to do. */
				eReturned = eReleaseBuffer;
 800811a:	2300      	movs	r3, #0
 800811c:	73fb      	strb	r3, [r7, #15]
				break;
 800811e:	bf00      	nop
		}
	}

	/* Perform any actions that resulted from processing the Ethernet frame. */
	switch( eReturned )
 8008120:	7bfb      	ldrb	r3, [r7, #15]
 8008122:	b2db      	uxtb	r3, r3
 8008124:	2b02      	cmp	r3, #2
 8008126:	d002      	beq.n	800812e <prvProcessEthernetPacket+0x7a>
 8008128:	2b03      	cmp	r3, #3
 800812a:	d00a      	beq.n	8008142 <prvProcessEthernetPacket+0x8e>
 800812c:	e004      	b.n	8008138 <prvProcessEthernetPacket+0x84>
	{
		case eReturnEthernetFrame :
			/* The Ethernet frame will have been updated (maybe it was
			an ARP request or a PING request?) and should be sent back to
			its source. */
			vReturnEthernetFrame( pxNetworkBuffer, pdTRUE );
 800812e:	6878      	ldr	r0, [r7, #4]
 8008130:	2101      	movs	r1, #1
 8008132:	f000 f9b5 	bl	80084a0 <vReturnEthernetFrame>
			/* parameter pdTRUE: the buffer must be released once
			the frame has been transmitted */
			break;
 8008136:	e005      	b.n	8008144 <prvProcessEthernetPacket+0x90>

		default :
			/* The frame is not being used anywhere, and the
			NetworkBufferDescriptor_t structure containing the frame should
			just be	released back to the list of free buffers. */
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8008138:	6878      	ldr	r0, [r7, #4]
 800813a:	f7ff fb4f 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
			break;
 800813e:	bf00      	nop
 8008140:	e000      	b.n	8008144 <prvProcessEthernetPacket+0x90>
			break;

		case eFrameConsumed :
			/* The frame is in use somewhere, don't release the buffer
			yet. */
			break;
 8008142:	bf00      	nop
			NetworkBufferDescriptor_t structure containing the frame should
			just be	released back to the list of free buffers. */
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
			break;
	}
}
 8008144:	3718      	adds	r7, #24
 8008146:	46bd      	mov	sp, r7
 8008148:	bd80      	pop	{r7, pc}
 800814a:	bf00      	nop

0800814c <prvAllowIPPacket>:
/*-----------------------------------------------------------*/

static eFrameProcessingResult_t prvAllowIPPacket( const IPPacket_t * const pxIPPacket,
	NetworkBufferDescriptor_t * const pxNetworkBuffer, UBaseType_t uxHeaderLength )
{
 800814c:	b480      	push	{r7}
 800814e:	b089      	sub	sp, #36	; 0x24
 8008150:	af00      	add	r7, sp, #0
 8008152:	60f8      	str	r0, [r7, #12]
 8008154:	60b9      	str	r1, [r7, #8]
 8008156:	607a      	str	r2, [r7, #4]
eFrameProcessingResult_t eReturn = eProcessBuffer;
 8008158:	2301      	movs	r3, #1
 800815a:	77fb      	strb	r3, [r7, #31]

#if( ( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 0 ) || ( ipconfigDRIVER_INCLUDED_RX_IP_CHECKSUM == 0 ) )
	const IPHeader_t * pxIPHeader = &( pxIPPacket->xIPHeader );
 800815c:	68fb      	ldr	r3, [r7, #12]
 800815e:	330e      	adds	r3, #14
 8008160:	61bb      	str	r3, [r7, #24]
	#if( ipconfigETHERNET_DRIVER_FILTERS_PACKETS == 0 )
	{
		/* In systems with a very small amount of RAM, it might be advantageous
		to have incoming messages checked earlier, by the network card driver.
		This method may decrease the usage of sparse network buffers. */
		uint32_t ulDestinationIPAddress = pxIPHeader->ulDestinationIPAddress;
 8008162:	69bb      	ldr	r3, [r7, #24]
 8008164:	691b      	ldr	r3, [r3, #16]
 8008166:	617b      	str	r3, [r7, #20]

			/* Ensure that the incoming packet is not fragmented (only outgoing
			packets can be fragmented) as these are the only handled IP frames
			currently. */
			if( ( pxIPHeader->usFragmentOffset & ipFRAGMENT_OFFSET_BIT_MASK ) != 0U )
 8008168:	69bb      	ldr	r3, [r7, #24]
 800816a:	88db      	ldrh	r3, [r3, #6]
 800816c:	b29b      	uxth	r3, r3
 800816e:	461a      	mov	r2, r3
 8008170:	f64f 730f 	movw	r3, #65295	; 0xff0f
 8008174:	4013      	ands	r3, r2
 8008176:	2b00      	cmp	r3, #0
 8008178:	d002      	beq.n	8008180 <prvAllowIPPacket+0x34>
			{
				/* Can not handle, fragmented packet. */
				eReturn = eReleaseBuffer;
 800817a:	2300      	movs	r3, #0
 800817c:	77fb      	strb	r3, [r7, #31]
 800817e:	e022      	b.n	80081c6 <prvAllowIPPacket+0x7a>
			}
			/* 0x45 means: IPv4 with an IP header of 5 x 4 = 20 bytes
			 * 0x47 means: IPv4 with an IP header of 7 x 4 = 28 bytes */
			else if( ( pxIPHeader->ucVersionHeaderLength < 0x45u ) || ( pxIPHeader->ucVersionHeaderLength > 0x4Fu ) )
 8008180:	69bb      	ldr	r3, [r7, #24]
 8008182:	781b      	ldrb	r3, [r3, #0]
 8008184:	2b44      	cmp	r3, #68	; 0x44
 8008186:	d903      	bls.n	8008190 <prvAllowIPPacket+0x44>
 8008188:	69bb      	ldr	r3, [r7, #24]
 800818a:	781b      	ldrb	r3, [r3, #0]
 800818c:	2b4f      	cmp	r3, #79	; 0x4f
 800818e:	d902      	bls.n	8008196 <prvAllowIPPacket+0x4a>
			{
				/* Can not handle, unknown or invalid header version. */
				eReturn = eReleaseBuffer;
 8008190:	2300      	movs	r3, #0
 8008192:	77fb      	strb	r3, [r7, #31]
 8008194:	e017      	b.n	80081c6 <prvAllowIPPacket+0x7a>
			}
				/* Is the packet for this IP address? */
			else if( ( ulDestinationIPAddress != *ipLOCAL_IP_ADDRESS_POINTER ) &&
 8008196:	4b0f      	ldr	r3, [pc, #60]	; (80081d4 <prvAllowIPPacket+0x88>)
 8008198:	695a      	ldr	r2, [r3, #20]
 800819a:	697b      	ldr	r3, [r7, #20]
 800819c:	429a      	cmp	r2, r3
 800819e:	d012      	beq.n	80081c6 <prvAllowIPPacket+0x7a>
 80081a0:	697b      	ldr	r3, [r7, #20]
 80081a2:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 80081a6:	d00e      	beq.n	80081c6 <prvAllowIPPacket+0x7a>
				/* Is it the global broadcast address 255.255.255.255 ? */
				( ulDestinationIPAddress != ipBROADCAST_IP_ADDRESS ) &&
				/* Is it a specific broadcast address 192.168.1.255 ? */
				( ulDestinationIPAddress != xNetworkAddressing.ulBroadcastAddress ) &&
 80081a8:	4b0b      	ldr	r3, [pc, #44]	; (80081d8 <prvAllowIPPacket+0x8c>)
 80081aa:	691a      	ldr	r2, [r3, #16]
				eReturn = eReleaseBuffer;
			}
				/* Is the packet for this IP address? */
			else if( ( ulDestinationIPAddress != *ipLOCAL_IP_ADDRESS_POINTER ) &&
				/* Is it the global broadcast address 255.255.255.255 ? */
				( ulDestinationIPAddress != ipBROADCAST_IP_ADDRESS ) &&
 80081ac:	697b      	ldr	r3, [r7, #20]
 80081ae:	429a      	cmp	r2, r3
 80081b0:	d009      	beq.n	80081c6 <prvAllowIPPacket+0x7a>
				/* Is it a specific broadcast address 192.168.1.255 ? */
				( ulDestinationIPAddress != xNetworkAddressing.ulBroadcastAddress ) &&
 80081b2:	697b      	ldr	r3, [r7, #20]
 80081b4:	4a09      	ldr	r2, [pc, #36]	; (80081dc <prvAllowIPPacket+0x90>)
 80081b6:	4293      	cmp	r3, r2
 80081b8:	d005      	beq.n	80081c6 <prvAllowIPPacket+0x7a>
			#if( ipconfigUSE_LLMNR == 1 )
				/* Is it the LLMNR multicast address? */
				( ulDestinationIPAddress != ipLLMNR_IP_ADDR ) &&
			#endif
				/* Or (during DHCP negotiation) we have no IP-address yet? */
				( *ipLOCAL_IP_ADDRESS_POINTER != 0UL ) )
 80081ba:	4b06      	ldr	r3, [pc, #24]	; (80081d4 <prvAllowIPPacket+0x88>)
 80081bc:	695b      	ldr	r3, [r3, #20]
				( ulDestinationIPAddress != ipBROADCAST_IP_ADDRESS ) &&
				/* Is it a specific broadcast address 192.168.1.255 ? */
				( ulDestinationIPAddress != xNetworkAddressing.ulBroadcastAddress ) &&
			#if( ipconfigUSE_LLMNR == 1 )
				/* Is it the LLMNR multicast address? */
				( ulDestinationIPAddress != ipLLMNR_IP_ADDR ) &&
 80081be:	2b00      	cmp	r3, #0
 80081c0:	d001      	beq.n	80081c6 <prvAllowIPPacket+0x7a>
			#endif
				/* Or (during DHCP negotiation) we have no IP-address yet? */
				( *ipLOCAL_IP_ADDRESS_POINTER != 0UL ) )
			{
				/* Packet is not for this node, release it */
				eReturn = eReleaseBuffer;
 80081c2:	2300      	movs	r3, #0
 80081c4:	77fb      	strb	r3, [r7, #31]
		( void ) pxNetworkBuffer;
		( void ) uxHeaderLength;
	}
	#endif /* ipconfigDRIVER_INCLUDED_RX_IP_CHECKSUM == 0 */

	return eReturn;
 80081c6:	7ffb      	ldrb	r3, [r7, #31]
}
 80081c8:	4618      	mov	r0, r3
 80081ca:	3724      	adds	r7, #36	; 0x24
 80081cc:	46bd      	mov	sp, r7
 80081ce:	f85d 7b04 	ldr.w	r7, [sp], #4
 80081d2:	4770      	bx	lr
 80081d4:	2000bb08 	.word	0x2000bb08
 80081d8:	2000c1c4 	.word	0x2000c1c4
 80081dc:	fc0000e0 	.word	0xfc0000e0

080081e0 <prvProcessIPPacket>:
/*-----------------------------------------------------------*/

static eFrameProcessingResult_t prvProcessIPPacket( const IPPacket_t * const pxIPPacket, NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 80081e0:	b580      	push	{r7, lr}
 80081e2:	b08c      	sub	sp, #48	; 0x30
 80081e4:	af00      	add	r7, sp, #0
 80081e6:	6078      	str	r0, [r7, #4]
 80081e8:	6039      	str	r1, [r7, #0]
eFrameProcessingResult_t eReturn;
const IPHeader_t * pxIPHeader = &( pxIPPacket->xIPHeader );
 80081ea:	687b      	ldr	r3, [r7, #4]
 80081ec:	330e      	adds	r3, #14
 80081ee:	62bb      	str	r3, [r7, #40]	; 0x28
UBaseType_t uxHeaderLength = ( UBaseType_t ) ( ( pxIPHeader->ucVersionHeaderLength & 0x0Fu ) << 2 );
 80081f0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80081f2:	781b      	ldrb	r3, [r3, #0]
 80081f4:	f003 030f 	and.w	r3, r3, #15
 80081f8:	009b      	lsls	r3, r3, #2
 80081fa:	627b      	str	r3, [r7, #36]	; 0x24
uint8_t ucProtocol;

	ucProtocol = pxIPPacket->xIPHeader.ucProtocol;
 80081fc:	687b      	ldr	r3, [r7, #4]
 80081fe:	7ddb      	ldrb	r3, [r3, #23]
 8008200:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
	/* Check if the IP headers are acceptable and if it has our destination. */
	eReturn = prvAllowIPPacket( pxIPPacket, pxNetworkBuffer, uxHeaderLength );
 8008204:	6878      	ldr	r0, [r7, #4]
 8008206:	6839      	ldr	r1, [r7, #0]
 8008208:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800820a:	f7ff ff9f 	bl	800814c <prvAllowIPPacket>
 800820e:	4603      	mov	r3, r0
 8008210:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f

	if( eReturn == eProcessBuffer )
 8008214:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
 8008218:	2b01      	cmp	r3, #1
 800821a:	f040 8081 	bne.w	8008320 <prvProcessIPPacket+0x140>
	{
		if( uxHeaderLength > ipSIZE_OF_IPv4_HEADER )
 800821e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008220:	2b14      	cmp	r3, #20
 8008222:	d91a      	bls.n	800825a <prvProcessIPPacket+0x7a>
		{
			/* All structs of headers expect a IP header size of 20 bytes
			 * IP header options were included, we'll ignore them and cut them out
			 * Note: IP options are mostly use in Multi-cast protocols */
			const size_t optlen = ( ( size_t ) uxHeaderLength ) - ipSIZE_OF_IPv4_HEADER;
 8008224:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008226:	3b14      	subs	r3, #20
 8008228:	61fb      	str	r3, [r7, #28]
			/* From: the previous start of UDP/ICMP/TCP data */
			uint8_t *pucSource = ( ( uint8_t * ) pxIPHeader ) + uxHeaderLength;
 800822a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800822c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800822e:	4413      	add	r3, r2
 8008230:	61bb      	str	r3, [r7, #24]
			/* To: the usual start of UDP/ICMP/TCP data at offset 20 from IP header */
			uint8_t *pucTarget = ( ( uint8_t * ) pxIPHeader ) + ipSIZE_OF_IPv4_HEADER;
 8008232:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008234:	3314      	adds	r3, #20
 8008236:	617b      	str	r3, [r7, #20]
			/* How many: total length minus the options and the lower headers */
			const size_t  xMoveLen = pxNetworkBuffer->xDataLength - optlen - ipSIZE_OF_IPv4_HEADER - ipSIZE_OF_ETH_HEADER;
 8008238:	683b      	ldr	r3, [r7, #0]
 800823a:	69da      	ldr	r2, [r3, #28]
 800823c:	69fb      	ldr	r3, [r7, #28]
 800823e:	1ad3      	subs	r3, r2, r3
 8008240:	3b22      	subs	r3, #34	; 0x22
 8008242:	613b      	str	r3, [r7, #16]

			memmove( pucTarget, pucSource, xMoveLen );
 8008244:	6978      	ldr	r0, [r7, #20]
 8008246:	69b9      	ldr	r1, [r7, #24]
 8008248:	693a      	ldr	r2, [r7, #16]
 800824a:	f00a f87b 	bl	8012344 <memmove>
			pxNetworkBuffer->xDataLength -= optlen;
 800824e:	683b      	ldr	r3, [r7, #0]
 8008250:	69da      	ldr	r2, [r3, #28]
 8008252:	69fb      	ldr	r3, [r7, #28]
 8008254:	1ad2      	subs	r2, r2, r3
 8008256:	683b      	ldr	r3, [r7, #0]
 8008258:	61da      	str	r2, [r3, #28]
		}
		/* Add the IP and MAC addresses to the ARP table if they are not
		already there - otherwise refresh the age of the existing
		entry. */
		if( ucProtocol != ( uint8_t ) ipPROTOCOL_UDP )
 800825a:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800825e:	2b11      	cmp	r3, #17
 8008260:	d007      	beq.n	8008272 <prvProcessIPPacket+0x92>
			 * For UDP packets, this will be done later in xProcessReceivedUDPPacket()
			 * as soon as know that the message will be handled by someone
			 * This will prevent that the ARP cache will get overwritten
			 * with the IP-address of useless broadcast packets
			 */
			vARPRefreshCacheEntry( &( pxIPPacket->xEthernetHeader.xSourceAddress ), pxIPHeader->ulSourceIPAddress );
 8008262:	687b      	ldr	r3, [r7, #4]
 8008264:	1d9a      	adds	r2, r3, #6
 8008266:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8008268:	68db      	ldr	r3, [r3, #12]
 800826a:	4610      	mov	r0, r2
 800826c:	4619      	mov	r1, r3
 800826e:	f000 f9fb 	bl	8008668 <vARPRefreshCacheEntry>
		}
		switch( ucProtocol )
 8008272:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8008276:	2b06      	cmp	r3, #6
 8008278:	d043      	beq.n	8008302 <prvProcessIPPacket+0x122>
 800827a:	2b11      	cmp	r3, #17
 800827c:	d013      	beq.n	80082a6 <prvProcessIPPacket+0xc6>
 800827e:	2b01      	cmp	r3, #1
 8008280:	d000      	beq.n	8008284 <prvProcessIPPacket+0xa4>
				}
				break;
#endif
			default	:
				/* Not a supported frame type. */
				break;
 8008282:	e04d      	b.n	8008320 <prvProcessIPPacket+0x140>
				wrong data will also be returned, and the source of the
				ping will know something went wrong because it will not
				be able to validate what it receives. */
				#if ( ipconfigREPLY_TO_INCOMING_PINGS == 1 ) || ( ipconfigSUPPORT_OUTGOING_PINGS == 1 )
				{
					ICMPPacket_t *pxICMPPacket = ( ICMPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 8008284:	683b      	ldr	r3, [r7, #0]
 8008286:	699b      	ldr	r3, [r3, #24]
 8008288:	60fb      	str	r3, [r7, #12]
					if( pxIPHeader->ulDestinationIPAddress == *ipLOCAL_IP_ADDRESS_POINTER )
 800828a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800828c:	691a      	ldr	r2, [r3, #16]
 800828e:	4b27      	ldr	r3, [pc, #156]	; (800832c <prvProcessIPPacket+0x14c>)
 8008290:	695b      	ldr	r3, [r3, #20]
 8008292:	429a      	cmp	r2, r3
 8008294:	d106      	bne.n	80082a4 <prvProcessIPPacket+0xc4>
					{
						eReturn = prvProcessICMPPacket( pxICMPPacket );
 8008296:	68f8      	ldr	r0, [r7, #12]
 8008298:	f000 f8e4 	bl	8008464 <prvProcessICMPPacket>
 800829c:	4603      	mov	r3, r0
 800829e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
					}
				}
				#endif /* ( ipconfigREPLY_TO_INCOMING_PINGS == 1 ) || ( ipconfigSUPPORT_OUTGOING_PINGS == 1 ) */
				break;
 80082a2:	e03d      	b.n	8008320 <prvProcessIPPacket+0x140>
 80082a4:	e03c      	b.n	8008320 <prvProcessIPPacket+0x140>

			case ipPROTOCOL_UDP :
				{
					/* The IP packet contained a UDP frame. */
					UDPPacket_t *pxUDPPacket = ( UDPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 80082a6:	683b      	ldr	r3, [r7, #0]
 80082a8:	699b      	ldr	r3, [r3, #24]
 80082aa:	60bb      	str	r3, [r7, #8]

					/* Note the header values required prior to the
					checksum generation as the checksum pseudo header
					may clobber some of these values. */
					pxNetworkBuffer->xDataLength = FreeRTOS_ntohs( pxUDPPacket->xUDPHeader.usLength ) - sizeof( UDPHeader_t );
 80082ac:	68bb      	ldr	r3, [r7, #8]
 80082ae:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 80082b0:	b29b      	uxth	r3, r3
 80082b2:	021b      	lsls	r3, r3, #8
 80082b4:	b29a      	uxth	r2, r3
 80082b6:	68bb      	ldr	r3, [r7, #8]
 80082b8:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 80082ba:	b29b      	uxth	r3, r3
 80082bc:	0a1b      	lsrs	r3, r3, #8
 80082be:	b29b      	uxth	r3, r3
 80082c0:	b29b      	uxth	r3, r3
 80082c2:	4313      	orrs	r3, r2
 80082c4:	b29b      	uxth	r3, r3
 80082c6:	b29b      	uxth	r3, r3
 80082c8:	f1a3 0208 	sub.w	r2, r3, #8
 80082cc:	683b      	ldr	r3, [r7, #0]
 80082ce:	61da      	str	r2, [r3, #28]
					/* HT:endian: fields in pxNetworkBuffer (usPort, ulIPAddress) were network order */
					pxNetworkBuffer->usPort = pxUDPPacket->xUDPHeader.usSourcePort;
 80082d0:	68bb      	ldr	r3, [r7, #8]
 80082d2:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 80082d4:	b29a      	uxth	r2, r3
 80082d6:	683b      	ldr	r3, [r7, #0]
 80082d8:	841a      	strh	r2, [r3, #32]
					pxNetworkBuffer->ulIPAddress = pxUDPPacket->xIPHeader.ulSourceIPAddress;
 80082da:	68bb      	ldr	r3, [r7, #8]
 80082dc:	f8d3 201a 	ldr.w	r2, [r3, #26]
 80082e0:	683b      	ldr	r3, [r7, #0]
 80082e2:	615a      	str	r2, [r3, #20]
					/* ipconfigDRIVER_INCLUDED_RX_IP_CHECKSUM:
					 * In some cases, the upper-layer checksum has been calculated
					 * by the NIC driver */
					/* Pass the packet payload to the UDP sockets implementation. */
					/* HT:endian: xProcessReceivedUDPPacket wanted network order */
					if( xProcessReceivedUDPPacket( pxNetworkBuffer, pxUDPPacket->xUDPHeader.usDestinationPort ) == pdPASS )
 80082e4:	68bb      	ldr	r3, [r7, #8]
 80082e6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 80082e8:	b29b      	uxth	r3, r3
 80082ea:	6838      	ldr	r0, [r7, #0]
 80082ec:	4619      	mov	r1, r3
 80082ee:	f001 ff65 	bl	800a1bc <xProcessReceivedUDPPacket>
 80082f2:	4603      	mov	r3, r0
 80082f4:	2b01      	cmp	r3, #1
 80082f6:	d103      	bne.n	8008300 <prvProcessIPPacket+0x120>
					{
						eReturn = eFrameConsumed;
 80082f8:	2303      	movs	r3, #3
 80082fa:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
					}
				}
				break;
 80082fe:	e00f      	b.n	8008320 <prvProcessIPPacket+0x140>
 8008300:	e00e      	b.n	8008320 <prvProcessIPPacket+0x140>

#if ipconfigUSE_TCP == 1
			case ipPROTOCOL_TCP :
				{

					if( xProcessReceivedTCPPacket( pxNetworkBuffer ) == pdPASS )
 8008302:	6838      	ldr	r0, [r7, #0]
 8008304:	f003 ffea 	bl	800c2dc <xProcessReceivedTCPPacket>
 8008308:	4603      	mov	r3, r0
 800830a:	2b01      	cmp	r3, #1
 800830c:	d102      	bne.n	8008314 <prvProcessIPPacket+0x134>
					{
						eReturn = eFrameConsumed;
 800830e:	2303      	movs	r3, #3
 8008310:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
					}

					/* Setting this variable will cause xTCPTimerCheck()
					to be called just before the IP-task blocks. */
					xProcessedTCPMessage++;
 8008314:	4b06      	ldr	r3, [pc, #24]	; (8008330 <prvProcessIPPacket+0x150>)
 8008316:	681b      	ldr	r3, [r3, #0]
 8008318:	3301      	adds	r3, #1
 800831a:	4a05      	ldr	r2, [pc, #20]	; (8008330 <prvProcessIPPacket+0x150>)
 800831c:	6013      	str	r3, [r2, #0]
				}
				break;
 800831e:	bf00      	nop
				/* Not a supported frame type. */
				break;
		}
	}

	return eReturn;
 8008320:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
}
 8008324:	4618      	mov	r0, r3
 8008326:	3730      	adds	r7, #48	; 0x30
 8008328:	46bd      	mov	sp, r7
 800832a:	bd80      	pop	{r7, pc}
 800832c:	2000bb08 	.word	0x2000bb08
 8008330:	2000c1f4 	.word	0x2000c1f4

08008334 <prvProcessICMPEchoReply>:
/*-----------------------------------------------------------*/

#if ( ipconfigSUPPORT_OUTGOING_PINGS == 1 )

	static void prvProcessICMPEchoReply( ICMPPacket_t * const pxICMPPacket )
	{
 8008334:	b580      	push	{r7, lr}
 8008336:	b086      	sub	sp, #24
 8008338:	af00      	add	r7, sp, #0
 800833a:	6078      	str	r0, [r7, #4]
	ePingReplyStatus_t eStatus = eSuccess;
 800833c:	2300      	movs	r3, #0
 800833e:	75fb      	strb	r3, [r7, #23]
	uint16_t usDataLength, usCount;
	uint8_t *pucByte;

		/* Find the total length of the IP packet. */
		usDataLength = pxICMPPacket->xIPHeader.usLength;
 8008340:	687b      	ldr	r3, [r7, #4]
 8008342:	7c1a      	ldrb	r2, [r3, #16]
 8008344:	7c5b      	ldrb	r3, [r3, #17]
 8008346:	021b      	lsls	r3, r3, #8
 8008348:	4313      	orrs	r3, r2
 800834a:	81fb      	strh	r3, [r7, #14]
		usDataLength = FreeRTOS_ntohs( usDataLength );
 800834c:	89fb      	ldrh	r3, [r7, #14]
 800834e:	021b      	lsls	r3, r3, #8
 8008350:	b29a      	uxth	r2, r3
 8008352:	89fb      	ldrh	r3, [r7, #14]
 8008354:	0a1b      	lsrs	r3, r3, #8
 8008356:	b29b      	uxth	r3, r3
 8008358:	b29b      	uxth	r3, r3
 800835a:	4313      	orrs	r3, r2
 800835c:	b29b      	uxth	r3, r3
 800835e:	81fb      	strh	r3, [r7, #14]

		/* Remove the length of the IP headers to obtain the length of the ICMP
		message itself. */
		usDataLength = ( uint16_t ) ( ( ( uint32_t ) usDataLength ) - ipSIZE_OF_IPv4_HEADER );
 8008360:	89fb      	ldrh	r3, [r7, #14]
 8008362:	3b14      	subs	r3, #20
 8008364:	81fb      	strh	r3, [r7, #14]

		/* Remove the length of the ICMP header, to obtain the length of
		data contained in the ping. */
		usDataLength = ( uint16_t ) ( ( ( uint32_t ) usDataLength ) - ipSIZE_OF_ICMP_HEADER );
 8008366:	89fb      	ldrh	r3, [r7, #14]
 8008368:	3b08      	subs	r3, #8
 800836a:	81fb      	strh	r3, [r7, #14]

		/* Checksum has already been checked before in prvProcessIPPacket */

		/* Find the first byte of the data within the ICMP packet. */
		pucByte = ( uint8_t * ) pxICMPPacket;
 800836c:	687b      	ldr	r3, [r7, #4]
 800836e:	613b      	str	r3, [r7, #16]
		pucByte += sizeof( ICMPPacket_t );
 8008370:	693b      	ldr	r3, [r7, #16]
 8008372:	332a      	adds	r3, #42	; 0x2a
 8008374:	613b      	str	r3, [r7, #16]

		/* Check each byte. */
		for( usCount = 0; usCount < usDataLength; usCount++ )
 8008376:	2300      	movs	r3, #0
 8008378:	82bb      	strh	r3, [r7, #20]
 800837a:	e00c      	b.n	8008396 <prvProcessICMPEchoReply+0x62>
		{
			if( *pucByte != ipECHO_DATA_FILL_BYTE )
 800837c:	693b      	ldr	r3, [r7, #16]
 800837e:	781b      	ldrb	r3, [r3, #0]
 8008380:	2b78      	cmp	r3, #120	; 0x78
 8008382:	d002      	beq.n	800838a <prvProcessICMPEchoReply+0x56>
			{
				eStatus = eInvalidData;
 8008384:	2302      	movs	r3, #2
 8008386:	75fb      	strb	r3, [r7, #23]
				break;
 8008388:	e009      	b.n	800839e <prvProcessICMPEchoReply+0x6a>
			}

			pucByte++;
 800838a:	693b      	ldr	r3, [r7, #16]
 800838c:	3301      	adds	r3, #1
 800838e:	613b      	str	r3, [r7, #16]
		/* Find the first byte of the data within the ICMP packet. */
		pucByte = ( uint8_t * ) pxICMPPacket;
		pucByte += sizeof( ICMPPacket_t );

		/* Check each byte. */
		for( usCount = 0; usCount < usDataLength; usCount++ )
 8008390:	8abb      	ldrh	r3, [r7, #20]
 8008392:	3301      	adds	r3, #1
 8008394:	82bb      	strh	r3, [r7, #20]
 8008396:	8aba      	ldrh	r2, [r7, #20]
 8008398:	89fb      	ldrh	r3, [r7, #14]
 800839a:	429a      	cmp	r2, r3
 800839c:	d3ee      	bcc.n	800837c <prvProcessICMPEchoReply+0x48>

			pucByte++;
		}

		/* Call back into the application to pass it the result. */
		vApplicationPingReplyHook( eStatus, pxICMPPacket->xICMPHeader.usIdentifier );
 800839e:	687b      	ldr	r3, [r7, #4]
 80083a0:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
 80083a2:	b29b      	uxth	r3, r3
 80083a4:	7dfa      	ldrb	r2, [r7, #23]
 80083a6:	4610      	mov	r0, r2
 80083a8:	4619      	mov	r1, r3
 80083aa:	f007 f86f 	bl	800f48c <vApplicationPingReplyHook>
	}
 80083ae:	3718      	adds	r7, #24
 80083b0:	46bd      	mov	sp, r7
 80083b2:	bd80      	pop	{r7, pc}

080083b4 <prvProcessICMPEchoRequest>:
/*-----------------------------------------------------------*/

#if ( ipconfigREPLY_TO_INCOMING_PINGS == 1 )

	static eFrameProcessingResult_t prvProcessICMPEchoRequest( ICMPPacket_t * const pxICMPPacket )
	{
 80083b4:	b480      	push	{r7}
 80083b6:	b087      	sub	sp, #28
 80083b8:	af00      	add	r7, sp, #0
 80083ba:	6078      	str	r0, [r7, #4]
	ICMPHeader_t *pxICMPHeader;
	IPHeader_t *pxIPHeader;
	uint16_t usRequest;

		pxICMPHeader = &( pxICMPPacket->xICMPHeader );
 80083bc:	687b      	ldr	r3, [r7, #4]
 80083be:	3322      	adds	r3, #34	; 0x22
 80083c0:	617b      	str	r3, [r7, #20]
		pxIPHeader = &( pxICMPPacket->xIPHeader );
 80083c2:	687b      	ldr	r3, [r7, #4]
 80083c4:	330e      	adds	r3, #14
 80083c6:	613b      	str	r3, [r7, #16]

		/* The checksum can be checked here - but a ping reply should be
		returned even if the checksum is incorrect so the other end can
		tell that the ping was received - even if the ping reply contains
		invalid data. */
		pxICMPHeader->ucTypeOfMessage = ( uint8_t ) ipICMP_ECHO_REPLY;
 80083c8:	697b      	ldr	r3, [r7, #20]
 80083ca:	2200      	movs	r2, #0
 80083cc:	701a      	strb	r2, [r3, #0]
		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 80083ce:	693b      	ldr	r3, [r7, #16]
 80083d0:	68da      	ldr	r2, [r3, #12]
 80083d2:	693b      	ldr	r3, [r7, #16]
 80083d4:	611a      	str	r2, [r3, #16]
		pxIPHeader->ulSourceIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 80083d6:	4b22      	ldr	r3, [pc, #136]	; (8008460 <prvProcessICMPEchoRequest+0xac>)
 80083d8:	695a      	ldr	r2, [r3, #20]
 80083da:	693b      	ldr	r3, [r7, #16]
 80083dc:	60da      	str	r2, [r3, #12]
		has been changed to ipICMP_ECHO_REPLY.  This is faster than calling
		usGenerateChecksum(). */

		/* due to compiler warning "integer operation result is out of range" */

		usRequest = ( uint16_t ) ( ( uint16_t )ipICMP_ECHO_REQUEST << 8 );
 80083de:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80083e2:	81fb      	strh	r3, [r7, #14]

		if( pxICMPHeader->usChecksum >= FreeRTOS_htons( 0xFFFFu - usRequest ) )
 80083e4:	697b      	ldr	r3, [r7, #20]
 80083e6:	885b      	ldrh	r3, [r3, #2]
 80083e8:	b29a      	uxth	r2, r3
 80083ea:	89fb      	ldrh	r3, [r7, #14]
 80083ec:	43db      	mvns	r3, r3
 80083ee:	b29b      	uxth	r3, r3
 80083f0:	021b      	lsls	r3, r3, #8
 80083f2:	b299      	uxth	r1, r3
 80083f4:	89f8      	ldrh	r0, [r7, #14]
 80083f6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 80083fa:	1a1b      	subs	r3, r3, r0
 80083fc:	0a1b      	lsrs	r3, r3, #8
 80083fe:	b29b      	uxth	r3, r3
 8008400:	430b      	orrs	r3, r1
 8008402:	b29b      	uxth	r3, r3
 8008404:	429a      	cmp	r2, r3
 8008406:	d312      	bcc.n	800842e <prvProcessICMPEchoRequest+0x7a>
		{
			pxICMPHeader->usChecksum = ( uint16_t )
				( ( ( uint32_t ) pxICMPHeader->usChecksum ) +
 8008408:	697b      	ldr	r3, [r7, #20]
 800840a:	885b      	ldrh	r3, [r3, #2]
 800840c:	b29a      	uxth	r2, r3
					FreeRTOS_htons( usRequest + 1UL ) );
 800840e:	89fb      	ldrh	r3, [r7, #14]
 8008410:	3301      	adds	r3, #1
 8008412:	b29b      	uxth	r3, r3
 8008414:	021b      	lsls	r3, r3, #8
 8008416:	b299      	uxth	r1, r3
 8008418:	89fb      	ldrh	r3, [r7, #14]
 800841a:	3301      	adds	r3, #1
 800841c:	0a1b      	lsrs	r3, r3, #8
 800841e:	b29b      	uxth	r3, r3
 8008420:	430b      	orrs	r3, r1
 8008422:	b29b      	uxth	r3, r3

		usRequest = ( uint16_t ) ( ( uint16_t )ipICMP_ECHO_REQUEST << 8 );

		if( pxICMPHeader->usChecksum >= FreeRTOS_htons( 0xFFFFu - usRequest ) )
		{
			pxICMPHeader->usChecksum = ( uint16_t )
 8008424:	4413      	add	r3, r2
 8008426:	b29a      	uxth	r2, r3
 8008428:	697b      	ldr	r3, [r7, #20]
 800842a:	805a      	strh	r2, [r3, #2]
 800842c:	e010      	b.n	8008450 <prvProcessICMPEchoRequest+0x9c>
					FreeRTOS_htons( usRequest + 1UL ) );
		}
		else
		{
			pxICMPHeader->usChecksum = ( uint16_t )
				( ( ( uint32_t ) pxICMPHeader->usChecksum ) +
 800842e:	697b      	ldr	r3, [r7, #20]
 8008430:	885b      	ldrh	r3, [r3, #2]
 8008432:	b29a      	uxth	r2, r3
					FreeRTOS_htons( usRequest ) );
 8008434:	89fb      	ldrh	r3, [r7, #14]
 8008436:	021b      	lsls	r3, r3, #8
 8008438:	b299      	uxth	r1, r3
 800843a:	89fb      	ldrh	r3, [r7, #14]
 800843c:	0a1b      	lsrs	r3, r3, #8
 800843e:	b29b      	uxth	r3, r3
 8008440:	b29b      	uxth	r3, r3
 8008442:	430b      	orrs	r3, r1
 8008444:	b29b      	uxth	r3, r3
 8008446:	b29b      	uxth	r3, r3
				( ( ( uint32_t ) pxICMPHeader->usChecksum ) +
					FreeRTOS_htons( usRequest + 1UL ) );
		}
		else
		{
			pxICMPHeader->usChecksum = ( uint16_t )
 8008448:	4413      	add	r3, r2
 800844a:	b29a      	uxth	r2, r3
 800844c:	697b      	ldr	r3, [r7, #20]
 800844e:	805a      	strh	r2, [r3, #2]
				( ( ( uint32_t ) pxICMPHeader->usChecksum ) +
					FreeRTOS_htons( usRequest ) );
		}
		return eReturnEthernetFrame;
 8008450:	2302      	movs	r3, #2
	}
 8008452:	4618      	mov	r0, r3
 8008454:	371c      	adds	r7, #28
 8008456:	46bd      	mov	sp, r7
 8008458:	f85d 7b04 	ldr.w	r7, [sp], #4
 800845c:	4770      	bx	lr
 800845e:	bf00      	nop
 8008460:	2000bb08 	.word	0x2000bb08

08008464 <prvProcessICMPPacket>:
/*-----------------------------------------------------------*/

#if ( ipconfigREPLY_TO_INCOMING_PINGS == 1 ) || ( ipconfigSUPPORT_OUTGOING_PINGS == 1 )

	static eFrameProcessingResult_t prvProcessICMPPacket( ICMPPacket_t * const pxICMPPacket )
	{
 8008464:	b580      	push	{r7, lr}
 8008466:	b084      	sub	sp, #16
 8008468:	af00      	add	r7, sp, #0
 800846a:	6078      	str	r0, [r7, #4]
	eFrameProcessingResult_t eReturn = eReleaseBuffer;
 800846c:	2300      	movs	r3, #0
 800846e:	73fb      	strb	r3, [r7, #15]

		iptraceICMP_PACKET_RECEIVED();
		switch( pxICMPPacket->xICMPHeader.ucTypeOfMessage )
 8008470:	687b      	ldr	r3, [r7, #4]
 8008472:	f893 3022 	ldrb.w	r3, [r3, #34]	; 0x22
 8008476:	2b00      	cmp	r3, #0
 8008478:	d008      	beq.n	800848c <prvProcessICMPPacket+0x28>
 800847a:	2b08      	cmp	r3, #8
 800847c:	d000      	beq.n	8008480 <prvProcessICMPPacket+0x1c>
				}
				#endif /* ipconfigSUPPORT_OUTGOING_PINGS */
				break;

			default	:
				break;
 800847e:	e009      	b.n	8008494 <prvProcessICMPPacket+0x30>
		switch( pxICMPPacket->xICMPHeader.ucTypeOfMessage )
		{
			case ipICMP_ECHO_REQUEST	:
				#if ( ipconfigREPLY_TO_INCOMING_PINGS == 1 )
				{
					eReturn = prvProcessICMPEchoRequest( pxICMPPacket );
 8008480:	6878      	ldr	r0, [r7, #4]
 8008482:	f7ff ff97 	bl	80083b4 <prvProcessICMPEchoRequest>
 8008486:	4603      	mov	r3, r0
 8008488:	73fb      	strb	r3, [r7, #15]
				}
				#endif /* ( ipconfigREPLY_TO_INCOMING_PINGS == 1 ) */
				break;
 800848a:	e003      	b.n	8008494 <prvProcessICMPPacket+0x30>

			case ipICMP_ECHO_REPLY		:
				#if ( ipconfigSUPPORT_OUTGOING_PINGS == 1 )
				{
					prvProcessICMPEchoReply( pxICMPPacket );
 800848c:	6878      	ldr	r0, [r7, #4]
 800848e:	f7ff ff51 	bl	8008334 <prvProcessICMPEchoReply>
				}
				#endif /* ipconfigSUPPORT_OUTGOING_PINGS */
				break;
 8008492:	bf00      	nop

			default	:
				break;
		}

		return eReturn;
 8008494:	7bfb      	ldrb	r3, [r7, #15]
	}
 8008496:	4618      	mov	r0, r3
 8008498:	3710      	adds	r7, #16
 800849a:	46bd      	mov	sp, r7
 800849c:	bd80      	pop	{r7, pc}
 800849e:	bf00      	nop

080084a0 <vReturnEthernetFrame>:
	return FreeRTOS_htons( ( (uint16_t) xSum.u32 ) );
}
/*-----------------------------------------------------------*/

void vReturnEthernetFrame( NetworkBufferDescriptor_t * pxNetworkBuffer, BaseType_t xReleaseAfterSend )
{
 80084a0:	b580      	push	{r7, lr}
 80084a2:	b084      	sub	sp, #16
 80084a4:	af00      	add	r7, sp, #0
 80084a6:	6078      	str	r0, [r7, #4]
 80084a8:	6039      	str	r1, [r7, #0]
	}
	#endif

#if( ipconfigZERO_COPY_TX_DRIVER != 0 )

	if( xReleaseAfterSend == pdFALSE )
 80084aa:	683b      	ldr	r3, [r7, #0]
 80084ac:	2b00      	cmp	r3, #0
 80084ae:	d10a      	bne.n	80084c6 <vReturnEthernetFrame+0x26>
	{
		pxNewBuffer = pxDuplicateNetworkBufferWithDescriptor( pxNetworkBuffer, ( BaseType_t ) pxNetworkBuffer->xDataLength );
 80084b0:	687b      	ldr	r3, [r7, #4]
 80084b2:	69db      	ldr	r3, [r3, #28]
 80084b4:	6878      	ldr	r0, [r7, #4]
 80084b6:	4619      	mov	r1, r3
 80084b8:	f7ff fbca 	bl	8007c50 <pxDuplicateNetworkBufferWithDescriptor>
 80084bc:	60f8      	str	r0, [r7, #12]
		xReleaseAfterSend = pdTRUE;
 80084be:	2301      	movs	r3, #1
 80084c0:	603b      	str	r3, [r7, #0]
		pxNetworkBuffer = pxNewBuffer;
 80084c2:	68fb      	ldr	r3, [r7, #12]
 80084c4:	607b      	str	r3, [r7, #4]
	}

	if( pxNetworkBuffer != NULL )
 80084c6:	687b      	ldr	r3, [r7, #4]
 80084c8:	2b00      	cmp	r3, #0
 80084ca:	d015      	beq.n	80084f8 <vReturnEthernetFrame+0x58>
#endif
	{
		pxEthernetHeader = ( EthernetHeader_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 80084cc:	687b      	ldr	r3, [r7, #4]
 80084ce:	699b      	ldr	r3, [r3, #24]
 80084d0:	60bb      	str	r3, [r7, #8]

		/* Swap source and destination MAC addresses. */
		memcpy( ( void * ) &( pxEthernetHeader->xDestinationAddress ), ( void * ) &( pxEthernetHeader->xSourceAddress ), sizeof( pxEthernetHeader->xDestinationAddress ) );
 80084d2:	68ba      	ldr	r2, [r7, #8]
 80084d4:	68bb      	ldr	r3, [r7, #8]
 80084d6:	3306      	adds	r3, #6
 80084d8:	4610      	mov	r0, r2
 80084da:	4619      	mov	r1, r3
 80084dc:	2206      	movs	r2, #6
 80084de:	f007 fde3 	bl	80100a8 <memcpy>
		memcpy( ( void * ) &( pxEthernetHeader->xSourceAddress) , ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 80084e2:	68bb      	ldr	r3, [r7, #8]
 80084e4:	3306      	adds	r3, #6
 80084e6:	4618      	mov	r0, r3
 80084e8:	4905      	ldr	r1, [pc, #20]	; (8008500 <vReturnEthernetFrame+0x60>)
 80084ea:	2206      	movs	r2, #6
 80084ec:	f007 fddc 	bl	80100a8 <memcpy>

		/* Send! */
		xNetworkInterfaceOutput( pxNetworkBuffer, xReleaseAfterSend );
 80084f0:	6878      	ldr	r0, [r7, #4]
 80084f2:	6839      	ldr	r1, [r7, #0]
 80084f4:	f7fe fc1a 	bl	8006d2c <xNetworkInterfaceOutput>
	}
}
 80084f8:	3710      	adds	r7, #16
 80084fa:	46bd      	mov	sp, r7
 80084fc:	bd80      	pop	{r7, pc}
 80084fe:	bf00      	nop
 8008500:	2000bb08 	.word	0x2000bb08

08008504 <FreeRTOS_GetIPAddress>:
/*-----------------------------------------------------------*/

uint32_t FreeRTOS_GetIPAddress( void )
{
 8008504:	b480      	push	{r7}
 8008506:	af00      	add	r7, sp, #0
	/* Returns the IP address of the NIC. */
	return *ipLOCAL_IP_ADDRESS_POINTER;
 8008508:	4b03      	ldr	r3, [pc, #12]	; (8008518 <FreeRTOS_GetIPAddress+0x14>)
 800850a:	695b      	ldr	r3, [r3, #20]
}
 800850c:	4618      	mov	r0, r3
 800850e:	46bd      	mov	sp, r7
 8008510:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008514:	4770      	bx	lr
 8008516:	bf00      	nop
 8008518:	2000bb08 	.word	0x2000bb08

0800851c <vIPSetDnsTimerEnableState>:
#endif /* ipconfigUSE_DHCP */
/*-----------------------------------------------------------*/

#if( ipconfigDNS_USE_CALLBACKS == 1 )
	void vIPSetDnsTimerEnableState( BaseType_t xEnableState )
	{
 800851c:	b480      	push	{r7}
 800851e:	b083      	sub	sp, #12
 8008520:	af00      	add	r7, sp, #0
 8008522:	6078      	str	r0, [r7, #4]
		if( xEnableState != 0 )
 8008524:	687b      	ldr	r3, [r7, #4]
 8008526:	2b00      	cmp	r3, #0
 8008528:	d005      	beq.n	8008536 <vIPSetDnsTimerEnableState+0x1a>
		{
			xDNSTimer.bActive = pdTRUE;
 800852a:	4a08      	ldr	r2, [pc, #32]	; (800854c <vIPSetDnsTimerEnableState+0x30>)
 800852c:	7813      	ldrb	r3, [r2, #0]
 800852e:	f043 0301 	orr.w	r3, r3, #1
 8008532:	7013      	strb	r3, [r2, #0]
 8008534:	e004      	b.n	8008540 <vIPSetDnsTimerEnableState+0x24>
		}
		else
		{
			xDNSTimer.bActive = pdFALSE;
 8008536:	4a05      	ldr	r2, [pc, #20]	; (800854c <vIPSetDnsTimerEnableState+0x30>)
 8008538:	7813      	ldrb	r3, [r2, #0]
 800853a:	f36f 0300 	bfc	r3, #0, #1
 800853e:	7013      	strb	r3, [r2, #0]
		}
	}
 8008540:	370c      	adds	r7, #12
 8008542:	46bd      	mov	sp, r7
 8008544:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008548:	4770      	bx	lr
 800854a:	bf00      	nop
 800854c:	2000c224 	.word	0x2000c224

08008550 <xIPIsNetworkTaskReady>:
	}
#endif /* ipconfigDNS_USE_CALLBACKS != 0 */
/*-----------------------------------------------------------*/

BaseType_t xIPIsNetworkTaskReady( void )
{
 8008550:	b480      	push	{r7}
 8008552:	af00      	add	r7, sp, #0
	return xIPTaskInitialised;
 8008554:	4b03      	ldr	r3, [pc, #12]	; (8008564 <xIPIsNetworkTaskReady+0x14>)
 8008556:	681b      	ldr	r3, [r3, #0]
}
 8008558:	4618      	mov	r0, r3
 800855a:	46bd      	mov	sp, r7
 800855c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008560:	4770      	bx	lr
 8008562:	bf00      	nop
 8008564:	2000c238 	.word	0x2000c238

08008568 <eARPProcessPacket>:
};

/*-----------------------------------------------------------*/

eFrameProcessingResult_t eARPProcessPacket( ARPPacket_t * const pxARPFrame )
{
 8008568:	b580      	push	{r7, lr}
 800856a:	b084      	sub	sp, #16
 800856c:	af00      	add	r7, sp, #0
 800856e:	6078      	str	r0, [r7, #4]
eFrameProcessingResult_t eReturn = eReleaseBuffer;
 8008570:	2300      	movs	r3, #0
 8008572:	73fb      	strb	r3, [r7, #15]
ARPHeader_t *pxARPHeader;

	pxARPHeader = &( pxARPFrame->xARPHeader );
 8008574:	687b      	ldr	r3, [r7, #4]
 8008576:	330e      	adds	r3, #14
 8008578:	60bb      	str	r3, [r7, #8]

	traceARP_PACKET_RECEIVED();

	/* Don't do anything if the local IP address is zero because
	that means a DHCP request has not completed. */
	if( *ipLOCAL_IP_ADDRESS_POINTER != 0UL )
 800857a:	4b39      	ldr	r3, [pc, #228]	; (8008660 <eARPProcessPacket+0xf8>)
 800857c:	695b      	ldr	r3, [r3, #20]
 800857e:	2b00      	cmp	r3, #0
 8008580:	d069      	beq.n	8008656 <eARPProcessPacket+0xee>
	{
		switch( pxARPHeader->usOperation )
 8008582:	68bb      	ldr	r3, [r7, #8]
 8008584:	88db      	ldrh	r3, [r3, #6]
 8008586:	b29b      	uxth	r3, r3
 8008588:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 800858c:	d003      	beq.n	8008596 <eARPProcessPacket+0x2e>
 800858e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8008592:	d055      	beq.n	8008640 <eARPProcessPacket+0xd8>
				#endif /* ipconfigARP_USE_CLASH_DETECTION */
				break;

			default :
				/* Invalid. */
				break;
 8008594:	e05f      	b.n	8008656 <eARPProcessPacket+0xee>
		switch( pxARPHeader->usOperation )
		{
			case ipARP_REQUEST	:
				/* The packet contained an ARP request.  Was it for the IP
				address of the node running this code? */
				if( pxARPHeader->ulTargetProtocolAddress == *ipLOCAL_IP_ADDRESS_POINTER )
 8008596:	68bb      	ldr	r3, [r7, #8]
 8008598:	699a      	ldr	r2, [r3, #24]
 800859a:	4b31      	ldr	r3, [pc, #196]	; (8008660 <eARPProcessPacket+0xf8>)
 800859c:	695b      	ldr	r3, [r3, #20]
 800859e:	429a      	cmp	r2, r3
 80085a0:	d14d      	bne.n	800863e <eARPProcessPacket+0xd6>
					iptraceSENDING_ARP_REPLY( pxARPHeader->ulSenderProtocolAddress );

					/* The request is for the address of this node.  Add the
					entry into the ARP cache, or refresh the entry if it
					already exists. */
					vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), pxARPHeader->ulSenderProtocolAddress );
 80085a2:	68bb      	ldr	r3, [r7, #8]
 80085a4:	f103 0208 	add.w	r2, r3, #8
 80085a8:	68bb      	ldr	r3, [r7, #8]
 80085aa:	f8d3 300e 	ldr.w	r3, [r3, #14]
 80085ae:	4610      	mov	r0, r2
 80085b0:	4619      	mov	r1, r3
 80085b2:	f000 f859 	bl	8008668 <vARPRefreshCacheEntry>

					/* Generate a reply payload in the same buffer. */
					pxARPHeader->usOperation = ( uint16_t ) ipARP_REPLY;
 80085b6:	68bb      	ldr	r3, [r7, #8]
 80085b8:	2200      	movs	r2, #0
 80085ba:	719a      	strb	r2, [r3, #6]
 80085bc:	2200      	movs	r2, #0
 80085be:	f042 0202 	orr.w	r2, r2, #2
 80085c2:	71da      	strb	r2, [r3, #7]
					if( pxARPHeader->ulTargetProtocolAddress == pxARPHeader->ulSenderProtocolAddress )
 80085c4:	68bb      	ldr	r3, [r7, #8]
 80085c6:	699a      	ldr	r2, [r3, #24]
 80085c8:	68bb      	ldr	r3, [r7, #8]
 80085ca:	f8d3 300e 	ldr.w	r3, [r3, #14]
 80085ce:	429a      	cmp	r2, r3
 80085d0:	d117      	bne.n	8008602 <eARPProcessPacket+0x9a>
					{
						/* A double IP address is detected! */
						/* Give the sources MAC address the value of the broadcast address, will be swapped later */
						memcpy( pxARPFrame->xEthernetHeader.xSourceAddress.ucBytes, xBroadcastMACAddress.ucBytes, sizeof( xBroadcastMACAddress ) );
 80085d2:	687b      	ldr	r3, [r7, #4]
 80085d4:	3306      	adds	r3, #6
 80085d6:	4618      	mov	r0, r3
 80085d8:	4922      	ldr	r1, [pc, #136]	; (8008664 <eARPProcessPacket+0xfc>)
 80085da:	2206      	movs	r2, #6
 80085dc:	f007 fd64 	bl	80100a8 <memcpy>
						memset( pxARPHeader->xTargetHardwareAddress.ucBytes, '\0', sizeof( MACAddress_t ) );
 80085e0:	68bb      	ldr	r3, [r7, #8]
 80085e2:	3312      	adds	r3, #18
 80085e4:	4618      	mov	r0, r3
 80085e6:	2100      	movs	r1, #0
 80085e8:	2206      	movs	r2, #6
 80085ea:	f007 fe5d 	bl	80102a8 <memset>
						pxARPHeader->ulTargetProtocolAddress = 0UL;
 80085ee:	68bb      	ldr	r3, [r7, #8]
 80085f0:	2200      	movs	r2, #0
 80085f2:	761a      	strb	r2, [r3, #24]
 80085f4:	2200      	movs	r2, #0
 80085f6:	765a      	strb	r2, [r3, #25]
 80085f8:	2200      	movs	r2, #0
 80085fa:	769a      	strb	r2, [r3, #26]
 80085fc:	2200      	movs	r2, #0
 80085fe:	76da      	strb	r2, [r3, #27]
 8008600:	e00e      	b.n	8008620 <eARPProcessPacket+0xb8>
					}
					else
					{
						memcpy( pxARPHeader->xTargetHardwareAddress.ucBytes, pxARPHeader->xSenderHardwareAddress.ucBytes, sizeof( MACAddress_t ) );
 8008602:	68bb      	ldr	r3, [r7, #8]
 8008604:	f103 0212 	add.w	r2, r3, #18
 8008608:	68bb      	ldr	r3, [r7, #8]
 800860a:	3308      	adds	r3, #8
 800860c:	4610      	mov	r0, r2
 800860e:	4619      	mov	r1, r3
 8008610:	2206      	movs	r2, #6
 8008612:	f007 fd49 	bl	80100a8 <memcpy>
						pxARPHeader->ulTargetProtocolAddress = pxARPHeader->ulSenderProtocolAddress;
 8008616:	68bb      	ldr	r3, [r7, #8]
 8008618:	f8d3 200e 	ldr.w	r2, [r3, #14]
 800861c:	68bb      	ldr	r3, [r7, #8]
 800861e:	619a      	str	r2, [r3, #24]
					}
					memcpy( pxARPHeader->xSenderHardwareAddress.ucBytes, ( void * ) ipLOCAL_MAC_ADDRESS, sizeof( MACAddress_t ) );
 8008620:	68bb      	ldr	r3, [r7, #8]
 8008622:	3308      	adds	r3, #8
 8008624:	4618      	mov	r0, r3
 8008626:	490e      	ldr	r1, [pc, #56]	; (8008660 <eARPProcessPacket+0xf8>)
 8008628:	2206      	movs	r2, #6
 800862a:	f007 fd3d 	bl	80100a8 <memcpy>
					pxARPHeader->ulSenderProtocolAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 800862e:	4b0c      	ldr	r3, [pc, #48]	; (8008660 <eARPProcessPacket+0xf8>)
 8008630:	695a      	ldr	r2, [r3, #20]
 8008632:	68bb      	ldr	r3, [r7, #8]
 8008634:	f8c3 200e 	str.w	r2, [r3, #14]

					eReturn = eReturnEthernetFrame;
 8008638:	2302      	movs	r3, #2
 800863a:	73fb      	strb	r3, [r7, #15]
				}
				break;
 800863c:	e00b      	b.n	8008656 <eARPProcessPacket+0xee>
 800863e:	e00a      	b.n	8008656 <eARPProcessPacket+0xee>

			case ipARP_REPLY :
				iptracePROCESSING_RECEIVED_ARP_REPLY( pxARPHeader->ulTargetProtocolAddress );
				vARPRefreshCacheEntry( &( pxARPHeader->xSenderHardwareAddress ), pxARPHeader->ulSenderProtocolAddress );
 8008640:	68bb      	ldr	r3, [r7, #8]
 8008642:	f103 0208 	add.w	r2, r3, #8
 8008646:	68bb      	ldr	r3, [r7, #8]
 8008648:	f8d3 300e 	ldr.w	r3, [r3, #14]
 800864c:	4610      	mov	r0, r2
 800864e:	4619      	mov	r1, r3
 8008650:	f000 f80a 	bl	8008668 <vARPRefreshCacheEntry>
						xARPHadIPClash = pdTRUE;
						memcpy( xARPClashMacAddress.ucBytes, pxARPHeader->xSenderHardwareAddress.ucBytes, sizeof( xARPClashMacAddress.ucBytes ) );
					}
				}
				#endif /* ipconfigARP_USE_CLASH_DETECTION */
				break;
 8008654:	bf00      	nop
				/* Invalid. */
				break;
		}
	}

	return eReturn;
 8008656:	7bfb      	ldrb	r3, [r7, #15]
}
 8008658:	4618      	mov	r0, r3
 800865a:	3710      	adds	r7, #16
 800865c:	46bd      	mov	sp, r7
 800865e:	bd80      	pop	{r7, pc}
 8008660:	2000bb08 	.word	0x2000bb08
 8008664:	08012a0c 	.word	0x08012a0c

08008668 <vARPRefreshCacheEntry>:

#endif	/* ipconfigUSE_ARP_REMOVE_ENTRY != 0 */
/*-----------------------------------------------------------*/

void vARPRefreshCacheEntry( const MACAddress_t * pxMACAddress, const uint32_t ulIPAddress )
{
 8008668:	b580      	push	{r7, lr}
 800866a:	b088      	sub	sp, #32
 800866c:	af00      	add	r7, sp, #0
 800866e:	6078      	str	r0, [r7, #4]
 8008670:	6039      	str	r1, [r7, #0]
BaseType_t x, xIpEntry = -1, xMacEntry = -1, xUseEntry = 0;
 8008672:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8008676:	61bb      	str	r3, [r7, #24]
 8008678:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800867c:	617b      	str	r3, [r7, #20]
 800867e:	2300      	movs	r3, #0
 8008680:	613b      	str	r3, [r7, #16]
uint8_t ucMinAgeFound = 0U;
 8008682:	2300      	movs	r3, #0
 8008684:	73fb      	strb	r3, [r7, #15]

	#if( ipconfigARP_STORES_REMOTE_ADDRESSES == 0 )
		/* Only process the IP address if it is on the local network.
		Unless: when '*ipLOCAL_IP_ADDRESS_POINTER' equals zero, the IP-address
		and netmask are still unknown. */
		if( ( ( ulIPAddress & xNetworkAddressing.ulNetMask ) == ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) ) ||
 8008686:	4b73      	ldr	r3, [pc, #460]	; (8008854 <vARPRefreshCacheEntry+0x1ec>)
 8008688:	695a      	ldr	r2, [r3, #20]
 800868a:	683b      	ldr	r3, [r7, #0]
 800868c:	405a      	eors	r2, r3
 800868e:	4b72      	ldr	r3, [pc, #456]	; (8008858 <vARPRefreshCacheEntry+0x1f0>)
 8008690:	685b      	ldr	r3, [r3, #4]
 8008692:	4013      	ands	r3, r2
 8008694:	2b00      	cmp	r3, #0
 8008696:	d004      	beq.n	80086a2 <vARPRefreshCacheEntry+0x3a>
			( *ipLOCAL_IP_ADDRESS_POINTER == 0ul ) )
 8008698:	4b6e      	ldr	r3, [pc, #440]	; (8008854 <vARPRefreshCacheEntry+0x1ec>)
 800869a:	695b      	ldr	r3, [r3, #20]

	#if( ipconfigARP_STORES_REMOTE_ADDRESSES == 0 )
		/* Only process the IP address if it is on the local network.
		Unless: when '*ipLOCAL_IP_ADDRESS_POINTER' equals zero, the IP-address
		and netmask are still unknown. */
		if( ( ( ulIPAddress & xNetworkAddressing.ulNetMask ) == ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) ) ||
 800869c:	2b00      	cmp	r3, #0
 800869e:	f040 80d5 	bne.w	800884c <vARPRefreshCacheEntry+0x1e4>
		zero the the gateway address is the only option. */
		if( pdTRUE )
	#endif
	{
		/* Start with the maximum possible number. */
		ucMinAgeFound--;
 80086a2:	7bfb      	ldrb	r3, [r7, #15]
 80086a4:	3b01      	subs	r3, #1
 80086a6:	73fb      	strb	r3, [r7, #15]

		/* For each entry in the ARP cache table. */
		for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 80086a8:	2300      	movs	r3, #0
 80086aa:	61fb      	str	r3, [r7, #28]
 80086ac:	e06b      	b.n	8008786 <vARPRefreshCacheEntry+0x11e>
		{
			/* Does this line in the cache table hold an entry for the IP
			address	being queried? */
			if( xARPCache[ x ].ulIPAddress == ulIPAddress )
 80086ae:	496b      	ldr	r1, [pc, #428]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 80086b0:	69fa      	ldr	r2, [r7, #28]
 80086b2:	4613      	mov	r3, r2
 80086b4:	005b      	lsls	r3, r3, #1
 80086b6:	4413      	add	r3, r2
 80086b8:	009b      	lsls	r3, r3, #2
 80086ba:	440b      	add	r3, r1
 80086bc:	681a      	ldr	r2, [r3, #0]
 80086be:	683b      	ldr	r3, [r7, #0]
 80086c0:	429a      	cmp	r2, r3
 80086c2:	d12e      	bne.n	8008722 <vARPRefreshCacheEntry+0xba>
			{
				if( pxMACAddress == NULL )
 80086c4:	687b      	ldr	r3, [r7, #4]
 80086c6:	2b00      	cmp	r3, #0
 80086c8:	d102      	bne.n	80086d0 <vARPRefreshCacheEntry+0x68>
				{
					/* In case the parameter pxMACAddress is NULL, an entry will be reserved to
					indicate that there is an outstanding ARP request, This entry will have
					"ucValid == pdFALSE". */
					xIpEntry = x;
 80086ca:	69fb      	ldr	r3, [r7, #28]
 80086cc:	61bb      	str	r3, [r7, #24]
					break;
 80086ce:	e05d      	b.n	800878c <vARPRefreshCacheEntry+0x124>
				}

				/* See if the MAC-address also matches. */
				if( memcmp( xARPCache[ x ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) ) == 0 )
 80086d0:	69fa      	ldr	r2, [r7, #28]
 80086d2:	4613      	mov	r3, r2
 80086d4:	005b      	lsls	r3, r3, #1
 80086d6:	4413      	add	r3, r2
 80086d8:	009b      	lsls	r3, r3, #2
 80086da:	4a60      	ldr	r2, [pc, #384]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 80086dc:	4413      	add	r3, r2
 80086de:	1d1a      	adds	r2, r3, #4
 80086e0:	687b      	ldr	r3, [r7, #4]
 80086e2:	4610      	mov	r0, r2
 80086e4:	4619      	mov	r1, r3
 80086e6:	2206      	movs	r2, #6
 80086e8:	f009 fe1c 	bl	8012324 <memcmp>
 80086ec:	4603      	mov	r3, r0
 80086ee:	2b00      	cmp	r3, #0
 80086f0:	d114      	bne.n	800871c <vARPRefreshCacheEntry+0xb4>
				{
					/* This function will be called for each received packet
					As this is by far the most common path the coding standard
					is relaxed in this case and a return is permitted as an
					optimisation. */
					xARPCache[ x ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
 80086f2:	495a      	ldr	r1, [pc, #360]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 80086f4:	69fa      	ldr	r2, [r7, #28]
 80086f6:	4613      	mov	r3, r2
 80086f8:	005b      	lsls	r3, r3, #1
 80086fa:	4413      	add	r3, r2
 80086fc:	009b      	lsls	r3, r3, #2
 80086fe:	440b      	add	r3, r1
 8008700:	3308      	adds	r3, #8
 8008702:	2296      	movs	r2, #150	; 0x96
 8008704:	709a      	strb	r2, [r3, #2]
					xARPCache[ x ].ucValid = ( uint8_t ) pdTRUE;
 8008706:	4955      	ldr	r1, [pc, #340]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 8008708:	69fa      	ldr	r2, [r7, #28]
 800870a:	4613      	mov	r3, r2
 800870c:	005b      	lsls	r3, r3, #1
 800870e:	4413      	add	r3, r2
 8008710:	009b      	lsls	r3, r3, #2
 8008712:	440b      	add	r3, r1
 8008714:	3308      	adds	r3, #8
 8008716:	2201      	movs	r2, #1
 8008718:	70da      	strb	r2, [r3, #3]
					return;
 800871a:	e097      	b.n	800884c <vARPRefreshCacheEntry+0x1e4>
				/* Found an entry containing ulIPAddress, but the MAC address
				doesn't match.  Might be an entry with ucValid=pdFALSE, waiting
				for an ARP reply.  Still want to see if there is match with the
				given MAC address.ucBytes.  If found, either of the two entries
				must be cleared. */
				xIpEntry = x;
 800871c:	69fb      	ldr	r3, [r7, #28]
 800871e:	61bb      	str	r3, [r7, #24]
 8008720:	e02e      	b.n	8008780 <vARPRefreshCacheEntry+0x118>
			}
			else if( ( pxMACAddress != NULL ) && ( memcmp( xARPCache[ x ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) ) == 0 ) )
 8008722:	687b      	ldr	r3, [r7, #4]
 8008724:	2b00      	cmp	r3, #0
 8008726:	d013      	beq.n	8008750 <vARPRefreshCacheEntry+0xe8>
 8008728:	69fa      	ldr	r2, [r7, #28]
 800872a:	4613      	mov	r3, r2
 800872c:	005b      	lsls	r3, r3, #1
 800872e:	4413      	add	r3, r2
 8008730:	009b      	lsls	r3, r3, #2
 8008732:	4a4a      	ldr	r2, [pc, #296]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 8008734:	4413      	add	r3, r2
 8008736:	1d1a      	adds	r2, r3, #4
 8008738:	687b      	ldr	r3, [r7, #4]
 800873a:	4610      	mov	r0, r2
 800873c:	4619      	mov	r1, r3
 800873e:	2206      	movs	r2, #6
 8008740:	f009 fdf0 	bl	8012324 <memcmp>
 8008744:	4603      	mov	r3, r0
 8008746:	2b00      	cmp	r3, #0
 8008748:	d102      	bne.n	8008750 <vARPRefreshCacheEntry+0xe8>
				if( bIsLocal[ 0 ] == bIsLocal[ 1 ] )
				{
					xMacEntry = x;
				}
	#else
				xMacEntry = x;
 800874a:	69fb      	ldr	r3, [r7, #28]
 800874c:	617b      	str	r3, [r7, #20]
 800874e:	e017      	b.n	8008780 <vARPRefreshCacheEntry+0x118>
	#endif
			}
			/* _HT_
			Shouldn't we test for xARPCache[ x ].ucValid == pdFALSE here ? */
			else if( xARPCache[ x ].ucAge < ucMinAgeFound )
 8008750:	4942      	ldr	r1, [pc, #264]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 8008752:	69fa      	ldr	r2, [r7, #28]
 8008754:	4613      	mov	r3, r2
 8008756:	005b      	lsls	r3, r3, #1
 8008758:	4413      	add	r3, r2
 800875a:	009b      	lsls	r3, r3, #2
 800875c:	440b      	add	r3, r1
 800875e:	3308      	adds	r3, #8
 8008760:	789b      	ldrb	r3, [r3, #2]
 8008762:	7bfa      	ldrb	r2, [r7, #15]
 8008764:	429a      	cmp	r2, r3
 8008766:	d90b      	bls.n	8008780 <vARPRefreshCacheEntry+0x118>
			{
				/* As the table is traversed, remember the table row that
				contains the oldest entry (the lowest age count, as ages are
				decremented to zero) so the row can be re-used if this function
				needs to add an entry that does not already exist. */
				ucMinAgeFound = xARPCache[ x ].ucAge;
 8008768:	493c      	ldr	r1, [pc, #240]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 800876a:	69fa      	ldr	r2, [r7, #28]
 800876c:	4613      	mov	r3, r2
 800876e:	005b      	lsls	r3, r3, #1
 8008770:	4413      	add	r3, r2
 8008772:	009b      	lsls	r3, r3, #2
 8008774:	440b      	add	r3, r1
 8008776:	3308      	adds	r3, #8
 8008778:	789b      	ldrb	r3, [r3, #2]
 800877a:	73fb      	strb	r3, [r7, #15]
				xUseEntry = x;
 800877c:	69fb      	ldr	r3, [r7, #28]
 800877e:	613b      	str	r3, [r7, #16]
	{
		/* Start with the maximum possible number. */
		ucMinAgeFound--;

		/* For each entry in the ARP cache table. */
		for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8008780:	69fb      	ldr	r3, [r7, #28]
 8008782:	3301      	adds	r3, #1
 8008784:	61fb      	str	r3, [r7, #28]
 8008786:	69fb      	ldr	r3, [r7, #28]
 8008788:	2b05      	cmp	r3, #5
 800878a:	dd90      	ble.n	80086ae <vARPRefreshCacheEntry+0x46>
				ucMinAgeFound = xARPCache[ x ].ucAge;
				xUseEntry = x;
			}
		}

		if( xMacEntry >= 0 )
 800878c:	697b      	ldr	r3, [r7, #20]
 800878e:	2b00      	cmp	r3, #0
 8008790:	db11      	blt.n	80087b6 <vARPRefreshCacheEntry+0x14e>
		{
			xUseEntry = xMacEntry;
 8008792:	697b      	ldr	r3, [r7, #20]
 8008794:	613b      	str	r3, [r7, #16]

			if( xIpEntry >= 0 )
 8008796:	69bb      	ldr	r3, [r7, #24]
 8008798:	2b00      	cmp	r3, #0
 800879a:	db11      	blt.n	80087c0 <vARPRefreshCacheEntry+0x158>
			{
				/* Both the MAC address as well as the IP address were found in
				different locations: clear the entry which matches the
				IP-address */
				memset( &xARPCache[ xIpEntry ], '\0', sizeof( xARPCache[ xIpEntry ] ) );
 800879c:	69ba      	ldr	r2, [r7, #24]
 800879e:	4613      	mov	r3, r2
 80087a0:	005b      	lsls	r3, r3, #1
 80087a2:	4413      	add	r3, r2
 80087a4:	009b      	lsls	r3, r3, #2
 80087a6:	4a2d      	ldr	r2, [pc, #180]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 80087a8:	4413      	add	r3, r2
 80087aa:	4618      	mov	r0, r3
 80087ac:	2100      	movs	r1, #0
 80087ae:	220c      	movs	r2, #12
 80087b0:	f007 fd7a 	bl	80102a8 <memset>
 80087b4:	e004      	b.n	80087c0 <vARPRefreshCacheEntry+0x158>
			}
		}
		else if( xIpEntry >= 0 )
 80087b6:	69bb      	ldr	r3, [r7, #24]
 80087b8:	2b00      	cmp	r3, #0
 80087ba:	db01      	blt.n	80087c0 <vARPRefreshCacheEntry+0x158>
		{
			/* An entry containing the IP-address was found, but it had a different MAC address */
			xUseEntry = xIpEntry;
 80087bc:	69bb      	ldr	r3, [r7, #24]
 80087be:	613b      	str	r3, [r7, #16]
		}

		/* If the entry was not found, we use the oldest entry and set the IPaddress */
		xARPCache[ xUseEntry ].ulIPAddress = ulIPAddress;
 80087c0:	4926      	ldr	r1, [pc, #152]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 80087c2:	693a      	ldr	r2, [r7, #16]
 80087c4:	4613      	mov	r3, r2
 80087c6:	005b      	lsls	r3, r3, #1
 80087c8:	4413      	add	r3, r2
 80087ca:	009b      	lsls	r3, r3, #2
 80087cc:	440b      	add	r3, r1
 80087ce:	683a      	ldr	r2, [r7, #0]
 80087d0:	601a      	str	r2, [r3, #0]

		if( pxMACAddress != NULL )
 80087d2:	687b      	ldr	r3, [r7, #4]
 80087d4:	2b00      	cmp	r3, #0
 80087d6:	d022      	beq.n	800881e <vARPRefreshCacheEntry+0x1b6>
		{
			memcpy( xARPCache[ xUseEntry ].xMACAddress.ucBytes, pxMACAddress->ucBytes, sizeof( pxMACAddress->ucBytes ) );
 80087d8:	693a      	ldr	r2, [r7, #16]
 80087da:	4613      	mov	r3, r2
 80087dc:	005b      	lsls	r3, r3, #1
 80087de:	4413      	add	r3, r2
 80087e0:	009b      	lsls	r3, r3, #2
 80087e2:	4a1e      	ldr	r2, [pc, #120]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 80087e4:	4413      	add	r3, r2
 80087e6:	1d1a      	adds	r2, r3, #4
 80087e8:	687b      	ldr	r3, [r7, #4]
 80087ea:	4610      	mov	r0, r2
 80087ec:	4619      	mov	r1, r3
 80087ee:	2206      	movs	r2, #6
 80087f0:	f007 fc5a 	bl	80100a8 <memcpy>

			iptraceARP_TABLE_ENTRY_CREATED( ulIPAddress, (*pxMACAddress) );
			/* And this entry does not need immediate attention */
			xARPCache[ xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_AGE;
 80087f4:	4919      	ldr	r1, [pc, #100]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 80087f6:	693a      	ldr	r2, [r7, #16]
 80087f8:	4613      	mov	r3, r2
 80087fa:	005b      	lsls	r3, r3, #1
 80087fc:	4413      	add	r3, r2
 80087fe:	009b      	lsls	r3, r3, #2
 8008800:	440b      	add	r3, r1
 8008802:	3308      	adds	r3, #8
 8008804:	2296      	movs	r2, #150	; 0x96
 8008806:	709a      	strb	r2, [r3, #2]
			xARPCache[ xUseEntry ].ucValid = ( uint8_t ) pdTRUE;
 8008808:	4914      	ldr	r1, [pc, #80]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 800880a:	693a      	ldr	r2, [r7, #16]
 800880c:	4613      	mov	r3, r2
 800880e:	005b      	lsls	r3, r3, #1
 8008810:	4413      	add	r3, r2
 8008812:	009b      	lsls	r3, r3, #2
 8008814:	440b      	add	r3, r1
 8008816:	3308      	adds	r3, #8
 8008818:	2201      	movs	r2, #1
 800881a:	70da      	strb	r2, [r3, #3]
 800881c:	e016      	b.n	800884c <vARPRefreshCacheEntry+0x1e4>
		}
		else if( xIpEntry < 0 )
 800881e:	69bb      	ldr	r3, [r7, #24]
 8008820:	2b00      	cmp	r3, #0
 8008822:	da13      	bge.n	800884c <vARPRefreshCacheEntry+0x1e4>
		{
			xARPCache[ xUseEntry ].ucAge = ( uint8_t ) ipconfigMAX_ARP_RETRANSMISSIONS;
 8008824:	490d      	ldr	r1, [pc, #52]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 8008826:	693a      	ldr	r2, [r7, #16]
 8008828:	4613      	mov	r3, r2
 800882a:	005b      	lsls	r3, r3, #1
 800882c:	4413      	add	r3, r2
 800882e:	009b      	lsls	r3, r3, #2
 8008830:	440b      	add	r3, r1
 8008832:	3308      	adds	r3, #8
 8008834:	2205      	movs	r2, #5
 8008836:	709a      	strb	r2, [r3, #2]
			xARPCache[ xUseEntry ].ucValid = ( uint8_t ) pdFALSE;
 8008838:	4908      	ldr	r1, [pc, #32]	; (800885c <vARPRefreshCacheEntry+0x1f4>)
 800883a:	693a      	ldr	r2, [r7, #16]
 800883c:	4613      	mov	r3, r2
 800883e:	005b      	lsls	r3, r3, #1
 8008840:	4413      	add	r3, r2
 8008842:	009b      	lsls	r3, r3, #2
 8008844:	440b      	add	r3, r1
 8008846:	3308      	adds	r3, #8
 8008848:	2200      	movs	r2, #0
 800884a:	70da      	strb	r2, [r3, #3]
		}
	}
}
 800884c:	3720      	adds	r7, #32
 800884e:	46bd      	mov	sp, r7
 8008850:	bd80      	pop	{r7, pc}
 8008852:	bf00      	nop
 8008854:	2000bb08 	.word	0x2000bb08
 8008858:	2000c1c4 	.word	0x2000c1c4
 800885c:	2000c244 	.word	0x2000c244

08008860 <eARPGetCacheEntry>:
#endif /* ipconfigUSE_ARP_REVERSED_LOOKUP */

/*-----------------------------------------------------------*/

eARPLookupResult_t eARPGetCacheEntry( uint32_t *pulIPAddress, MACAddress_t * const pxMACAddress )
{
 8008860:	b580      	push	{r7, lr}
 8008862:	b084      	sub	sp, #16
 8008864:	af00      	add	r7, sp, #0
 8008866:	6078      	str	r0, [r7, #4]
 8008868:	6039      	str	r1, [r7, #0]
eARPLookupResult_t eReturn;
uint32_t ulAddressToLookup;

#if( ipconfigUSE_LLMNR == 1 )
	if( *pulIPAddress == ipLLMNR_IP_ADDR )	/* Is in network byte order */
 800886a:	687b      	ldr	r3, [r7, #4]
 800886c:	681b      	ldr	r3, [r3, #0]
 800886e:	4a2a      	ldr	r2, [pc, #168]	; (8008918 <eARPGetCacheEntry+0xb8>)
 8008870:	4293      	cmp	r3, r2
 8008872:	d108      	bne.n	8008886 <eARPGetCacheEntry+0x26>
	{
		/* The LLMNR IP-address has a fixed virtual MAC address */
		memcpy( pxMACAddress->ucBytes, xLLMNR_MacAdress.ucBytes, sizeof( MACAddress_t ) );
 8008874:	683b      	ldr	r3, [r7, #0]
 8008876:	4618      	mov	r0, r3
 8008878:	4928      	ldr	r1, [pc, #160]	; (800891c <eARPGetCacheEntry+0xbc>)
 800887a:	2206      	movs	r2, #6
 800887c:	f007 fc14 	bl	80100a8 <memcpy>
		eReturn = eARPCacheHit;
 8008880:	2301      	movs	r3, #1
 8008882:	73fb      	strb	r3, [r7, #15]
 8008884:	e042      	b.n	800890c <eARPGetCacheEntry+0xac>
	}
	else
#endif
	if( ( *pulIPAddress == ipBROADCAST_IP_ADDRESS ) ||	/* Is it the general broadcast address 255.255.255.255? */
 8008886:	687b      	ldr	r3, [r7, #4]
 8008888:	681b      	ldr	r3, [r3, #0]
 800888a:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800888e:	d005      	beq.n	800889c <eARPGetCacheEntry+0x3c>
		( *pulIPAddress == xNetworkAddressing.ulBroadcastAddress ) )/* Or a local broadcast address, eg 192.168.1.255? */
 8008890:	687b      	ldr	r3, [r7, #4]
 8008892:	681a      	ldr	r2, [r3, #0]
 8008894:	4b22      	ldr	r3, [pc, #136]	; (8008920 <eARPGetCacheEntry+0xc0>)
 8008896:	691b      	ldr	r3, [r3, #16]
		memcpy( pxMACAddress->ucBytes, xLLMNR_MacAdress.ucBytes, sizeof( MACAddress_t ) );
		eReturn = eARPCacheHit;
	}
	else
#endif
	if( ( *pulIPAddress == ipBROADCAST_IP_ADDRESS ) ||	/* Is it the general broadcast address 255.255.255.255? */
 8008898:	429a      	cmp	r2, r3
 800889a:	d108      	bne.n	80088ae <eARPGetCacheEntry+0x4e>
		( *pulIPAddress == xNetworkAddressing.ulBroadcastAddress ) )/* Or a local broadcast address, eg 192.168.1.255? */
	{
		/* This is a broadcast so uses the broadcast MAC address. */
		memcpy( pxMACAddress->ucBytes, xBroadcastMACAddress.ucBytes, sizeof( MACAddress_t ) );
 800889c:	683b      	ldr	r3, [r7, #0]
 800889e:	4618      	mov	r0, r3
 80088a0:	4920      	ldr	r1, [pc, #128]	; (8008924 <eARPGetCacheEntry+0xc4>)
 80088a2:	2206      	movs	r2, #6
 80088a4:	f007 fc00 	bl	80100a8 <memcpy>
		eReturn = eARPCacheHit;
 80088a8:	2301      	movs	r3, #1
 80088aa:	73fb      	strb	r3, [r7, #15]
 80088ac:	e02e      	b.n	800890c <eARPGetCacheEntry+0xac>
	}
	else if( *ipLOCAL_IP_ADDRESS_POINTER == 0UL )
 80088ae:	4b1e      	ldr	r3, [pc, #120]	; (8008928 <eARPGetCacheEntry+0xc8>)
 80088b0:	695b      	ldr	r3, [r3, #20]
 80088b2:	2b00      	cmp	r3, #0
 80088b4:	d102      	bne.n	80088bc <eARPGetCacheEntry+0x5c>
	{
		/* The IP address has not yet been assigned, so there is nothing that
		can be done. */
		eReturn = eCantSendPacket;
 80088b6:	2302      	movs	r3, #2
 80088b8:	73fb      	strb	r3, [r7, #15]
 80088ba:	e027      	b.n	800890c <eARPGetCacheEntry+0xac>
	}
	else
	{
		eReturn = eARPCacheMiss;
 80088bc:	2300      	movs	r3, #0
 80088be:	73fb      	strb	r3, [r7, #15]

		if( ( *pulIPAddress & xNetworkAddressing.ulNetMask ) != ( ( *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) )
 80088c0:	687b      	ldr	r3, [r7, #4]
 80088c2:	681a      	ldr	r2, [r3, #0]
 80088c4:	4b18      	ldr	r3, [pc, #96]	; (8008928 <eARPGetCacheEntry+0xc8>)
 80088c6:	695b      	ldr	r3, [r3, #20]
 80088c8:	405a      	eors	r2, r3
 80088ca:	4b15      	ldr	r3, [pc, #84]	; (8008920 <eARPGetCacheEntry+0xc0>)
 80088cc:	685b      	ldr	r3, [r3, #4]
 80088ce:	4013      	ands	r3, r2
 80088d0:	2b00      	cmp	r3, #0
 80088d2:	d003      	beq.n	80088dc <eARPGetCacheEntry+0x7c>
			else
#endif
			{
				/* The IP address is off the local network, so look up the
				hardware address of the router, if any. */
				ulAddressToLookup = xNetworkAddressing.ulGatewayAddress;
 80088d4:	4b12      	ldr	r3, [pc, #72]	; (8008920 <eARPGetCacheEntry+0xc0>)
 80088d6:	689b      	ldr	r3, [r3, #8]
 80088d8:	60bb      	str	r3, [r7, #8]
 80088da:	e002      	b.n	80088e2 <eARPGetCacheEntry+0x82>
		}
		else
		{
			/* The IP address is on the local network, so lookup the requested
			IP address directly. */
			ulAddressToLookup = *pulIPAddress;
 80088dc:	687b      	ldr	r3, [r7, #4]
 80088de:	681b      	ldr	r3, [r3, #0]
 80088e0:	60bb      	str	r3, [r7, #8]
		}

		if( eReturn == eARPCacheMiss )
 80088e2:	7bfb      	ldrb	r3, [r7, #15]
 80088e4:	2b00      	cmp	r3, #0
 80088e6:	d111      	bne.n	800890c <eARPGetCacheEntry+0xac>
		{
			if( ulAddressToLookup == 0UL )
 80088e8:	68bb      	ldr	r3, [r7, #8]
 80088ea:	2b00      	cmp	r3, #0
 80088ec:	d102      	bne.n	80088f4 <eARPGetCacheEntry+0x94>
			{
				/* The address is not on the local network, and there is not a
				router. */
				eReturn = eCantSendPacket;
 80088ee:	2302      	movs	r3, #2
 80088f0:	73fb      	strb	r3, [r7, #15]
 80088f2:	e00b      	b.n	800890c <eARPGetCacheEntry+0xac>
			}
			else
			{
				eReturn = prvCacheLookup( ulAddressToLookup, pxMACAddress );
 80088f4:	68b8      	ldr	r0, [r7, #8]
 80088f6:	6839      	ldr	r1, [r7, #0]
 80088f8:	f000 f818 	bl	800892c <prvCacheLookup>
 80088fc:	4603      	mov	r3, r0
 80088fe:	73fb      	strb	r3, [r7, #15]

				if( eReturn == eARPCacheMiss )
 8008900:	7bfb      	ldrb	r3, [r7, #15]
 8008902:	2b00      	cmp	r3, #0
 8008904:	d102      	bne.n	800890c <eARPGetCacheEntry+0xac>
				{
					/* It might be that the ARP has to go to the gateway. */
					*pulIPAddress = ulAddressToLookup;
 8008906:	687b      	ldr	r3, [r7, #4]
 8008908:	68ba      	ldr	r2, [r7, #8]
 800890a:	601a      	str	r2, [r3, #0]
				}
			}
		}
	}

	return eReturn;
 800890c:	7bfb      	ldrb	r3, [r7, #15]
}
 800890e:	4618      	mov	r0, r3
 8008910:	3710      	adds	r7, #16
 8008912:	46bd      	mov	sp, r7
 8008914:	bd80      	pop	{r7, pc}
 8008916:	bf00      	nop
 8008918:	fc0000e0 	.word	0xfc0000e0
 800891c:	08012a44 	.word	0x08012a44
 8008920:	2000c1c4 	.word	0x2000c1c4
 8008924:	08012a0c 	.word	0x08012a0c
 8008928:	2000bb08 	.word	0x2000bb08

0800892c <prvCacheLookup>:

/*-----------------------------------------------------------*/

static eARPLookupResult_t prvCacheLookup( uint32_t ulAddressToLookup, MACAddress_t * const pxMACAddress )
{
 800892c:	b580      	push	{r7, lr}
 800892e:	b084      	sub	sp, #16
 8008930:	af00      	add	r7, sp, #0
 8008932:	6078      	str	r0, [r7, #4]
 8008934:	6039      	str	r1, [r7, #0]
BaseType_t x;
eARPLookupResult_t eReturn = eARPCacheMiss;
 8008936:	2300      	movs	r3, #0
 8008938:	72fb      	strb	r3, [r7, #11]

	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 800893a:	2300      	movs	r3, #0
 800893c:	60fb      	str	r3, [r7, #12]
 800893e:	e02c      	b.n	800899a <prvCacheLookup+0x6e>
	{
		/* Does this row in the ARP cache table hold an entry for the IP address
		being queried? */
		if( xARPCache[ x ].ulIPAddress == ulAddressToLookup )
 8008940:	491a      	ldr	r1, [pc, #104]	; (80089ac <prvCacheLookup+0x80>)
 8008942:	68fa      	ldr	r2, [r7, #12]
 8008944:	4613      	mov	r3, r2
 8008946:	005b      	lsls	r3, r3, #1
 8008948:	4413      	add	r3, r2
 800894a:	009b      	lsls	r3, r3, #2
 800894c:	440b      	add	r3, r1
 800894e:	681a      	ldr	r2, [r3, #0]
 8008950:	687b      	ldr	r3, [r7, #4]
 8008952:	429a      	cmp	r2, r3
 8008954:	d11e      	bne.n	8008994 <prvCacheLookup+0x68>
		{
			/* A matching valid entry was found. */
			if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 8008956:	4915      	ldr	r1, [pc, #84]	; (80089ac <prvCacheLookup+0x80>)
 8008958:	68fa      	ldr	r2, [r7, #12]
 800895a:	4613      	mov	r3, r2
 800895c:	005b      	lsls	r3, r3, #1
 800895e:	4413      	add	r3, r2
 8008960:	009b      	lsls	r3, r3, #2
 8008962:	440b      	add	r3, r1
 8008964:	3308      	adds	r3, #8
 8008966:	78db      	ldrb	r3, [r3, #3]
 8008968:	2b00      	cmp	r3, #0
 800896a:	d102      	bne.n	8008972 <prvCacheLookup+0x46>
			{
				/* This entry is waiting an ARP reply, so is not valid. */
				eReturn = eCantSendPacket;
 800896c:	2302      	movs	r3, #2
 800896e:	72fb      	strb	r3, [r7, #11]
			{
				/* A valid entry was found. */
				memcpy( pxMACAddress->ucBytes, xARPCache[ x ].xMACAddress.ucBytes, sizeof( MACAddress_t ) );
				eReturn = eARPCacheHit;
			}
			break;
 8008970:	e016      	b.n	80089a0 <prvCacheLookup+0x74>
				eReturn = eCantSendPacket;
			}
			else
			{
				/* A valid entry was found. */
				memcpy( pxMACAddress->ucBytes, xARPCache[ x ].xMACAddress.ucBytes, sizeof( MACAddress_t ) );
 8008972:	6839      	ldr	r1, [r7, #0]
 8008974:	68fa      	ldr	r2, [r7, #12]
 8008976:	4613      	mov	r3, r2
 8008978:	005b      	lsls	r3, r3, #1
 800897a:	4413      	add	r3, r2
 800897c:	009b      	lsls	r3, r3, #2
 800897e:	4a0b      	ldr	r2, [pc, #44]	; (80089ac <prvCacheLookup+0x80>)
 8008980:	4413      	add	r3, r2
 8008982:	3304      	adds	r3, #4
 8008984:	4608      	mov	r0, r1
 8008986:	4619      	mov	r1, r3
 8008988:	2206      	movs	r2, #6
 800898a:	f007 fb8d 	bl	80100a8 <memcpy>
				eReturn = eARPCacheHit;
 800898e:	2301      	movs	r3, #1
 8008990:	72fb      	strb	r3, [r7, #11]
			}
			break;
 8008992:	e005      	b.n	80089a0 <prvCacheLookup+0x74>
{
BaseType_t x;
eARPLookupResult_t eReturn = eARPCacheMiss;

	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8008994:	68fb      	ldr	r3, [r7, #12]
 8008996:	3301      	adds	r3, #1
 8008998:	60fb      	str	r3, [r7, #12]
 800899a:	68fb      	ldr	r3, [r7, #12]
 800899c:	2b05      	cmp	r3, #5
 800899e:	ddcf      	ble.n	8008940 <prvCacheLookup+0x14>
			}
			break;
		}
	}

	return eReturn;
 80089a0:	7afb      	ldrb	r3, [r7, #11]
}
 80089a2:	4618      	mov	r0, r3
 80089a4:	3710      	adds	r7, #16
 80089a6:	46bd      	mov	sp, r7
 80089a8:	bd80      	pop	{r7, pc}
 80089aa:	bf00      	nop
 80089ac:	2000c244 	.word	0x2000c244

080089b0 <vARPAgeCache>:
/*-----------------------------------------------------------*/

void vARPAgeCache( void )
{
 80089b0:	b580      	push	{r7, lr}
 80089b2:	b082      	sub	sp, #8
 80089b4:	af00      	add	r7, sp, #0
BaseType_t x;
TickType_t xTimeNow;

	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 80089b6:	2300      	movs	r3, #0
 80089b8:	607b      	str	r3, [r7, #4]
 80089ba:	e063      	b.n	8008a84 <vARPAgeCache+0xd4>
	{
		/* If the entry is valid (its age is greater than zero). */
		if( xARPCache[ x ].ucAge > 0U )
 80089bc:	4940      	ldr	r1, [pc, #256]	; (8008ac0 <vARPAgeCache+0x110>)
 80089be:	687a      	ldr	r2, [r7, #4]
 80089c0:	4613      	mov	r3, r2
 80089c2:	005b      	lsls	r3, r3, #1
 80089c4:	4413      	add	r3, r2
 80089c6:	009b      	lsls	r3, r3, #2
 80089c8:	440b      	add	r3, r1
 80089ca:	3308      	adds	r3, #8
 80089cc:	789b      	ldrb	r3, [r3, #2]
 80089ce:	2b00      	cmp	r3, #0
 80089d0:	d055      	beq.n	8008a7e <vARPAgeCache+0xce>
		{
			/* Decrement the age value of the entry in this ARP cache table row.
			When the age reaches zero it is no longer considered valid. */
			( xARPCache[ x ].ucAge )--;
 80089d2:	493b      	ldr	r1, [pc, #236]	; (8008ac0 <vARPAgeCache+0x110>)
 80089d4:	687a      	ldr	r2, [r7, #4]
 80089d6:	4613      	mov	r3, r2
 80089d8:	005b      	lsls	r3, r3, #1
 80089da:	4413      	add	r3, r2
 80089dc:	009b      	lsls	r3, r3, #2
 80089de:	440b      	add	r3, r1
 80089e0:	3308      	adds	r3, #8
 80089e2:	789b      	ldrb	r3, [r3, #2]
 80089e4:	3b01      	subs	r3, #1
 80089e6:	b2d8      	uxtb	r0, r3
 80089e8:	4935      	ldr	r1, [pc, #212]	; (8008ac0 <vARPAgeCache+0x110>)
 80089ea:	687a      	ldr	r2, [r7, #4]
 80089ec:	4613      	mov	r3, r2
 80089ee:	005b      	lsls	r3, r3, #1
 80089f0:	4413      	add	r3, r2
 80089f2:	009b      	lsls	r3, r3, #2
 80089f4:	440b      	add	r3, r1
 80089f6:	3308      	adds	r3, #8
 80089f8:	4602      	mov	r2, r0
 80089fa:	709a      	strb	r2, [r3, #2]

			/* If the entry is not yet valid, then it is waiting an ARP
			reply, and the ARP request should be retransmitted. */
			if( xARPCache[ x ].ucValid == ( uint8_t ) pdFALSE )
 80089fc:	4930      	ldr	r1, [pc, #192]	; (8008ac0 <vARPAgeCache+0x110>)
 80089fe:	687a      	ldr	r2, [r7, #4]
 8008a00:	4613      	mov	r3, r2
 8008a02:	005b      	lsls	r3, r3, #1
 8008a04:	4413      	add	r3, r2
 8008a06:	009b      	lsls	r3, r3, #2
 8008a08:	440b      	add	r3, r1
 8008a0a:	3308      	adds	r3, #8
 8008a0c:	78db      	ldrb	r3, [r3, #3]
 8008a0e:	2b00      	cmp	r3, #0
 8008a10:	d10b      	bne.n	8008a2a <vARPAgeCache+0x7a>
			{
				FreeRTOS_OutputARPRequest( xARPCache[ x ].ulIPAddress );
 8008a12:	492b      	ldr	r1, [pc, #172]	; (8008ac0 <vARPAgeCache+0x110>)
 8008a14:	687a      	ldr	r2, [r7, #4]
 8008a16:	4613      	mov	r3, r2
 8008a18:	005b      	lsls	r3, r3, #1
 8008a1a:	4413      	add	r3, r2
 8008a1c:	009b      	lsls	r3, r3, #2
 8008a1e:	440b      	add	r3, r1
 8008a20:	681b      	ldr	r3, [r3, #0]
 8008a22:	4618      	mov	r0, r3
 8008a24:	f000 f852 	bl	8008acc <FreeRTOS_OutputARPRequest>
 8008a28:	e015      	b.n	8008a56 <vARPAgeCache+0xa6>
			}
			else if( xARPCache[ x ].ucAge <= ( uint8_t ) arpMAX_ARP_AGE_BEFORE_NEW_ARP_REQUEST )
 8008a2a:	4925      	ldr	r1, [pc, #148]	; (8008ac0 <vARPAgeCache+0x110>)
 8008a2c:	687a      	ldr	r2, [r7, #4]
 8008a2e:	4613      	mov	r3, r2
 8008a30:	005b      	lsls	r3, r3, #1
 8008a32:	4413      	add	r3, r2
 8008a34:	009b      	lsls	r3, r3, #2
 8008a36:	440b      	add	r3, r1
 8008a38:	3308      	adds	r3, #8
 8008a3a:	789b      	ldrb	r3, [r3, #2]
 8008a3c:	2b03      	cmp	r3, #3
 8008a3e:	d80a      	bhi.n	8008a56 <vARPAgeCache+0xa6>
			{
				/* This entry will get removed soon.  See if the MAC address is
				still valid to prevent this happening. */
				iptraceARP_TABLE_ENTRY_WILL_EXPIRE( xARPCache[ x ].ulIPAddress );
				FreeRTOS_OutputARPRequest( xARPCache[ x ].ulIPAddress );
 8008a40:	491f      	ldr	r1, [pc, #124]	; (8008ac0 <vARPAgeCache+0x110>)
 8008a42:	687a      	ldr	r2, [r7, #4]
 8008a44:	4613      	mov	r3, r2
 8008a46:	005b      	lsls	r3, r3, #1
 8008a48:	4413      	add	r3, r2
 8008a4a:	009b      	lsls	r3, r3, #2
 8008a4c:	440b      	add	r3, r1
 8008a4e:	681b      	ldr	r3, [r3, #0]
 8008a50:	4618      	mov	r0, r3
 8008a52:	f000 f83b 	bl	8008acc <FreeRTOS_OutputARPRequest>
			else
			{
				/* The age has just ticked down, with nothing to do. */
			}

			if( xARPCache[ x ].ucAge == 0u )
 8008a56:	491a      	ldr	r1, [pc, #104]	; (8008ac0 <vARPAgeCache+0x110>)
 8008a58:	687a      	ldr	r2, [r7, #4]
 8008a5a:	4613      	mov	r3, r2
 8008a5c:	005b      	lsls	r3, r3, #1
 8008a5e:	4413      	add	r3, r2
 8008a60:	009b      	lsls	r3, r3, #2
 8008a62:	440b      	add	r3, r1
 8008a64:	3308      	adds	r3, #8
 8008a66:	789b      	ldrb	r3, [r3, #2]
 8008a68:	2b00      	cmp	r3, #0
 8008a6a:	d108      	bne.n	8008a7e <vARPAgeCache+0xce>
			{
				/* The entry is no longer valid.  Wipe it out. */
				iptraceARP_TABLE_ENTRY_EXPIRED( xARPCache[ x ].ulIPAddress );
				xARPCache[ x ].ulIPAddress = 0UL;
 8008a6c:	4914      	ldr	r1, [pc, #80]	; (8008ac0 <vARPAgeCache+0x110>)
 8008a6e:	687a      	ldr	r2, [r7, #4]
 8008a70:	4613      	mov	r3, r2
 8008a72:	005b      	lsls	r3, r3, #1
 8008a74:	4413      	add	r3, r2
 8008a76:	009b      	lsls	r3, r3, #2
 8008a78:	440b      	add	r3, r1
 8008a7a:	2200      	movs	r2, #0
 8008a7c:	601a      	str	r2, [r3, #0]
{
BaseType_t x;
TickType_t xTimeNow;

	/* Loop through each entry in the ARP cache. */
	for( x = 0; x < ipconfigARP_CACHE_ENTRIES; x++ )
 8008a7e:	687b      	ldr	r3, [r7, #4]
 8008a80:	3301      	adds	r3, #1
 8008a82:	607b      	str	r3, [r7, #4]
 8008a84:	687b      	ldr	r3, [r7, #4]
 8008a86:	2b05      	cmp	r3, #5
 8008a88:	dd98      	ble.n	80089bc <vARPAgeCache+0xc>
				xARPCache[ x ].ulIPAddress = 0UL;
			}
		}
	}

	xTimeNow = xTaskGetTickCount ();
 8008a8a:	f7fc fd7b 	bl	8005584 <xTaskGetTickCount>
 8008a8e:	6038      	str	r0, [r7, #0]

	if( ( xLastGratuitousARPTime == ( TickType_t ) 0 ) || ( ( xTimeNow - xLastGratuitousARPTime ) > ( TickType_t ) arpGRATUITOUS_ARP_PERIOD ) )
 8008a90:	4b0c      	ldr	r3, [pc, #48]	; (8008ac4 <vARPAgeCache+0x114>)
 8008a92:	681b      	ldr	r3, [r3, #0]
 8008a94:	2b00      	cmp	r3, #0
 8008a96:	d007      	beq.n	8008aa8 <vARPAgeCache+0xf8>
 8008a98:	4b0a      	ldr	r3, [pc, #40]	; (8008ac4 <vARPAgeCache+0x114>)
 8008a9a:	681b      	ldr	r3, [r3, #0]
 8008a9c:	683a      	ldr	r2, [r7, #0]
 8008a9e:	1ad3      	subs	r3, r2, r3
 8008aa0:	f644 6220 	movw	r2, #20000	; 0x4e20
 8008aa4:	4293      	cmp	r3, r2
 8008aa6:	d907      	bls.n	8008ab8 <vARPAgeCache+0x108>
	{
		FreeRTOS_OutputARPRequest( *ipLOCAL_IP_ADDRESS_POINTER );
 8008aa8:	4b07      	ldr	r3, [pc, #28]	; (8008ac8 <vARPAgeCache+0x118>)
 8008aaa:	695b      	ldr	r3, [r3, #20]
 8008aac:	4618      	mov	r0, r3
 8008aae:	f000 f80d 	bl	8008acc <FreeRTOS_OutputARPRequest>
		xLastGratuitousARPTime = xTimeNow;
 8008ab2:	4a04      	ldr	r2, [pc, #16]	; (8008ac4 <vARPAgeCache+0x114>)
 8008ab4:	683b      	ldr	r3, [r7, #0]
 8008ab6:	6013      	str	r3, [r2, #0]
	}
}
 8008ab8:	3708      	adds	r7, #8
 8008aba:	46bd      	mov	sp, r7
 8008abc:	bd80      	pop	{r7, pc}
 8008abe:	bf00      	nop
 8008ac0:	2000c244 	.word	0x2000c244
 8008ac4:	2000c28c 	.word	0x2000c28c
 8008ac8:	2000bb08 	.word	0x2000bb08

08008acc <FreeRTOS_OutputARPRequest>:
	xSendEventToIPTask( eARPTimerEvent );
}

/*-----------------------------------------------------------*/
void FreeRTOS_OutputARPRequest( uint32_t ulIPAddress )
{
 8008acc:	b580      	push	{r7, lr}
 8008ace:	b084      	sub	sp, #16
 8008ad0:	af00      	add	r7, sp, #0
 8008ad2:	6078      	str	r0, [r7, #4]
NetworkBufferDescriptor_t *pxNetworkBuffer;

	/* This is called from the context of the IP event task, so a block time
	must not be used. */
	pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( sizeof( ARPPacket_t ), ( TickType_t ) 0 );
 8008ad4:	202a      	movs	r0, #42	; 0x2a
 8008ad6:	2100      	movs	r1, #0
 8008ad8:	f7fe fe06 	bl	80076e8 <pxGetNetworkBufferWithDescriptor>
 8008adc:	60f8      	str	r0, [r7, #12]

	if( pxNetworkBuffer != NULL )
 8008ade:	68fb      	ldr	r3, [r7, #12]
 8008ae0:	2b00      	cmp	r3, #0
 8008ae2:	d009      	beq.n	8008af8 <FreeRTOS_OutputARPRequest+0x2c>
	{
		pxNetworkBuffer->ulIPAddress = ulIPAddress;
 8008ae4:	68fb      	ldr	r3, [r7, #12]
 8008ae6:	687a      	ldr	r2, [r7, #4]
 8008ae8:	615a      	str	r2, [r3, #20]
		vARPGenerateRequestPacket( pxNetworkBuffer );
 8008aea:	68f8      	ldr	r0, [r7, #12]
 8008aec:	f000 f808 	bl	8008b00 <vARPGenerateRequestPacket>
				pxNetworkBuffer->xDataLength = ( size_t ) ipconfigETHERNET_MINIMUM_PACKET_BYTES;
			}
		}
		#endif

		xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
 8008af0:	68f8      	ldr	r0, [r7, #12]
 8008af2:	2101      	movs	r1, #1
 8008af4:	f7fe f91a 	bl	8006d2c <xNetworkInterfaceOutput>
	}
}
 8008af8:	3710      	adds	r7, #16
 8008afa:	46bd      	mov	sp, r7
 8008afc:	bd80      	pop	{r7, pc}
 8008afe:	bf00      	nop

08008b00 <vARPGenerateRequestPacket>:

void vARPGenerateRequestPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 8008b00:	b580      	push	{r7, lr}
 8008b02:	b084      	sub	sp, #16
 8008b04:	af00      	add	r7, sp, #0
 8008b06:	6078      	str	r0, [r7, #4]
ARPPacket_t *pxARPPacket;

	pxARPPacket = ( ARPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer;
 8008b08:	687b      	ldr	r3, [r7, #4]
 8008b0a:	699b      	ldr	r3, [r3, #24]
 8008b0c:	60fb      	str	r3, [r7, #12]
		xARPHeader.ucHardwareAddressLength;
		xARPHeader.ucProtocolAddressLength;
		xARPHeader.usOperation;
		xARPHeader.xTargetHardwareAddress;
	*/
	memcpy( ( void * ) &( pxARPPacket->xEthernetHeader ), ( void * ) xDefaultPartARPPacketHeader, sizeof( xDefaultPartARPPacketHeader ) );
 8008b0e:	68fb      	ldr	r3, [r7, #12]
 8008b10:	4618      	mov	r0, r3
 8008b12:	4910      	ldr	r1, [pc, #64]	; (8008b54 <vARPGenerateRequestPacket+0x54>)
 8008b14:	2226      	movs	r2, #38	; 0x26
 8008b16:	f007 fac7 	bl	80100a8 <memcpy>
	memcpy( ( void * ) pxARPPacket->xEthernetHeader.xSourceAddress.ucBytes , ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8008b1a:	68fb      	ldr	r3, [r7, #12]
 8008b1c:	3306      	adds	r3, #6
 8008b1e:	4618      	mov	r0, r3
 8008b20:	490d      	ldr	r1, [pc, #52]	; (8008b58 <vARPGenerateRequestPacket+0x58>)
 8008b22:	2206      	movs	r2, #6
 8008b24:	f007 fac0 	bl	80100a8 <memcpy>
	memcpy( ( void * ) pxARPPacket->xARPHeader.xSenderHardwareAddress.ucBytes, ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 8008b28:	68fb      	ldr	r3, [r7, #12]
 8008b2a:	3316      	adds	r3, #22
 8008b2c:	4618      	mov	r0, r3
 8008b2e:	490a      	ldr	r1, [pc, #40]	; (8008b58 <vARPGenerateRequestPacket+0x58>)
 8008b30:	2206      	movs	r2, #6
 8008b32:	f007 fab9 	bl	80100a8 <memcpy>
	/* HT:endian: network to network */
	pxARPPacket->xARPHeader.ulSenderProtocolAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 8008b36:	4b08      	ldr	r3, [pc, #32]	; (8008b58 <vARPGenerateRequestPacket+0x58>)
 8008b38:	695a      	ldr	r2, [r3, #20]
 8008b3a:	68fb      	ldr	r3, [r7, #12]
 8008b3c:	61da      	str	r2, [r3, #28]
	pxARPPacket->xARPHeader.ulTargetProtocolAddress = pxNetworkBuffer->ulIPAddress;
 8008b3e:	687b      	ldr	r3, [r7, #4]
 8008b40:	695a      	ldr	r2, [r3, #20]
 8008b42:	68fb      	ldr	r3, [r7, #12]
 8008b44:	f8c3 2026 	str.w	r2, [r3, #38]	; 0x26

	pxNetworkBuffer->xDataLength = sizeof( ARPPacket_t );
 8008b48:	687b      	ldr	r3, [r7, #4]
 8008b4a:	222a      	movs	r2, #42	; 0x2a
 8008b4c:	61da      	str	r2, [r3, #28]

	iptraceCREATING_ARP_REQUEST( pxNetworkBuffer->ulIPAddress );
}
 8008b4e:	3710      	adds	r7, #16
 8008b50:	46bd      	mov	sp, r7
 8008b52:	bd80      	pop	{r7, pc}
 8008b54:	08012a1c 	.word	0x08012a1c
 8008b58:	2000bb08 	.word	0x2000bb08

08008b5c <FreeRTOS_max_uint32>:
	static portINLINE BaseType_t  	FreeRTOS_min_BaseType  (BaseType_t  a, BaseType_t  b);
	static portINLINE UBaseType_t  	FreeRTOS_min_UBaseType (UBaseType_t  a, UBaseType_t  b);


	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return a >= b ? a : b; }
	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return a >= b ? a : b; }
 8008b5c:	b480      	push	{r7}
 8008b5e:	b083      	sub	sp, #12
 8008b60:	af00      	add	r7, sp, #0
 8008b62:	6078      	str	r0, [r7, #4]
 8008b64:	6039      	str	r1, [r7, #0]
 8008b66:	687a      	ldr	r2, [r7, #4]
 8008b68:	683b      	ldr	r3, [r7, #0]
 8008b6a:	4293      	cmp	r3, r2
 8008b6c:	bf38      	it	cc
 8008b6e:	4613      	movcc	r3, r2
 8008b70:	4618      	mov	r0, r3
 8008b72:	370c      	adds	r7, #12
 8008b74:	46bd      	mov	sp, r7
 8008b76:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008b7a:	4770      	bx	lr

08008b7c <FreeRTOS_round_up>:
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return a <= b ? a : b; }
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
	static portINLINE uint32_t FreeRTOS_round_up   (uint32_t a, uint32_t d) { return d * ( ( a + d - 1u ) / d ); }
 8008b7c:	b480      	push	{r7}
 8008b7e:	b083      	sub	sp, #12
 8008b80:	af00      	add	r7, sp, #0
 8008b82:	6078      	str	r0, [r7, #4]
 8008b84:	6039      	str	r1, [r7, #0]
 8008b86:	687a      	ldr	r2, [r7, #4]
 8008b88:	683b      	ldr	r3, [r7, #0]
 8008b8a:	4413      	add	r3, r2
 8008b8c:	1e5a      	subs	r2, r3, #1
 8008b8e:	683b      	ldr	r3, [r7, #0]
 8008b90:	fbb2 f3f3 	udiv	r3, r2, r3
 8008b94:	683a      	ldr	r2, [r7, #0]
 8008b96:	fb02 f303 	mul.w	r3, r2, r3
 8008b9a:	4618      	mov	r0, r3
 8008b9c:	370c      	adds	r7, #12
 8008b9e:	46bd      	mov	sp, r7
 8008ba0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008ba4:	4770      	bx	lr
 8008ba6:	bf00      	nop

08008ba8 <uxStreamBufferSpace>:
}
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper );
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
 8008ba8:	b480      	push	{r7}
 8008baa:	b087      	sub	sp, #28
 8008bac:	af00      	add	r7, sp, #0
 8008bae:	60f8      	str	r0, [r7, #12]
 8008bb0:	60b9      	str	r1, [r7, #8]
 8008bb2:	607a      	str	r2, [r7, #4]
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 8008bb4:	68fb      	ldr	r3, [r7, #12]
 8008bb6:	691a      	ldr	r2, [r3, #16]
 8008bb8:	687b      	ldr	r3, [r7, #4]
 8008bba:	441a      	add	r2, r3
 8008bbc:	68bb      	ldr	r3, [r7, #8]
 8008bbe:	1ad3      	subs	r3, r2, r3
 8008bc0:	3b01      	subs	r3, #1
 8008bc2:	617b      	str	r3, [r7, #20]
	if( uxCount >= pxBuffer->LENGTH )
 8008bc4:	68fb      	ldr	r3, [r7, #12]
 8008bc6:	691a      	ldr	r2, [r3, #16]
 8008bc8:	697b      	ldr	r3, [r7, #20]
 8008bca:	429a      	cmp	r2, r3
 8008bcc:	d804      	bhi.n	8008bd8 <uxStreamBufferSpace+0x30>
	{
		uxCount -= pxBuffer->LENGTH;
 8008bce:	68fb      	ldr	r3, [r7, #12]
 8008bd0:	691b      	ldr	r3, [r3, #16]
 8008bd2:	697a      	ldr	r2, [r7, #20]
 8008bd4:	1ad3      	subs	r3, r2, r3
 8008bd6:	617b      	str	r3, [r7, #20]
	}

	return uxCount;
 8008bd8:	697b      	ldr	r3, [r7, #20]
}
 8008bda:	4618      	mov	r0, r3
 8008bdc:	371c      	adds	r7, #28
 8008bde:	46bd      	mov	sp, r7
 8008be0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008be4:	4770      	bx	lr
 8008be6:	bf00      	nop

08008be8 <uxStreamBufferDistance>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper );
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
 8008be8:	b480      	push	{r7}
 8008bea:	b087      	sub	sp, #28
 8008bec:	af00      	add	r7, sp, #0
 8008bee:	60f8      	str	r0, [r7, #12]
 8008bf0:	60b9      	str	r1, [r7, #8]
 8008bf2:	607a      	str	r2, [r7, #4]
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 8008bf4:	68fb      	ldr	r3, [r7, #12]
 8008bf6:	691a      	ldr	r2, [r3, #16]
 8008bf8:	687b      	ldr	r3, [r7, #4]
 8008bfa:	441a      	add	r2, r3
 8008bfc:	68bb      	ldr	r3, [r7, #8]
 8008bfe:	1ad3      	subs	r3, r2, r3
 8008c00:	617b      	str	r3, [r7, #20]
	if ( uxCount >= pxBuffer->LENGTH )
 8008c02:	68fb      	ldr	r3, [r7, #12]
 8008c04:	691a      	ldr	r2, [r3, #16]
 8008c06:	697b      	ldr	r3, [r7, #20]
 8008c08:	429a      	cmp	r2, r3
 8008c0a:	d804      	bhi.n	8008c16 <uxStreamBufferDistance+0x2e>
	{
		uxCount -= pxBuffer->LENGTH;
 8008c0c:	68fb      	ldr	r3, [r7, #12]
 8008c0e:	691b      	ldr	r3, [r3, #16]
 8008c10:	697a      	ldr	r2, [r7, #20]
 8008c12:	1ad3      	subs	r3, r2, r3
 8008c14:	617b      	str	r3, [r7, #20]
	}

	return uxCount;
 8008c16:	697b      	ldr	r3, [r7, #20]
}
 8008c18:	4618      	mov	r0, r3
 8008c1a:	371c      	adds	r7, #28
 8008c1c:	46bd      	mov	sp, r7
 8008c1e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8008c22:	4770      	bx	lr

08008c24 <uxStreamBufferGetSpace>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer )
{
 8008c24:	b580      	push	{r7, lr}
 8008c26:	b084      	sub	sp, #16
 8008c28:	af00      	add	r7, sp, #0
 8008c2a:	6078      	str	r0, [r7, #4]
/* Returns the number of items which can still be added to uxHead
before hitting on uxTail */
size_t uxHead = pxBuffer->uxHead;
 8008c2c:	687b      	ldr	r3, [r7, #4]
 8008c2e:	689b      	ldr	r3, [r3, #8]
 8008c30:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
 8008c32:	687b      	ldr	r3, [r7, #4]
 8008c34:	681b      	ldr	r3, [r3, #0]
 8008c36:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferSpace( pxBuffer, uxHead, uxTail );
 8008c38:	6878      	ldr	r0, [r7, #4]
 8008c3a:	68f9      	ldr	r1, [r7, #12]
 8008c3c:	68ba      	ldr	r2, [r7, #8]
 8008c3e:	f7ff ffb3 	bl	8008ba8 <uxStreamBufferSpace>
 8008c42:	4603      	mov	r3, r0
}
 8008c44:	4618      	mov	r0, r3
 8008c46:	3710      	adds	r7, #16
 8008c48:	46bd      	mov	sp, r7
 8008c4a:	bd80      	pop	{r7, pc}

08008c4c <uxStreamBufferFrontSpace>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferFrontSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferFrontSpace( const StreamBuffer_t *pxBuffer )
{
 8008c4c:	b580      	push	{r7, lr}
 8008c4e:	b084      	sub	sp, #16
 8008c50:	af00      	add	r7, sp, #0
 8008c52:	6078      	str	r0, [r7, #4]
/* Distance between uxFront and uxTail
or the number of items which can still be added to uxFront,
before hitting on uxTail */

size_t uxFront = pxBuffer->uxFront;
 8008c54:	687b      	ldr	r3, [r7, #4]
 8008c56:	68db      	ldr	r3, [r3, #12]
 8008c58:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
 8008c5a:	687b      	ldr	r3, [r7, #4]
 8008c5c:	681b      	ldr	r3, [r3, #0]
 8008c5e:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferSpace( pxBuffer, uxFront, uxTail );
 8008c60:	6878      	ldr	r0, [r7, #4]
 8008c62:	68f9      	ldr	r1, [r7, #12]
 8008c64:	68ba      	ldr	r2, [r7, #8]
 8008c66:	f7ff ff9f 	bl	8008ba8 <uxStreamBufferSpace>
 8008c6a:	4603      	mov	r3, r0
}
 8008c6c:	4618      	mov	r0, r3
 8008c6e:	3710      	adds	r7, #16
 8008c70:	46bd      	mov	sp, r7
 8008c72:	bd80      	pop	{r7, pc}

08008c74 <uxStreamBufferGetSize>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
{
 8008c74:	b580      	push	{r7, lr}
 8008c76:	b084      	sub	sp, #16
 8008c78:	af00      	add	r7, sp, #0
 8008c7a:	6078      	str	r0, [r7, #4]
/* Returns the number of items which can be read from uxTail
before reaching uxHead */
size_t uxHead = pxBuffer->uxHead;
 8008c7c:	687b      	ldr	r3, [r7, #4]
 8008c7e:	689b      	ldr	r3, [r3, #8]
 8008c80:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
 8008c82:	687b      	ldr	r3, [r7, #4]
 8008c84:	681b      	ldr	r3, [r3, #0]
 8008c86:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferDistance( pxBuffer, uxTail, uxHead );
 8008c88:	6878      	ldr	r0, [r7, #4]
 8008c8a:	68b9      	ldr	r1, [r7, #8]
 8008c8c:	68fa      	ldr	r2, [r7, #12]
 8008c8e:	f7ff ffab 	bl	8008be8 <uxStreamBufferDistance>
 8008c92:	4603      	mov	r3, r0
}
 8008c94:	4618      	mov	r0, r3
 8008c96:	3710      	adds	r7, #16
 8008c98:	46bd      	mov	sp, r7
 8008c9a:	bd80      	pop	{r7, pc}

08008c9c <vNetworkSocketsInit>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vNetworkSocketsInit( void )
{
 8008c9c:	b580      	push	{r7, lr}
 8008c9e:	b082      	sub	sp, #8
 8008ca0:	af00      	add	r7, sp, #0
const uint32_t ulAutoPortRange = socketAUTO_PORT_ALLOCATION_MAX_NUMBER - socketAUTO_PORT_ALLOCATION_RESET_NUMBER;
 8008ca2:	f44f 5378 	mov.w	r3, #15872	; 0x3e00
 8008ca6:	607b      	str	r3, [r7, #4]
uint32_t ulRandomPort;

	vListInitialise( &xBoundUDPSocketsList );
 8008ca8:	481a      	ldr	r0, [pc, #104]	; (8008d14 <vNetworkSocketsInit+0x78>)
 8008caa:	f7fa ff3f 	bl	8003b2c <vListInitialise>

	/* Determine the first anonymous UDP port number to get assigned.  Give it
	a random value in order to avoid confusion about port numbers being used
	earlier, before rebooting the device.  Start with the first auto port
	number, then add a random offset up to a maximum of the range of numbers. */
	ulRandomPort = socketAUTO_PORT_ALLOCATION_START_NUMBER;
 8008cae:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8008cb2:	603b      	str	r3, [r7, #0]
	ulRandomPort += ( ipconfigRAND32() % ulAutoPortRange );
 8008cb4:	f006 fb9e 	bl	800f3f4 <uxRand>
 8008cb8:	4603      	mov	r3, r0
 8008cba:	687a      	ldr	r2, [r7, #4]
 8008cbc:	fbb3 f2f2 	udiv	r2, r3, r2
 8008cc0:	6879      	ldr	r1, [r7, #4]
 8008cc2:	fb01 f202 	mul.w	r2, r1, r2
 8008cc6:	1a9b      	subs	r3, r3, r2
 8008cc8:	683a      	ldr	r2, [r7, #0]
 8008cca:	4413      	add	r3, r2
 8008ccc:	603b      	str	r3, [r7, #0]
	usNextPortToUse[ socketNEXT_UDP_PORT_NUMBER_INDEX ] = ( uint16_t ) ulRandomPort;
 8008cce:	683b      	ldr	r3, [r7, #0]
 8008cd0:	b29a      	uxth	r2, r3
 8008cd2:	4b11      	ldr	r3, [pc, #68]	; (8008d18 <vNetworkSocketsInit+0x7c>)
 8008cd4:	801a      	strh	r2, [r3, #0]

	#if( ipconfigUSE_TCP == 1 )
	{
		extern uint32_t ulNextInitialSequenceNumber;

		ulNextInitialSequenceNumber = ipconfigRAND32();
 8008cd6:	f006 fb8d 	bl	800f3f4 <uxRand>
 8008cda:	4602      	mov	r2, r0
 8008cdc:	4b0f      	ldr	r3, [pc, #60]	; (8008d1c <vNetworkSocketsInit+0x80>)
 8008cde:	601a      	str	r2, [r3, #0]

		/* Determine the first anonymous TCP port number to get assigned. */
		ulRandomPort = socketAUTO_PORT_ALLOCATION_START_NUMBER;
 8008ce0:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 8008ce4:	603b      	str	r3, [r7, #0]
		ulRandomPort += ( ipconfigRAND32() % ulAutoPortRange );
 8008ce6:	f006 fb85 	bl	800f3f4 <uxRand>
 8008cea:	4603      	mov	r3, r0
 8008cec:	687a      	ldr	r2, [r7, #4]
 8008cee:	fbb3 f2f2 	udiv	r2, r3, r2
 8008cf2:	6879      	ldr	r1, [r7, #4]
 8008cf4:	fb01 f202 	mul.w	r2, r1, r2
 8008cf8:	1a9b      	subs	r3, r3, r2
 8008cfa:	683a      	ldr	r2, [r7, #0]
 8008cfc:	4413      	add	r3, r2
 8008cfe:	603b      	str	r3, [r7, #0]
		usNextPortToUse[ socketNEXT_TCP_PORT_NUMBER_INDEX ] = ( uint16_t ) ulRandomPort;
 8008d00:	683b      	ldr	r3, [r7, #0]
 8008d02:	b29a      	uxth	r2, r3
 8008d04:	4b04      	ldr	r3, [pc, #16]	; (8008d18 <vNetworkSocketsInit+0x7c>)
 8008d06:	805a      	strh	r2, [r3, #2]

		vListInitialise( &xBoundTCPSocketsList );
 8008d08:	4805      	ldr	r0, [pc, #20]	; (8008d20 <vNetworkSocketsInit+0x84>)
 8008d0a:	f7fa ff0f 	bl	8003b2c <vListInitialise>
	}
	#endif  /* ipconfigUSE_TCP == 1 */
}
 8008d0e:	3708      	adds	r7, #8
 8008d10:	46bd      	mov	sp, r7
 8008d12:	bd80      	pop	{r7, pc}
 8008d14:	2000cf24 	.word	0x2000cf24
 8008d18:	2000c290 	.word	0x2000c290
 8008d1c:	2000c298 	.word	0x2000c298
 8008d20:	2000cf10 	.word	0x2000cf10

08008d24 <prvDetermineSocketSize>:
/*-----------------------------------------------------------*/

static BaseType_t prvDetermineSocketSize( BaseType_t xDomain, BaseType_t xType, BaseType_t xProtocol, size_t *pxSocketSize )
{
 8008d24:	b580      	push	{r7, lr}
 8008d26:	b088      	sub	sp, #32
 8008d28:	af00      	add	r7, sp, #0
 8008d2a:	60f8      	str	r0, [r7, #12]
 8008d2c:	60b9      	str	r1, [r7, #8]
 8008d2e:	607a      	str	r2, [r7, #4]
 8008d30:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdPASS;
 8008d32:	2301      	movs	r3, #1
 8008d34:	61fb      	str	r3, [r7, #28]
FreeRTOS_Socket_t *pxSocket;

	/* Asserts must not appear before it has been determined that the network
	task is ready - otherwise the asserts will fail. */
	if( xIPIsNetworkTaskReady() == pdFALSE )
 8008d36:	f7ff fc0b 	bl	8008550 <xIPIsNetworkTaskReady>
 8008d3a:	4603      	mov	r3, r0
 8008d3c:	2b00      	cmp	r3, #0
 8008d3e:	d102      	bne.n	8008d46 <prvDetermineSocketSize+0x22>
	{
		xReturn = pdFAIL;
 8008d40:	2300      	movs	r3, #0
 8008d42:	61fb      	str	r3, [r7, #28]
 8008d44:	e045      	b.n	8008dd2 <prvDetermineSocketSize+0xae>
	}
	else
	{
		/* Only Ethernet is currently supported. */
		configASSERT( xDomain == FREERTOS_AF_INET );
 8008d46:	68fb      	ldr	r3, [r7, #12]
 8008d48:	2b02      	cmp	r3, #2
 8008d4a:	d009      	beq.n	8008d60 <prvDetermineSocketSize+0x3c>
 8008d4c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008d50:	f383 8811 	msr	BASEPRI, r3
 8008d54:	f3bf 8f6f 	isb	sy
 8008d58:	f3bf 8f4f 	dsb	sy
 8008d5c:	61bb      	str	r3, [r7, #24]
 8008d5e:	e7fe      	b.n	8008d5e <prvDetermineSocketSize+0x3a>

		/* Check if the UDP socket-list has been initialised. */
		configASSERT( listLIST_IS_INITIALISED( &xBoundUDPSocketsList ) );
 8008d60:	4b1e      	ldr	r3, [pc, #120]	; (8008ddc <prvDetermineSocketSize+0xb8>)
 8008d62:	689b      	ldr	r3, [r3, #8]
 8008d64:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8008d68:	d009      	beq.n	8008d7e <prvDetermineSocketSize+0x5a>
 8008d6a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008d6e:	f383 8811 	msr	BASEPRI, r3
 8008d72:	f3bf 8f6f 	isb	sy
 8008d76:	f3bf 8f4f 	dsb	sy
 8008d7a:	617b      	str	r3, [r7, #20]
 8008d7c:	e7fe      	b.n	8008d7c <prvDetermineSocketSize+0x58>
		#if( ipconfigUSE_TCP == 1 )
		{
			/* Check if the TCP socket-list has been initialised. */
			configASSERT( listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) );
 8008d7e:	4b18      	ldr	r3, [pc, #96]	; (8008de0 <prvDetermineSocketSize+0xbc>)
 8008d80:	689b      	ldr	r3, [r3, #8]
 8008d82:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8008d86:	d009      	beq.n	8008d9c <prvDetermineSocketSize+0x78>
 8008d88:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008d8c:	f383 8811 	msr	BASEPRI, r3
 8008d90:	f3bf 8f6f 	isb	sy
 8008d94:	f3bf 8f4f 	dsb	sy
 8008d98:	613b      	str	r3, [r7, #16]
 8008d9a:	e7fe      	b.n	8008d9a <prvDetermineSocketSize+0x76>
		}
		#endif  /* ipconfigUSE_TCP == 1 */

		if( xProtocol == FREERTOS_IPPROTO_UDP )
 8008d9c:	687b      	ldr	r3, [r7, #4]
 8008d9e:	2b11      	cmp	r3, #17
 8008da0:	d108      	bne.n	8008db4 <prvDetermineSocketSize+0x90>
		{
			if( xType != FREERTOS_SOCK_DGRAM )
 8008da2:	68bb      	ldr	r3, [r7, #8]
 8008da4:	2b02      	cmp	r3, #2
 8008da6:	d001      	beq.n	8008dac <prvDetermineSocketSize+0x88>
			{
				xReturn = pdFAIL;
 8008da8:	2300      	movs	r3, #0
 8008daa:	61fb      	str	r3, [r7, #28]
			}
			/* In case a UDP socket is created, do not allocate space for TCP data. */
			*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xUDP );
 8008dac:	683b      	ldr	r3, [r7, #0]
 8008dae:	224c      	movs	r2, #76	; 0x4c
 8008db0:	601a      	str	r2, [r3, #0]
 8008db2:	e00e      	b.n	8008dd2 <prvDetermineSocketSize+0xae>
		}
#if( ipconfigUSE_TCP == 1 )
		else if( xProtocol == FREERTOS_IPPROTO_TCP )
 8008db4:	687b      	ldr	r3, [r7, #4]
 8008db6:	2b06      	cmp	r3, #6
 8008db8:	d109      	bne.n	8008dce <prvDetermineSocketSize+0xaa>
		{
			if( xType != FREERTOS_SOCK_STREAM )
 8008dba:	68bb      	ldr	r3, [r7, #8]
 8008dbc:	2b01      	cmp	r3, #1
 8008dbe:	d001      	beq.n	8008dc4 <prvDetermineSocketSize+0xa0>
			{
				xReturn = pdFAIL;
 8008dc0:	2300      	movs	r3, #0
 8008dc2:	61fb      	str	r3, [r7, #28]
			}

			*pxSocketSize = ( sizeof( *pxSocket ) - sizeof( pxSocket->u ) ) + sizeof( pxSocket->u.xTCP );
 8008dc4:	683b      	ldr	r3, [r7, #0]
 8008dc6:	f44f 72d0 	mov.w	r2, #416	; 0x1a0
 8008dca:	601a      	str	r2, [r3, #0]
 8008dcc:	e001      	b.n	8008dd2 <prvDetermineSocketSize+0xae>
		}
#endif  /* ipconfigUSE_TCP == 1 */
		else
		{
			xReturn = pdFAIL;
 8008dce:	2300      	movs	r3, #0
 8008dd0:	61fb      	str	r3, [r7, #28]
		}
	}
	/* In case configASSERT() is not used */
	( void )xDomain;
	return xReturn;
 8008dd2:	69fb      	ldr	r3, [r7, #28]
}
 8008dd4:	4618      	mov	r0, r3
 8008dd6:	3720      	adds	r7, #32
 8008dd8:	46bd      	mov	sp, r7
 8008dda:	bd80      	pop	{r7, pc}
 8008ddc:	2000cf24 	.word	0x2000cf24
 8008de0:	2000cf10 	.word	0x2000cf10

08008de4 <FreeRTOS_socket>:
/*-----------------------------------------------------------*/

/* FreeRTOS_socket() allocates and initiates a socket */
Socket_t FreeRTOS_socket( BaseType_t xDomain, BaseType_t xType, BaseType_t xProtocol )
{
 8008de4:	b580      	push	{r7, lr}
 8008de6:	b088      	sub	sp, #32
 8008de8:	af00      	add	r7, sp, #0
 8008dea:	60f8      	str	r0, [r7, #12]
 8008dec:	60b9      	str	r1, [r7, #8]
 8008dee:	607a      	str	r2, [r7, #4]
FreeRTOS_Socket_t *pxSocket;
size_t uxSocketSize;
EventGroupHandle_t xEventGroup;
Socket_t xReturn;

	if( prvDetermineSocketSize( xDomain, xType, xProtocol, &uxSocketSize ) == pdFAIL )
 8008df0:	f107 0310 	add.w	r3, r7, #16
 8008df4:	68f8      	ldr	r0, [r7, #12]
 8008df6:	68b9      	ldr	r1, [r7, #8]
 8008df8:	687a      	ldr	r2, [r7, #4]
 8008dfa:	f7ff ff93 	bl	8008d24 <prvDetermineSocketSize>
 8008dfe:	4603      	mov	r3, r0
 8008e00:	2b00      	cmp	r3, #0
 8008e02:	d103      	bne.n	8008e0c <FreeRTOS_socket+0x28>
	{
		xReturn = FREERTOS_INVALID_SOCKET;
 8008e04:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8008e08:	61bb      	str	r3, [r7, #24]
 8008e0a:	e07d      	b.n	8008f08 <FreeRTOS_socket+0x124>
	{
		/* Allocate the structure that will hold the socket information.  The
		size depends on the type of socket: UDP sockets need less space.  A
		define 'pvPortMallocSocket' will used to allocate the necessary space.
		By default it points to the FreeRTOS function 'pvPortMalloc()'. */
		pxSocket = ( FreeRTOS_Socket_t * ) pvPortMallocSocket( uxSocketSize );
 8008e0c:	693b      	ldr	r3, [r7, #16]
 8008e0e:	4618      	mov	r0, r3
 8008e10:	f7fb f94e 	bl	80040b0 <pvPortMalloc>
 8008e14:	61f8      	str	r0, [r7, #28]

		if( pxSocket == NULL )
 8008e16:	69fb      	ldr	r3, [r7, #28]
 8008e18:	2b00      	cmp	r3, #0
 8008e1a:	d103      	bne.n	8008e24 <FreeRTOS_socket+0x40>
		{
			pxSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
 8008e1c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8008e20:	61fb      	str	r3, [r7, #28]
 8008e22:	e06f      	b.n	8008f04 <FreeRTOS_socket+0x120>
			iptraceFAILED_TO_CREATE_SOCKET();
		}
		else if( ( xEventGroup = xEventGroupCreate() ) == NULL )
 8008e24:	f7fd fb68 	bl	80064f8 <xEventGroupCreate>
 8008e28:	6178      	str	r0, [r7, #20]
 8008e2a:	697b      	ldr	r3, [r7, #20]
 8008e2c:	2b00      	cmp	r3, #0
 8008e2e:	d106      	bne.n	8008e3e <FreeRTOS_socket+0x5a>
		{
			vPortFreeSocket( pxSocket );
 8008e30:	69f8      	ldr	r0, [r7, #28]
 8008e32:	f7fb f9dd 	bl	80041f0 <vPortFree>
			pxSocket = ( FreeRTOS_Socket_t * ) FREERTOS_INVALID_SOCKET;
 8008e36:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8008e3a:	61fb      	str	r3, [r7, #28]
 8008e3c:	e062      	b.n	8008f04 <FreeRTOS_socket+0x120>
			iptraceFAILED_TO_CREATE_EVENT_GROUP();
		}
		else
		{
			/* Clear the entire space to avoid nulling individual entries */
			memset( pxSocket, '\0', uxSocketSize );
 8008e3e:	693b      	ldr	r3, [r7, #16]
 8008e40:	69f8      	ldr	r0, [r7, #28]
 8008e42:	2100      	movs	r1, #0
 8008e44:	461a      	mov	r2, r3
 8008e46:	f007 fa2f 	bl	80102a8 <memset>

			pxSocket->xEventGroup = xEventGroup;
 8008e4a:	69fb      	ldr	r3, [r7, #28]
 8008e4c:	697a      	ldr	r2, [r7, #20]
 8008e4e:	605a      	str	r2, [r3, #4]

			/* Initialise the socket's members.  The semaphore will be created
			if the socket is bound to an address, for now the pointer to the
			semaphore is just set to NULL to show it has not been created. */
			if( xProtocol == FREERTOS_IPPROTO_UDP )
 8008e50:	687b      	ldr	r3, [r7, #4]
 8008e52:	2b11      	cmp	r3, #17
 8008e54:	d104      	bne.n	8008e60 <FreeRTOS_socket+0x7c>
			{
				vListInitialise( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 8008e56:	69fb      	ldr	r3, [r7, #28]
 8008e58:	3338      	adds	r3, #56	; 0x38
 8008e5a:	4618      	mov	r0, r3
 8008e5c:	f7fa fe66 	bl	8003b2c <vListInitialise>
					pxSocket->u.xUDP.uxMaxPackets = ( UBaseType_t ) ipconfigUDP_MAX_RX_PACKETS;
				}
				#endif /* ipconfigUDP_MAX_RX_PACKETS > 0 */
			}

			vListInitialiseItem( &( pxSocket->xBoundSocketListItem ) );
 8008e60:	69fb      	ldr	r3, [r7, #28]
 8008e62:	3308      	adds	r3, #8
 8008e64:	4618      	mov	r0, r3
 8008e66:	f7fa fe81 	bl	8003b6c <vListInitialiseItem>
			listSET_LIST_ITEM_OWNER( &( pxSocket->xBoundSocketListItem ), ( void * ) pxSocket );
 8008e6a:	69fb      	ldr	r3, [r7, #28]
 8008e6c:	69fa      	ldr	r2, [r7, #28]
 8008e6e:	615a      	str	r2, [r3, #20]

			pxSocket->xReceiveBlockTime = ipconfigSOCK_DEFAULT_RECEIVE_BLOCK_TIME;
 8008e70:	69fb      	ldr	r3, [r7, #28]
 8008e72:	f241 3288 	movw	r2, #5000	; 0x1388
 8008e76:	61da      	str	r2, [r3, #28]
			pxSocket->xSendBlockTime    = ipconfigSOCK_DEFAULT_SEND_BLOCK_TIME;
 8008e78:	69fb      	ldr	r3, [r7, #28]
 8008e7a:	f241 3288 	movw	r2, #5000	; 0x1388
 8008e7e:	621a      	str	r2, [r3, #32]
			pxSocket->ucSocketOptions   = ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 8008e80:	69fb      	ldr	r3, [r7, #28]
 8008e82:	2202      	movs	r2, #2
 8008e84:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
			pxSocket->ucProtocol        = ( uint8_t ) xProtocol; /* protocol: UDP or TCP */
 8008e88:	687b      	ldr	r3, [r7, #4]
 8008e8a:	b2da      	uxtb	r2, r3
 8008e8c:	69fb      	ldr	r3, [r7, #28]
 8008e8e:	f883 2027 	strb.w	r2, [r3, #39]	; 0x27

			#if( ipconfigUSE_TCP == 1 )
			{
				if( xProtocol == FREERTOS_IPPROTO_TCP )
 8008e92:	687b      	ldr	r3, [r7, #4]
 8008e94:	2b06      	cmp	r3, #6
 8008e96:	d135      	bne.n	8008f04 <FreeRTOS_socket+0x120>
				{
					/* StreamSize is expressed in number of bytes */
					/* Round up buffer sizes to nearest multiple of MSS */
					pxSocket->u.xTCP.usInitMSS    = pxSocket->u.xTCP.usCurMSS = ipconfigTCP_MSS;
 8008e98:	69fb      	ldr	r3, [r7, #28]
 8008e9a:	f240 52b4 	movw	r2, #1460	; 0x5b4
 8008e9e:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
 8008ea2:	69fb      	ldr	r3, [r7, #28]
 8008ea4:	f8b3 204a 	ldrh.w	r2, [r3, #74]	; 0x4a
 8008ea8:	69fb      	ldr	r3, [r7, #28]
 8008eaa:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
					pxSocket->u.xTCP.uxRxStreamSize = ( size_t ) ipconfigTCP_RX_BUFFER_LENGTH;
 8008eae:	69fb      	ldr	r3, [r7, #28]
 8008eb0:	f241 121c 	movw	r2, #4380	; 0x111c
 8008eb4:	66da      	str	r2, [r3, #108]	; 0x6c
					pxSocket->u.xTCP.uxTxStreamSize = ( size_t ) FreeRTOS_round_up( ipconfigTCP_TX_BUFFER_LENGTH, ipconfigTCP_MSS );
 8008eb6:	f640 3068 	movw	r0, #2920	; 0xb68
 8008eba:	f240 51b4 	movw	r1, #1460	; 0x5b4
 8008ebe:	f7ff fe5d 	bl	8008b7c <FreeRTOS_round_up>
 8008ec2:	4602      	mov	r2, r0
 8008ec4:	69fb      	ldr	r3, [r7, #28]
 8008ec6:	671a      	str	r2, [r3, #112]	; 0x70
					/* Use half of the buffer size of the TCP windows */
					#if ( ipconfigUSE_TCP_WIN == 1 )
					{
						pxSocket->u.xTCP.uxRxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.uxRxStreamSize / 2 ) / ipconfigTCP_MSS );
 8008ec8:	69fb      	ldr	r3, [r7, #28]
 8008eca:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008ecc:	08db      	lsrs	r3, r3, #3
 8008ece:	4a11      	ldr	r2, [pc, #68]	; (8008f14 <FreeRTOS_socket+0x130>)
 8008ed0:	fba2 2303 	umull	r2, r3, r2, r3
 8008ed4:	099b      	lsrs	r3, r3, #6
 8008ed6:	2001      	movs	r0, #1
 8008ed8:	4619      	mov	r1, r3
 8008eda:	f7ff fe3f 	bl	8008b5c <FreeRTOS_max_uint32>
 8008ede:	4602      	mov	r2, r0
 8008ee0:	69fb      	ldr	r3, [r7, #28]
 8008ee2:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
						pxSocket->u.xTCP.uxTxWinSize  = FreeRTOS_max_uint32( 1UL, ( uint32_t ) ( pxSocket->u.xTCP.uxTxStreamSize / 2 ) / ipconfigTCP_MSS );
 8008ee6:	69fb      	ldr	r3, [r7, #28]
 8008ee8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008eea:	08db      	lsrs	r3, r3, #3
 8008eec:	4a09      	ldr	r2, [pc, #36]	; (8008f14 <FreeRTOS_socket+0x130>)
 8008eee:	fba2 2303 	umull	r2, r3, r2, r3
 8008ef2:	099b      	lsrs	r3, r3, #6
 8008ef4:	2001      	movs	r0, #1
 8008ef6:	4619      	mov	r1, r3
 8008ef8:	f7ff fe30 	bl	8008b5c <FreeRTOS_max_uint32>
 8008efc:	4602      	mov	r2, r0
 8008efe:	69fb      	ldr	r3, [r7, #28]
 8008f00:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
				}
			}
			#endif  /* ipconfigUSE_TCP == 1 */
		}

		xReturn = ( Socket_t ) pxSocket;
 8008f04:	69fb      	ldr	r3, [r7, #28]
 8008f06:	61bb      	str	r3, [r7, #24]
	}

	/* Remove compiler warnings in the case the configASSERT() is not defined. */
	( void ) xDomain;

	return xReturn;
 8008f08:	69bb      	ldr	r3, [r7, #24]
}
 8008f0a:	4618      	mov	r0, r3
 8008f0c:	3720      	adds	r7, #32
 8008f0e:	46bd      	mov	sp, r7
 8008f10:	bd80      	pop	{r7, pc}
 8008f12:	bf00      	nop
 8008f14:	2ce33e6d 	.word	0x2ce33e6d

08008f18 <FreeRTOS_sendto>:
	return lReturn;
}
/*-----------------------------------------------------------*/

int32_t FreeRTOS_sendto( Socket_t xSocket, const void *pvBuffer, size_t xTotalDataLength, BaseType_t xFlags, const struct freertos_sockaddr *pxDestinationAddress, socklen_t xDestinationAddressLength )
{
 8008f18:	b580      	push	{r7, lr}
 8008f1a:	b08e      	sub	sp, #56	; 0x38
 8008f1c:	af00      	add	r7, sp, #0
 8008f1e:	60f8      	str	r0, [r7, #12]
 8008f20:	60b9      	str	r1, [r7, #8]
 8008f22:	607a      	str	r2, [r7, #4]
 8008f24:	603b      	str	r3, [r7, #0]
NetworkBufferDescriptor_t *pxNetworkBuffer;
IPStackEvent_t xStackTxEvent = { eStackTxEvent, NULL };
 8008f26:	2303      	movs	r3, #3
 8008f28:	f887 3020 	strb.w	r3, [r7, #32]
 8008f2c:	2300      	movs	r3, #0
 8008f2e:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
TickType_t xTicksToWait;
int32_t lReturn = 0;
 8008f30:	2300      	movs	r3, #0
 8008f32:	633b      	str	r3, [r7, #48]	; 0x30
FreeRTOS_Socket_t *pxSocket;

	pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 8008f34:	68fb      	ldr	r3, [r7, #12]
 8008f36:	62fb      	str	r3, [r7, #44]	; 0x2c

	/* The function prototype is designed to maintain the expected Berkeley
	sockets standard, but this implementation does not use all the
	parameters. */
	( void ) xDestinationAddressLength;
	configASSERT( pvBuffer );
 8008f38:	68bb      	ldr	r3, [r7, #8]
 8008f3a:	2b00      	cmp	r3, #0
 8008f3c:	d109      	bne.n	8008f52 <FreeRTOS_sendto+0x3a>
 8008f3e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8008f42:	f383 8811 	msr	BASEPRI, r3
 8008f46:	f3bf 8f6f 	isb	sy
 8008f4a:	f3bf 8f4f 	dsb	sy
 8008f4e:	62bb      	str	r3, [r7, #40]	; 0x28
 8008f50:	e7fe      	b.n	8008f50 <FreeRTOS_sendto+0x38>

	if( xTotalDataLength <= ( size_t ) ipMAX_UDP_PAYLOAD_LENGTH )
 8008f52:	687b      	ldr	r3, [r7, #4]
 8008f54:	f5b3 6fb8 	cmp.w	r3, #1472	; 0x5c0
 8008f58:	d876      	bhi.n	8009048 <FreeRTOS_sendto+0x130>
	{
		/* If the socket is not already bound to an address, bind it now.
		Passing NULL as the address parameter tells FreeRTOS_bind() to select
		the address to bind to. */
		if( ( socketSOCKET_IS_BOUND( pxSocket ) != pdFALSE ) ||
 8008f5a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008f5c:	699b      	ldr	r3, [r3, #24]
 8008f5e:	2b00      	cmp	r3, #0
 8008f60:	d107      	bne.n	8008f72 <FreeRTOS_sendto+0x5a>
			( FreeRTOS_bind( xSocket, NULL, 0u ) == 0 ) )
 8008f62:	68f8      	ldr	r0, [r7, #12]
 8008f64:	2100      	movs	r1, #0
 8008f66:	2200      	movs	r2, #0
 8008f68:	f000 f874 	bl	8009054 <FreeRTOS_bind>
 8008f6c:	4603      	mov	r3, r0
	if( xTotalDataLength <= ( size_t ) ipMAX_UDP_PAYLOAD_LENGTH )
	{
		/* If the socket is not already bound to an address, bind it now.
		Passing NULL as the address parameter tells FreeRTOS_bind() to select
		the address to bind to. */
		if( ( socketSOCKET_IS_BOUND( pxSocket ) != pdFALSE ) ||
 8008f6e:	2b00      	cmp	r3, #0
 8008f70:	d16a      	bne.n	8009048 <FreeRTOS_sendto+0x130>
			( FreeRTOS_bind( xSocket, NULL, 0u ) == 0 ) )
		{
			xTicksToWait = pxSocket->xSendBlockTime;
 8008f72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008f74:	6a1b      	ldr	r3, [r3, #32]
 8008f76:	617b      	str	r3, [r7, #20]
					xTicksToWait = ( TickType_t )0;
				}
			}
			#endif /* ipconfigUSE_CALLBACKS */

			if( ( xFlags & FREERTOS_MSG_DONTWAIT ) != 0 )
 8008f78:	683b      	ldr	r3, [r7, #0]
 8008f7a:	f003 0310 	and.w	r3, r3, #16
 8008f7e:	2b00      	cmp	r3, #0
 8008f80:	d001      	beq.n	8008f86 <FreeRTOS_sendto+0x6e>
			{
				xTicksToWait = ( TickType_t ) 0;
 8008f82:	2300      	movs	r3, #0
 8008f84:	617b      	str	r3, [r7, #20]
			}

			if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
 8008f86:	683b      	ldr	r3, [r7, #0]
 8008f88:	f003 0301 	and.w	r3, r3, #1
 8008f8c:	2b00      	cmp	r3, #0
 8008f8e:	d126      	bne.n	8008fde <FreeRTOS_sendto+0xc6>
			{
				/* Zero copy is not set, so obtain a network buffer into
				which the payload will be copied. */
				vTaskSetTimeOutState( &xTimeOut );
 8008f90:	f107 0318 	add.w	r3, r7, #24
 8008f94:	4618      	mov	r0, r3
 8008f96:	f7fc fde5 	bl	8005b64 <vTaskSetTimeOutState>

				/* Block until a buffer becomes available, or until a
				timeout has been reached */
				pxNetworkBuffer = pxGetNetworkBufferWithDescriptor( xTotalDataLength + sizeof( UDPPacket_t ), xTicksToWait );
 8008f9a:	687b      	ldr	r3, [r7, #4]
 8008f9c:	f103 022a 	add.w	r2, r3, #42	; 0x2a
 8008fa0:	697b      	ldr	r3, [r7, #20]
 8008fa2:	4610      	mov	r0, r2
 8008fa4:	4619      	mov	r1, r3
 8008fa6:	f7fe fb9f 	bl	80076e8 <pxGetNetworkBufferWithDescriptor>
 8008faa:	6378      	str	r0, [r7, #52]	; 0x34

				if( pxNetworkBuffer != NULL )
 8008fac:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008fae:	2b00      	cmp	r3, #0
 8008fb0:	d019      	beq.n	8008fe6 <FreeRTOS_sendto+0xce>
				{
					memcpy( ( void * ) &( pxNetworkBuffer->pucEthernetBuffer[ ipUDP_PAYLOAD_OFFSET_IPv4 ] ), ( void * ) pvBuffer, xTotalDataLength );
 8008fb2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008fb4:	699b      	ldr	r3, [r3, #24]
 8008fb6:	332a      	adds	r3, #42	; 0x2a
 8008fb8:	4618      	mov	r0, r3
 8008fba:	68b9      	ldr	r1, [r7, #8]
 8008fbc:	687a      	ldr	r2, [r7, #4]
 8008fbe:	f007 f873 	bl	80100a8 <memcpy>

					if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE )
 8008fc2:	f107 0218 	add.w	r2, r7, #24
 8008fc6:	f107 0314 	add.w	r3, r7, #20
 8008fca:	4610      	mov	r0, r2
 8008fcc:	4619      	mov	r1, r3
 8008fce:	f7fc fdeb 	bl	8005ba8 <xTaskCheckForTimeOut>
 8008fd2:	4603      	mov	r3, r0
 8008fd4:	2b01      	cmp	r3, #1
 8008fd6:	d106      	bne.n	8008fe6 <FreeRTOS_sendto+0xce>
					{
						/* The entire block time has been used up. */
						xTicksToWait = ( TickType_t ) 0;
 8008fd8:	2300      	movs	r3, #0
 8008fda:	617b      	str	r3, [r7, #20]
 8008fdc:	e003      	b.n	8008fe6 <FreeRTOS_sendto+0xce>
			else
			{
				/* When zero copy is used, pvBuffer is a pointer to the
				payload of a buffer that has already been obtained from the
				stack.  Obtain the network buffer pointer from the buffer. */
				pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( (void*)pvBuffer );
 8008fde:	68b8      	ldr	r0, [r7, #8]
 8008fe0:	f7fe fe82 	bl	8007ce8 <pxUDPPayloadBuffer_to_NetworkBuffer>
 8008fe4:	6378      	str	r0, [r7, #52]	; 0x34
			}

			if( pxNetworkBuffer != NULL )
 8008fe6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008fe8:	2b00      	cmp	r3, #0
 8008fea:	d02d      	beq.n	8009048 <FreeRTOS_sendto+0x130>
			{
				pxNetworkBuffer->xDataLength = xTotalDataLength;
 8008fec:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008fee:	687a      	ldr	r2, [r7, #4]
 8008ff0:	61da      	str	r2, [r3, #28]
				pxNetworkBuffer->usPort = pxDestinationAddress->sin_port;
 8008ff2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8008ff4:	885a      	ldrh	r2, [r3, #2]
 8008ff6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008ff8:	841a      	strh	r2, [r3, #32]
				pxNetworkBuffer->usBoundPort = ( uint16_t ) socketGET_SOCKET_PORT( pxSocket );
 8008ffa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8008ffc:	689b      	ldr	r3, [r3, #8]
 8008ffe:	b29a      	uxth	r2, r3
 8009000:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8009002:	845a      	strh	r2, [r3, #34]	; 0x22
				pxNetworkBuffer->ulIPAddress = pxDestinationAddress->sin_addr;
 8009004:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8009006:	685a      	ldr	r2, [r3, #4]
 8009008:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800900a:	615a      	str	r2, [r3, #20]

				/* The socket options are passed to the IP layer in the
				space that will eventually get used by the Ethernet header. */
				pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ] = pxSocket->ucSocketOptions;
 800900c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800900e:	699b      	ldr	r3, [r3, #24]
 8009010:	3306      	adds	r3, #6
 8009012:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009014:	f892 2026 	ldrb.w	r2, [r2, #38]	; 0x26
 8009018:	701a      	strb	r2, [r3, #0]

				/* Tell the networking task that the packet needs sending. */
				xStackTxEvent.pvData = pxNetworkBuffer;
 800901a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800901c:	627b      	str	r3, [r7, #36]	; 0x24

				/* Ask the IP-task to send this packet */
				if( xSendEventStructToIPTask( &xStackTxEvent, xTicksToWait ) == pdPASS )
 800901e:	697b      	ldr	r3, [r7, #20]
 8009020:	f107 0220 	add.w	r2, r7, #32
 8009024:	4610      	mov	r0, r2
 8009026:	4619      	mov	r1, r3
 8009028:	f7fe ffc2 	bl	8007fb0 <xSendEventStructToIPTask>
 800902c:	4603      	mov	r3, r0
 800902e:	2b01      	cmp	r3, #1
 8009030:	d102      	bne.n	8009038 <FreeRTOS_sendto+0x120>
				{
					/* The packet was successfully sent to the IP task. */
					lReturn = ( int32_t ) xTotalDataLength;
 8009032:	687b      	ldr	r3, [r7, #4]
 8009034:	633b      	str	r3, [r7, #48]	; 0x30
 8009036:	e007      	b.n	8009048 <FreeRTOS_sendto+0x130>
				}
				else
				{
					/* If the buffer was allocated in this function, release
					it. */
					if( ( xFlags & FREERTOS_ZERO_COPY ) == 0 )
 8009038:	683b      	ldr	r3, [r7, #0]
 800903a:	f003 0301 	and.w	r3, r3, #1
 800903e:	2b00      	cmp	r3, #0
 8009040:	d102      	bne.n	8009048 <FreeRTOS_sendto+0x130>
					{
						vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8009042:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8009044:	f7fe fbca 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
	{
		/* The data is longer than the available buffer space. */
		iptraceSENDTO_DATA_TOO_LONG();
	}

	return lReturn;
 8009048:	6b3b      	ldr	r3, [r7, #48]	; 0x30
} /* Tested */
 800904a:	4618      	mov	r0, r3
 800904c:	3738      	adds	r7, #56	; 0x38
 800904e:	46bd      	mov	sp, r7
 8009050:	bd80      	pop	{r7, pc}
 8009052:	bf00      	nop

08009054 <FreeRTOS_bind>:
 * be used for both UDP and TCP sockets.  The actual binding will be performed
 * by the IP-task to avoid mutual access to the bound-socket-lists
 * (xBoundUDPSocketsList or xBoundTCPSocketsList).
 */
BaseType_t FreeRTOS_bind( Socket_t xSocket, struct freertos_sockaddr * pxAddress, socklen_t xAddressLength )
{
 8009054:	b580      	push	{r7, lr}
 8009056:	b08a      	sub	sp, #40	; 0x28
 8009058:	af02      	add	r7, sp, #8
 800905a:	60f8      	str	r0, [r7, #12]
 800905c:	60b9      	str	r1, [r7, #8]
 800905e:	607a      	str	r2, [r7, #4]
IPStackEvent_t xBindEvent;
FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 8009060:	68fb      	ldr	r3, [r7, #12]
 8009062:	61bb      	str	r3, [r7, #24]
BaseType_t xReturn = 0;
 8009064:	2300      	movs	r3, #0
 8009066:	61fb      	str	r3, [r7, #28]

	( void ) xAddressLength;

	if( ( pxSocket == NULL ) || ( pxSocket == FREERTOS_INVALID_SOCKET ) )
 8009068:	69bb      	ldr	r3, [r7, #24]
 800906a:	2b00      	cmp	r3, #0
 800906c:	d003      	beq.n	8009076 <FreeRTOS_bind+0x22>
 800906e:	69bb      	ldr	r3, [r7, #24]
 8009070:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009074:	d103      	bne.n	800907e <FreeRTOS_bind+0x2a>
	{
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009076:	f06f 0315 	mvn.w	r3, #21
 800907a:	61fb      	str	r3, [r7, #28]
 800907c:	e045      	b.n	800910a <FreeRTOS_bind+0xb6>
	}
	/* Once a socket is bound to a port, it can not be bound to a different
	port number */
	else if( socketSOCKET_IS_BOUND( pxSocket) != pdFALSE )
 800907e:	69bb      	ldr	r3, [r7, #24]
 8009080:	699b      	ldr	r3, [r3, #24]
 8009082:	2b00      	cmp	r3, #0
 8009084:	d001      	beq.n	800908a <FreeRTOS_bind+0x36>
 8009086:	2301      	movs	r3, #1
 8009088:	e000      	b.n	800908c <FreeRTOS_bind+0x38>
 800908a:	2300      	movs	r3, #0
 800908c:	2b00      	cmp	r3, #0
 800908e:	d003      	beq.n	8009098 <FreeRTOS_bind+0x44>
	{
		/* The socket is already bound. */
		FreeRTOS_debug_printf( ( "vSocketBind: Socket already bound to %d\n", pxSocket->usLocalPort ) );
		xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009090:	f06f 0315 	mvn.w	r3, #21
 8009094:	61fb      	str	r3, [r7, #28]
 8009096:	e038      	b.n	800910a <FreeRTOS_bind+0xb6>
	}
	else
	{
		/* Prepare a messages to the IP-task in order to perform the binding.
		The desired port number will be passed in usLocalPort. */
		xBindEvent.eEventType = eSocketBindEvent;
 8009098:	2308      	movs	r3, #8
 800909a:	743b      	strb	r3, [r7, #16]
		xBindEvent.pvData = ( void * ) xSocket;
 800909c:	68fb      	ldr	r3, [r7, #12]
 800909e:	617b      	str	r3, [r7, #20]
		if( pxAddress != NULL )
 80090a0:	68bb      	ldr	r3, [r7, #8]
 80090a2:	2b00      	cmp	r3, #0
 80090a4:	d00e      	beq.n	80090c4 <FreeRTOS_bind+0x70>
		{
			pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
 80090a6:	68bb      	ldr	r3, [r7, #8]
 80090a8:	885b      	ldrh	r3, [r3, #2]
 80090aa:	021b      	lsls	r3, r3, #8
 80090ac:	b29a      	uxth	r2, r3
 80090ae:	68bb      	ldr	r3, [r7, #8]
 80090b0:	885b      	ldrh	r3, [r3, #2]
 80090b2:	0a1b      	lsrs	r3, r3, #8
 80090b4:	b29b      	uxth	r3, r3
 80090b6:	b29b      	uxth	r3, r3
 80090b8:	4313      	orrs	r3, r2
 80090ba:	b29b      	uxth	r3, r3
 80090bc:	b29a      	uxth	r2, r3
 80090be:	69bb      	ldr	r3, [r7, #24]
 80090c0:	849a      	strh	r2, [r3, #36]	; 0x24
 80090c2:	e002      	b.n	80090ca <FreeRTOS_bind+0x76>
		}
		else
		{
			/* Caller wants to bind to a random port number. */
			pxSocket->usLocalPort = 0u;
 80090c4:	69bb      	ldr	r3, [r7, #24]
 80090c6:	2200      	movs	r2, #0
 80090c8:	849a      	strh	r2, [r3, #36]	; 0x24
		}

		/* portMAX_DELAY is used as a the time-out parameter, as binding *must*
		succeed before the socket can be used.  _RB_ The use of an infinite
		block time needs be changed as it could result in the task hanging. */
		if( xSendEventStructToIPTask( &xBindEvent, ( TickType_t ) portMAX_DELAY ) == pdFAIL )
 80090ca:	f107 0310 	add.w	r3, r7, #16
 80090ce:	4618      	mov	r0, r3
 80090d0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80090d4:	f7fe ff6c 	bl	8007fb0 <xSendEventStructToIPTask>
 80090d8:	4603      	mov	r3, r0
 80090da:	2b00      	cmp	r3, #0
 80090dc:	d103      	bne.n	80090e6 <FreeRTOS_bind+0x92>
		{
			/* Failed to wake-up the IP-task, no use to wait for it */
			FreeRTOS_debug_printf( ( "FreeRTOS_bind: send event failed\n" ) );
			xReturn = -pdFREERTOS_ERRNO_ECANCELED;
 80090de:	f06f 038b 	mvn.w	r3, #139	; 0x8b
 80090e2:	61fb      	str	r3, [r7, #28]
 80090e4:	e011      	b.n	800910a <FreeRTOS_bind+0xb6>
		}
		else
		{
			/* The IP-task will set the 'eSOCKET_BOUND' bit when it has done its
			job. */
			xEventGroupWaitBits( pxSocket->xEventGroup, eSOCKET_BOUND, pdTRUE /*xClearOnExit*/, pdFALSE /*xWaitAllBits*/, portMAX_DELAY );
 80090e6:	69bb      	ldr	r3, [r7, #24]
 80090e8:	685a      	ldr	r2, [r3, #4]
 80090ea:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80090ee:	9300      	str	r3, [sp, #0]
 80090f0:	4610      	mov	r0, r2
 80090f2:	2110      	movs	r1, #16
 80090f4:	2201      	movs	r2, #1
 80090f6:	2300      	movs	r3, #0
 80090f8:	f7fd fa16 	bl	8006528 <xEventGroupWaitBits>
			if( socketSOCKET_IS_BOUND( pxSocket ) == pdFALSE )
 80090fc:	69bb      	ldr	r3, [r7, #24]
 80090fe:	699b      	ldr	r3, [r3, #24]
 8009100:	2b00      	cmp	r3, #0
 8009102:	d102      	bne.n	800910a <FreeRTOS_bind+0xb6>
			{
				xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009104:	f06f 0315 	mvn.w	r3, #21
 8009108:	61fb      	str	r3, [r7, #28]
			}
		}
	}

	return xReturn;
 800910a:	69fb      	ldr	r3, [r7, #28]
}
 800910c:	4618      	mov	r0, r3
 800910e:	3720      	adds	r7, #32
 8009110:	46bd      	mov	sp, r7
 8009112:	bd80      	pop	{r7, pc}

08009114 <vSocketBind>:
 * vSocketBind(): internal version of bind() that should not be called directly.
 * 'xInternal' is used for TCP sockets only: it allows to have several
 * (connected) child sockets bound to the same server port.
 */
BaseType_t vSocketBind( FreeRTOS_Socket_t *pxSocket, struct freertos_sockaddr * pxAddress, size_t uxAddressLength, BaseType_t xInternal )
{
 8009114:	b580      	push	{r7, lr}
 8009116:	b08c      	sub	sp, #48	; 0x30
 8009118:	af00      	add	r7, sp, #0
 800911a:	60f8      	str	r0, [r7, #12]
 800911c:	60b9      	str	r1, [r7, #8]
 800911e:	607a      	str	r2, [r7, #4]
 8009120:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = 0; /* In Berkeley sockets, 0 means pass for bind(). */
 8009122:	2300      	movs	r3, #0
 8009124:	62fb      	str	r3, [r7, #44]	; 0x2c
#if( ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND == 1 )
	struct freertos_sockaddr xAddress;
#endif /* ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND */

#if( ipconfigUSE_TCP == 1 )
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8009126:	68fb      	ldr	r3, [r7, #12]
 8009128:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 800912c:	2b06      	cmp	r3, #6
 800912e:	d102      	bne.n	8009136 <vSocketBind+0x22>
	{
		pxSocketList = &xBoundTCPSocketsList;
 8009130:	4b3e      	ldr	r3, [pc, #248]	; (800922c <vSocketBind+0x118>)
 8009132:	62bb      	str	r3, [r7, #40]	; 0x28
 8009134:	e001      	b.n	800913a <vSocketBind+0x26>
	}
	else
#endif  /* ipconfigUSE_TCP == 1 */
	{
		pxSocketList = &xBoundUDPSocketsList;
 8009136:	4b3e      	ldr	r3, [pc, #248]	; (8009230 <vSocketBind+0x11c>)
 8009138:	62bb      	str	r3, [r7, #40]	; 0x28

	/* The function prototype is designed to maintain the expected Berkeley
	sockets standard, but this implementation does not use all the parameters. */
	( void ) uxAddressLength;

	configASSERT( pxSocket );
 800913a:	68fb      	ldr	r3, [r7, #12]
 800913c:	2b00      	cmp	r3, #0
 800913e:	d109      	bne.n	8009154 <vSocketBind+0x40>
 8009140:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009144:	f383 8811 	msr	BASEPRI, r3
 8009148:	f3bf 8f6f 	isb	sy
 800914c:	f3bf 8f4f 	dsb	sy
 8009150:	627b      	str	r3, [r7, #36]	; 0x24
 8009152:	e7fe      	b.n	8009152 <vSocketBind+0x3e>
	configASSERT( pxSocket != FREERTOS_INVALID_SOCKET );
 8009154:	68fb      	ldr	r3, [r7, #12]
 8009156:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800915a:	d109      	bne.n	8009170 <vSocketBind+0x5c>
 800915c:	f04f 0350 	mov.w	r3, #80	; 0x50
 8009160:	f383 8811 	msr	BASEPRI, r3
 8009164:	f3bf 8f6f 	isb	sy
 8009168:	f3bf 8f4f 	dsb	sy
 800916c:	623b      	str	r3, [r7, #32]
 800916e:	e7fe      	b.n	800916e <vSocketBind+0x5a>
		/* pxAddress will be NULL if sendto() was called on a socket without the
		socket being bound to an address.  In this case, automatically allocate
		an address to the socket.  There is a very tiny chance that the allocated
		port will already be in use - if that is the case, then the check below
		[pxListFindListItemWithValue()] will result in an error being returned. */
		if( pxAddress == NULL )
 8009170:	68bb      	ldr	r3, [r7, #8]
 8009172:	2b00      	cmp	r3, #0
 8009174:	d105      	bne.n	8009182 <vSocketBind+0x6e>
		{
			pxAddress = &xAddress;
 8009176:	f107 0314 	add.w	r3, r7, #20
 800917a:	60bb      	str	r3, [r7, #8]
			/* For now, put it to zero, will be assigned later */
			pxAddress->sin_port = 0u;
 800917c:	68bb      	ldr	r3, [r7, #8]
 800917e:	2200      	movs	r2, #0
 8009180:	805a      	strh	r2, [r3, #2]
	}
	#endif /* ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND == 1 */

	/* Sockets must be bound before calling FreeRTOS_sendto() if
	ipconfigALLOW_SOCKET_SEND_WITHOUT_BIND is not set to 1. */
	configASSERT( pxAddress );
 8009182:	68bb      	ldr	r3, [r7, #8]
 8009184:	2b00      	cmp	r3, #0
 8009186:	d109      	bne.n	800919c <vSocketBind+0x88>
 8009188:	f04f 0350 	mov.w	r3, #80	; 0x50
 800918c:	f383 8811 	msr	BASEPRI, r3
 8009190:	f3bf 8f6f 	isb	sy
 8009194:	f3bf 8f4f 	dsb	sy
 8009198:	61fb      	str	r3, [r7, #28]
 800919a:	e7fe      	b.n	800919a <vSocketBind+0x86>

	if( pxAddress != NULL )
 800919c:	68bb      	ldr	r3, [r7, #8]
 800919e:	2b00      	cmp	r3, #0
 80091a0:	d03c      	beq.n	800921c <vSocketBind+0x108>
	{
		if( pxAddress->sin_port == 0u )
 80091a2:	68bb      	ldr	r3, [r7, #8]
 80091a4:	885b      	ldrh	r3, [r3, #2]
 80091a6:	2b00      	cmp	r3, #0
 80091a8:	d109      	bne.n	80091be <vSocketBind+0xaa>
		{
			pxAddress->sin_port = prvGetPrivatePortNumber( ( BaseType_t ) pxSocket->ucProtocol );
 80091aa:	68fb      	ldr	r3, [r7, #12]
 80091ac:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 80091b0:	4618      	mov	r0, r3
 80091b2:	f000 fa95 	bl	80096e0 <prvGetPrivatePortNumber>
 80091b6:	4603      	mov	r3, r0
 80091b8:	461a      	mov	r2, r3
 80091ba:	68bb      	ldr	r3, [r7, #8]
 80091bc:	805a      	strh	r2, [r3, #2]
		confirmed that the socket was not yet bound to a port.  If it is called
		from the IP-task, no such check is necessary. */

		/* Check to ensure the port is not already in use.  If the bind is
		called internally, a port MAY be used by more than one socket. */
		if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) ) &&
 80091be:	683b      	ldr	r3, [r7, #0]
 80091c0:	2b00      	cmp	r3, #0
 80091c2:	d004      	beq.n	80091ce <vSocketBind+0xba>
 80091c4:	68fb      	ldr	r3, [r7, #12]
 80091c6:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 80091ca:	2b06      	cmp	r3, #6
 80091cc:	d00c      	beq.n	80091e8 <vSocketBind+0xd4>
			( pxListFindListItemWithValue( pxSocketList, ( TickType_t ) pxAddress->sin_port ) != NULL ) )
 80091ce:	68bb      	ldr	r3, [r7, #8]
 80091d0:	885b      	ldrh	r3, [r3, #2]
 80091d2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 80091d4:	4619      	mov	r1, r3
 80091d6:	f000 fad1 	bl	800977c <pxListFindListItemWithValue>
 80091da:	4603      	mov	r3, r0
		confirmed that the socket was not yet bound to a port.  If it is called
		from the IP-task, no such check is necessary. */

		/* Check to ensure the port is not already in use.  If the bind is
		called internally, a port MAY be used by more than one socket. */
		if( ( ( xInternal == pdFALSE ) || ( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP ) ) &&
 80091dc:	2b00      	cmp	r3, #0
 80091de:	d003      	beq.n	80091e8 <vSocketBind+0xd4>
			( pxListFindListItemWithValue( pxSocketList, ( TickType_t ) pxAddress->sin_port ) != NULL ) )
		{
			FreeRTOS_debug_printf( ( "vSocketBind: %sP port %d in use\n",
				pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP ? "TC" : "UD",
				FreeRTOS_ntohs( pxAddress->sin_port ) ) );
			xReturn = -pdFREERTOS_ERRNO_EADDRINUSE;
 80091e0:	f06f 036f 	mvn.w	r3, #111	; 0x6f
 80091e4:	62fb      	str	r3, [r7, #44]	; 0x2c
 80091e6:	e01c      	b.n	8009222 <vSocketBind+0x10e>
		}
		else
		{
			/* Allocate the port number to the socket.
			This macro will set 'xBoundSocketListItem->xItemValue' */
			socketSET_SOCKET_PORT( pxSocket, pxAddress->sin_port );
 80091e8:	68bb      	ldr	r3, [r7, #8]
 80091ea:	885b      	ldrh	r3, [r3, #2]
 80091ec:	461a      	mov	r2, r3
 80091ee:	68fb      	ldr	r3, [r7, #12]
 80091f0:	609a      	str	r2, [r3, #8]

			/* And also store it in a socket field 'usLocalPort' in host-byte-order,
			mostly used for logging and debugging purposes */
			pxSocket->usLocalPort = FreeRTOS_ntohs( pxAddress->sin_port );
 80091f2:	68bb      	ldr	r3, [r7, #8]
 80091f4:	885b      	ldrh	r3, [r3, #2]
 80091f6:	021b      	lsls	r3, r3, #8
 80091f8:	b29a      	uxth	r2, r3
 80091fa:	68bb      	ldr	r3, [r7, #8]
 80091fc:	885b      	ldrh	r3, [r3, #2]
 80091fe:	0a1b      	lsrs	r3, r3, #8
 8009200:	b29b      	uxth	r3, r3
 8009202:	b29b      	uxth	r3, r3
 8009204:	4313      	orrs	r3, r2
 8009206:	b29b      	uxth	r3, r3
 8009208:	b29a      	uxth	r2, r3
 800920a:	68fb      	ldr	r3, [r7, #12]
 800920c:	849a      	strh	r2, [r3, #36]	; 0x24
					vTaskSuspendAll();
				}
				#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */

				/* Add the socket to 'xBoundUDPSocketsList' or 'xBoundTCPSocketsList' */
				vListInsertEnd( pxSocketList, &( pxSocket->xBoundSocketListItem ) );
 800920e:	68fb      	ldr	r3, [r7, #12]
 8009210:	3308      	adds	r3, #8
 8009212:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 8009214:	4619      	mov	r1, r3
 8009216:	f7fa fcb5 	bl	8003b84 <vListInsertEnd>
 800921a:	e002      	b.n	8009222 <vSocketBind+0x10e>
			}
		}
	}
	else
	{
		xReturn = -pdFREERTOS_ERRNO_EADDRNOTAVAIL;
 800921c:	f06f 037c 	mvn.w	r3, #124	; 0x7c
 8009220:	62fb      	str	r3, [r7, #44]	; 0x2c
	if( xReturn != 0 )
	{
		iptraceBIND_FAILED( xSocket, ( FreeRTOS_ntohs( pxAddress->sin_port ) ) );
	}

	return xReturn;
 8009222:	6afb      	ldr	r3, [r7, #44]	; 0x2c
} /* Tested */
 8009224:	4618      	mov	r0, r3
 8009226:	3730      	adds	r7, #48	; 0x30
 8009228:	46bd      	mov	sp, r7
 800922a:	bd80      	pop	{r7, pc}
 800922c:	2000cf10 	.word	0x2000cf10
 8009230:	2000cf24 	.word	0x2000cf24

08009234 <FreeRTOS_closesocket>:
 * In case of a TCP socket: the connection will not be closed automatically
 * Subsequent messages for the closed socket will be responded to with a RST
 * The IP-task will actually close the socket, after receiving a 'eSocketCloseEvent' message
 */
BaseType_t FreeRTOS_closesocket( Socket_t xSocket )
{
 8009234:	b580      	push	{r7, lr}
 8009236:	b086      	sub	sp, #24
 8009238:	af00      	add	r7, sp, #0
 800923a:	6078      	str	r0, [r7, #4]
BaseType_t xResult;
#if( ipconfigUSE_TCP == 1 ) && ( ipconfigUSE_CALLBACKS == 1 )
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * )xSocket;
#endif
IPStackEvent_t xCloseEvent;
xCloseEvent.eEventType = eSocketCloseEvent;
 800923c:	2309      	movs	r3, #9
 800923e:	733b      	strb	r3, [r7, #12]
xCloseEvent.pvData = ( void * ) xSocket;
 8009240:	687b      	ldr	r3, [r7, #4]
 8009242:	613b      	str	r3, [r7, #16]

	if( ( xSocket == NULL ) || ( xSocket == FREERTOS_INVALID_SOCKET ) )
 8009244:	687b      	ldr	r3, [r7, #4]
 8009246:	2b00      	cmp	r3, #0
 8009248:	d003      	beq.n	8009252 <FreeRTOS_closesocket+0x1e>
 800924a:	687b      	ldr	r3, [r7, #4]
 800924c:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009250:	d102      	bne.n	8009258 <FreeRTOS_closesocket+0x24>
	{
		xResult = 0;
 8009252:	2300      	movs	r3, #0
 8009254:	617b      	str	r3, [r7, #20]
 8009256:	e00e      	b.n	8009276 <FreeRTOS_closesocket+0x42>
		packet handling. */

		/* Note when changing the time-out value below, it must be checked who is calling
		this function. If it is called by the IP-task, a deadlock could occur.
		The IP-task would only call it in case of a user call-back */
		if( xSendEventStructToIPTask( &xCloseEvent, ( TickType_t ) 0 ) == pdFAIL )
 8009258:	f107 030c 	add.w	r3, r7, #12
 800925c:	4618      	mov	r0, r3
 800925e:	2100      	movs	r1, #0
 8009260:	f7fe fea6 	bl	8007fb0 <xSendEventStructToIPTask>
 8009264:	4603      	mov	r3, r0
 8009266:	2b00      	cmp	r3, #0
 8009268:	d103      	bne.n	8009272 <FreeRTOS_closesocket+0x3e>
		{
			FreeRTOS_debug_printf( ( "FreeRTOS_closesocket: failed\n" ) );
			xResult = -1;
 800926a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800926e:	617b      	str	r3, [r7, #20]
 8009270:	e001      	b.n	8009276 <FreeRTOS_closesocket+0x42>
		}
		else
		{
			xResult = 1;
 8009272:	2301      	movs	r3, #1
 8009274:	617b      	str	r3, [r7, #20]
		}
	}

	return xResult;
 8009276:	697b      	ldr	r3, [r7, #20]
}
 8009278:	4618      	mov	r0, r3
 800927a:	3718      	adds	r7, #24
 800927c:	46bd      	mov	sp, r7
 800927e:	bd80      	pop	{r7, pc}

08009280 <vSocketClose>:

/* This is the internal version of FreeRTOS_closesocket()
 * It will be called by the IPtask only to avoid problems with synchronicity
 */
void *vSocketClose( FreeRTOS_Socket_t *pxSocket )
{
 8009280:	b580      	push	{r7, lr}
 8009282:	b084      	sub	sp, #16
 8009284:	af00      	add	r7, sp, #0
 8009286:	6078      	str	r0, [r7, #4]
NetworkBufferDescriptor_t *pxNetworkBuffer;

	#if( ipconfigUSE_TCP == 1 )
	{
		/* For TCP: clean up a little more. */
		if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8009288:	687b      	ldr	r3, [r7, #4]
 800928a:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 800928e:	2b06      	cmp	r3, #6
 8009290:	d122      	bne.n	80092d8 <vSocketClose+0x58>
		{
			#if( ipconfigUSE_TCP_WIN == 1 )
			{
				if( pxSocket->u.xTCP.pxAckMessage != NULL )
 8009292:	687b      	ldr	r3, [r7, #4]
 8009294:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8009296:	2b00      	cmp	r3, #0
 8009298:	d004      	beq.n	80092a4 <vSocketClose+0x24>
				{
					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 800929a:	687b      	ldr	r3, [r7, #4]
 800929c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800929e:	4618      	mov	r0, r3
 80092a0:	f7fe fa9c 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
				}
				/* Free the resources which were claimed by the tcpWin member */
				vTCPWindowDestroy( &pxSocket->u.xTCP.xTCPWindow );
 80092a4:	687b      	ldr	r3, [r7, #4]
 80092a6:	33dc      	adds	r3, #220	; 0xdc
 80092a8:	4618      	mov	r0, r3
 80092aa:	f003 fced 	bl	800cc88 <vTCPWindowDestroy>
			}
			#endif /* ipconfigUSE_TCP_WIN */

			/* Free the input and output streams */
			if( pxSocket->u.xTCP.rxStream != NULL )
 80092ae:	687b      	ldr	r3, [r7, #4]
 80092b0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80092b2:	2b00      	cmp	r3, #0
 80092b4:	d004      	beq.n	80092c0 <vSocketClose+0x40>
			{
				vPortFreeLarge( pxSocket->u.xTCP.rxStream );
 80092b6:	687b      	ldr	r3, [r7, #4]
 80092b8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80092ba:	4618      	mov	r0, r3
 80092bc:	f7fa ff98 	bl	80041f0 <vPortFree>
			}

			if( pxSocket->u.xTCP.txStream != NULL )
 80092c0:	687b      	ldr	r3, [r7, #4]
 80092c2:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80092c4:	2b00      	cmp	r3, #0
 80092c6:	d004      	beq.n	80092d2 <vSocketClose+0x52>
			{
				vPortFreeLarge( pxSocket->u.xTCP.txStream );
 80092c8:	687b      	ldr	r3, [r7, #4]
 80092ca:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80092cc:	4618      	mov	r0, r3
 80092ce:	f7fa ff8f 	bl	80041f0 <vPortFree>
			}

			/* In case this is a child socket, make sure the child-count of the
			parent socket is decreased. */
			prvTCPSetSocketCount( pxSocket );
 80092d2:	6878      	ldr	r0, [r7, #4]
 80092d4:	f000 f834 	bl	8009340 <prvTCPSetSocketCount>
	}
	#endif  /* ipconfigUSE_TCP == 1 */

	/* Socket must be unbound first, to ensure no more packets are queued on
	it. */
	if( socketSOCKET_IS_BOUND( pxSocket ) != pdFALSE )
 80092d8:	687b      	ldr	r3, [r7, #4]
 80092da:	699b      	ldr	r3, [r3, #24]
 80092dc:	2b00      	cmp	r3, #0
 80092de:	d001      	beq.n	80092e4 <vSocketClose+0x64>
 80092e0:	2301      	movs	r3, #1
 80092e2:	e000      	b.n	80092e6 <vSocketClose+0x66>
 80092e4:	2300      	movs	r3, #0
 80092e6:	2b00      	cmp	r3, #0
 80092e8:	d004      	beq.n	80092f4 <vSocketClose+0x74>
		{
			vTaskSuspendAll();
		}
		#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */

		uxListRemove( &( pxSocket->xBoundSocketListItem ) );
 80092ea:	687b      	ldr	r3, [r7, #4]
 80092ec:	3308      	adds	r3, #8
 80092ee:	4618      	mov	r0, r3
 80092f0:	f7fa fca4 	bl	8003c3c <uxListRemove>
		#endif /* ipconfigETHERNET_DRIVER_FILTERS_PACKETS */
	}

	/* Now the socket is not bound the list of waiting packets can be
	drained. */
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
 80092f4:	687b      	ldr	r3, [r7, #4]
 80092f6:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 80092fa:	2b11      	cmp	r3, #17
 80092fc:	d10f      	bne.n	800931e <vSocketClose+0x9e>
	{
		while( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U )
 80092fe:	e00a      	b.n	8009316 <vSocketClose+0x96>
		{
			pxNetworkBuffer = ( NetworkBufferDescriptor_t * ) listGET_OWNER_OF_HEAD_ENTRY( &( pxSocket->u.xUDP.xWaitingPacketsList ) );
 8009300:	687b      	ldr	r3, [r7, #4]
 8009302:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8009304:	68db      	ldr	r3, [r3, #12]
 8009306:	60fb      	str	r3, [r7, #12]
			uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
 8009308:	68fb      	ldr	r3, [r7, #12]
 800930a:	4618      	mov	r0, r3
 800930c:	f7fa fc96 	bl	8003c3c <uxListRemove>
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 8009310:	68f8      	ldr	r0, [r7, #12]
 8009312:	f7fe fa63 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>

	/* Now the socket is not bound the list of waiting packets can be
	drained. */
	if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
	{
		while( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U )
 8009316:	687b      	ldr	r3, [r7, #4]
 8009318:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800931a:	2b00      	cmp	r3, #0
 800931c:	d1f0      	bne.n	8009300 <vSocketClose+0x80>
			uxListRemove( &( pxNetworkBuffer->xBufferListItem ) );
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
		}
	}

	if( pxSocket->xEventGroup )
 800931e:	687b      	ldr	r3, [r7, #4]
 8009320:	685b      	ldr	r3, [r3, #4]
 8009322:	2b00      	cmp	r3, #0
 8009324:	d004      	beq.n	8009330 <vSocketClose+0xb0>
	{
		vEventGroupDelete( pxSocket->xEventGroup );
 8009326:	687b      	ldr	r3, [r7, #4]
 8009328:	685b      	ldr	r3, [r3, #4]
 800932a:	4618      	mov	r0, r3
 800932c:	f7fd fa86 	bl	800683c <vEventGroupDelete>
		}
	}
	#endif /* ( ipconfigUSE_TCP == 1 ) && ( ipconfigHAS_DEBUG_PRINTF != 0 ) */

	/* Anf finally, after all resources have been freed, free the socket space */
	vPortFreeSocket( pxSocket );
 8009330:	6878      	ldr	r0, [r7, #4]
 8009332:	f7fa ff5d 	bl	80041f0 <vPortFree>

	return 0;
 8009336:	2300      	movs	r3, #0
} /* Tested */
 8009338:	4618      	mov	r0, r3
 800933a:	3710      	adds	r7, #16
 800933c:	46bd      	mov	sp, r7
 800933e:	bd80      	pop	{r7, pc}

08009340 <prvTCPSetSocketCount>:
	 * When a child socket gets closed, make sure to update the child-count of the
	 * parent.  When a listening parent socket is closed, make sure no child-sockets
	 * keep a pointer to it.
	 */
	static void prvTCPSetSocketCount( FreeRTOS_Socket_t *pxSocketToDelete )
	{
 8009340:	b480      	push	{r7}
 8009342:	b087      	sub	sp, #28
 8009344:	af00      	add	r7, sp, #0
 8009346:	6078      	str	r0, [r7, #4]
	const ListItem_t *pxIterator;
	const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
 8009348:	4b17      	ldr	r3, [pc, #92]	; (80093a8 <prvTCPSetSocketCount+0x68>)
 800934a:	613b      	str	r3, [r7, #16]
	FreeRTOS_Socket_t *pxOtherSocket;
	uint16_t usLocalPort = pxSocketToDelete->usLocalPort;
 800934c:	687b      	ldr	r3, [r7, #4]
 800934e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8009350:	81fb      	strh	r3, [r7, #14]

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8009352:	693b      	ldr	r3, [r7, #16]
 8009354:	685b      	ldr	r3, [r3, #4]
 8009356:	617b      	str	r3, [r7, #20]
 8009358:	e01d      	b.n	8009396 <prvTCPSetSocketCount+0x56>
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			pxOtherSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800935a:	697b      	ldr	r3, [r7, #20]
 800935c:	68db      	ldr	r3, [r3, #12]
 800935e:	60bb      	str	r3, [r7, #8]
			if( ( pxOtherSocket->u.xTCP.ucTCPState == eTCP_LISTEN ) &&
 8009360:	68bb      	ldr	r3, [r7, #8]
 8009362:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 8009366:	2b01      	cmp	r3, #1
 8009368:	d112      	bne.n	8009390 <prvTCPSetSocketCount+0x50>
				( pxOtherSocket->usLocalPort == usLocalPort ) &&
 800936a:	68bb      	ldr	r3, [r7, #8]
 800936c:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			pxOtherSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
			if( ( pxOtherSocket->u.xTCP.ucTCPState == eTCP_LISTEN ) &&
 800936e:	89fa      	ldrh	r2, [r7, #14]
 8009370:	429a      	cmp	r2, r3
 8009372:	d10d      	bne.n	8009390 <prvTCPSetSocketCount+0x50>
				( pxOtherSocket->usLocalPort == usLocalPort ) &&
				( pxOtherSocket->u.xTCP.usChildCount ) )
 8009374:	68bb      	ldr	r3, [r7, #8]
 8009376:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			pxOtherSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
			if( ( pxOtherSocket->u.xTCP.ucTCPState == eTCP_LISTEN ) &&
				( pxOtherSocket->usLocalPort == usLocalPort ) &&
 800937a:	2b00      	cmp	r3, #0
 800937c:	d008      	beq.n	8009390 <prvTCPSetSocketCount+0x50>
				( pxOtherSocket->u.xTCP.usChildCount ) )
			{
				pxOtherSocket->u.xTCP.usChildCount--;
 800937e:	68bb      	ldr	r3, [r7, #8]
 8009380:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
 8009384:	3b01      	subs	r3, #1
 8009386:	b29a      	uxth	r2, r3
 8009388:	68bb      	ldr	r3, [r7, #8]
 800938a:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
				FreeRTOS_debug_printf( ( "Lost: Socket %u now has %u / %u child%s\n",
					pxOtherSocket->usLocalPort,
					pxOtherSocket->u.xTCP.usChildCount,
					pxOtherSocket->u.xTCP.usBacklog,
					pxOtherSocket->u.xTCP.usChildCount == 1u ? "" : "ren" ) );
				break;
 800938e:	e006      	b.n	800939e <prvTCPSetSocketCount+0x5e>
	FreeRTOS_Socket_t *pxOtherSocket;
	uint16_t usLocalPort = pxSocketToDelete->usLocalPort;

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8009390:	697b      	ldr	r3, [r7, #20]
 8009392:	685b      	ldr	r3, [r3, #4]
 8009394:	617b      	str	r3, [r7, #20]
	const ListItem_t *pxIterator;
	const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
	FreeRTOS_Socket_t *pxOtherSocket;
	uint16_t usLocalPort = pxSocketToDelete->usLocalPort;

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 8009396:	697a      	ldr	r2, [r7, #20]
 8009398:	693b      	ldr	r3, [r7, #16]
 800939a:	429a      	cmp	r2, r3
 800939c:	d1dd      	bne.n	800935a <prvTCPSetSocketCount+0x1a>
					pxOtherSocket->u.xTCP.usBacklog,
					pxOtherSocket->u.xTCP.usChildCount == 1u ? "" : "ren" ) );
				break;
			}
		}
	}
 800939e:	371c      	adds	r7, #28
 80093a0:	46bd      	mov	sp, r7
 80093a2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80093a6:	4770      	bx	lr
 80093a8:	2000cf18 	.word	0x2000cf18

080093ac <FreeRTOS_setsockopt>:
#endif /* ipconfigUSE_TCP == 1 */

/*-----------------------------------------------------------*/

BaseType_t FreeRTOS_setsockopt( Socket_t xSocket, int32_t lLevel, int32_t lOptionName, const void *pvOptionValue, size_t xOptionLength )
{
 80093ac:	b590      	push	{r4, r7, lr}
 80093ae:	b08d      	sub	sp, #52	; 0x34
 80093b0:	af02      	add	r7, sp, #8
 80093b2:	60f8      	str	r0, [r7, #12]
 80093b4:	60b9      	str	r1, [r7, #8]
 80093b6:	607a      	str	r2, [r7, #4]
 80093b8:	603b      	str	r3, [r7, #0]
/* The standard Berkeley function returns 0 for success. */
BaseType_t xReturn = -pdFREERTOS_ERRNO_EINVAL;
 80093ba:	f06f 0315 	mvn.w	r3, #21
 80093be:	627b      	str	r3, [r7, #36]	; 0x24
BaseType_t lOptionValue;
FreeRTOS_Socket_t *pxSocket;

	pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 80093c0:	68fb      	ldr	r3, [r7, #12]
 80093c2:	623b      	str	r3, [r7, #32]
	/* The function prototype is designed to maintain the expected Berkeley
	sockets standard, but this implementation does not use all the parameters. */
	( void ) lLevel;
	( void ) xOptionLength;

	configASSERT( xSocket );
 80093c4:	68fb      	ldr	r3, [r7, #12]
 80093c6:	2b00      	cmp	r3, #0
 80093c8:	d109      	bne.n	80093de <FreeRTOS_setsockopt+0x32>
 80093ca:	f04f 0350 	mov.w	r3, #80	; 0x50
 80093ce:	f383 8811 	msr	BASEPRI, r3
 80093d2:	f3bf 8f6f 	isb	sy
 80093d6:	f3bf 8f4f 	dsb	sy
 80093da:	613b      	str	r3, [r7, #16]
 80093dc:	e7fe      	b.n	80093dc <FreeRTOS_setsockopt+0x30>

	switch( lOptionName )
 80093de:	687b      	ldr	r3, [r7, #4]
 80093e0:	2b0f      	cmp	r3, #15
 80093e2:	f200 8174 	bhi.w	80096ce <FreeRTOS_setsockopt+0x322>
 80093e6:	a201      	add	r2, pc, #4	; (adr r2, 80093ec <FreeRTOS_setsockopt+0x40>)
 80093e8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80093ec:	0800942d 	.word	0x0800942d
 80093f0:	0800943b 	.word	0x0800943b
 80093f4:	08009467 	.word	0x08009467
 80093f8:	080096cf 	.word	0x080096cf
 80093fc:	0800949d 	.word	0x0800949d
 8009400:	0800949d 	.word	0x0800949d
 8009404:	080096cf 	.word	0x080096cf
 8009408:	080096cf 	.word	0x080096cf
 800940c:	080096cf 	.word	0x080096cf
 8009410:	080096cf 	.word	0x080096cf
 8009414:	080096cf 	.word	0x080096cf
 8009418:	0800959f 	.word	0x0800959f
 800941c:	080095d7 	.word	0x080095d7
 8009420:	080094f9 	.word	0x080094f9
 8009424:	0800960f 	.word	0x0800960f
 8009428:	0800967b 	.word	0x0800967b
	{
		case FREERTOS_SO_RCVTIMEO	:
			/* Receive time out. */
			pxSocket->xReceiveBlockTime = *( ( TickType_t * ) pvOptionValue );
 800942c:	683b      	ldr	r3, [r7, #0]
 800942e:	681a      	ldr	r2, [r3, #0]
 8009430:	6a3b      	ldr	r3, [r7, #32]
 8009432:	61da      	str	r2, [r3, #28]
			xReturn = 0;
 8009434:	2300      	movs	r3, #0
 8009436:	627b      	str	r3, [r7, #36]	; 0x24
			break;
 8009438:	e14d      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>

		case FREERTOS_SO_SNDTIMEO	:
			pxSocket->xSendBlockTime = *( ( TickType_t * ) pvOptionValue );
 800943a:	683b      	ldr	r3, [r7, #0]
 800943c:	681a      	ldr	r2, [r3, #0]
 800943e:	6a3b      	ldr	r3, [r7, #32]
 8009440:	621a      	str	r2, [r3, #32]
			if( pxSocket->ucProtocol == ( uint8_t ) FREERTOS_IPPROTO_UDP )
 8009442:	6a3b      	ldr	r3, [r7, #32]
 8009444:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8009448:	2b11      	cmp	r3, #17
 800944a:	d109      	bne.n	8009460 <FreeRTOS_setsockopt+0xb4>
			{
				/* The send time out is capped for the reason stated in the
				comments where ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS is defined
				in FreeRTOSIPConfig.h (assuming an official configuration file
				is being used. */
				if( pxSocket->xSendBlockTime > ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS )
 800944c:	6a3b      	ldr	r3, [r7, #32]
 800944e:	6a1b      	ldr	r3, [r3, #32]
 8009450:	f241 3288 	movw	r2, #5000	; 0x1388
 8009454:	4293      	cmp	r3, r2
 8009456:	d903      	bls.n	8009460 <FreeRTOS_setsockopt+0xb4>
				{
					pxSocket->xSendBlockTime = ipconfigUDP_MAX_SEND_BLOCK_TIME_TICKS;
 8009458:	6a3b      	ldr	r3, [r7, #32]
 800945a:	f241 3288 	movw	r2, #5000	; 0x1388
 800945e:	621a      	str	r2, [r3, #32]
			{
				/* For TCP socket, it isn't necessary to limit the blocking time
				because	the FreeRTOS_send() function does not wait for a network
				buffer to become available. */
			}
			xReturn = 0;
 8009460:	2300      	movs	r3, #0
 8009462:	627b      	str	r3, [r7, #36]	; 0x24
			break;
 8009464:	e137      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>
				break;
		#endif /* ipconfigUDP_MAX_RX_PACKETS */

		case FREERTOS_SO_UDPCKSUM_OUT :
			/* Turn calculating of the UDP checksum on/off for this socket. */
			lOptionValue = ( BaseType_t ) pvOptionValue;
 8009466:	683b      	ldr	r3, [r7, #0]
 8009468:	61fb      	str	r3, [r7, #28]

			if( lOptionValue == 0 )
 800946a:	69fb      	ldr	r3, [r7, #28]
 800946c:	2b00      	cmp	r3, #0
 800946e:	d109      	bne.n	8009484 <FreeRTOS_setsockopt+0xd8>
			{
				pxSocket->ucSocketOptions &= ( uint8_t ) ~FREERTOS_SO_UDPCKSUM_OUT;
 8009470:	6a3b      	ldr	r3, [r7, #32]
 8009472:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 8009476:	f023 0302 	bic.w	r3, r3, #2
 800947a:	b2da      	uxtb	r2, r3
 800947c:	6a3b      	ldr	r3, [r7, #32]
 800947e:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
 8009482:	e008      	b.n	8009496 <FreeRTOS_setsockopt+0xea>
			}
			else
			{
				pxSocket->ucSocketOptions |= ( uint8_t ) FREERTOS_SO_UDPCKSUM_OUT;
 8009484:	6a3b      	ldr	r3, [r7, #32]
 8009486:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 800948a:	f043 0302 	orr.w	r3, r3, #2
 800948e:	b2da      	uxtb	r2, r3
 8009490:	6a3b      	ldr	r3, [r7, #32]
 8009492:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
			}
			xReturn = 0;
 8009496:	2300      	movs	r3, #0
 8009498:	627b      	str	r3, [r7, #36]	; 0x24
			break;
 800949a:	e11c      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>
			case FREERTOS_SO_SNDBUF:	/* Set the size of the send buffer, in units of MSS (TCP only) */
			case FREERTOS_SO_RCVBUF:	/* Set the size of the receive buffer, in units of MSS (TCP only) */
				{
					uint32_t ulNewValue;

					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800949c:	6a3b      	ldr	r3, [r7, #32]
 800949e:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 80094a2:	2b06      	cmp	r3, #6
 80094a4:	d000      	beq.n	80094a8 <FreeRTOS_setsockopt+0xfc>
					{
						FreeRTOS_debug_printf( ( "Set SO_%sBUF: wrong socket type\n",
							( lOptionName == FREERTOS_SO_SNDBUF ) ? "SND" : "RCV" ) );
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
 80094a6:	e116      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>
					}

					if( ( ( lOptionName == FREERTOS_SO_SNDBUF ) && ( pxSocket->u.xTCP.txStream != NULL ) ) ||
 80094a8:	687b      	ldr	r3, [r7, #4]
 80094aa:	2b04      	cmp	r3, #4
 80094ac:	d104      	bne.n	80094b8 <FreeRTOS_setsockopt+0x10c>
 80094ae:	6a3b      	ldr	r3, [r7, #32]
 80094b0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 80094b2:	2b00      	cmp	r3, #0
 80094b4:	f040 810f 	bne.w	80096d6 <FreeRTOS_setsockopt+0x32a>
 80094b8:	687b      	ldr	r3, [r7, #4]
 80094ba:	2b05      	cmp	r3, #5
 80094bc:	d104      	bne.n	80094c8 <FreeRTOS_setsockopt+0x11c>
						( ( lOptionName == FREERTOS_SO_RCVBUF ) && ( pxSocket->u.xTCP.rxStream != NULL ) ) )
 80094be:	6a3b      	ldr	r3, [r7, #32]
 80094c0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80094c2:	2b00      	cmp	r3, #0
 80094c4:	f040 8107 	bne.w	80096d6 <FreeRTOS_setsockopt+0x32a>
						FreeRTOS_debug_printf( ( "Set SO_%sBUF: buffer already created\n",
							( lOptionName == FREERTOS_SO_SNDBUF ) ? "SND" : "RCV" ) );
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
					}

					ulNewValue = *( ( uint32_t * ) pvOptionValue );
 80094c8:	683b      	ldr	r3, [r7, #0]
 80094ca:	681b      	ldr	r3, [r3, #0]
 80094cc:	61bb      	str	r3, [r7, #24]

					if( lOptionName == FREERTOS_SO_SNDBUF )
 80094ce:	687b      	ldr	r3, [r7, #4]
 80094d0:	2b04      	cmp	r3, #4
 80094d2:	d10b      	bne.n	80094ec <FreeRTOS_setsockopt+0x140>
					{
						/* Round up to nearest MSS size */
						ulNewValue = FreeRTOS_round_up( ulNewValue, ( uint32_t ) pxSocket->u.xTCP.usInitMSS );
 80094d4:	6a3b      	ldr	r3, [r7, #32]
 80094d6:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 80094da:	69b8      	ldr	r0, [r7, #24]
 80094dc:	4619      	mov	r1, r3
 80094de:	f7ff fb4d 	bl	8008b7c <FreeRTOS_round_up>
 80094e2:	61b8      	str	r0, [r7, #24]
						pxSocket->u.xTCP.uxTxStreamSize = ulNewValue;
 80094e4:	6a3b      	ldr	r3, [r7, #32]
 80094e6:	69ba      	ldr	r2, [r7, #24]
 80094e8:	671a      	str	r2, [r3, #112]	; 0x70
 80094ea:	e002      	b.n	80094f2 <FreeRTOS_setsockopt+0x146>
					}
					else
					{
						pxSocket->u.xTCP.uxRxStreamSize = ulNewValue;
 80094ec:	6a3b      	ldr	r3, [r7, #32]
 80094ee:	69ba      	ldr	r2, [r7, #24]
 80094f0:	66da      	str	r2, [r3, #108]	; 0x6c
					}
				}
				xReturn = 0;
 80094f2:	2300      	movs	r3, #0
 80094f4:	627b      	str	r3, [r7, #36]	; 0x24
				break;
 80094f6:	e0ee      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>

			case FREERTOS_SO_WIN_PROPERTIES:	/* Set all buffer and window properties in one call, parameter is pointer to WinProperties_t */
				{
					WinProperties_t* pxProps;

					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 80094f8:	6a3b      	ldr	r3, [r7, #32]
 80094fa:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 80094fe:	2b06      	cmp	r3, #6
 8009500:	d000      	beq.n	8009504 <FreeRTOS_setsockopt+0x158>
					{
						FreeRTOS_debug_printf( ( "Set SO_WIN_PROP: wrong socket type\n" ) );
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
 8009502:	e0e8      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>
					}

					if( ( pxSocket->u.xTCP.txStream != NULL ) || ( pxSocket->u.xTCP.rxStream != NULL ) )
 8009504:	6a3b      	ldr	r3, [r7, #32]
 8009506:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8009508:	2b00      	cmp	r3, #0
 800950a:	f040 80e4 	bne.w	80096d6 <FreeRTOS_setsockopt+0x32a>
 800950e:	6a3b      	ldr	r3, [r7, #32]
 8009510:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009512:	2b00      	cmp	r3, #0
 8009514:	f040 80df 	bne.w	80096d6 <FreeRTOS_setsockopt+0x32a>
					{
						FreeRTOS_debug_printf( ( "Set SO_WIN_PROP: buffer already created\n" ) );
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
					}

					pxProps = ( ( WinProperties_t * ) pvOptionValue );
 8009518:	683b      	ldr	r3, [r7, #0]
 800951a:	617b      	str	r3, [r7, #20]
					FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_SNDBUF, &( pxProps->lTxBufSize ), sizeof( pxProps->lTxBufSize ) );
 800951c:	697c      	ldr	r4, [r7, #20]
 800951e:	2304      	movs	r3, #4
 8009520:	9300      	str	r3, [sp, #0]
 8009522:	68f8      	ldr	r0, [r7, #12]
 8009524:	2100      	movs	r1, #0
 8009526:	2204      	movs	r2, #4
 8009528:	4623      	mov	r3, r4
 800952a:	f7ff ff3f 	bl	80093ac <FreeRTOS_setsockopt>
					FreeRTOS_setsockopt( xSocket, 0, FREERTOS_SO_RCVBUF, &( pxProps->lRxBufSize ), sizeof( pxProps->lRxBufSize ) );
 800952e:	697b      	ldr	r3, [r7, #20]
 8009530:	f103 0408 	add.w	r4, r3, #8
 8009534:	2304      	movs	r3, #4
 8009536:	9300      	str	r3, [sp, #0]
 8009538:	68f8      	ldr	r0, [r7, #12]
 800953a:	2100      	movs	r1, #0
 800953c:	2205      	movs	r2, #5
 800953e:	4623      	mov	r3, r4
 8009540:	f7ff ff34 	bl	80093ac <FreeRTOS_setsockopt>
					#if( ipconfigUSE_TCP_WIN == 1 )
					{
						pxSocket->u.xTCP.uxRxWinSize = ( uint32_t )pxProps->lRxWinSize;	/* Fixed value: size of the TCP reception window */
 8009544:	697b      	ldr	r3, [r7, #20]
 8009546:	68db      	ldr	r3, [r3, #12]
 8009548:	461a      	mov	r2, r3
 800954a:	6a3b      	ldr	r3, [r7, #32]
 800954c:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
						pxSocket->u.xTCP.uxTxWinSize = ( uint32_t )pxProps->lTxWinSize;	/* Fixed value: size of the TCP transmit window */
 8009550:	697b      	ldr	r3, [r7, #20]
 8009552:	685b      	ldr	r3, [r3, #4]
 8009554:	461a      	mov	r2, r3
 8009556:	6a3b      	ldr	r3, [r7, #32]
 8009558:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
					}
					#endif

					/* In case the socket has already initialised its tcpWin,
					adapt the window size parameters */
					if( pxSocket->u.xTCP.xTCPWindow.u.bits.bHasInit != pdFALSE_UNSIGNED )
 800955c:	6a3b      	ldr	r3, [r7, #32]
 800955e:	f893 30dc 	ldrb.w	r3, [r3, #220]	; 0xdc
 8009562:	f003 0301 	and.w	r3, r3, #1
 8009566:	b2db      	uxtb	r3, r3
 8009568:	2b00      	cmp	r3, #0
 800956a:	d015      	beq.n	8009598 <FreeRTOS_setsockopt+0x1ec>
					{
						pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength = pxSocket->u.xTCP.uxRxWinSize * pxSocket->u.xTCP.usInitMSS;
 800956c:	6a3b      	ldr	r3, [r7, #32]
 800956e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 8009572:	6a3a      	ldr	r2, [r7, #32]
 8009574:	f8b2 204c 	ldrh.w	r2, [r2, #76]	; 0x4c
 8009578:	fb02 f203 	mul.w	r2, r2, r3
 800957c:	6a3b      	ldr	r3, [r7, #32]
 800957e:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
						pxSocket->u.xTCP.xTCPWindow.xSize.ulRxWindowLength = pxSocket->u.xTCP.uxTxWinSize * pxSocket->u.xTCP.usInitMSS;
 8009582:	6a3b      	ldr	r3, [r7, #32]
 8009584:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 8009588:	6a3a      	ldr	r2, [r7, #32]
 800958a:	f8b2 204c 	ldrh.w	r2, [r2, #76]	; 0x4c
 800958e:	fb02 f203 	mul.w	r2, r2, r3
 8009592:	6a3b      	ldr	r3, [r7, #32]
 8009594:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
					}
				}

				xReturn = 0;
 8009598:	2300      	movs	r3, #0
 800959a:	627b      	str	r3, [r7, #36]	; 0x24
				break;
 800959c:	e09b      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>

			case FREERTOS_SO_REUSE_LISTEN_SOCKET:	/* If true, the server-socket will turn into a connected socket */
				{
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800959e:	6a3b      	ldr	r3, [r7, #32]
 80095a0:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 80095a4:	2b06      	cmp	r3, #6
 80095a6:	d000      	beq.n	80095aa <FreeRTOS_setsockopt+0x1fe>
					{
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
 80095a8:	e095      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>
					}
					if( *( ( BaseType_t * ) pvOptionValue ) != 0 )
 80095aa:	683b      	ldr	r3, [r7, #0]
 80095ac:	681b      	ldr	r3, [r3, #0]
 80095ae:	2b00      	cmp	r3, #0
 80095b0:	d007      	beq.n	80095c2 <FreeRTOS_setsockopt+0x216>
					{
						pxSocket->u.xTCP.bits.bReuseSocket = pdTRUE_UNSIGNED;
 80095b2:	6a3a      	ldr	r2, [r7, #32]
 80095b4:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 80095b8:	f043 0308 	orr.w	r3, r3, #8
 80095bc:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
 80095c0:	e006      	b.n	80095d0 <FreeRTOS_setsockopt+0x224>
					}
					else
					{
						pxSocket->u.xTCP.bits.bReuseSocket = pdFALSE_UNSIGNED;
 80095c2:	6a3a      	ldr	r2, [r7, #32]
 80095c4:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 80095c8:	f36f 03c3 	bfc	r3, #3, #1
 80095cc:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
					}
				}
				xReturn = 0;
 80095d0:	2300      	movs	r3, #0
 80095d2:	627b      	str	r3, [r7, #36]	; 0x24
				break;
 80095d4:	e07f      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>

			case FREERTOS_SO_CLOSE_AFTER_SEND:		/* As soon as the last byte has been transmitted, finalise the connection */
				{
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 80095d6:	6a3b      	ldr	r3, [r7, #32]
 80095d8:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 80095dc:	2b06      	cmp	r3, #6
 80095de:	d000      	beq.n	80095e2 <FreeRTOS_setsockopt+0x236>
					{
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
 80095e0:	e079      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>
					}

					if( *( ( BaseType_t * ) pvOptionValue ) != 0 )
 80095e2:	683b      	ldr	r3, [r7, #0]
 80095e4:	681b      	ldr	r3, [r3, #0]
 80095e6:	2b00      	cmp	r3, #0
 80095e8:	d007      	beq.n	80095fa <FreeRTOS_setsockopt+0x24e>
					{
						pxSocket->u.xTCP.bits.bCloseAfterSend = pdTRUE_UNSIGNED;
 80095ea:	6a3a      	ldr	r2, [r7, #32]
 80095ec:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 80095f0:	f043 0310 	orr.w	r3, r3, #16
 80095f4:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
 80095f8:	e006      	b.n	8009608 <FreeRTOS_setsockopt+0x25c>
					}
					else
					{
						pxSocket->u.xTCP.bits.bCloseAfterSend = pdFALSE_UNSIGNED;
 80095fa:	6a3a      	ldr	r2, [r7, #32]
 80095fc:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 8009600:	f36f 1304 	bfc	r3, #4, #1
 8009604:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
					}
				}
				xReturn = 0;
 8009608:	2300      	movs	r3, #0
 800960a:	627b      	str	r3, [r7, #36]	; 0x24
				break;
 800960c:	e063      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>

			case FREERTOS_SO_SET_FULL_SIZE:		/* Refuse to send packets smaller than MSS  */
				{
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800960e:	6a3b      	ldr	r3, [r7, #32]
 8009610:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8009614:	2b06      	cmp	r3, #6
 8009616:	d000      	beq.n	800961a <FreeRTOS_setsockopt+0x26e>
					{
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
 8009618:	e05d      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>
					}

					if( *( ( BaseType_t * ) pvOptionValue ) != 0 )
 800961a:	683b      	ldr	r3, [r7, #0]
 800961c:	681b      	ldr	r3, [r3, #0]
 800961e:	2b00      	cmp	r3, #0
 8009620:	d007      	beq.n	8009632 <FreeRTOS_setsockopt+0x286>
					{
						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdTRUE_UNSIGNED;
 8009622:	6a3a      	ldr	r2, [r7, #32]
 8009624:	f892 30dc 	ldrb.w	r3, [r2, #220]	; 0xdc
 8009628:	f043 0302 	orr.w	r3, r3, #2
 800962c:	f882 30dc 	strb.w	r3, [r2, #220]	; 0xdc
 8009630:	e006      	b.n	8009640 <FreeRTOS_setsockopt+0x294>
					}
					else
					{
						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdFALSE_UNSIGNED;
 8009632:	6a3a      	ldr	r2, [r7, #32]
 8009634:	f892 30dc 	ldrb.w	r3, [r2, #220]	; 0xdc
 8009638:	f36f 0341 	bfc	r3, #1, #1
 800963c:	f882 30dc 	strb.w	r3, [r2, #220]	; 0xdc
					}

					if( ( pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize == pdFALSE_UNSIGNED ) &&
 8009640:	6a3b      	ldr	r3, [r7, #32]
 8009642:	f893 30dc 	ldrb.w	r3, [r3, #220]	; 0xdc
 8009646:	f003 0302 	and.w	r3, r3, #2
 800964a:	b2db      	uxtb	r3, r3
 800964c:	2b00      	cmp	r3, #0
 800964e:	d111      	bne.n	8009674 <FreeRTOS_setsockopt+0x2c8>
						( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) &&
 8009650:	6a3b      	ldr	r3, [r7, #32]
 8009652:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
					else
					{
						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdFALSE_UNSIGNED;
					}

					if( ( pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize == pdFALSE_UNSIGNED ) &&
 8009656:	2b04      	cmp	r3, #4
 8009658:	d90c      	bls.n	8009674 <FreeRTOS_setsockopt+0x2c8>
						( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) &&
						( FreeRTOS_outstanding( pxSocket ) != 0 ) )
 800965a:	6a38      	ldr	r0, [r7, #32]
 800965c:	f000 fab4 	bl	8009bc8 <FreeRTOS_tx_size>
 8009660:	4603      	mov	r3, r0
					{
						pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize = pdFALSE_UNSIGNED;
					}

					if( ( pxSocket->u.xTCP.xTCPWindow.u.bits.bSendFullSize == pdFALSE_UNSIGNED ) &&
						( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) &&
 8009662:	2b00      	cmp	r3, #0
 8009664:	d006      	beq.n	8009674 <FreeRTOS_setsockopt+0x2c8>
						( FreeRTOS_outstanding( pxSocket ) != 0 ) )
					{
						pxSocket->u.xTCP.usTimeout = 1u; /* to set/clear bSendFullSize */
 8009666:	6a3b      	ldr	r3, [r7, #32]
 8009668:	2201      	movs	r2, #1
 800966a:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
						xSendEventToIPTask( eTCPTimerEvent );
 800966e:	2005      	movs	r0, #5
 8009670:	f7fe fc88 	bl	8007f84 <xSendEventToIPTask>
					}
				}
				xReturn = 0;
 8009674:	2300      	movs	r3, #0
 8009676:	627b      	str	r3, [r7, #36]	; 0x24
				break;
 8009678:	e02d      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>

			case FREERTOS_SO_STOP_RX:		/* Refuse to receive more packts */
				{
					if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 800967a:	6a3b      	ldr	r3, [r7, #32]
 800967c:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8009680:	2b06      	cmp	r3, #6
 8009682:	d000      	beq.n	8009686 <FreeRTOS_setsockopt+0x2da>
					{
						break;	/* will return -pdFREERTOS_ERRNO_EINVAL */
 8009684:	e027      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>
					}

					if( *( ( BaseType_t * ) pvOptionValue ) != 0 )
 8009686:	683b      	ldr	r3, [r7, #0]
 8009688:	681b      	ldr	r3, [r3, #0]
 800968a:	2b00      	cmp	r3, #0
 800968c:	d007      	beq.n	800969e <FreeRTOS_setsockopt+0x2f2>
					{
						pxSocket->u.xTCP.bits.bRxStopped = pdTRUE_UNSIGNED;
 800968e:	6a3a      	ldr	r2, [r7, #32]
 8009690:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
 8009694:	f043 0304 	orr.w	r3, r3, #4
 8009698:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
 800969c:	e006      	b.n	80096ac <FreeRTOS_setsockopt+0x300>
					}
					else
					{
						pxSocket->u.xTCP.bits.bRxStopped = pdFALSE_UNSIGNED;
 800969e:	6a3a      	ldr	r2, [r7, #32]
 80096a0:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
 80096a4:	f36f 0382 	bfc	r3, #2, #1
 80096a8:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
					}

					pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 80096ac:	6a3a      	ldr	r2, [r7, #32]
 80096ae:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 80096b2:	f043 0301 	orr.w	r3, r3, #1
 80096b6:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
					pxSocket->u.xTCP.usTimeout = 1u; /* to set/clear bRxStopped */
 80096ba:	6a3b      	ldr	r3, [r7, #32]
 80096bc:	2201      	movs	r2, #1
 80096be:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
					xSendEventToIPTask( eTCPTimerEvent );
 80096c2:	2005      	movs	r0, #5
 80096c4:	f7fe fc5e 	bl	8007f84 <xSendEventToIPTask>
				}
				xReturn = 0;
 80096c8:	2300      	movs	r3, #0
 80096ca:	627b      	str	r3, [r7, #36]	; 0x24
				break;
 80096cc:	e003      	b.n	80096d6 <FreeRTOS_setsockopt+0x32a>

		#endif  /* ipconfigUSE_TCP == 1 */

		default :
			/* No other options are handled. */
			xReturn = -pdFREERTOS_ERRNO_ENOPROTOOPT;
 80096ce:	f06f 036c 	mvn.w	r3, #108	; 0x6c
 80096d2:	627b      	str	r3, [r7, #36]	; 0x24
			break;
 80096d4:	bf00      	nop
	}

	return xReturn;
 80096d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
} /* Tested */
 80096d8:	4618      	mov	r0, r3
 80096da:	372c      	adds	r7, #44	; 0x2c
 80096dc:	46bd      	mov	sp, r7
 80096de:	bd90      	pop	{r4, r7, pc}

080096e0 <prvGetPrivatePortNumber>:

/*-----------------------------------------------------------*/

/* Get a free private ('anonymous') port number */
static uint16_t prvGetPrivatePortNumber( BaseType_t xProtocol )
{
 80096e0:	b580      	push	{r7, lr}
 80096e2:	b086      	sub	sp, #24
 80096e4:	af00      	add	r7, sp, #0
 80096e6:	6078      	str	r0, [r7, #4]
uint16_t usResult;
BaseType_t xIndex;
const List_t *pxList;

#if ipconfigUSE_TCP == 1
	if( xProtocol == ( BaseType_t ) FREERTOS_IPPROTO_TCP )
 80096e8:	687b      	ldr	r3, [r7, #4]
 80096ea:	2b06      	cmp	r3, #6
 80096ec:	d104      	bne.n	80096f8 <prvGetPrivatePortNumber+0x18>
	{
		xIndex = socketNEXT_TCP_PORT_NUMBER_INDEX;
 80096ee:	2301      	movs	r3, #1
 80096f0:	617b      	str	r3, [r7, #20]
		pxList = &xBoundTCPSocketsList;
 80096f2:	4b1f      	ldr	r3, [pc, #124]	; (8009770 <prvGetPrivatePortNumber+0x90>)
 80096f4:	613b      	str	r3, [r7, #16]
 80096f6:	e003      	b.n	8009700 <prvGetPrivatePortNumber+0x20>
	}
	else
#endif
	{
		xIndex = socketNEXT_UDP_PORT_NUMBER_INDEX;
 80096f8:	2300      	movs	r3, #0
 80096fa:	617b      	str	r3, [r7, #20]
		pxList = &xBoundUDPSocketsList;
 80096fc:	4b1d      	ldr	r3, [pc, #116]	; (8009774 <prvGetPrivatePortNumber+0x94>)
 80096fe:	613b      	str	r3, [r7, #16]
	/*_RB_ This needs to be randomised rather than sequential. */
	/* _HT_ Agreed, although many OS's use sequential port numbers, see
	https://www.cymru.com/jtk/misc/ephemeralports.html  */
	for ( ;; )
	{
		++( usNextPortToUse[ xIndex ] );
 8009700:	4a1d      	ldr	r2, [pc, #116]	; (8009778 <prvGetPrivatePortNumber+0x98>)
 8009702:	697b      	ldr	r3, [r7, #20]
 8009704:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8009708:	3301      	adds	r3, #1
 800970a:	b299      	uxth	r1, r3
 800970c:	4a1a      	ldr	r2, [pc, #104]	; (8009778 <prvGetPrivatePortNumber+0x98>)
 800970e:	697b      	ldr	r3, [r7, #20]
 8009710:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]

		if( usNextPortToUse[ xIndex ] >= socketAUTO_PORT_ALLOCATION_MAX_NUMBER )
 8009714:	4a18      	ldr	r2, [pc, #96]	; (8009778 <prvGetPrivatePortNumber+0x98>)
 8009716:	697b      	ldr	r3, [r7, #20]
 8009718:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800971c:	f5b3 4f7f 	cmp.w	r3, #65280	; 0xff00
 8009720:	d305      	bcc.n	800972e <prvGetPrivatePortNumber+0x4e>
		{
			/* Don't go right back to the start of the dynamic/private port
			range numbers as any persistent sockets are likely to have been
			create first so the early port numbers may still be in use. */
			usNextPortToUse[ xIndex ] = socketAUTO_PORT_ALLOCATION_RESET_NUMBER;
 8009722:	4a15      	ldr	r2, [pc, #84]	; (8009778 <prvGetPrivatePortNumber+0x98>)
 8009724:	697b      	ldr	r3, [r7, #20]
 8009726:	f44f 4141 	mov.w	r1, #49408	; 0xc100
 800972a:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
		}

		usResult = FreeRTOS_htons( usNextPortToUse[ xIndex ] );
 800972e:	4a12      	ldr	r2, [pc, #72]	; (8009778 <prvGetPrivatePortNumber+0x98>)
 8009730:	697b      	ldr	r3, [r7, #20]
 8009732:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8009736:	021b      	lsls	r3, r3, #8
 8009738:	b299      	uxth	r1, r3
 800973a:	4a0f      	ldr	r2, [pc, #60]	; (8009778 <prvGetPrivatePortNumber+0x98>)
 800973c:	697b      	ldr	r3, [r7, #20]
 800973e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8009742:	0a1b      	lsrs	r3, r3, #8
 8009744:	b29b      	uxth	r3, r3
 8009746:	b29b      	uxth	r3, r3
 8009748:	460a      	mov	r2, r1
 800974a:	4313      	orrs	r3, r2
 800974c:	b29b      	uxth	r3, r3
 800974e:	81fb      	strh	r3, [r7, #14]

		if( pxListFindListItemWithValue( pxList, ( TickType_t ) usResult ) == NULL )
 8009750:	89fb      	ldrh	r3, [r7, #14]
 8009752:	6938      	ldr	r0, [r7, #16]
 8009754:	4619      	mov	r1, r3
 8009756:	f000 f811 	bl	800977c <pxListFindListItemWithValue>
 800975a:	4603      	mov	r3, r0
 800975c:	2b00      	cmp	r3, #0
 800975e:	d100      	bne.n	8009762 <prvGetPrivatePortNumber+0x82>
		{
			break;
 8009760:	e000      	b.n	8009764 <prvGetPrivatePortNumber+0x84>
		}
	}
 8009762:	e7cd      	b.n	8009700 <prvGetPrivatePortNumber+0x20>
	return usResult;
 8009764:	89fb      	ldrh	r3, [r7, #14]
} /* Tested */
 8009766:	4618      	mov	r0, r3
 8009768:	3718      	adds	r7, #24
 800976a:	46bd      	mov	sp, r7
 800976c:	bd80      	pop	{r7, pc}
 800976e:	bf00      	nop
 8009770:	2000cf10 	.word	0x2000cf10
 8009774:	2000cf24 	.word	0x2000cf24
 8009778:	2000c290 	.word	0x2000c290

0800977c <pxListFindListItemWithValue>:
/*-----------------------------------------------------------*/

/* pxListFindListItemWithValue: find a list item in a bound socket list
'xWantedItemValue' refers to a port number */
static const ListItem_t * pxListFindListItemWithValue( const List_t *pxList, TickType_t xWantedItemValue )
{
 800977c:	b580      	push	{r7, lr}
 800977e:	b086      	sub	sp, #24
 8009780:	af00      	add	r7, sp, #0
 8009782:	6078      	str	r0, [r7, #4]
 8009784:	6039      	str	r1, [r7, #0]
const ListItem_t * pxResult = NULL;
 8009786:	2300      	movs	r3, #0
 8009788:	617b      	str	r3, [r7, #20]

	if( ( xIPIsNetworkTaskReady() != pdFALSE ) && ( pxList != NULL ) )
 800978a:	f7fe fee1 	bl	8008550 <xIPIsNetworkTaskReady>
 800978e:	4603      	mov	r3, r0
 8009790:	2b00      	cmp	r3, #0
 8009792:	d018      	beq.n	80097c6 <pxListFindListItemWithValue+0x4a>
 8009794:	687b      	ldr	r3, [r7, #4]
 8009796:	2b00      	cmp	r3, #0
 8009798:	d015      	beq.n	80097c6 <pxListFindListItemWithValue+0x4a>
	{
		const ListItem_t *pxIterator;
		const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( pxList );
 800979a:	687b      	ldr	r3, [r7, #4]
 800979c:	3308      	adds	r3, #8
 800979e:	60fb      	str	r3, [r7, #12]
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 80097a0:	68fb      	ldr	r3, [r7, #12]
 80097a2:	685b      	ldr	r3, [r3, #4]
 80097a4:	613b      	str	r3, [r7, #16]
 80097a6:	e00a      	b.n	80097be <pxListFindListItemWithValue+0x42>
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			if( listGET_LIST_ITEM_VALUE( pxIterator ) == xWantedItemValue )
 80097a8:	693b      	ldr	r3, [r7, #16]
 80097aa:	681a      	ldr	r2, [r3, #0]
 80097ac:	683b      	ldr	r3, [r7, #0]
 80097ae:	429a      	cmp	r2, r3
 80097b0:	d102      	bne.n	80097b8 <pxListFindListItemWithValue+0x3c>
			{
				pxResult = pxIterator;
 80097b2:	693b      	ldr	r3, [r7, #16]
 80097b4:	617b      	str	r3, [r7, #20]
				break;
 80097b6:	e006      	b.n	80097c6 <pxListFindListItemWithValue+0x4a>
	{
		const ListItem_t *pxIterator;
		const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( pxList );
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 80097b8:	693b      	ldr	r3, [r7, #16]
 80097ba:	685b      	ldr	r3, [r3, #4]
 80097bc:	613b      	str	r3, [r7, #16]

	if( ( xIPIsNetworkTaskReady() != pdFALSE ) && ( pxList != NULL ) )
	{
		const ListItem_t *pxIterator;
		const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( pxList );
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 80097be:	693a      	ldr	r2, [r7, #16]
 80097c0:	68fb      	ldr	r3, [r7, #12]
 80097c2:	429a      	cmp	r2, r3
 80097c4:	d1f0      	bne.n	80097a8 <pxListFindListItemWithValue+0x2c>
				break;
			}
		}
	}

	return pxResult;
 80097c6:	697b      	ldr	r3, [r7, #20]
} /* Tested */
 80097c8:	4618      	mov	r0, r3
 80097ca:	3718      	adds	r7, #24
 80097cc:	46bd      	mov	sp, r7
 80097ce:	bd80      	pop	{r7, pc}

080097d0 <pxUDPSocketLookup>:

/*-----------------------------------------------------------*/

FreeRTOS_Socket_t *pxUDPSocketLookup( UBaseType_t uxLocalPort )
{
 80097d0:	b580      	push	{r7, lr}
 80097d2:	b086      	sub	sp, #24
 80097d4:	af00      	add	r7, sp, #0
 80097d6:	6078      	str	r0, [r7, #4]
const ListItem_t *pxListItem;
FreeRTOS_Socket_t *pxSocket = NULL;
 80097d8:	2300      	movs	r3, #0
 80097da:	617b      	str	r3, [r7, #20]

	/* Looking up a socket is quite simple, find a match with the local port.

	See if there is a list item associated with the port number on the
	list of bound sockets. */
	pxListItem = pxListFindListItemWithValue( &xBoundUDPSocketsList, ( TickType_t ) uxLocalPort );
 80097dc:	480e      	ldr	r0, [pc, #56]	; (8009818 <pxUDPSocketLookup+0x48>)
 80097de:	6879      	ldr	r1, [r7, #4]
 80097e0:	f7ff ffcc 	bl	800977c <pxListFindListItemWithValue>
 80097e4:	6138      	str	r0, [r7, #16]

	if( pxListItem != NULL )
 80097e6:	693b      	ldr	r3, [r7, #16]
 80097e8:	2b00      	cmp	r3, #0
 80097ea:	d00f      	beq.n	800980c <pxUDPSocketLookup+0x3c>
	{
		/* The owner of the list item is the socket itself. */
		pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxListItem );
 80097ec:	693b      	ldr	r3, [r7, #16]
 80097ee:	68db      	ldr	r3, [r3, #12]
 80097f0:	617b      	str	r3, [r7, #20]
		configASSERT( pxSocket != NULL );
 80097f2:	697b      	ldr	r3, [r7, #20]
 80097f4:	2b00      	cmp	r3, #0
 80097f6:	d109      	bne.n	800980c <pxUDPSocketLookup+0x3c>
 80097f8:	f04f 0350 	mov.w	r3, #80	; 0x50
 80097fc:	f383 8811 	msr	BASEPRI, r3
 8009800:	f3bf 8f6f 	isb	sy
 8009804:	f3bf 8f4f 	dsb	sy
 8009808:	60fb      	str	r3, [r7, #12]
 800980a:	e7fe      	b.n	800980a <pxUDPSocketLookup+0x3a>
	}
	return pxSocket;
 800980c:	697b      	ldr	r3, [r7, #20]
}
 800980e:	4618      	mov	r0, r3
 8009810:	3718      	adds	r7, #24
 8009812:	46bd      	mov	sp, r7
 8009814:	bd80      	pop	{r7, pc}
 8009816:	bf00      	nop
 8009818:	2000cf24 	.word	0x2000cf24

0800981c <vSocketWakeUpUser>:
}

/*-----------------------------------------------------------*/

void vSocketWakeUpUser( FreeRTOS_Socket_t *pxSocket )
{
 800981c:	b580      	push	{r7, lr}
 800981e:	b084      	sub	sp, #16
 8009820:	af00      	add	r7, sp, #0
 8009822:	6078      	str	r0, [r7, #4]
	}
	#endif /* ipconfigSOCKET_HAS_USER_SEMAPHORE */

	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
	{
		if( pxSocket->pxSocketSet != NULL )
 8009824:	687b      	ldr	r3, [r7, #4]
 8009826:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009828:	2b00      	cmp	r3, #0
 800982a:	d015      	beq.n	8009858 <vSocketWakeUpUser+0x3c>
		{
			EventBits_t xSelectBits = ( pxSocket->xEventBits >> SOCKET_EVENT_BIT_COUNT ) & eSELECT_ALL;
 800982c:	687b      	ldr	r3, [r7, #4]
 800982e:	681b      	ldr	r3, [r3, #0]
 8009830:	0a1b      	lsrs	r3, r3, #8
 8009832:	f003 030f 	and.w	r3, r3, #15
 8009836:	60fb      	str	r3, [r7, #12]
			if( xSelectBits != 0ul )
 8009838:	68fb      	ldr	r3, [r7, #12]
 800983a:	2b00      	cmp	r3, #0
 800983c:	d00c      	beq.n	8009858 <vSocketWakeUpUser+0x3c>
			{
				pxSocket->xSocketBits |= xSelectBits;
 800983e:	687b      	ldr	r3, [r7, #4]
 8009840:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8009842:	68fb      	ldr	r3, [r7, #12]
 8009844:	431a      	orrs	r2, r3
 8009846:	687b      	ldr	r3, [r7, #4]
 8009848:	631a      	str	r2, [r3, #48]	; 0x30
				xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, xSelectBits );
 800984a:	687b      	ldr	r3, [r7, #4]
 800984c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800984e:	681b      	ldr	r3, [r3, #0]
 8009850:	4618      	mov	r0, r3
 8009852:	68f9      	ldr	r1, [r7, #12]
 8009854:	f7fc ff68 	bl	8006728 <xEventGroupSetBits>
			}
		}

		pxSocket->xEventBits &= eSOCKET_ALL;
 8009858:	687b      	ldr	r3, [r7, #4]
 800985a:	681b      	ldr	r3, [r3, #0]
 800985c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
 8009860:	687b      	ldr	r3, [r7, #4]
 8009862:	601a      	str	r2, [r3, #0]
	}
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */

	if( ( pxSocket->xEventGroup != NULL ) && ( pxSocket->xEventBits != 0u ) )
 8009864:	687b      	ldr	r3, [r7, #4]
 8009866:	685b      	ldr	r3, [r3, #4]
 8009868:	2b00      	cmp	r3, #0
 800986a:	d00b      	beq.n	8009884 <vSocketWakeUpUser+0x68>
 800986c:	687b      	ldr	r3, [r7, #4]
 800986e:	681b      	ldr	r3, [r3, #0]
 8009870:	2b00      	cmp	r3, #0
 8009872:	d007      	beq.n	8009884 <vSocketWakeUpUser+0x68>
	{
		xEventGroupSetBits( pxSocket->xEventGroup, pxSocket->xEventBits );
 8009874:	687b      	ldr	r3, [r7, #4]
 8009876:	685a      	ldr	r2, [r3, #4]
 8009878:	687b      	ldr	r3, [r7, #4]
 800987a:	681b      	ldr	r3, [r3, #0]
 800987c:	4610      	mov	r0, r2
 800987e:	4619      	mov	r1, r3
 8009880:	f7fc ff52 	bl	8006728 <xEventGroupSetBits>
	}

	pxSocket->xEventBits = 0ul;
 8009884:	687b      	ldr	r3, [r7, #4]
 8009886:	2200      	movs	r2, #0
 8009888:	601a      	str	r2, [r3, #0]
}
 800988a:	3710      	adds	r7, #16
 800988c:	46bd      	mov	sp, r7
 800988e:	bd80      	pop	{r7, pc}

08009890 <xTCPTimerCheck>:
	 * - Send new data
	 * - Send a keep-alive packet
	 * - Check for timeout (in non-connected states only)
	 */
	TickType_t xTCPTimerCheck( BaseType_t xWillSleep )
	{
 8009890:	b580      	push	{r7, lr}
 8009892:	b088      	sub	sp, #32
 8009894:	af00      	add	r7, sp, #0
 8009896:	6078      	str	r0, [r7, #4]
	FreeRTOS_Socket_t *pxSocket;
	TickType_t xShortest = pdMS_TO_TICKS( ( TickType_t ) ipTCP_TIMER_PERIOD_MS );
 8009898:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800989c:	61fb      	str	r3, [r7, #28]
	TickType_t xNow = xTaskGetTickCount();
 800989e:	f7fb fe71 	bl	8005584 <xTaskGetTickCount>
 80098a2:	6138      	str	r0, [r7, #16]
	static TickType_t xLastTime = 0u;
	TickType_t xDelta = xNow - xLastTime;
 80098a4:	4b30      	ldr	r3, [pc, #192]	; (8009968 <xTCPTimerCheck+0xd8>)
 80098a6:	681b      	ldr	r3, [r3, #0]
 80098a8:	693a      	ldr	r2, [r7, #16]
 80098aa:	1ad3      	subs	r3, r2, r3
 80098ac:	61bb      	str	r3, [r7, #24]
	ListItem_t* pxEnd = ( ListItem_t * ) listGET_END_MARKER( &xBoundTCPSocketsList );
 80098ae:	4b2f      	ldr	r3, [pc, #188]	; (800996c <xTCPTimerCheck+0xdc>)
 80098b0:	60fb      	str	r3, [r7, #12]
	ListItem_t *pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 80098b2:	4b2f      	ldr	r3, [pc, #188]	; (8009970 <xTCPTimerCheck+0xe0>)
 80098b4:	68db      	ldr	r3, [r3, #12]
 80098b6:	617b      	str	r3, [r7, #20]

		xLastTime = xNow;
 80098b8:	4a2b      	ldr	r2, [pc, #172]	; (8009968 <xTCPTimerCheck+0xd8>)
 80098ba:	693b      	ldr	r3, [r7, #16]
 80098bc:	6013      	str	r3, [r2, #0]

		if( xDelta == 0u )
 80098be:	69bb      	ldr	r3, [r7, #24]
 80098c0:	2b00      	cmp	r3, #0
 80098c2:	d101      	bne.n	80098c8 <xTCPTimerCheck+0x38>
		{
			xDelta = 1u;
 80098c4:	2301      	movs	r3, #1
 80098c6:	61bb      	str	r3, [r7, #24]
		}

		while( pxIterator != pxEnd )
 80098c8:	e045      	b.n	8009956 <xTCPTimerCheck+0xc6>
		{
			pxSocket = ( FreeRTOS_Socket_t * )listGET_LIST_ITEM_OWNER( pxIterator );
 80098ca:	697b      	ldr	r3, [r7, #20]
 80098cc:	68db      	ldr	r3, [r3, #12]
 80098ce:	60bb      	str	r3, [r7, #8]
			pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator );
 80098d0:	697b      	ldr	r3, [r7, #20]
 80098d2:	685b      	ldr	r3, [r3, #4]
 80098d4:	617b      	str	r3, [r7, #20]

			/* Sockets with 'tmout == 0' do not need any regular attention. */
			if( pxSocket->u.xTCP.usTimeout == 0u )
 80098d6:	68bb      	ldr	r3, [r7, #8]
 80098d8:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 80098dc:	2b00      	cmp	r3, #0
 80098de:	d100      	bne.n	80098e2 <xTCPTimerCheck+0x52>
			{
				continue;
 80098e0:	e039      	b.n	8009956 <xTCPTimerCheck+0xc6>
			}

			if( xDelta < ( TickType_t ) pxSocket->u.xTCP.usTimeout )
 80098e2:	68bb      	ldr	r3, [r7, #8]
 80098e4:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 80098e8:	461a      	mov	r2, r3
 80098ea:	69bb      	ldr	r3, [r7, #24]
 80098ec:	429a      	cmp	r2, r3
 80098ee:	d90a      	bls.n	8009906 <xTCPTimerCheck+0x76>
			{
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) ( ( ( TickType_t ) pxSocket->u.xTCP.usTimeout ) - xDelta );
 80098f0:	68bb      	ldr	r3, [r7, #8]
 80098f2:	f8b3 2048 	ldrh.w	r2, [r3, #72]	; 0x48
 80098f6:	69bb      	ldr	r3, [r7, #24]
 80098f8:	b29b      	uxth	r3, r3
 80098fa:	1ad3      	subs	r3, r2, r3
 80098fc:	b29a      	uxth	r2, r3
 80098fe:	68bb      	ldr	r3, [r7, #8]
 8009900:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
 8009904:	e00a      	b.n	800991c <xTCPTimerCheck+0x8c>
			}
			else
			{
				pxSocket->u.xTCP.usTimeout = 0u;
 8009906:	68bb      	ldr	r3, [r7, #8]
 8009908:	2200      	movs	r2, #0
 800990a:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48

				/* Within this function, the socket might want to send a delayed
				ack or send out data or whatever it needs to do. */
				if( xTCPSocketCheck( pxSocket ) < 0 )
 800990e:	68b8      	ldr	r0, [r7, #8]
 8009910:	f000 fe68 	bl	800a5e4 <xTCPSocketCheck>
 8009914:	4603      	mov	r3, r0
 8009916:	2b00      	cmp	r3, #0
 8009918:	da00      	bge.n	800991c <xTCPTimerCheck+0x8c>
				{
					/* Continue because the socket was deleted. */
					continue;
 800991a:	e01c      	b.n	8009956 <xTCPTimerCheck+0xc6>
			}

			/* In xEventBits the driver may indicate that the socket has
			important events for the user.  These are only done just before the
			IP-task goes to sleep. */
			if( pxSocket->xEventBits != 0u )
 800991c:	68bb      	ldr	r3, [r7, #8]
 800991e:	681b      	ldr	r3, [r3, #0]
 8009920:	2b00      	cmp	r3, #0
 8009922:	d008      	beq.n	8009936 <xTCPTimerCheck+0xa6>
			{
				if( xWillSleep != pdFALSE )
 8009924:	687b      	ldr	r3, [r7, #4]
 8009926:	2b00      	cmp	r3, #0
 8009928:	d003      	beq.n	8009932 <xTCPTimerCheck+0xa2>
				{
					/* The IP-task is about to go to sleep, so messages can be
					sent to the socket owners. */
					vSocketWakeUpUser( pxSocket );
 800992a:	68b8      	ldr	r0, [r7, #8]
 800992c:	f7ff ff76 	bl	800981c <vSocketWakeUpUser>
 8009930:	e001      	b.n	8009936 <xTCPTimerCheck+0xa6>
				}
				else
				{
					/* Or else make sure this will be called again to wake-up
					the sockets' owner. */
					xShortest = ( TickType_t ) 0;
 8009932:	2300      	movs	r3, #0
 8009934:	61fb      	str	r3, [r7, #28]
				}
			}

			if( ( pxSocket->u.xTCP.usTimeout != 0u ) && ( xShortest > ( TickType_t ) pxSocket->u.xTCP.usTimeout ) )
 8009936:	68bb      	ldr	r3, [r7, #8]
 8009938:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 800993c:	2b00      	cmp	r3, #0
 800993e:	d00a      	beq.n	8009956 <xTCPTimerCheck+0xc6>
 8009940:	68bb      	ldr	r3, [r7, #8]
 8009942:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 8009946:	461a      	mov	r2, r3
 8009948:	69fb      	ldr	r3, [r7, #28]
 800994a:	429a      	cmp	r2, r3
 800994c:	d203      	bcs.n	8009956 <xTCPTimerCheck+0xc6>
			{
				xShortest = ( TickType_t ) pxSocket->u.xTCP.usTimeout;
 800994e:	68bb      	ldr	r3, [r7, #8]
 8009950:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 8009954:	61fb      	str	r3, [r7, #28]
		if( xDelta == 0u )
		{
			xDelta = 1u;
		}

		while( pxIterator != pxEnd )
 8009956:	697a      	ldr	r2, [r7, #20]
 8009958:	68fb      	ldr	r3, [r7, #12]
 800995a:	429a      	cmp	r2, r3
 800995c:	d1b5      	bne.n	80098ca <xTCPTimerCheck+0x3a>
			{
				xShortest = ( TickType_t ) pxSocket->u.xTCP.usTimeout;
			}
		}

		return xShortest;
 800995e:	69fb      	ldr	r3, [r7, #28]
	}
 8009960:	4618      	mov	r0, r3
 8009962:	3720      	adds	r7, #32
 8009964:	46bd      	mov	sp, r7
 8009966:	bd80      	pop	{r7, pc}
 8009968:	2000c294 	.word	0x2000c294
 800996c:	2000cf18 	.word	0x2000cf18
 8009970:	2000cf10 	.word	0x2000cf10

08009974 <pxTCPSocketLookup>:
	 * looking up a socket is a little more complex:
	 * Both a local port, and a remote port and IP address are being used
	 * For a socket in listening mode, the remote port and IP address are both 0
	 */
	FreeRTOS_Socket_t *pxTCPSocketLookup( uint32_t ulLocalIP, UBaseType_t uxLocalPort, uint32_t ulRemoteIP, UBaseType_t uxRemotePort )
	{
 8009974:	b480      	push	{r7}
 8009976:	b08b      	sub	sp, #44	; 0x2c
 8009978:	af00      	add	r7, sp, #0
 800997a:	60f8      	str	r0, [r7, #12]
 800997c:	60b9      	str	r1, [r7, #8]
 800997e:	607a      	str	r2, [r7, #4]
 8009980:	603b      	str	r3, [r7, #0]
	ListItem_t *pxIterator;
	FreeRTOS_Socket_t *pxResult = NULL, *pxListenSocket = NULL;
 8009982:	2300      	movs	r3, #0
 8009984:	623b      	str	r3, [r7, #32]
 8009986:	2300      	movs	r3, #0
 8009988:	61fb      	str	r3, [r7, #28]
	MiniListItem_t *pxEnd = ( MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
 800998a:	4b1c      	ldr	r3, [pc, #112]	; (80099fc <pxTCPSocketLookup+0x88>)
 800998c:	61bb      	str	r3, [r7, #24]

		/* Parameter not yet supported. */
		( void ) ulLocalIP;

		for( pxIterator  = ( ListItem_t * ) listGET_NEXT( pxEnd );
 800998e:	69bb      	ldr	r3, [r7, #24]
 8009990:	685b      	ldr	r3, [r3, #4]
 8009992:	627b      	str	r3, [r7, #36]	; 0x24
 8009994:	e021      	b.n	80099da <pxTCPSocketLookup+0x66>
			 pxIterator != ( ListItem_t * ) pxEnd;
			 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8009996:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009998:	68db      	ldr	r3, [r3, #12]
 800999a:	617b      	str	r3, [r7, #20]

			if( pxSocket->usLocalPort == ( uint16_t ) uxLocalPort )
 800999c:	697b      	ldr	r3, [r7, #20]
 800999e:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 80099a0:	68bb      	ldr	r3, [r7, #8]
 80099a2:	b29b      	uxth	r3, r3
 80099a4:	429a      	cmp	r2, r3
 80099a6:	d115      	bne.n	80099d4 <pxTCPSocketLookup+0x60>
			{
				if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN )
 80099a8:	697b      	ldr	r3, [r7, #20]
 80099aa:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 80099ae:	2b01      	cmp	r3, #1
 80099b0:	d102      	bne.n	80099b8 <pxTCPSocketLookup+0x44>
				{
					/* If this is a socket listening to uxLocalPort, remember it
					in case there is no perfect match. */
					pxListenSocket = pxSocket;
 80099b2:	697b      	ldr	r3, [r7, #20]
 80099b4:	61fb      	str	r3, [r7, #28]
 80099b6:	e00d      	b.n	80099d4 <pxTCPSocketLookup+0x60>
				}
				else if( ( pxSocket->u.xTCP.usRemotePort == ( uint16_t ) uxRemotePort ) && ( pxSocket->u.xTCP.ulRemoteIP == ulRemoteIP ) )
 80099b8:	697b      	ldr	r3, [r7, #20]
 80099ba:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
 80099bc:	683b      	ldr	r3, [r7, #0]
 80099be:	b29b      	uxth	r3, r3
 80099c0:	429a      	cmp	r2, r3
 80099c2:	d107      	bne.n	80099d4 <pxTCPSocketLookup+0x60>
 80099c4:	697b      	ldr	r3, [r7, #20]
 80099c6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80099c8:	687b      	ldr	r3, [r7, #4]
 80099ca:	429a      	cmp	r2, r3
 80099cc:	d102      	bne.n	80099d4 <pxTCPSocketLookup+0x60>
				{
					/* For sockets not in listening mode, find a match with
					xLocalPort, ulRemoteIP AND xRemotePort. */
					pxResult = pxSocket;
 80099ce:	697b      	ldr	r3, [r7, #20]
 80099d0:	623b      	str	r3, [r7, #32]
					break;
 80099d2:	e006      	b.n	80099e2 <pxTCPSocketLookup+0x6e>
		/* Parameter not yet supported. */
		( void ) ulLocalIP;

		for( pxIterator  = ( ListItem_t * ) listGET_NEXT( pxEnd );
			 pxIterator != ( ListItem_t * ) pxEnd;
			 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
 80099d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80099d6:	685b      	ldr	r3, [r3, #4]
 80099d8:	627b      	str	r3, [r7, #36]	; 0x24
	MiniListItem_t *pxEnd = ( MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );

		/* Parameter not yet supported. */
		( void ) ulLocalIP;

		for( pxIterator  = ( ListItem_t * ) listGET_NEXT( pxEnd );
 80099da:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80099dc:	69bb      	ldr	r3, [r7, #24]
 80099de:	429a      	cmp	r2, r3
 80099e0:	d1d9      	bne.n	8009996 <pxTCPSocketLookup+0x22>
					pxResult = pxSocket;
					break;
				}
			}
		}
		if( pxResult == NULL )
 80099e2:	6a3b      	ldr	r3, [r7, #32]
 80099e4:	2b00      	cmp	r3, #0
 80099e6:	d101      	bne.n	80099ec <pxTCPSocketLookup+0x78>
		{
			/* An exact match was not found, maybe a listening socket was
			found. */
			pxResult = pxListenSocket;
 80099e8:	69fb      	ldr	r3, [r7, #28]
 80099ea:	623b      	str	r3, [r7, #32]
		}

		return pxResult;
 80099ec:	6a3b      	ldr	r3, [r7, #32]
	}
 80099ee:	4618      	mov	r0, r3
 80099f0:	372c      	adds	r7, #44	; 0x2c
 80099f2:	46bd      	mov	sp, r7
 80099f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80099f8:	4770      	bx	lr
 80099fa:	bf00      	nop
 80099fc:	2000cf18 	.word	0x2000cf18

08009a00 <prvTCPCreateStream>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP == 1 )

	static StreamBuffer_t *prvTCPCreateStream ( FreeRTOS_Socket_t *pxSocket, BaseType_t xIsInputStream )
	{
 8009a00:	b580      	push	{r7, lr}
 8009a02:	b086      	sub	sp, #24
 8009a04:	af00      	add	r7, sp, #0
 8009a06:	6078      	str	r0, [r7, #4]
 8009a08:	6039      	str	r1, [r7, #0]
	size_t uxLength;
	size_t uxSize;

		/* Now that a stream is created, the maximum size is fixed before
		creation, it could still be changed with setsockopt(). */
		if( xIsInputStream != pdFALSE )
 8009a0a:	683b      	ldr	r3, [r7, #0]
 8009a0c:	2b00      	cmp	r3, #0
 8009a0e:	d01c      	beq.n	8009a4a <prvTCPCreateStream+0x4a>
		{
			uxLength = pxSocket->u.xTCP.uxRxStreamSize;
 8009a10:	687b      	ldr	r3, [r7, #4]
 8009a12:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009a14:	617b      	str	r3, [r7, #20]

			if( pxSocket->u.xTCP.uxLittleSpace == 0ul )
 8009a16:	687b      	ldr	r3, [r7, #4]
 8009a18:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8009a1a:	2b00      	cmp	r3, #0
 8009a1c:	d107      	bne.n	8009a2e <prvTCPCreateStream+0x2e>
			{
				pxSocket->u.xTCP.uxLittleSpace  = ( 1ul * pxSocket->u.xTCP.uxRxStreamSize ) / 5u; /*_RB_ Why divide by 5?  Can this be changed to a #define? */
 8009a1e:	687b      	ldr	r3, [r7, #4]
 8009a20:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009a22:	4a25      	ldr	r2, [pc, #148]	; (8009ab8 <prvTCPCreateStream+0xb8>)
 8009a24:	fba2 2303 	umull	r2, r3, r2, r3
 8009a28:	089a      	lsrs	r2, r3, #2
 8009a2a:	687b      	ldr	r3, [r7, #4]
 8009a2c:	665a      	str	r2, [r3, #100]	; 0x64
			}

			if( pxSocket->u.xTCP.uxEnoughSpace == 0ul )
 8009a2e:	687b      	ldr	r3, [r7, #4]
 8009a30:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 8009a32:	2b00      	cmp	r3, #0
 8009a34:	d10c      	bne.n	8009a50 <prvTCPCreateStream+0x50>
			{
				pxSocket->u.xTCP.uxEnoughSpace = ( 4ul * pxSocket->u.xTCP.uxRxStreamSize ) / 5u; /*_RB_ Why multiply by 4?  Maybe sock80_PERCENT?*/
 8009a36:	687b      	ldr	r3, [r7, #4]
 8009a38:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009a3a:	009b      	lsls	r3, r3, #2
 8009a3c:	4a1e      	ldr	r2, [pc, #120]	; (8009ab8 <prvTCPCreateStream+0xb8>)
 8009a3e:	fba2 2303 	umull	r2, r3, r2, r3
 8009a42:	089a      	lsrs	r2, r3, #2
 8009a44:	687b      	ldr	r3, [r7, #4]
 8009a46:	669a      	str	r2, [r3, #104]	; 0x68
 8009a48:	e002      	b.n	8009a50 <prvTCPCreateStream+0x50>
			}
		}
		else
		{
			uxLength = pxSocket->u.xTCP.uxTxStreamSize;
 8009a4a:	687b      	ldr	r3, [r7, #4]
 8009a4c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8009a4e:	617b      	str	r3, [r7, #20]
		}

		/* Add an extra 4 (or 8) bytes. */
		uxLength += sizeof( size_t );
 8009a50:	697b      	ldr	r3, [r7, #20]
 8009a52:	3304      	adds	r3, #4
 8009a54:	617b      	str	r3, [r7, #20]

		/* And make the length a multiple of sizeof( size_t ). */
		uxLength &= ~( sizeof( size_t ) - 1u );
 8009a56:	697b      	ldr	r3, [r7, #20]
 8009a58:	f023 0303 	bic.w	r3, r3, #3
 8009a5c:	617b      	str	r3, [r7, #20]

		uxSize = sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) + uxLength;
 8009a5e:	697b      	ldr	r3, [r7, #20]
 8009a60:	3314      	adds	r3, #20
 8009a62:	613b      	str	r3, [r7, #16]

		pxBuffer = ( StreamBuffer_t * )pvPortMallocLarge( uxSize );
 8009a64:	6938      	ldr	r0, [r7, #16]
 8009a66:	f7fa fb23 	bl	80040b0 <pvPortMalloc>
 8009a6a:	60f8      	str	r0, [r7, #12]

		if( pxBuffer == NULL )
 8009a6c:	68fb      	ldr	r3, [r7, #12]
 8009a6e:	2b00      	cmp	r3, #0
 8009a70:	d10b      	bne.n	8009a8a <prvTCPCreateStream+0x8a>
		{
			FreeRTOS_debug_printf( ( "prvTCPCreateStream: malloc failed\n" ) );
			pxSocket->u.xTCP.bits.bMallocError = pdTRUE_UNSIGNED;
 8009a72:	687a      	ldr	r2, [r7, #4]
 8009a74:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
 8009a78:	f043 0308 	orr.w	r3, r3, #8
 8009a7c:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 8009a80:	6878      	ldr	r0, [r7, #4]
 8009a82:	2108      	movs	r1, #8
 8009a84:	f001 fae8 	bl	800b058 <vTCPStateChange>
 8009a88:	e011      	b.n	8009aae <prvTCPCreateStream+0xae>
		}
		else
		{
			/* Clear the markers of the stream */
			memset( pxBuffer, '\0', sizeof( *pxBuffer ) - sizeof( pxBuffer->ucArray ) );
 8009a8a:	68f8      	ldr	r0, [r7, #12]
 8009a8c:	2100      	movs	r1, #0
 8009a8e:	2214      	movs	r2, #20
 8009a90:	f006 fc0a 	bl	80102a8 <memset>
			pxBuffer->LENGTH = ( size_t ) uxLength ;
 8009a94:	68fb      	ldr	r3, [r7, #12]
 8009a96:	697a      	ldr	r2, [r7, #20]
 8009a98:	611a      	str	r2, [r3, #16]
			if( xTCPWindowLoggingLevel != 0 )
			{
				FreeRTOS_debug_printf( ( "prvTCPCreateStream: %cxStream created %lu bytes (total %lu)\n", xIsInputStream ? 'R' : 'T', uxLength, uxSize ) );
			}

			if( xIsInputStream != 0 )
 8009a9a:	683b      	ldr	r3, [r7, #0]
 8009a9c:	2b00      	cmp	r3, #0
 8009a9e:	d003      	beq.n	8009aa8 <prvTCPCreateStream+0xa8>
			{
				pxSocket->u.xTCP.rxStream = pxBuffer;
 8009aa0:	687b      	ldr	r3, [r7, #4]
 8009aa2:	68fa      	ldr	r2, [r7, #12]
 8009aa4:	675a      	str	r2, [r3, #116]	; 0x74
 8009aa6:	e002      	b.n	8009aae <prvTCPCreateStream+0xae>
			}
			else
			{
				pxSocket->u.xTCP.txStream = pxBuffer;
 8009aa8:	687b      	ldr	r3, [r7, #4]
 8009aaa:	68fa      	ldr	r2, [r7, #12]
 8009aac:	679a      	str	r2, [r3, #120]	; 0x78
			}
		}

		return pxBuffer;
 8009aae:	68fb      	ldr	r3, [r7, #12]
	}
 8009ab0:	4618      	mov	r0, r3
 8009ab2:	3718      	adds	r7, #24
 8009ab4:	46bd      	mov	sp, r7
 8009ab6:	bd80      	pop	{r7, pc}
 8009ab8:	cccccccd 	.word	0xcccccccd

08009abc <lTCPAddRxdata>:
	/*
	 * Add data to the RxStream.  When uxOffset > 0, data has come in out-of-order
	 * and will be put in front of the head so it can not be popped by the user.
	 */
	int32_t lTCPAddRxdata( FreeRTOS_Socket_t *pxSocket, size_t uxOffset, const uint8_t *pcData, uint32_t ulByteCount )
	{
 8009abc:	b580      	push	{r7, lr}
 8009abe:	b088      	sub	sp, #32
 8009ac0:	af00      	add	r7, sp, #0
 8009ac2:	60f8      	str	r0, [r7, #12]
 8009ac4:	60b9      	str	r1, [r7, #8]
 8009ac6:	607a      	str	r2, [r7, #4]
 8009ac8:	603b      	str	r3, [r7, #0]
	StreamBuffer_t *pxStream = pxSocket->u.xTCP.rxStream;
 8009aca:	68fb      	ldr	r3, [r7, #12]
 8009acc:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009ace:	61fb      	str	r3, [r7, #28]
		/* int32_t uxStreamBufferAdd( pxBuffer, uxOffset, pucData, aCount )
		if( pucData != NULL ) copy data the the buffer
		if( pucData == NULL ) no copying, just advance rxHead
		if( uxOffset != 0 ) Just store data which has come out-of-order
		if( uxOffset == 0 ) Also advance rxHead */
		if( pxStream == NULL )
 8009ad0:	69fb      	ldr	r3, [r7, #28]
 8009ad2:	2b00      	cmp	r3, #0
 8009ad4:	d10a      	bne.n	8009aec <lTCPAddRxdata+0x30>
		{
			pxStream = prvTCPCreateStream( pxSocket, pdTRUE );
 8009ad6:	68f8      	ldr	r0, [r7, #12]
 8009ad8:	2101      	movs	r1, #1
 8009ada:	f7ff ff91 	bl	8009a00 <prvTCPCreateStream>
 8009ade:	61f8      	str	r0, [r7, #28]
			if( pxStream == NULL )
 8009ae0:	69fb      	ldr	r3, [r7, #28]
 8009ae2:	2b00      	cmp	r3, #0
 8009ae4:	d102      	bne.n	8009aec <lTCPAddRxdata+0x30>
			{
				return -1;
 8009ae6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8009aea:	e045      	b.n	8009b78 <lTCPAddRxdata+0xbc>
				pcData = NULL;
			}
		}
		#endif /* ipconfigUSE_CALLBACKS */

		xResult = ( int32_t ) uxStreamBufferAdd( pxStream, uxOffset, pcData, ( size_t ) ulByteCount );
 8009aec:	69f8      	ldr	r0, [r7, #28]
 8009aee:	68b9      	ldr	r1, [r7, #8]
 8009af0:	687a      	ldr	r2, [r7, #4]
 8009af2:	683b      	ldr	r3, [r7, #0]
 8009af4:	f003 ff14 	bl	800d920 <uxStreamBufferAdd>
 8009af8:	4603      	mov	r3, r0
 8009afa:	61bb      	str	r3, [r7, #24]
					pxStream->uxFront ) );
			}
		}
		#endif /* ipconfigHAS_DEBUG_PRINTF */

		if( uxOffset == 0u )
 8009afc:	68bb      	ldr	r3, [r7, #8]
 8009afe:	2b00      	cmp	r3, #0
 8009b00:	d139      	bne.n	8009b76 <lTCPAddRxdata+0xba>
					}
				} else
			#endif /* ipconfigUSE_CALLBACKS */
			{
				/* See if running out of space. */
				if( pxSocket->u.xTCP.bits.bLowWater == pdFALSE_UNSIGNED )
 8009b02:	68fb      	ldr	r3, [r7, #12]
 8009b04:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8009b08:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8009b0c:	b2db      	uxtb	r3, r3
 8009b0e:	2b00      	cmp	r3, #0
 8009b10:	d11f      	bne.n	8009b52 <lTCPAddRxdata+0x96>
				{
					size_t uxFrontSpace = uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 8009b12:	68fb      	ldr	r3, [r7, #12]
 8009b14:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009b16:	4618      	mov	r0, r3
 8009b18:	f7ff f898 	bl	8008c4c <uxStreamBufferFrontSpace>
 8009b1c:	6178      	str	r0, [r7, #20]
					if( uxFrontSpace <= pxSocket->u.xTCP.uxLittleSpace  )
 8009b1e:	68fb      	ldr	r3, [r7, #12]
 8009b20:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8009b22:	697b      	ldr	r3, [r7, #20]
 8009b24:	429a      	cmp	r2, r3
 8009b26:	d314      	bcc.n	8009b52 <lTCPAddRxdata+0x96>
					{
						pxSocket->u.xTCP.bits.bLowWater = pdTRUE_UNSIGNED;
 8009b28:	68fa      	ldr	r2, [r7, #12]
 8009b2a:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 8009b2e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009b32:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
						pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 8009b36:	68fa      	ldr	r2, [r7, #12]
 8009b38:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8009b3c:	f043 0301 	orr.w	r3, r3, #1
 8009b40:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41

						/* bLowWater was reached, send the changed window size. */
						pxSocket->u.xTCP.usTimeout = 1u;
 8009b44:	68fb      	ldr	r3, [r7, #12]
 8009b46:	2201      	movs	r2, #1
 8009b48:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
						xSendEventToIPTask( eTCPTimerEvent );
 8009b4c:	2005      	movs	r0, #5
 8009b4e:	f7fe fa19 	bl	8007f84 <xSendEventToIPTask>
					}
				}

				/* New incoming data is available, wake up the user.   User's
				semaphores will be set just before the IP-task goes asleep. */
				pxSocket->xEventBits |= eSOCKET_RECEIVE;
 8009b52:	68fb      	ldr	r3, [r7, #12]
 8009b54:	681b      	ldr	r3, [r3, #0]
 8009b56:	f043 0201 	orr.w	r2, r3, #1
 8009b5a:	68fb      	ldr	r3, [r7, #12]
 8009b5c:	601a      	str	r2, [r3, #0]

				#if ipconfigSUPPORT_SELECT_FUNCTION == 1
				{
					if( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 )
 8009b5e:	68fb      	ldr	r3, [r7, #12]
 8009b60:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009b62:	f003 0301 	and.w	r3, r3, #1
 8009b66:	2b00      	cmp	r3, #0
 8009b68:	d005      	beq.n	8009b76 <lTCPAddRxdata+0xba>
					{
						pxSocket->xEventBits |= ( eSELECT_READ << SOCKET_EVENT_BIT_COUNT );
 8009b6a:	68fb      	ldr	r3, [r7, #12]
 8009b6c:	681b      	ldr	r3, [r3, #0]
 8009b6e:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 8009b72:	68fb      	ldr	r3, [r7, #12]
 8009b74:	601a      	str	r2, [r3, #0]
				}
				#endif
			}
		}

		return xResult;
 8009b76:	69bb      	ldr	r3, [r7, #24]
	}
 8009b78:	4618      	mov	r0, r3
 8009b7a:	3720      	adds	r7, #32
 8009b7c:	46bd      	mov	sp, r7
 8009b7e:	bd80      	pop	{r7, pc}

08009b80 <FreeRTOS_tx_space>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP ==1 )

	BaseType_t FreeRTOS_tx_space( Socket_t xSocket )
	{
 8009b80:	b580      	push	{r7, lr}
 8009b82:	b084      	sub	sp, #16
 8009b84:	af00      	add	r7, sp, #0
 8009b86:	6078      	str	r0, [r7, #4]
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 8009b88:	687b      	ldr	r3, [r7, #4]
 8009b8a:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8009b8c:	68bb      	ldr	r3, [r7, #8]
 8009b8e:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8009b92:	2b06      	cmp	r3, #6
 8009b94:	d003      	beq.n	8009b9e <FreeRTOS_tx_space+0x1e>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009b96:	f06f 0315 	mvn.w	r3, #21
 8009b9a:	60fb      	str	r3, [r7, #12]
 8009b9c:	e00e      	b.n	8009bbc <FreeRTOS_tx_space+0x3c>
		}
		else
		{
			if( pxSocket->u.xTCP.txStream != NULL )
 8009b9e:	68bb      	ldr	r3, [r7, #8]
 8009ba0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8009ba2:	2b00      	cmp	r3, #0
 8009ba4:	d007      	beq.n	8009bb6 <FreeRTOS_tx_space+0x36>
			{
				xReturn = ( BaseType_t ) uxStreamBufferGetSpace ( pxSocket->u.xTCP.txStream );
 8009ba6:	68bb      	ldr	r3, [r7, #8]
 8009ba8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8009baa:	4618      	mov	r0, r3
 8009bac:	f7ff f83a 	bl	8008c24 <uxStreamBufferGetSpace>
 8009bb0:	4603      	mov	r3, r0
 8009bb2:	60fb      	str	r3, [r7, #12]
 8009bb4:	e002      	b.n	8009bbc <FreeRTOS_tx_space+0x3c>
			}
			else
			{
				xReturn = ( BaseType_t ) pxSocket->u.xTCP.uxTxStreamSize;
 8009bb6:	68bb      	ldr	r3, [r7, #8]
 8009bb8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8009bba:	60fb      	str	r3, [r7, #12]
			}
		}

		return xReturn;
 8009bbc:	68fb      	ldr	r3, [r7, #12]
	}
 8009bbe:	4618      	mov	r0, r3
 8009bc0:	3710      	adds	r7, #16
 8009bc2:	46bd      	mov	sp, r7
 8009bc4:	bd80      	pop	{r7, pc}
 8009bc6:	bf00      	nop

08009bc8 <FreeRTOS_tx_size>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP == 1 )

	BaseType_t FreeRTOS_tx_size( Socket_t xSocket )
	{
 8009bc8:	b580      	push	{r7, lr}
 8009bca:	b084      	sub	sp, #16
 8009bcc:	af00      	add	r7, sp, #0
 8009bce:	6078      	str	r0, [r7, #4]
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 8009bd0:	687b      	ldr	r3, [r7, #4]
 8009bd2:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8009bd4:	68bb      	ldr	r3, [r7, #8]
 8009bd6:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8009bda:	2b06      	cmp	r3, #6
 8009bdc:	d003      	beq.n	8009be6 <FreeRTOS_tx_size+0x1e>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009bde:	f06f 0315 	mvn.w	r3, #21
 8009be2:	60fb      	str	r3, [r7, #12]
 8009be4:	e00d      	b.n	8009c02 <FreeRTOS_tx_size+0x3a>
		}
		else
		{
			if( pxSocket->u.xTCP.txStream != NULL )
 8009be6:	68bb      	ldr	r3, [r7, #8]
 8009be8:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8009bea:	2b00      	cmp	r3, #0
 8009bec:	d007      	beq.n	8009bfe <FreeRTOS_tx_size+0x36>
			{
				xReturn = ( BaseType_t ) uxStreamBufferGetSize ( pxSocket->u.xTCP.txStream );
 8009bee:	68bb      	ldr	r3, [r7, #8]
 8009bf0:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8009bf2:	4618      	mov	r0, r3
 8009bf4:	f7ff f83e 	bl	8008c74 <uxStreamBufferGetSize>
 8009bf8:	4603      	mov	r3, r0
 8009bfa:	60fb      	str	r3, [r7, #12]
 8009bfc:	e001      	b.n	8009c02 <FreeRTOS_tx_size+0x3a>
			}
			else
			{
				xReturn = 0;
 8009bfe:	2300      	movs	r3, #0
 8009c00:	60fb      	str	r3, [r7, #12]
			}
		}

		return xReturn;
 8009c02:	68fb      	ldr	r3, [r7, #12]
	}
 8009c04:	4618      	mov	r0, r3
 8009c06:	3710      	adds	r7, #16
 8009c08:	46bd      	mov	sp, r7
 8009c0a:	bd80      	pop	{r7, pc}

08009c0c <FreeRTOS_rx_size>:

	/*
	 * Returns the number of bytes which can be read.
	 */
	BaseType_t FreeRTOS_rx_size( Socket_t xSocket )
	{
 8009c0c:	b580      	push	{r7, lr}
 8009c0e:	b084      	sub	sp, #16
 8009c10:	af00      	add	r7, sp, #0
 8009c12:	6078      	str	r0, [r7, #4]
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 8009c14:	687b      	ldr	r3, [r7, #4]
 8009c16:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn;

		if( pxSocket->ucProtocol != ( uint8_t ) FREERTOS_IPPROTO_TCP )
 8009c18:	68bb      	ldr	r3, [r7, #8]
 8009c1a:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8009c1e:	2b06      	cmp	r3, #6
 8009c20:	d003      	beq.n	8009c2a <FreeRTOS_rx_size+0x1e>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 8009c22:	f06f 0315 	mvn.w	r3, #21
 8009c26:	60fb      	str	r3, [r7, #12]
 8009c28:	e00d      	b.n	8009c46 <FreeRTOS_rx_size+0x3a>
		}
		else if( pxSocket->u.xTCP.rxStream != NULL )
 8009c2a:	68bb      	ldr	r3, [r7, #8]
 8009c2c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009c2e:	2b00      	cmp	r3, #0
 8009c30:	d007      	beq.n	8009c42 <FreeRTOS_rx_size+0x36>
		{
			xReturn = ( BaseType_t ) uxStreamBufferGetSize( pxSocket->u.xTCP.rxStream );
 8009c32:	68bb      	ldr	r3, [r7, #8]
 8009c34:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009c36:	4618      	mov	r0, r3
 8009c38:	f7ff f81c 	bl	8008c74 <uxStreamBufferGetSize>
 8009c3c:	4603      	mov	r3, r0
 8009c3e:	60fb      	str	r3, [r7, #12]
 8009c40:	e001      	b.n	8009c46 <FreeRTOS_rx_size+0x3a>
		}
		else
		{
			xReturn = 0;
 8009c42:	2300      	movs	r3, #0
 8009c44:	60fb      	str	r3, [r7, #12]
		}

		return xReturn;
 8009c46:	68fb      	ldr	r3, [r7, #12]
	}
 8009c48:	4618      	mov	r0, r3
 8009c4a:	3710      	adds	r7, #16
 8009c4c:	46bd      	mov	sp, r7
 8009c4e:	bd80      	pop	{r7, pc}

08009c50 <vTCPNetStat>:
/*-----------------------------------------------------------*/

#if( ( ipconfigHAS_PRINTF != 0 ) && ( ipconfigUSE_TCP == 1 ) )

	void vTCPNetStat( void )
	{
 8009c50:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8009c54:	b091      	sub	sp, #68	; 0x44
 8009c56:	af06      	add	r7, sp, #24
	/* Show a simple listing of all created sockets and their connections */
	ListItem_t *pxIterator;
	BaseType_t count = 0;
 8009c58:	2300      	movs	r3, #0
 8009c5a:	623b      	str	r3, [r7, #32]

		if( listLIST_IS_INITIALISED( &xBoundTCPSocketsList ) == pdFALSE )
 8009c5c:	4b56      	ldr	r3, [pc, #344]	; (8009db8 <vTCPNetStat+0x168>)
 8009c5e:	689b      	ldr	r3, [r3, #8]
 8009c60:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 8009c64:	d003      	beq.n	8009c6e <vTCPNetStat+0x1e>
		{
			FreeRTOS_printf( ( "PLUS-TCP not initialized\n" ) );
 8009c66:	4855      	ldr	r0, [pc, #340]	; (8009dbc <vTCPNetStat+0x16c>)
 8009c68:	f005 f93e 	bl	800eee8 <lUDPLoggingPrintf>
 8009c6c:	e0a0      	b.n	8009db0 <vTCPNetStat+0x160>
		}
		else
		{
			FreeRTOS_printf( ( "Prot Port IP-Remote       : Port  R/T Status       Alive  tmout Child\n" ) );
 8009c6e:	4854      	ldr	r0, [pc, #336]	; (8009dc0 <vTCPNetStat+0x170>)
 8009c70:	f005 f93a 	bl	800eee8 <lUDPLoggingPrintf>
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8009c74:	4b50      	ldr	r3, [pc, #320]	; (8009db8 <vTCPNetStat+0x168>)
 8009c76:	68db      	ldr	r3, [r3, #12]
 8009c78:	627b      	str	r3, [r7, #36]	; 0x24
 8009c7a:	e06a      	b.n	8009d52 <vTCPNetStat+0x102>
				 pxIterator != ( ListItem_t * ) listGET_END_MARKER( &xBoundTCPSocketsList );
				 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
			{
				FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8009c7c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009c7e:	68db      	ldr	r3, [r3, #12]
 8009c80:	61bb      	str	r3, [r7, #24]
				#if( ipconfigTCP_KEEP_ALIVE == 1 )
					TickType_t age = xTaskGetTickCount() - pxSocket->u.xTCP.xLastAliveTime;
 8009c82:	f7fb fc7f 	bl	8005584 <xTaskGetTickCount>
 8009c86:	4602      	mov	r2, r0
 8009c88:	69bb      	ldr	r3, [r7, #24]
 8009c8a:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8009c8c:	1ad3      	subs	r3, r2, r3
 8009c8e:	61fb      	str	r3, [r7, #28]
					TickType_t age = 0u;
				#endif
				#if( ipconfigUSE_CALLBACKS == 1 )
					void *pxHandleReceive = (void*)pxSocket->u.xTCP.pxHandleReceive;
				#else
					void *pxHandleReceive = (void*)NULL;
 8009c90:	2300      	movs	r3, #0
 8009c92:	617b      	str	r3, [r7, #20]
				#endif
				char ucChildText[16] = "";
 8009c94:	2300      	movs	r3, #0
 8009c96:	607b      	str	r3, [r7, #4]
 8009c98:	f107 0308 	add.w	r3, r7, #8
 8009c9c:	2200      	movs	r2, #0
 8009c9e:	601a      	str	r2, [r3, #0]
 8009ca0:	3304      	adds	r3, #4
 8009ca2:	2200      	movs	r2, #0
 8009ca4:	601a      	str	r2, [r3, #0]
 8009ca6:	3304      	adds	r3, #4
 8009ca8:	2200      	movs	r2, #0
 8009caa:	601a      	str	r2, [r3, #0]
 8009cac:	3304      	adds	r3, #4
				if (pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN)
 8009cae:	69bb      	ldr	r3, [r7, #24]
 8009cb0:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 8009cb4:	2b01      	cmp	r3, #1
 8009cb6:	d10f      	bne.n	8009cd8 <vTCPNetStat+0x88>
				{
					snprintf( ucChildText, sizeof( ucChildText ), " %d/%d",
						pxSocket->u.xTCP.usChildCount,
 8009cb8:	69bb      	ldr	r3, [r7, #24]
 8009cba:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
					void *pxHandleReceive = (void*)NULL;
				#endif
				char ucChildText[16] = "";
				if (pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN)
				{
					snprintf( ucChildText, sizeof( ucChildText ), " %d/%d",
 8009cbe:	461c      	mov	r4, r3
						pxSocket->u.xTCP.usChildCount,
						pxSocket->u.xTCP.usBacklog);
 8009cc0:	69bb      	ldr	r3, [r7, #24]
 8009cc2:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
					void *pxHandleReceive = (void*)NULL;
				#endif
				char ucChildText[16] = "";
				if (pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN)
				{
					snprintf( ucChildText, sizeof( ucChildText ), " %d/%d",
 8009cc6:	461a      	mov	r2, r3
 8009cc8:	1d3b      	adds	r3, r7, #4
 8009cca:	9200      	str	r2, [sp, #0]
 8009ccc:	4618      	mov	r0, r3
 8009cce:	2110      	movs	r1, #16
 8009cd0:	4a3c      	ldr	r2, [pc, #240]	; (8009dc4 <vTCPNetStat+0x174>)
 8009cd2:	4623      	mov	r3, r4
 8009cd4:	f004 ff26 	bl	800eb24 <snprintf>
						pxSocket->u.xTCP.usChildCount,
						pxSocket->u.xTCP.usBacklog);
				}
				if( age > 999999 )
 8009cd8:	69fb      	ldr	r3, [r7, #28]
 8009cda:	4a3b      	ldr	r2, [pc, #236]	; (8009dc8 <vTCPNetStat+0x178>)
 8009cdc:	4293      	cmp	r3, r2
 8009cde:	d901      	bls.n	8009ce4 <vTCPNetStat+0x94>
					age = 999999;
 8009ce0:	4b39      	ldr	r3, [pc, #228]	; (8009dc8 <vTCPNetStat+0x178>)
 8009ce2:	61fb      	str	r3, [r7, #28]
				FreeRTOS_printf( ( "TCP %5d %-16lxip:%5d %d/%d %-13.13s %6lu %6u%s\n",
 8009ce4:	69bb      	ldr	r3, [r7, #24]
 8009ce6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8009ce8:	4699      	mov	r9, r3
 8009cea:	69bb      	ldr	r3, [r7, #24]
 8009cec:	6b9c      	ldr	r4, [r3, #56]	; 0x38
 8009cee:	69bb      	ldr	r3, [r7, #24]
 8009cf0:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 8009cf2:	4698      	mov	r8, r3
 8009cf4:	69bb      	ldr	r3, [r7, #24]
 8009cf6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8009cf8:	2b00      	cmp	r3, #0
 8009cfa:	bf14      	ite	ne
 8009cfc:	2301      	movne	r3, #1
 8009cfe:	2300      	moveq	r3, #0
 8009d00:	b2db      	uxtb	r3, r3
 8009d02:	461e      	mov	r6, r3
 8009d04:	69bb      	ldr	r3, [r7, #24]
 8009d06:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8009d08:	2b00      	cmp	r3, #0
 8009d0a:	bf14      	ite	ne
 8009d0c:	2301      	movne	r3, #1
 8009d0e:	2300      	moveq	r3, #0
 8009d10:	b2db      	uxtb	r3, r3
 8009d12:	461d      	mov	r5, r3
 8009d14:	69bb      	ldr	r3, [r7, #24]
 8009d16:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 8009d1a:	4618      	mov	r0, r3
 8009d1c:	f002 fd40 	bl	800c7a0 <FreeRTOS_GetTCPStateName>
 8009d20:	4601      	mov	r1, r0
 8009d22:	69bb      	ldr	r3, [r7, #24]
 8009d24:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 8009d28:	461a      	mov	r2, r3
 8009d2a:	9600      	str	r6, [sp, #0]
 8009d2c:	9501      	str	r5, [sp, #4]
 8009d2e:	9102      	str	r1, [sp, #8]
 8009d30:	69fb      	ldr	r3, [r7, #28]
 8009d32:	9303      	str	r3, [sp, #12]
 8009d34:	9204      	str	r2, [sp, #16]
 8009d36:	1d3b      	adds	r3, r7, #4
 8009d38:	9305      	str	r3, [sp, #20]
 8009d3a:	4824      	ldr	r0, [pc, #144]	; (8009dcc <vTCPNetStat+0x17c>)
 8009d3c:	4649      	mov	r1, r9
 8009d3e:	4622      	mov	r2, r4
 8009d40:	4643      	mov	r3, r8
 8009d42:	f005 f8d1 	bl	800eee8 <lUDPLoggingPrintf>
					age,
					pxSocket->u.xTCP.usTimeout,
					ucChildText ) );
					/* Remove compiler warnings if FreeRTOS_debug_printf() is not defined. */
					( void ) pxHandleReceive;
				count++;
 8009d46:	6a3b      	ldr	r3, [r7, #32]
 8009d48:	3301      	adds	r3, #1
 8009d4a:	623b      	str	r3, [r7, #32]
		else
		{
			FreeRTOS_printf( ( "Prot Port IP-Remote       : Port  R/T Status       Alive  tmout Child\n" ) );
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
				 pxIterator != ( ListItem_t * ) listGET_END_MARKER( &xBoundTCPSocketsList );
				 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
 8009d4c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009d4e:	685b      	ldr	r3, [r3, #4]
 8009d50:	627b      	str	r3, [r7, #36]	; 0x24
			FreeRTOS_printf( ( "PLUS-TCP not initialized\n" ) );
		}
		else
		{
			FreeRTOS_printf( ( "Prot Port IP-Remote       : Port  R/T Status       Alive  tmout Child\n" ) );
			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 8009d52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009d54:	4a1e      	ldr	r2, [pc, #120]	; (8009dd0 <vTCPNetStat+0x180>)
 8009d56:	4293      	cmp	r3, r2
 8009d58:	d190      	bne.n	8009c7c <vTCPNetStat+0x2c>
					/* Remove compiler warnings if FreeRTOS_debug_printf() is not defined. */
					( void ) pxHandleReceive;
				count++;
			}

			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
 8009d5a:	4b1e      	ldr	r3, [pc, #120]	; (8009dd4 <vTCPNetStat+0x184>)
 8009d5c:	68db      	ldr	r3, [r3, #12]
 8009d5e:	627b      	str	r3, [r7, #36]	; 0x24
 8009d60:	e014      	b.n	8009d8c <vTCPNetStat+0x13c>
				 pxIterator != ( ListItem_t * ) listGET_END_MARKER( &xBoundUDPSocketsList );
				 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
			{
				/* Local port on this machine */
				FreeRTOS_printf( ( "UDP Port %5u\n",
 8009d62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009d64:	681b      	ldr	r3, [r3, #0]
 8009d66:	b29b      	uxth	r3, r3
 8009d68:	021b      	lsls	r3, r3, #8
 8009d6a:	b29a      	uxth	r2, r3
 8009d6c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009d6e:	681b      	ldr	r3, [r3, #0]
 8009d70:	0a1b      	lsrs	r3, r3, #8
 8009d72:	b29b      	uxth	r3, r3
 8009d74:	4313      	orrs	r3, r2
 8009d76:	b29b      	uxth	r3, r3
 8009d78:	4817      	ldr	r0, [pc, #92]	; (8009dd8 <vTCPNetStat+0x188>)
 8009d7a:	4619      	mov	r1, r3
 8009d7c:	f005 f8b4 	bl	800eee8 <lUDPLoggingPrintf>
					FreeRTOS_ntohs( listGET_LIST_ITEM_VALUE( pxIterator ) ) ) );
				count++;
 8009d80:	6a3b      	ldr	r3, [r7, #32]
 8009d82:	3301      	adds	r3, #1
 8009d84:	623b      	str	r3, [r7, #32]
				count++;
			}

			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
				 pxIterator != ( ListItem_t * ) listGET_END_MARKER( &xBoundUDPSocketsList );
				 pxIterator  = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
 8009d86:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009d88:	685b      	ldr	r3, [r3, #4]
 8009d8a:	627b      	str	r3, [r7, #36]	; 0x24
					/* Remove compiler warnings if FreeRTOS_debug_printf() is not defined. */
					( void ) pxHandleReceive;
				count++;
			}

			for( pxIterator  = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundUDPSocketsList );
 8009d8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009d8e:	4a13      	ldr	r2, [pc, #76]	; (8009ddc <vTCPNetStat+0x18c>)
 8009d90:	4293      	cmp	r3, r2
 8009d92:	d1e6      	bne.n	8009d62 <vTCPNetStat+0x112>
				FreeRTOS_printf( ( "UDP Port %5u\n",
					FreeRTOS_ntohs( listGET_LIST_ITEM_VALUE( pxIterator ) ) ) );
				count++;
			}

			FreeRTOS_printf( ( "FreeRTOS_netstat: %lu sockets %lu < %lu < %d buffers free\n",
 8009d94:	f7fd fd62 	bl	800785c <uxGetMinimumFreeNetworkBuffers>
 8009d98:	4605      	mov	r5, r0
 8009d9a:	f7fd fd53 	bl	8007844 <uxGetNumberOfFreeNetworkBuffers>
 8009d9e:	4604      	mov	r4, r0
 8009da0:	231f      	movs	r3, #31
 8009da2:	9300      	str	r3, [sp, #0]
 8009da4:	480e      	ldr	r0, [pc, #56]	; (8009de0 <vTCPNetStat+0x190>)
 8009da6:	6a39      	ldr	r1, [r7, #32]
 8009da8:	462a      	mov	r2, r5
 8009daa:	4623      	mov	r3, r4
 8009dac:	f005 f89c 	bl	800eee8 <lUDPLoggingPrintf>
				count,
				uxGetMinimumFreeNetworkBuffers( ),
				uxGetNumberOfFreeNetworkBuffers( ),
				ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ) );
		}
	}
 8009db0:	372c      	adds	r7, #44	; 0x2c
 8009db2:	46bd      	mov	sp, r7
 8009db4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8009db8:	2000cf10 	.word	0x2000cf10
 8009dbc:	0801263c 	.word	0x0801263c
 8009dc0:	08012658 	.word	0x08012658
 8009dc4:	080126a0 	.word	0x080126a0
 8009dc8:	000f423f 	.word	0x000f423f
 8009dcc:	080126a8 	.word	0x080126a8
 8009dd0:	2000cf18 	.word	0x2000cf18
 8009dd4:	2000cf24 	.word	0x2000cf24
 8009dd8:	080126d8 	.word	0x080126d8
 8009ddc:	2000cf2c 	.word	0x2000cf2c
 8009de0:	080126e8 	.word	0x080126e8

08009de4 <vSocketSelect>:
/*-----------------------------------------------------------*/

#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )

	void vSocketSelect( SocketSelect_t *pxSocketSet )
	{
 8009de4:	b580      	push	{r7, lr}
 8009de6:	b08c      	sub	sp, #48	; 0x30
 8009de8:	af00      	add	r7, sp, #0
 8009dea:	6078      	str	r0, [r7, #4]
	BaseType_t xRound;
	EventBits_t xSocketBits, xBitsToClear;
	#if ipconfigUSE_TCP == 1
		BaseType_t xLastRound = 1;
 8009dec:	2301      	movs	r3, #1
 8009dee:	613b      	str	r3, [r7, #16]
	#else
		BaseType_t xLastRound = 0;
	#endif

		/* These flags will be switched on after checking the socket status. */
		EventBits_t xGroupBits = 0;
 8009df0:	2300      	movs	r3, #0
 8009df2:	627b      	str	r3, [r7, #36]	; 0x24
		pxSocketSet->pxSocket = NULL;
 8009df4:	687b      	ldr	r3, [r7, #4]
 8009df6:	2200      	movs	r2, #0
 8009df8:	609a      	str	r2, [r3, #8]

		for( xRound = 0; xRound <= xLastRound; xRound++ )
 8009dfa:	2300      	movs	r3, #0
 8009dfc:	62fb      	str	r3, [r7, #44]	; 0x2c
 8009dfe:	e0cb      	b.n	8009f98 <vSocketSelect+0x1b4>
		{
			const ListItem_t *pxIterator;
			const MiniListItem_t *pxEnd;
			if( xRound == 0 )
 8009e00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009e02:	2b00      	cmp	r3, #0
 8009e04:	d102      	bne.n	8009e0c <vSocketSelect+0x28>
			{
				pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundUDPSocketsList );
 8009e06:	4b7a      	ldr	r3, [pc, #488]	; (8009ff0 <vSocketSelect+0x20c>)
 8009e08:	61fb      	str	r3, [r7, #28]
 8009e0a:	e001      	b.n	8009e10 <vSocketSelect+0x2c>
			}
		#if ipconfigUSE_TCP == 1
			else
			{
				pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
 8009e0c:	4b79      	ldr	r3, [pc, #484]	; (8009ff4 <vSocketSelect+0x210>)
 8009e0e:	61fb      	str	r3, [r7, #28]
			}
		#endif /* ipconfigUSE_TCP == 1 */
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
 8009e10:	69fb      	ldr	r3, [r7, #28]
 8009e12:	685b      	ldr	r3, [r3, #4]
 8009e14:	623b      	str	r3, [r7, #32]
 8009e16:	e0b7      	b.n	8009f88 <vSocketSelect+0x1a4>
				 pxIterator != ( const ListItem_t * ) pxEnd;
				 pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
			{
				FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 8009e18:	6a3b      	ldr	r3, [r7, #32]
 8009e1a:	68db      	ldr	r3, [r3, #12]
 8009e1c:	60fb      	str	r3, [r7, #12]
				if( pxSocket->pxSocketSet != pxSocketSet )
 8009e1e:	68fb      	ldr	r3, [r7, #12]
 8009e20:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8009e22:	687b      	ldr	r3, [r7, #4]
 8009e24:	429a      	cmp	r2, r3
 8009e26:	d000      	beq.n	8009e2a <vSocketSelect+0x46>
				{
					/* Socket does not belong to this select group. */
					continue;
 8009e28:	e0ab      	b.n	8009f82 <vSocketSelect+0x19e>
				}
				xSocketBits = 0;
 8009e2a:	2300      	movs	r3, #0
 8009e2c:	62bb      	str	r3, [r7, #40]	; 0x28

				#if( ipconfigUSE_TCP == 1 )
					if( pxSocket->ucProtocol == FREERTOS_IPPROTO_TCP )
 8009e2e:	68fb      	ldr	r3, [r7, #12]
 8009e30:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 8009e34:	2b06      	cmp	r3, #6
 8009e36:	f040 808f 	bne.w	8009f58 <vSocketSelect+0x174>
					{
						/* Check if the socket has already been accepted by the
						owner.  If not, it is useless to return it from a
						select(). */
						BaseType_t bAccepted = pdFALSE;
 8009e3a:	2300      	movs	r3, #0
 8009e3c:	61bb      	str	r3, [r7, #24]

						if( pxSocket->u.xTCP.bits.bPassQueued == pdFALSE_UNSIGNED )
 8009e3e:	68fb      	ldr	r3, [r7, #12]
 8009e40:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8009e44:	f003 0304 	and.w	r3, r3, #4
 8009e48:	b2db      	uxtb	r3, r3
 8009e4a:	2b00      	cmp	r3, #0
 8009e4c:	d109      	bne.n	8009e62 <vSocketSelect+0x7e>
						{
							if( pxSocket->u.xTCP.bits.bPassAccept == pdFALSE_UNSIGNED )
 8009e4e:	68fb      	ldr	r3, [r7, #12]
 8009e50:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8009e54:	f003 0302 	and.w	r3, r3, #2
 8009e58:	b2db      	uxtb	r3, r3
 8009e5a:	2b00      	cmp	r3, #0
 8009e5c:	d101      	bne.n	8009e62 <vSocketSelect+0x7e>
							{
								bAccepted = pdTRUE;
 8009e5e:	2301      	movs	r3, #1
 8009e60:	61bb      	str	r3, [r7, #24]
							}
						}

						/* Is the set owner interested in READ events? */
						if( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 )
 8009e62:	68fb      	ldr	r3, [r7, #12]
 8009e64:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009e66:	f003 0301 	and.w	r3, r3, #1
 8009e6a:	2b00      	cmp	r3, #0
 8009e6c:	d023      	beq.n	8009eb6 <vSocketSelect+0xd2>
						{
							if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN )
 8009e6e:	68fb      	ldr	r3, [r7, #12]
 8009e70:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 8009e74:	2b01      	cmp	r3, #1
 8009e76:	d111      	bne.n	8009e9c <vSocketSelect+0xb8>
							{
								if( ( pxSocket->u.xTCP.pxPeerSocket != NULL ) && ( pxSocket->u.xTCP.pxPeerSocket->u.xTCP.bits.bPassAccept != 0 ) )
 8009e78:	68fb      	ldr	r3, [r7, #12]
 8009e7a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009e7c:	2b00      	cmp	r3, #0
 8009e7e:	d01a      	beq.n	8009eb6 <vSocketSelect+0xd2>
 8009e80:	68fb      	ldr	r3, [r7, #12]
 8009e82:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8009e84:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 8009e88:	f003 0302 	and.w	r3, r3, #2
 8009e8c:	b2db      	uxtb	r3, r3
 8009e8e:	2b00      	cmp	r3, #0
 8009e90:	d011      	beq.n	8009eb6 <vSocketSelect+0xd2>
								{
									xSocketBits |= eSELECT_READ;
 8009e92:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009e94:	f043 0301 	orr.w	r3, r3, #1
 8009e98:	62bb      	str	r3, [r7, #40]	; 0x28
 8009e9a:	e00c      	b.n	8009eb6 <vSocketSelect+0xd2>
								}
							}
							else if( ( bAccepted != 0 ) && ( FreeRTOS_recvcount( pxSocket ) > 0 ) )
 8009e9c:	69bb      	ldr	r3, [r7, #24]
 8009e9e:	2b00      	cmp	r3, #0
 8009ea0:	d009      	beq.n	8009eb6 <vSocketSelect+0xd2>
 8009ea2:	68f8      	ldr	r0, [r7, #12]
 8009ea4:	f7ff feb2 	bl	8009c0c <FreeRTOS_rx_size>
 8009ea8:	4603      	mov	r3, r0
 8009eaa:	2b00      	cmp	r3, #0
 8009eac:	dd03      	ble.n	8009eb6 <vSocketSelect+0xd2>
							{
								xSocketBits |= eSELECT_READ;
 8009eae:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009eb0:	f043 0301 	orr.w	r3, r3, #1
 8009eb4:	62bb      	str	r3, [r7, #40]	; 0x28
							}
						}
						/* Is the set owner interested in EXCEPTION events? */
						if( ( pxSocket->xSelectBits & eSELECT_EXCEPT ) != 0 )
 8009eb6:	68fb      	ldr	r3, [r7, #12]
 8009eb8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009eba:	f003 0304 	and.w	r3, r3, #4
 8009ebe:	2b00      	cmp	r3, #0
 8009ec0:	d00d      	beq.n	8009ede <vSocketSelect+0xfa>
						{
							if( ( pxSocket->u.xTCP.ucTCPState == eCLOSE_WAIT ) || ( pxSocket->u.xTCP.ucTCPState == eCLOSED ) )
 8009ec2:	68fb      	ldr	r3, [r7, #12]
 8009ec4:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 8009ec8:	2b08      	cmp	r3, #8
 8009eca:	d004      	beq.n	8009ed6 <vSocketSelect+0xf2>
 8009ecc:	68fb      	ldr	r3, [r7, #12]
 8009ece:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 8009ed2:	2b00      	cmp	r3, #0
 8009ed4:	d103      	bne.n	8009ede <vSocketSelect+0xfa>
							{
								xSocketBits |= eSELECT_EXCEPT;
 8009ed6:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009ed8:	f043 0304 	orr.w	r3, r3, #4
 8009edc:	62bb      	str	r3, [r7, #40]	; 0x28
							}
						}

						/* Is the set owner interested in WRITE events? */
						if( ( pxSocket->xSelectBits & eSELECT_WRITE ) != 0 )
 8009ede:	68fb      	ldr	r3, [r7, #12]
 8009ee0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009ee2:	f003 0302 	and.w	r3, r3, #2
 8009ee6:	2b00      	cmp	r3, #0
 8009ee8:	d035      	beq.n	8009f56 <vSocketSelect+0x172>
						{
							BaseType_t bMatch = pdFALSE;
 8009eea:	2300      	movs	r3, #0
 8009eec:	617b      	str	r3, [r7, #20]

							if( bAccepted != 0 )
 8009eee:	69bb      	ldr	r3, [r7, #24]
 8009ef0:	2b00      	cmp	r3, #0
 8009ef2:	d007      	beq.n	8009f04 <vSocketSelect+0x120>
							{
								if( FreeRTOS_tx_space( pxSocket ) > 0 )
 8009ef4:	68f8      	ldr	r0, [r7, #12]
 8009ef6:	f7ff fe43 	bl	8009b80 <FreeRTOS_tx_space>
 8009efa:	4603      	mov	r3, r0
 8009efc:	2b00      	cmp	r3, #0
 8009efe:	dd01      	ble.n	8009f04 <vSocketSelect+0x120>
								{
									bMatch = pdTRUE;
 8009f00:	2301      	movs	r3, #1
 8009f02:	617b      	str	r3, [r7, #20]
								}
							}

							if( bMatch == pdFALSE )
 8009f04:	697b      	ldr	r3, [r7, #20]
 8009f06:	2b00      	cmp	r3, #0
 8009f08:	d11d      	bne.n	8009f46 <vSocketSelect+0x162>
							{
								if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) &&
 8009f0a:	68fb      	ldr	r3, [r7, #12]
 8009f0c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8009f10:	f003 0308 	and.w	r3, r3, #8
 8009f14:	b2db      	uxtb	r3, r3
 8009f16:	2b00      	cmp	r3, #0
 8009f18:	d015      	beq.n	8009f46 <vSocketSelect+0x162>
									( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) &&
 8009f1a:	68fb      	ldr	r3, [r7, #12]
 8009f1c:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
								}
							}

							if( bMatch == pdFALSE )
							{
								if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) &&
 8009f20:	2b04      	cmp	r3, #4
 8009f22:	d910      	bls.n	8009f46 <vSocketSelect+0x162>
									( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) &&
									( pxSocket->u.xTCP.bits.bConnPassed == pdFALSE_UNSIGNED ) )
 8009f24:	68fb      	ldr	r3, [r7, #12]
 8009f26:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 8009f2a:	f003 0310 	and.w	r3, r3, #16
 8009f2e:	b2db      	uxtb	r3, r3
							}

							if( bMatch == pdFALSE )
							{
								if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) &&
									( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) &&
 8009f30:	2b00      	cmp	r3, #0
 8009f32:	d108      	bne.n	8009f46 <vSocketSelect+0x162>
									( pxSocket->u.xTCP.bits.bConnPassed == pdFALSE_UNSIGNED ) )
								{
									pxSocket->u.xTCP.bits.bConnPassed = pdTRUE_UNSIGNED;
 8009f34:	68fa      	ldr	r2, [r7, #12]
 8009f36:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 8009f3a:	f043 0310 	orr.w	r3, r3, #16
 8009f3e:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
									bMatch = pdTRUE;
 8009f42:	2301      	movs	r3, #1
 8009f44:	617b      	str	r3, [r7, #20]
								}
							}

							if( bMatch != pdFALSE )
 8009f46:	697b      	ldr	r3, [r7, #20]
 8009f48:	2b00      	cmp	r3, #0
 8009f4a:	d004      	beq.n	8009f56 <vSocketSelect+0x172>
							{
								xSocketBits |= eSELECT_WRITE;
 8009f4c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f4e:	f043 0302 	orr.w	r3, r3, #2
 8009f52:	62bb      	str	r3, [r7, #40]	; 0x28
 8009f54:	e00e      	b.n	8009f74 <vSocketSelect+0x190>
 8009f56:	e00d      	b.n	8009f74 <vSocketSelect+0x190>
					}
					else
				#endif /* ipconfigUSE_TCP == 1 */
				{
					/* Select events for UDP are simpler. */
					if( ( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 ) &&
 8009f58:	68fb      	ldr	r3, [r7, #12]
 8009f5a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8009f5c:	f003 0301 	and.w	r3, r3, #1
 8009f60:	2b00      	cmp	r3, #0
 8009f62:	d007      	beq.n	8009f74 <vSocketSelect+0x190>
						( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U ) )
 8009f64:	68fb      	ldr	r3, [r7, #12]
 8009f66:	6b9b      	ldr	r3, [r3, #56]	; 0x38
					}
					else
				#endif /* ipconfigUSE_TCP == 1 */
				{
					/* Select events for UDP are simpler. */
					if( ( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 ) &&
 8009f68:	2b00      	cmp	r3, #0
 8009f6a:	d003      	beq.n	8009f74 <vSocketSelect+0x190>
						( listCURRENT_LIST_LENGTH( &( pxSocket->u.xUDP.xWaitingPacketsList ) ) > 0U ) )
					{
						xSocketBits |= eSELECT_READ;
 8009f6c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f6e:	f043 0301 	orr.w	r3, r3, #1
 8009f72:	62bb      	str	r3, [r7, #40]	; 0x28
					/* The WRITE and EXCEPT bits are not used for UDP */
				}	/* if( pxSocket->ucProtocol == FREERTOS_IPPROTO_TCP ) */

				/* Each socket keeps its own event flags, which are looked-up
				by FreeRTOS_FD_ISSSET() */
				pxSocket->xSocketBits = xSocketBits;
 8009f74:	68fb      	ldr	r3, [r7, #12]
 8009f76:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8009f78:	631a      	str	r2, [r3, #48]	; 0x30

				/* The ORed value will be used to set the bits in the event
				group. */
				xGroupBits |= xSocketBits;
 8009f7a:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009f7c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8009f7e:	4313      	orrs	r3, r2
 8009f80:	627b      	str	r3, [r7, #36]	; 0x24
				pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
			}
		#endif /* ipconfigUSE_TCP == 1 */
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
				 pxIterator != ( const ListItem_t * ) pxEnd;
				 pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 8009f82:	6a3b      	ldr	r3, [r7, #32]
 8009f84:	685b      	ldr	r3, [r3, #4]
 8009f86:	623b      	str	r3, [r7, #32]
			else
			{
				pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xBoundTCPSocketsList );
			}
		#endif /* ipconfigUSE_TCP == 1 */
			for( pxIterator = ( const ListItem_t * ) ( listGET_NEXT( pxEnd ) );
 8009f88:	6a3a      	ldr	r2, [r7, #32]
 8009f8a:	69fb      	ldr	r3, [r7, #28]
 8009f8c:	429a      	cmp	r2, r3
 8009f8e:	f47f af43 	bne.w	8009e18 <vSocketSelect+0x34>

		/* These flags will be switched on after checking the socket status. */
		EventBits_t xGroupBits = 0;
		pxSocketSet->pxSocket = NULL;

		for( xRound = 0; xRound <= xLastRound; xRound++ )
 8009f92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8009f94:	3301      	adds	r3, #1
 8009f96:	62fb      	str	r3, [r7, #44]	; 0x2c
 8009f98:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8009f9a:	693b      	ldr	r3, [r7, #16]
 8009f9c:	429a      	cmp	r2, r3
 8009f9e:	f77f af2f 	ble.w	8009e00 <vSocketSelect+0x1c>
				xGroupBits |= xSocketBits;

			}	/* for( pxIterator ... ) */
		}	/* for( xRound = 0; xRound <= xLastRound; xRound++ ) */

		xBitsToClear = xEventGroupGetBits( pxSocketSet->xSelectGroup );
 8009fa2:	687b      	ldr	r3, [r7, #4]
 8009fa4:	681b      	ldr	r3, [r3, #0]
 8009fa6:	4618      	mov	r0, r3
 8009fa8:	2100      	movs	r1, #0
 8009faa:	f7fc fb87 	bl	80066bc <xEventGroupClearBits>
 8009fae:	60b8      	str	r0, [r7, #8]

		/* Now set the necessary bits. */
		xBitsToClear = ( xBitsToClear & ~xGroupBits ) & eSELECT_ALL;
 8009fb0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009fb2:	43da      	mvns	r2, r3
 8009fb4:	68bb      	ldr	r3, [r7, #8]
 8009fb6:	4013      	ands	r3, r2
 8009fb8:	f003 030f 	and.w	r3, r3, #15
 8009fbc:	60bb      	str	r3, [r7, #8]
		#if( ipconfigSUPPORT_SIGNALS != 0 )
		{
			/* Maybe the socketset was signalled, but don't
			clear the 'eSELECT_INTR' bit here, as it will be used
			and cleared in FreeRTOS_select(). */
			xBitsToClear &= ( EventBits_t ) ~eSELECT_INTR;
 8009fbe:	68bb      	ldr	r3, [r7, #8]
 8009fc0:	f023 0308 	bic.w	r3, r3, #8
 8009fc4:	60bb      	str	r3, [r7, #8]
		}
		#endif /* ipconfigSUPPORT_SIGNALS */

		if( xBitsToClear != 0 )
 8009fc6:	68bb      	ldr	r3, [r7, #8]
 8009fc8:	2b00      	cmp	r3, #0
 8009fca:	d005      	beq.n	8009fd8 <vSocketSelect+0x1f4>
		{
			xEventGroupClearBits( pxSocketSet->xSelectGroup, xBitsToClear );
 8009fcc:	687b      	ldr	r3, [r7, #4]
 8009fce:	681b      	ldr	r3, [r3, #0]
 8009fd0:	4618      	mov	r0, r3
 8009fd2:	68b9      	ldr	r1, [r7, #8]
 8009fd4:	f7fc fb72 	bl	80066bc <xEventGroupClearBits>
		}

		/* Now include eSELECT_CALL_IP to wakeup the caller. */
		xEventGroupSetBits( pxSocketSet->xSelectGroup, xGroupBits | eSELECT_CALL_IP );
 8009fd8:	687b      	ldr	r3, [r7, #4]
 8009fda:	681a      	ldr	r2, [r3, #0]
 8009fdc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009fde:	f043 0310 	orr.w	r3, r3, #16
 8009fe2:	4610      	mov	r0, r2
 8009fe4:	4619      	mov	r1, r3
 8009fe6:	f7fc fb9f 	bl	8006728 <xEventGroupSetBits>
	}
 8009fea:	3730      	adds	r7, #48	; 0x30
 8009fec:	46bd      	mov	sp, r7
 8009fee:	bd80      	pop	{r7, pc}
 8009ff0:	2000cf2c 	.word	0x2000cf2c
 8009ff4:	2000cf18 	.word	0x2000cf18

08009ff8 <FreeRTOS_SignalSocket>:

#if( ipconfigSUPPORT_SIGNALS != 0 )

	/* Send a signal to the task which reads from this socket. */
	BaseType_t FreeRTOS_SignalSocket( Socket_t xSocket )
	{
 8009ff8:	b580      	push	{r7, lr}
 8009ffa:	b084      	sub	sp, #16
 8009ffc:	af00      	add	r7, sp, #0
 8009ffe:	6078      	str	r0, [r7, #4]
	FreeRTOS_Socket_t *pxSocket = ( FreeRTOS_Socket_t * ) xSocket;
 800a000:	687b      	ldr	r3, [r7, #4]
 800a002:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn;

		if( pxSocket == NULL )
 800a004:	68bb      	ldr	r3, [r7, #8]
 800a006:	2b00      	cmp	r3, #0
 800a008:	d103      	bne.n	800a012 <FreeRTOS_SignalSocket+0x1a>
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800a00a:	f06f 0315 	mvn.w	r3, #21
 800a00e:	60fb      	str	r3, [r7, #12]
 800a010:	e022      	b.n	800a058 <FreeRTOS_SignalSocket+0x60>
		}
		else
	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
		if( ( pxSocket->pxSocketSet != NULL ) && ( pxSocket->pxSocketSet->xSelectGroup != NULL ) )
 800a012:	68bb      	ldr	r3, [r7, #8]
 800a014:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a016:	2b00      	cmp	r3, #0
 800a018:	d00e      	beq.n	800a038 <FreeRTOS_SignalSocket+0x40>
 800a01a:	68bb      	ldr	r3, [r7, #8]
 800a01c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a01e:	681b      	ldr	r3, [r3, #0]
 800a020:	2b00      	cmp	r3, #0
 800a022:	d009      	beq.n	800a038 <FreeRTOS_SignalSocket+0x40>
		{
			xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, eSELECT_INTR );
 800a024:	68bb      	ldr	r3, [r7, #8]
 800a026:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a028:	681b      	ldr	r3, [r3, #0]
 800a02a:	4618      	mov	r0, r3
 800a02c:	2108      	movs	r1, #8
 800a02e:	f7fc fb7b 	bl	8006728 <xEventGroupSetBits>
			xReturn = 0;
 800a032:	2300      	movs	r3, #0
 800a034:	60fb      	str	r3, [r7, #12]
 800a036:	e00f      	b.n	800a058 <FreeRTOS_SignalSocket+0x60>
		}
		else
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */
		if( pxSocket->xEventGroup != NULL )
 800a038:	68bb      	ldr	r3, [r7, #8]
 800a03a:	685b      	ldr	r3, [r3, #4]
 800a03c:	2b00      	cmp	r3, #0
 800a03e:	d008      	beq.n	800a052 <FreeRTOS_SignalSocket+0x5a>
		{
			xEventGroupSetBits( pxSocket->xEventGroup, eSOCKET_INTR );
 800a040:	68bb      	ldr	r3, [r7, #8]
 800a042:	685b      	ldr	r3, [r3, #4]
 800a044:	4618      	mov	r0, r3
 800a046:	2140      	movs	r1, #64	; 0x40
 800a048:	f7fc fb6e 	bl	8006728 <xEventGroupSetBits>
			xReturn = 0;
 800a04c:	2300      	movs	r3, #0
 800a04e:	60fb      	str	r3, [r7, #12]
 800a050:	e002      	b.n	800a058 <FreeRTOS_SignalSocket+0x60>
		}
		else
		{
			xReturn = -pdFREERTOS_ERRNO_EINVAL;
 800a052:	f06f 0315 	mvn.w	r3, #21
 800a056:	60fb      	str	r3, [r7, #12]
		}

		return xReturn;
 800a058:	68fb      	ldr	r3, [r7, #12]
	}
 800a05a:	4618      	mov	r0, r3
 800a05c:	3710      	adds	r7, #16
 800a05e:	46bd      	mov	sp, r7
 800a060:	bd80      	pop	{r7, pc}
 800a062:	bf00      	nop

0800a064 <vProcessGeneratedUDPPacket>:
	}
};
/*-----------------------------------------------------------*/

void vProcessGeneratedUDPPacket( NetworkBufferDescriptor_t * const pxNetworkBuffer )
{
 800a064:	b580      	push	{r7, lr}
 800a066:	b088      	sub	sp, #32
 800a068:	af00      	add	r7, sp, #0
 800a06a:	6078      	str	r0, [r7, #4]
UDPPacket_t *pxUDPPacket;
IPHeader_t *pxIPHeader;
eARPLookupResult_t eReturned;
uint32_t ulIPAddress = pxNetworkBuffer->ulIPAddress;
 800a06c:	687b      	ldr	r3, [r7, #4]
 800a06e:	695b      	ldr	r3, [r3, #20]
 800a070:	60fb      	str	r3, [r7, #12]

	/* Map the UDP packet onto the start of the frame. */
	pxUDPPacket = ( UDPPacket_t * ) pxNetworkBuffer->pucEthernetBuffer;
 800a072:	687b      	ldr	r3, [r7, #4]
 800a074:	699b      	ldr	r3, [r3, #24]
 800a076:	61bb      	str	r3, [r7, #24]

	/* Determine the ARP cache status for the requested IP address. */
	eReturned = eARPGetCacheEntry( &( ulIPAddress ), &( pxUDPPacket->xEthernetHeader.xDestinationAddress ) );
 800a078:	69bb      	ldr	r3, [r7, #24]
 800a07a:	f107 020c 	add.w	r2, r7, #12
 800a07e:	4610      	mov	r0, r2
 800a080:	4619      	mov	r1, r3
 800a082:	f7fe fbed 	bl	8008860 <eARPGetCacheEntry>
 800a086:	4603      	mov	r3, r0
 800a088:	77fb      	strb	r3, [r7, #31]

	if( eReturned != eCantSendPacket )
 800a08a:	7ffb      	ldrb	r3, [r7, #31]
 800a08c:	2b02      	cmp	r3, #2
 800a08e:	f000 8083 	beq.w	800a198 <vProcessGeneratedUDPPacket+0x134>
	{
		if( eReturned == eARPCacheHit )
 800a092:	7ffb      	ldrb	r3, [r7, #31]
 800a094:	2b01      	cmp	r3, #1
 800a096:	d16e      	bne.n	800a176 <vProcessGeneratedUDPPacket+0x112>
				uint8_t ucSocketOptions;
			#endif
			iptraceSENDING_UDP_PACKET( pxNetworkBuffer->ulIPAddress );

			/* Create short cuts to the data within the packet. */
			pxIPHeader = &( pxUDPPacket->xIPHeader );
 800a098:	69bb      	ldr	r3, [r7, #24]
 800a09a:	330e      	adds	r3, #14
 800a09c:	617b      	str	r3, [r7, #20]

		#if ( ipconfigSUPPORT_OUTGOING_PINGS == 1 )
			/* Is it possible that the packet is not actually a UDP packet
			after all, but an ICMP packet. */
			if( pxNetworkBuffer->usPort != ipPACKET_CONTAINS_ICMP_DATA )
 800a09e:	687b      	ldr	r3, [r7, #4]
 800a0a0:	8c1b      	ldrh	r3, [r3, #32]
 800a0a2:	2b00      	cmp	r3, #0
 800a0a4:	d026      	beq.n	800a0f4 <vProcessGeneratedUDPPacket+0x90>
		#endif /* ipconfigSUPPORT_OUTGOING_PINGS */
			{
			UDPHeader_t *pxUDPHeader;

				pxUDPHeader = &( pxUDPPacket->xUDPHeader );
 800a0a6:	69bb      	ldr	r3, [r7, #24]
 800a0a8:	3322      	adds	r3, #34	; 0x22
 800a0aa:	613b      	str	r3, [r7, #16]

				pxUDPHeader->usDestinationPort = pxNetworkBuffer->usPort;
 800a0ac:	687b      	ldr	r3, [r7, #4]
 800a0ae:	8c1a      	ldrh	r2, [r3, #32]
 800a0b0:	693b      	ldr	r3, [r7, #16]
 800a0b2:	805a      	strh	r2, [r3, #2]
				pxUDPHeader->usSourcePort = pxNetworkBuffer->usBoundPort;
 800a0b4:	687b      	ldr	r3, [r7, #4]
 800a0b6:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 800a0b8:	693b      	ldr	r3, [r7, #16]
 800a0ba:	801a      	strh	r2, [r3, #0]
				pxUDPHeader->usLength = ( uint16_t ) ( pxNetworkBuffer->xDataLength + sizeof( UDPHeader_t ) );
 800a0bc:	687b      	ldr	r3, [r7, #4]
 800a0be:	69db      	ldr	r3, [r3, #28]
 800a0c0:	b29b      	uxth	r3, r3
 800a0c2:	3308      	adds	r3, #8
 800a0c4:	b29a      	uxth	r2, r3
 800a0c6:	693b      	ldr	r3, [r7, #16]
 800a0c8:	809a      	strh	r2, [r3, #4]
				pxUDPHeader->usLength = FreeRTOS_htons( pxUDPHeader->usLength );
 800a0ca:	693b      	ldr	r3, [r7, #16]
 800a0cc:	889b      	ldrh	r3, [r3, #4]
 800a0ce:	b29b      	uxth	r3, r3
 800a0d0:	021b      	lsls	r3, r3, #8
 800a0d2:	b29a      	uxth	r2, r3
 800a0d4:	693b      	ldr	r3, [r7, #16]
 800a0d6:	889b      	ldrh	r3, [r3, #4]
 800a0d8:	b29b      	uxth	r3, r3
 800a0da:	0a1b      	lsrs	r3, r3, #8
 800a0dc:	b29b      	uxth	r3, r3
 800a0de:	b29b      	uxth	r3, r3
 800a0e0:	4313      	orrs	r3, r2
 800a0e2:	b29b      	uxth	r3, r3
 800a0e4:	b29a      	uxth	r2, r3
 800a0e6:	693b      	ldr	r3, [r7, #16]
 800a0e8:	809a      	strh	r2, [r3, #4]
				pxUDPHeader->usChecksum = 0u;
 800a0ea:	693b      	ldr	r3, [r7, #16]
 800a0ec:	2200      	movs	r2, #0
 800a0ee:	719a      	strb	r2, [r3, #6]
 800a0f0:	2200      	movs	r2, #0
 800a0f2:	71da      	strb	r2, [r3, #7]
			*/
			/* Save options now, as they will be overwritten by memcpy */
			#if( ipconfigDRIVER_INCLUDED_TX_IP_CHECKSUM == 0 )
				ucSocketOptions = pxNetworkBuffer->pucEthernetBuffer[ ipSOCKET_OPTIONS_OFFSET ];
			#endif
			memcpy( ( void *) &( pxUDPPacket->xEthernetHeader.xSourceAddress ), ( void * ) xDefaultPartUDPPacketHeader.ucBytes, sizeof( xDefaultPartUDPPacketHeader ) );
 800a0f4:	69bb      	ldr	r3, [r7, #24]
 800a0f6:	3306      	adds	r3, #6
 800a0f8:	4618      	mov	r0, r3
 800a0fa:	492e      	ldr	r1, [pc, #184]	; (800a1b4 <vProcessGeneratedUDPPacket+0x150>)
 800a0fc:	2218      	movs	r2, #24
 800a0fe:	f005 ffd3 	bl	80100a8 <memcpy>

		#if ipconfigSUPPORT_OUTGOING_PINGS == 1
			if( pxNetworkBuffer->usPort == ipPACKET_CONTAINS_ICMP_DATA )
 800a102:	687b      	ldr	r3, [r7, #4]
 800a104:	8c1b      	ldrh	r3, [r3, #32]
 800a106:	2b00      	cmp	r3, #0
 800a108:	d10a      	bne.n	800a120 <vProcessGeneratedUDPPacket+0xbc>
			{
				pxIPHeader->ucProtocol = ipPROTOCOL_ICMP;
 800a10a:	697b      	ldr	r3, [r7, #20]
 800a10c:	2201      	movs	r2, #1
 800a10e:	725a      	strb	r2, [r3, #9]
				pxIPHeader->usLength = ( uint16_t ) ( pxNetworkBuffer->xDataLength + sizeof( IPHeader_t ) );
 800a110:	687b      	ldr	r3, [r7, #4]
 800a112:	69db      	ldr	r3, [r3, #28]
 800a114:	b29b      	uxth	r3, r3
 800a116:	3314      	adds	r3, #20
 800a118:	b29a      	uxth	r2, r3
 800a11a:	697b      	ldr	r3, [r7, #20]
 800a11c:	805a      	strh	r2, [r3, #2]
 800a11e:	e006      	b.n	800a12e <vProcessGeneratedUDPPacket+0xca>
			}
			else
		#endif /* ipconfigSUPPORT_OUTGOING_PINGS */
			{
				pxIPHeader->usLength = ( uint16_t ) ( pxNetworkBuffer->xDataLength + sizeof( IPHeader_t ) + sizeof( UDPHeader_t ) );
 800a120:	687b      	ldr	r3, [r7, #4]
 800a122:	69db      	ldr	r3, [r3, #28]
 800a124:	b29b      	uxth	r3, r3
 800a126:	331c      	adds	r3, #28
 800a128:	b29a      	uxth	r2, r3
 800a12a:	697b      	ldr	r3, [r7, #20]
 800a12c:	805a      	strh	r2, [r3, #2]
			}

			/* The total transmit size adds on the Ethernet header. */
			pxNetworkBuffer->xDataLength = pxIPHeader->usLength + sizeof( EthernetHeader_t );
 800a12e:	697b      	ldr	r3, [r7, #20]
 800a130:	885b      	ldrh	r3, [r3, #2]
 800a132:	b29b      	uxth	r3, r3
 800a134:	f103 020e 	add.w	r2, r3, #14
 800a138:	687b      	ldr	r3, [r7, #4]
 800a13a:	61da      	str	r2, [r3, #28]
			pxIPHeader->usLength = FreeRTOS_htons( pxIPHeader->usLength );
 800a13c:	697b      	ldr	r3, [r7, #20]
 800a13e:	885b      	ldrh	r3, [r3, #2]
 800a140:	b29b      	uxth	r3, r3
 800a142:	021b      	lsls	r3, r3, #8
 800a144:	b29a      	uxth	r2, r3
 800a146:	697b      	ldr	r3, [r7, #20]
 800a148:	885b      	ldrh	r3, [r3, #2]
 800a14a:	b29b      	uxth	r3, r3
 800a14c:	0a1b      	lsrs	r3, r3, #8
 800a14e:	b29b      	uxth	r3, r3
 800a150:	b29b      	uxth	r3, r3
 800a152:	4313      	orrs	r3, r2
 800a154:	b29b      	uxth	r3, r3
 800a156:	b29a      	uxth	r2, r3
 800a158:	697b      	ldr	r3, [r7, #20]
 800a15a:	805a      	strh	r2, [r3, #2]
			/* HT:endian: changed back to network endian */
			pxIPHeader->ulDestinationIPAddress = pxNetworkBuffer->ulIPAddress;
 800a15c:	687b      	ldr	r3, [r7, #4]
 800a15e:	695a      	ldr	r2, [r3, #20]
 800a160:	697b      	ldr	r3, [r7, #20]
 800a162:	611a      	str	r2, [r3, #16]

			#if( ipconfigUSE_LLMNR == 1 )
			{
				/* LLMNR messages are typically used on a LAN and they're
				 * not supposed to cross routers */
				if( pxNetworkBuffer->ulIPAddress == ipLLMNR_IP_ADDR )
 800a164:	687b      	ldr	r3, [r7, #4]
 800a166:	695b      	ldr	r3, [r3, #20]
 800a168:	4a13      	ldr	r2, [pc, #76]	; (800a1b8 <vProcessGeneratedUDPPacket+0x154>)
 800a16a:	4293      	cmp	r3, r2
 800a16c:	d114      	bne.n	800a198 <vProcessGeneratedUDPPacket+0x134>
				{
					pxIPHeader->ucTimeToLive = 0x01;
 800a16e:	697b      	ldr	r3, [r7, #20]
 800a170:	2201      	movs	r2, #1
 800a172:	721a      	strb	r2, [r3, #8]
 800a174:	e010      	b.n	800a198 <vProcessGeneratedUDPPacket+0x134>
					pxUDPPacket->xUDPHeader.usChecksum = 0u;
				}
			}
			#endif
		}
		else if( eReturned == eARPCacheMiss )
 800a176:	7ffb      	ldrb	r3, [r7, #31]
 800a178:	2b00      	cmp	r3, #0
 800a17a:	d10b      	bne.n	800a194 <vProcessGeneratedUDPPacket+0x130>
		{
			/* Add an entry to the ARP table with a null hardware address.
			This allows the ARP timer to know that an ARP reply is
			outstanding, and perform retransmissions if necessary. */
			vARPRefreshCacheEntry( NULL, ulIPAddress );
 800a17c:	68fb      	ldr	r3, [r7, #12]
 800a17e:	2000      	movs	r0, #0
 800a180:	4619      	mov	r1, r3
 800a182:	f7fe fa71 	bl	8008668 <vARPRefreshCacheEntry>

			/* Generate an ARP for the required IP address. */
			iptracePACKET_DROPPED_TO_GENERATE_ARP( pxNetworkBuffer->ulIPAddress );
			pxNetworkBuffer->ulIPAddress = ulIPAddress;
 800a186:	68fa      	ldr	r2, [r7, #12]
 800a188:	687b      	ldr	r3, [r7, #4]
 800a18a:	615a      	str	r2, [r3, #20]
			vARPGenerateRequestPacket( pxNetworkBuffer );
 800a18c:	6878      	ldr	r0, [r7, #4]
 800a18e:	f7fe fcb7 	bl	8008b00 <vARPGenerateRequestPacket>
 800a192:	e001      	b.n	800a198 <vProcessGeneratedUDPPacket+0x134>
		}
		else
		{
			/* The lookup indicated that an ARP request has already been
			sent out for the queried IP address. */
			eReturned = eCantSendPacket;
 800a194:	2302      	movs	r3, #2
 800a196:	77fb      	strb	r3, [r7, #31]
		}
	}

	if( eReturned != eCantSendPacket )
 800a198:	7ffb      	ldrb	r3, [r7, #31]
 800a19a:	2b02      	cmp	r3, #2
 800a19c:	d004      	beq.n	800a1a8 <vProcessGeneratedUDPPacket+0x144>
				pxNetworkBuffer->xDataLength = ( size_t ) ipconfigETHERNET_MINIMUM_PACKET_BYTES;
			}
		}
		#endif

		xNetworkInterfaceOutput( pxNetworkBuffer, pdTRUE );
 800a19e:	6878      	ldr	r0, [r7, #4]
 800a1a0:	2101      	movs	r1, #1
 800a1a2:	f7fc fdc3 	bl	8006d2c <xNetworkInterfaceOutput>
 800a1a6:	e002      	b.n	800a1ae <vProcessGeneratedUDPPacket+0x14a>
	}
	else
	{
		/* The packet can't be sent (DHCP not completed?).  Just drop the
		packet. */
		vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800a1a8:	6878      	ldr	r0, [r7, #4]
 800a1aa:	f7fd fb17 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
	}
}
 800a1ae:	3720      	adds	r7, #32
 800a1b0:	46bd      	mov	sp, r7
 800a1b2:	bd80      	pop	{r7, pc}
 800a1b4:	2000bb08 	.word	0x2000bb08
 800a1b8:	fc0000e0 	.word	0xfc0000e0

0800a1bc <xProcessReceivedUDPPacket>:
/*-----------------------------------------------------------*/

BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer, uint16_t usPort )
{
 800a1bc:	b580      	push	{r7, lr}
 800a1be:	b086      	sub	sp, #24
 800a1c0:	af00      	add	r7, sp, #0
 800a1c2:	6078      	str	r0, [r7, #4]
 800a1c4:	460b      	mov	r3, r1
 800a1c6:	807b      	strh	r3, [r7, #2]
BaseType_t xReturn = pdPASS;
 800a1c8:	2301      	movs	r3, #1
 800a1ca:	617b      	str	r3, [r7, #20]
FreeRTOS_Socket_t *pxSocket;

UDPPacket_t *pxUDPPacket = (UDPPacket_t *) pxNetworkBuffer->pucEthernetBuffer;
 800a1cc:	687b      	ldr	r3, [r7, #4]
 800a1ce:	699b      	ldr	r3, [r3, #24]
 800a1d0:	613b      	str	r3, [r7, #16]

	pxSocket = pxUDPSocketLookup( usPort );
 800a1d2:	887b      	ldrh	r3, [r7, #2]
 800a1d4:	4618      	mov	r0, r3
 800a1d6:	f7ff fafb 	bl	80097d0 <pxUDPSocketLookup>
 800a1da:	60f8      	str	r0, [r7, #12]

	if( pxSocket )
 800a1dc:	68fb      	ldr	r3, [r7, #12]
 800a1de:	2b00      	cmp	r3, #0
 800a1e0:	d03a      	beq.n	800a258 <xProcessReceivedUDPPacket+0x9c>
	{

		/* When refreshing the ARP cache with received UDP packets we must be
		careful;  hundreds of broadcast messages may pass and if we're not
		handling them, no use to fill the ARP cache with those IP addresses. */
		vARPRefreshCacheEntry( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
 800a1e2:	693b      	ldr	r3, [r7, #16]
 800a1e4:	1d9a      	adds	r2, r3, #6
 800a1e6:	693b      	ldr	r3, [r7, #16]
 800a1e8:	f8d3 301a 	ldr.w	r3, [r3, #26]
 800a1ec:	4610      	mov	r0, r2
 800a1ee:	4619      	mov	r1, r3
 800a1f0:	f7fe fa3a 	bl	8008668 <vARPRefreshCacheEntry>
				}
			}
		}
		#endif

		if( xReturn == pdPASS )
 800a1f4:	697b      	ldr	r3, [r7, #20]
 800a1f6:	2b01      	cmp	r3, #1
 800a1f8:	d16a      	bne.n	800a2d0 <xProcessReceivedUDPPacket+0x114>
		{
			vTaskSuspendAll();
 800a1fa:	f7fb f913 	bl	8005424 <vTaskSuspendAll>
			{
				if( xReturn == pdPASS )
 800a1fe:	697b      	ldr	r3, [r7, #20]
 800a200:	2b01      	cmp	r3, #1
 800a202:	d10b      	bne.n	800a21c <xProcessReceivedUDPPacket+0x60>
				{
					taskENTER_CRITICAL();
 800a204:	f7f9 fe42 	bl	8003e8c <vPortEnterCritical>
					{
						/* Add the network packet to the list of packets to be
						processed by the socket. */
						vListInsertEnd( &( pxSocket->u.xUDP.xWaitingPacketsList ), &( pxNetworkBuffer->xBufferListItem ) );
 800a208:	68fb      	ldr	r3, [r7, #12]
 800a20a:	f103 0238 	add.w	r2, r3, #56	; 0x38
 800a20e:	687b      	ldr	r3, [r7, #4]
 800a210:	4610      	mov	r0, r2
 800a212:	4619      	mov	r1, r3
 800a214:	f7f9 fcb6 	bl	8003b84 <vListInsertEnd>
					}
					taskEXIT_CRITICAL();
 800a218:	f7f9 fe66 	bl	8003ee8 <vPortExitCritical>
				}
			}
			xTaskResumeAll();
 800a21c:	f7fb f910 	bl	8005440 <xTaskResumeAll>

			/* Set the socket's receive event */
			if( pxSocket->xEventGroup != NULL )
 800a220:	68fb      	ldr	r3, [r7, #12]
 800a222:	685b      	ldr	r3, [r3, #4]
 800a224:	2b00      	cmp	r3, #0
 800a226:	d005      	beq.n	800a234 <xProcessReceivedUDPPacket+0x78>
			{
				xEventGroupSetBits( pxSocket->xEventGroup, eSOCKET_RECEIVE );
 800a228:	68fb      	ldr	r3, [r7, #12]
 800a22a:	685b      	ldr	r3, [r3, #4]
 800a22c:	4618      	mov	r0, r3
 800a22e:	2101      	movs	r1, #1
 800a230:	f7fc fa7a 	bl	8006728 <xEventGroupSetBits>
			}

			#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
			{
				if( ( pxSocket->pxSocketSet != NULL ) && ( ( pxSocket->xSelectBits & eSELECT_READ ) != 0 ) )
 800a234:	68fb      	ldr	r3, [r7, #12]
 800a236:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a238:	2b00      	cmp	r3, #0
 800a23a:	d049      	beq.n	800a2d0 <xProcessReceivedUDPPacket+0x114>
 800a23c:	68fb      	ldr	r3, [r7, #12]
 800a23e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a240:	f003 0301 	and.w	r3, r3, #1
 800a244:	2b00      	cmp	r3, #0
 800a246:	d043      	beq.n	800a2d0 <xProcessReceivedUDPPacket+0x114>
				{
					xEventGroupSetBits( pxSocket->pxSocketSet->xSelectGroup, eSELECT_READ );
 800a248:	68fb      	ldr	r3, [r7, #12]
 800a24a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800a24c:	681b      	ldr	r3, [r3, #0]
 800a24e:	4618      	mov	r0, r3
 800a250:	2101      	movs	r1, #1
 800a252:	f7fc fa69 	bl	8006728 <xEventGroupSetBits>
 800a256:	e03b      	b.n	800a2d0 <xProcessReceivedUDPPacket+0x114>
		#if( ipconfigUSE_DNS == 1 )
			/* a DNS reply, check for the source port.  Although the DNS client
			does open a UDP socket to send a messages, this socket will be
			closed after a short timeout.  Messages that come late (after the
			socket is closed) will be treated here. */
			if( FreeRTOS_ntohs( pxUDPPacket->xUDPHeader.usSourcePort ) == ipDNS_PORT )
 800a258:	693b      	ldr	r3, [r7, #16]
 800a25a:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 800a25c:	b29b      	uxth	r3, r3
 800a25e:	021b      	lsls	r3, r3, #8
 800a260:	b29a      	uxth	r2, r3
 800a262:	693b      	ldr	r3, [r7, #16]
 800a264:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 800a266:	b29b      	uxth	r3, r3
 800a268:	0a1b      	lsrs	r3, r3, #8
 800a26a:	b29b      	uxth	r3, r3
 800a26c:	b29b      	uxth	r3, r3
 800a26e:	4313      	orrs	r3, r2
 800a270:	b29b      	uxth	r3, r3
 800a272:	b21b      	sxth	r3, r3
 800a274:	2b35      	cmp	r3, #53	; 0x35
 800a276:	d10e      	bne.n	800a296 <xProcessReceivedUDPPacket+0xda>
			{
				vARPRefreshCacheEntry( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
 800a278:	693b      	ldr	r3, [r7, #16]
 800a27a:	1d9a      	adds	r2, r3, #6
 800a27c:	693b      	ldr	r3, [r7, #16]
 800a27e:	f8d3 301a 	ldr.w	r3, [r3, #26]
 800a282:	4610      	mov	r0, r2
 800a284:	4619      	mov	r1, r3
 800a286:	f7fe f9ef 	bl	8008668 <vARPRefreshCacheEntry>
				xReturn = ( BaseType_t )ulDNSHandlePacket( pxNetworkBuffer );
 800a28a:	6878      	ldr	r0, [r7, #4]
 800a28c:	f003 fd60 	bl	800dd50 <ulDNSHandlePacket>
 800a290:	4603      	mov	r3, r0
 800a292:	617b      	str	r3, [r7, #20]
 800a294:	e01c      	b.n	800a2d0 <xProcessReceivedUDPPacket+0x114>
			else
		#endif

		#if( ipconfigUSE_LLMNR == 1 )
			/* a LLMNR request, check for the destination port. */
			if( ( usPort == FreeRTOS_ntohs( ipLLMNR_PORT ) ) ||
 800a296:	887b      	ldrh	r3, [r7, #2]
 800a298:	f64e 3214 	movw	r2, #60180	; 0xeb14
 800a29c:	4293      	cmp	r3, r2
 800a29e:	d006      	beq.n	800a2ae <xProcessReceivedUDPPacket+0xf2>
				( pxUDPPacket->xUDPHeader.usSourcePort == FreeRTOS_ntohs( ipLLMNR_PORT ) ) )
 800a2a0:	693b      	ldr	r3, [r7, #16]
 800a2a2:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 800a2a4:	b29b      	uxth	r3, r3
			else
		#endif

		#if( ipconfigUSE_LLMNR == 1 )
			/* a LLMNR request, check for the destination port. */
			if( ( usPort == FreeRTOS_ntohs( ipLLMNR_PORT ) ) ||
 800a2a6:	f64e 3214 	movw	r2, #60180	; 0xeb14
 800a2aa:	4293      	cmp	r3, r2
 800a2ac:	d10e      	bne.n	800a2cc <xProcessReceivedUDPPacket+0x110>
				( pxUDPPacket->xUDPHeader.usSourcePort == FreeRTOS_ntohs( ipLLMNR_PORT ) ) )
			{
				vARPRefreshCacheEntry( &( pxUDPPacket->xEthernetHeader.xSourceAddress ), pxUDPPacket->xIPHeader.ulSourceIPAddress );
 800a2ae:	693b      	ldr	r3, [r7, #16]
 800a2b0:	1d9a      	adds	r2, r3, #6
 800a2b2:	693b      	ldr	r3, [r7, #16]
 800a2b4:	f8d3 301a 	ldr.w	r3, [r3, #26]
 800a2b8:	4610      	mov	r0, r2
 800a2ba:	4619      	mov	r1, r3
 800a2bc:	f7fe f9d4 	bl	8008668 <vARPRefreshCacheEntry>
				xReturn = ( BaseType_t )ulDNSHandlePacket( pxNetworkBuffer );
 800a2c0:	6878      	ldr	r0, [r7, #4]
 800a2c2:	f003 fd45 	bl	800dd50 <ulDNSHandlePacket>
 800a2c6:	4603      	mov	r3, r0
 800a2c8:	617b      	str	r3, [r7, #20]
 800a2ca:	e001      	b.n	800a2d0 <xProcessReceivedUDPPacket+0x114>
				xReturn = ( BaseType_t )ulNBNSHandlePacket( pxNetworkBuffer );
			}
			else
		#endif /* ipconfigUSE_NBNS */
		{
			xReturn = pdFAIL;
 800a2cc:	2300      	movs	r3, #0
 800a2ce:	617b      	str	r3, [r7, #20]
		}
	}

	return xReturn;
 800a2d0:	697b      	ldr	r3, [r7, #20]
}
 800a2d2:	4618      	mov	r0, r3
 800a2d4:	3718      	adds	r7, #24
 800a2d6:	46bd      	mov	sp, r7
 800a2d8:	bd80      	pop	{r7, pc}
 800a2da:	bf00      	nop

0800a2dc <FreeRTOS_max_int32>:
	static portINLINE UBaseType_t FreeRTOS_max_UBaseTyp (UBaseType_t a, UBaseType_t b);
	static portINLINE BaseType_t  	FreeRTOS_min_BaseType  (BaseType_t  a, BaseType_t  b);
	static portINLINE UBaseType_t  	FreeRTOS_min_UBaseType (UBaseType_t  a, UBaseType_t  b);


	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return a >= b ? a : b; }
 800a2dc:	b480      	push	{r7}
 800a2de:	b083      	sub	sp, #12
 800a2e0:	af00      	add	r7, sp, #0
 800a2e2:	6078      	str	r0, [r7, #4]
 800a2e4:	6039      	str	r1, [r7, #0]
 800a2e6:	687a      	ldr	r2, [r7, #4]
 800a2e8:	683b      	ldr	r3, [r7, #0]
 800a2ea:	4293      	cmp	r3, r2
 800a2ec:	bfb8      	it	lt
 800a2ee:	4613      	movlt	r3, r2
 800a2f0:	4618      	mov	r0, r3
 800a2f2:	370c      	adds	r7, #12
 800a2f4:	46bd      	mov	sp, r7
 800a2f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a2fa:	4770      	bx	lr

0800a2fc <FreeRTOS_min_int32>:
	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return a >= b ? a : b; }
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return a <= b ? a : b; }
 800a2fc:	b480      	push	{r7}
 800a2fe:	b083      	sub	sp, #12
 800a300:	af00      	add	r7, sp, #0
 800a302:	6078      	str	r0, [r7, #4]
 800a304:	6039      	str	r1, [r7, #0]
 800a306:	687a      	ldr	r2, [r7, #4]
 800a308:	683b      	ldr	r3, [r7, #0]
 800a30a:	4293      	cmp	r3, r2
 800a30c:	bfa8      	it	ge
 800a30e:	4613      	movge	r3, r2
 800a310:	4618      	mov	r0, r3
 800a312:	370c      	adds	r7, #12
 800a314:	46bd      	mov	sp, r7
 800a316:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a31a:	4770      	bx	lr

0800a31c <FreeRTOS_min_uint32>:
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
 800a31c:	b480      	push	{r7}
 800a31e:	b083      	sub	sp, #12
 800a320:	af00      	add	r7, sp, #0
 800a322:	6078      	str	r0, [r7, #4]
 800a324:	6039      	str	r1, [r7, #0]
 800a326:	687a      	ldr	r2, [r7, #4]
 800a328:	683b      	ldr	r3, [r7, #0]
 800a32a:	4293      	cmp	r3, r2
 800a32c:	bf28      	it	cs
 800a32e:	4613      	movcs	r3, r2
 800a330:	4618      	mov	r0, r3
 800a332:	370c      	adds	r7, #12
 800a334:	46bd      	mov	sp, r7
 800a336:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a33a:	4770      	bx	lr

0800a33c <uxStreamBufferSpace>:
}
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper );
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
 800a33c:	b480      	push	{r7}
 800a33e:	b087      	sub	sp, #28
 800a340:	af00      	add	r7, sp, #0
 800a342:	60f8      	str	r0, [r7, #12]
 800a344:	60b9      	str	r1, [r7, #8]
 800a346:	607a      	str	r2, [r7, #4]
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 800a348:	68fb      	ldr	r3, [r7, #12]
 800a34a:	691a      	ldr	r2, [r3, #16]
 800a34c:	687b      	ldr	r3, [r7, #4]
 800a34e:	441a      	add	r2, r3
 800a350:	68bb      	ldr	r3, [r7, #8]
 800a352:	1ad3      	subs	r3, r2, r3
 800a354:	3b01      	subs	r3, #1
 800a356:	617b      	str	r3, [r7, #20]
	if( uxCount >= pxBuffer->LENGTH )
 800a358:	68fb      	ldr	r3, [r7, #12]
 800a35a:	691a      	ldr	r2, [r3, #16]
 800a35c:	697b      	ldr	r3, [r7, #20]
 800a35e:	429a      	cmp	r2, r3
 800a360:	d804      	bhi.n	800a36c <uxStreamBufferSpace+0x30>
	{
		uxCount -= pxBuffer->LENGTH;
 800a362:	68fb      	ldr	r3, [r7, #12]
 800a364:	691b      	ldr	r3, [r3, #16]
 800a366:	697a      	ldr	r2, [r7, #20]
 800a368:	1ad3      	subs	r3, r2, r3
 800a36a:	617b      	str	r3, [r7, #20]
	}

	return uxCount;
 800a36c:	697b      	ldr	r3, [r7, #20]
}
 800a36e:	4618      	mov	r0, r3
 800a370:	371c      	adds	r7, #28
 800a372:	46bd      	mov	sp, r7
 800a374:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a378:	4770      	bx	lr
 800a37a:	bf00      	nop

0800a37c <uxStreamBufferDistance>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper );
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
 800a37c:	b480      	push	{r7}
 800a37e:	b087      	sub	sp, #28
 800a380:	af00      	add	r7, sp, #0
 800a382:	60f8      	str	r0, [r7, #12]
 800a384:	60b9      	str	r1, [r7, #8]
 800a386:	607a      	str	r2, [r7, #4]
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 800a388:	68fb      	ldr	r3, [r7, #12]
 800a38a:	691a      	ldr	r2, [r3, #16]
 800a38c:	687b      	ldr	r3, [r7, #4]
 800a38e:	441a      	add	r2, r3
 800a390:	68bb      	ldr	r3, [r7, #8]
 800a392:	1ad3      	subs	r3, r2, r3
 800a394:	617b      	str	r3, [r7, #20]
	if ( uxCount >= pxBuffer->LENGTH )
 800a396:	68fb      	ldr	r3, [r7, #12]
 800a398:	691a      	ldr	r2, [r3, #16]
 800a39a:	697b      	ldr	r3, [r7, #20]
 800a39c:	429a      	cmp	r2, r3
 800a39e:	d804      	bhi.n	800a3aa <uxStreamBufferDistance+0x2e>
	{
		uxCount -= pxBuffer->LENGTH;
 800a3a0:	68fb      	ldr	r3, [r7, #12]
 800a3a2:	691b      	ldr	r3, [r3, #16]
 800a3a4:	697a      	ldr	r2, [r7, #20]
 800a3a6:	1ad3      	subs	r3, r2, r3
 800a3a8:	617b      	str	r3, [r7, #20]
	}

	return uxCount;
 800a3aa:	697b      	ldr	r3, [r7, #20]
}
 800a3ac:	4618      	mov	r0, r3
 800a3ae:	371c      	adds	r7, #28
 800a3b0:	46bd      	mov	sp, r7
 800a3b2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a3b6:	4770      	bx	lr

0800a3b8 <uxStreamBufferGetSpace>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer )
{
 800a3b8:	b580      	push	{r7, lr}
 800a3ba:	b084      	sub	sp, #16
 800a3bc:	af00      	add	r7, sp, #0
 800a3be:	6078      	str	r0, [r7, #4]
/* Returns the number of items which can still be added to uxHead
before hitting on uxTail */
size_t uxHead = pxBuffer->uxHead;
 800a3c0:	687b      	ldr	r3, [r7, #4]
 800a3c2:	689b      	ldr	r3, [r3, #8]
 800a3c4:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
 800a3c6:	687b      	ldr	r3, [r7, #4]
 800a3c8:	681b      	ldr	r3, [r3, #0]
 800a3ca:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferSpace( pxBuffer, uxHead, uxTail );
 800a3cc:	6878      	ldr	r0, [r7, #4]
 800a3ce:	68f9      	ldr	r1, [r7, #12]
 800a3d0:	68ba      	ldr	r2, [r7, #8]
 800a3d2:	f7ff ffb3 	bl	800a33c <uxStreamBufferSpace>
 800a3d6:	4603      	mov	r3, r0
}
 800a3d8:	4618      	mov	r0, r3
 800a3da:	3710      	adds	r7, #16
 800a3dc:	46bd      	mov	sp, r7
 800a3de:	bd80      	pop	{r7, pc}

0800a3e0 <uxStreamBufferFrontSpace>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferFrontSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferFrontSpace( const StreamBuffer_t *pxBuffer )
{
 800a3e0:	b580      	push	{r7, lr}
 800a3e2:	b084      	sub	sp, #16
 800a3e4:	af00      	add	r7, sp, #0
 800a3e6:	6078      	str	r0, [r7, #4]
/* Distance between uxFront and uxTail
or the number of items which can still be added to uxFront,
before hitting on uxTail */

size_t uxFront = pxBuffer->uxFront;
 800a3e8:	687b      	ldr	r3, [r7, #4]
 800a3ea:	68db      	ldr	r3, [r3, #12]
 800a3ec:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
 800a3ee:	687b      	ldr	r3, [r7, #4]
 800a3f0:	681b      	ldr	r3, [r3, #0]
 800a3f2:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferSpace( pxBuffer, uxFront, uxTail );
 800a3f4:	6878      	ldr	r0, [r7, #4]
 800a3f6:	68f9      	ldr	r1, [r7, #12]
 800a3f8:	68ba      	ldr	r2, [r7, #8]
 800a3fa:	f7ff ff9f 	bl	800a33c <uxStreamBufferSpace>
 800a3fe:	4603      	mov	r3, r0
}
 800a400:	4618      	mov	r0, r3
 800a402:	3710      	adds	r7, #16
 800a404:	46bd      	mov	sp, r7
 800a406:	bd80      	pop	{r7, pc}

0800a408 <uxStreamBufferMidSpace>:
}
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferMidSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferMidSpace( const StreamBuffer_t *pxBuffer )
{
 800a408:	b580      	push	{r7, lr}
 800a40a:	b084      	sub	sp, #16
 800a40c:	af00      	add	r7, sp, #0
 800a40e:	6078      	str	r0, [r7, #4]
/* Returns the distance between uxHead and uxMid */
size_t uxHead = pxBuffer->uxHead;
 800a410:	687b      	ldr	r3, [r7, #4]
 800a412:	689b      	ldr	r3, [r3, #8]
 800a414:	60fb      	str	r3, [r7, #12]
size_t uxMid = pxBuffer->uxMid;
 800a416:	687b      	ldr	r3, [r7, #4]
 800a418:	685b      	ldr	r3, [r3, #4]
 800a41a:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferDistance( pxBuffer, uxMid, uxHead );
 800a41c:	6878      	ldr	r0, [r7, #4]
 800a41e:	68b9      	ldr	r1, [r7, #8]
 800a420:	68fa      	ldr	r2, [r7, #12]
 800a422:	f7ff ffab 	bl	800a37c <uxStreamBufferDistance>
 800a426:	4603      	mov	r3, r0
}
 800a428:	4618      	mov	r0, r3
 800a42a:	3710      	adds	r7, #16
 800a42c:	46bd      	mov	sp, r7
 800a42e:	bd80      	pop	{r7, pc}

0800a430 <vStreamBufferMoveMid>:
/*-----------------------------------------------------------*/

static portINLINE void vStreamBufferMoveMid( StreamBuffer_t *pxBuffer, size_t uxCount );
static portINLINE void vStreamBufferMoveMid( StreamBuffer_t *pxBuffer, size_t uxCount )
{
 800a430:	b580      	push	{r7, lr}
 800a432:	b084      	sub	sp, #16
 800a434:	af00      	add	r7, sp, #0
 800a436:	6078      	str	r0, [r7, #4]
 800a438:	6039      	str	r1, [r7, #0]
/* Increment uxMid, but no further than uxHead */
size_t uxSize = uxStreamBufferMidSpace( pxBuffer );
 800a43a:	6878      	ldr	r0, [r7, #4]
 800a43c:	f7ff ffe4 	bl	800a408 <uxStreamBufferMidSpace>
 800a440:	60f8      	str	r0, [r7, #12]

	if( uxCount > uxSize )
 800a442:	683a      	ldr	r2, [r7, #0]
 800a444:	68fb      	ldr	r3, [r7, #12]
 800a446:	429a      	cmp	r2, r3
 800a448:	d901      	bls.n	800a44e <vStreamBufferMoveMid+0x1e>
	{
		uxCount = uxSize;
 800a44a:	68fb      	ldr	r3, [r7, #12]
 800a44c:	603b      	str	r3, [r7, #0]
	}
	pxBuffer->uxMid += uxCount;
 800a44e:	687b      	ldr	r3, [r7, #4]
 800a450:	685a      	ldr	r2, [r3, #4]
 800a452:	683b      	ldr	r3, [r7, #0]
 800a454:	441a      	add	r2, r3
 800a456:	687b      	ldr	r3, [r7, #4]
 800a458:	605a      	str	r2, [r3, #4]
	if( pxBuffer->uxMid >= pxBuffer->LENGTH )
 800a45a:	687b      	ldr	r3, [r7, #4]
 800a45c:	685a      	ldr	r2, [r3, #4]
 800a45e:	687b      	ldr	r3, [r7, #4]
 800a460:	691b      	ldr	r3, [r3, #16]
 800a462:	429a      	cmp	r2, r3
 800a464:	d306      	bcc.n	800a474 <vStreamBufferMoveMid+0x44>
	{
		pxBuffer->uxMid -= pxBuffer->LENGTH;
 800a466:	687b      	ldr	r3, [r7, #4]
 800a468:	685a      	ldr	r2, [r3, #4]
 800a46a:	687b      	ldr	r3, [r7, #4]
 800a46c:	691b      	ldr	r3, [r3, #16]
 800a46e:	1ad2      	subs	r2, r2, r3
 800a470:	687b      	ldr	r3, [r7, #4]
 800a472:	605a      	str	r2, [r3, #4]
	}
}
 800a474:	3710      	adds	r7, #16
 800a476:	46bd      	mov	sp, r7
 800a478:	bd80      	pop	{r7, pc}
 800a47a:	bf00      	nop

0800a47c <ulChar2u32>:
/*
 * Some helping function, their meaning should be clear
 */
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
{
 800a47c:	b480      	push	{r7}
 800a47e:	b083      	sub	sp, #12
 800a480:	af00      	add	r7, sp, #0
 800a482:	6078      	str	r0, [r7, #4]
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 800a484:	687b      	ldr	r3, [r7, #4]
 800a486:	781b      	ldrb	r3, [r3, #0]
 800a488:	061a      	lsls	r2, r3, #24
			( ( ( uint32_t )apChr[1] ) << 16) |
 800a48a:	687b      	ldr	r3, [r7, #4]
 800a48c:	3301      	adds	r3, #1
 800a48e:	781b      	ldrb	r3, [r3, #0]
 800a490:	041b      	lsls	r3, r3, #16
 * Some helping function, their meaning should be clear
 */
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
{
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 800a492:	431a      	orrs	r2, r3
			( ( ( uint32_t )apChr[1] ) << 16) |
			( ( ( uint32_t )apChr[2] ) << 8) |
 800a494:	687b      	ldr	r3, [r7, #4]
 800a496:	3302      	adds	r3, #2
 800a498:	781b      	ldrb	r3, [r3, #0]
 800a49a:	021b      	lsls	r3, r3, #8
 */
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
{
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
			( ( ( uint32_t )apChr[1] ) << 16) |
 800a49c:	4313      	orrs	r3, r2
			( ( ( uint32_t )apChr[2] ) << 8) |
			( ( ( uint32_t )apChr[3] ) );
 800a49e:	687a      	ldr	r2, [r7, #4]
 800a4a0:	3203      	adds	r2, #3
 800a4a2:	7812      	ldrb	r2, [r2, #0]
 * Some helping function, their meaning should be clear
 */
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr);
static portINLINE uint32_t ulChar2u32 (const uint8_t *apChr)
{
	return  ( ( ( uint32_t )apChr[0] ) << 24) |
 800a4a4:	4313      	orrs	r3, r2
			( ( ( uint32_t )apChr[1] ) << 16) |
			( ( ( uint32_t )apChr[2] ) << 8) |
			( ( ( uint32_t )apChr[3] ) );
}
 800a4a6:	4618      	mov	r0, r3
 800a4a8:	370c      	adds	r7, #12
 800a4aa:	46bd      	mov	sp, r7
 800a4ac:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4b0:	4770      	bx	lr
 800a4b2:	bf00      	nop

0800a4b4 <usChar2u16>:

static portINLINE uint16_t usChar2u16 (const uint8_t *apChr);
static portINLINE uint16_t usChar2u16 (const uint8_t *apChr)
{
 800a4b4:	b480      	push	{r7}
 800a4b6:	b083      	sub	sp, #12
 800a4b8:	af00      	add	r7, sp, #0
 800a4ba:	6078      	str	r0, [r7, #4]
	return ( uint16_t )
			( ( ( ( uint32_t )apChr[0] ) << 8) |
 800a4bc:	687b      	ldr	r3, [r7, #4]
 800a4be:	781b      	ldrb	r3, [r3, #0]
}

static portINLINE uint16_t usChar2u16 (const uint8_t *apChr);
static portINLINE uint16_t usChar2u16 (const uint8_t *apChr)
{
	return ( uint16_t )
 800a4c0:	b29b      	uxth	r3, r3
 800a4c2:	021b      	lsls	r3, r3, #8
 800a4c4:	b29a      	uxth	r2, r3
			( ( ( ( uint32_t )apChr[0] ) << 8) |
			  ( ( ( uint32_t )apChr[1] ) ) );
 800a4c6:	687b      	ldr	r3, [r7, #4]
 800a4c8:	3301      	adds	r3, #1
 800a4ca:	781b      	ldrb	r3, [r3, #0]
}

static portINLINE uint16_t usChar2u16 (const uint8_t *apChr);
static portINLINE uint16_t usChar2u16 (const uint8_t *apChr)
{
	return ( uint16_t )
 800a4cc:	b29b      	uxth	r3, r3
 800a4ce:	4313      	orrs	r3, r2
 800a4d0:	b29b      	uxth	r3, r3
			( ( ( ( uint32_t )apChr[0] ) << 8) |
			  ( ( ( uint32_t )apChr[1] ) ) );
}
 800a4d2:	4618      	mov	r0, r3
 800a4d4:	370c      	adds	r7, #12
 800a4d6:	46bd      	mov	sp, r7
 800a4d8:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a4dc:	4770      	bx	lr
 800a4de:	bf00      	nop

0800a4e0 <prvTCPSocketIsActive>:

/* prvTCPSocketIsActive() returns true if the socket must be checked.
 * Non-active sockets are waiting for user action, either connect()
 * or close(). */
static BaseType_t prvTCPSocketIsActive( UBaseType_t uxStatus )
{
 800a4e0:	b480      	push	{r7}
 800a4e2:	b083      	sub	sp, #12
 800a4e4:	af00      	add	r7, sp, #0
 800a4e6:	6078      	str	r0, [r7, #4]
	switch( uxStatus )
 800a4e8:	687b      	ldr	r3, [r7, #4]
 800a4ea:	2b0b      	cmp	r3, #11
 800a4ec:	d81c      	bhi.n	800a528 <prvTCPSocketIsActive+0x48>
 800a4ee:	a201      	add	r2, pc, #4	; (adr r2, 800a4f4 <prvTCPSocketIsActive+0x14>)
 800a4f0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a4f4:	0800a525 	.word	0x0800a525
 800a4f8:	0800a529 	.word	0x0800a529
 800a4fc:	0800a529 	.word	0x0800a529
 800a500:	0800a529 	.word	0x0800a529
 800a504:	0800a529 	.word	0x0800a529
 800a508:	0800a529 	.word	0x0800a529
 800a50c:	0800a529 	.word	0x0800a529
 800a510:	0800a525 	.word	0x0800a525
 800a514:	0800a525 	.word	0x0800a525
 800a518:	0800a525 	.word	0x0800a525
 800a51c:	0800a529 	.word	0x0800a529
 800a520:	0800a525 	.word	0x0800a525
	case eCLOSED:
	case eCLOSE_WAIT:
	case eFIN_WAIT_2:
	case eCLOSING:
	case eTIME_WAIT:
		return pdFALSE;
 800a524:	2300      	movs	r3, #0
 800a526:	e000      	b.n	800a52a <prvTCPSocketIsActive+0x4a>
	default:
		return pdTRUE;
 800a528:	2301      	movs	r3, #1
	}
}
 800a52a:	4618      	mov	r0, r3
 800a52c:	370c      	adds	r7, #12
 800a52e:	46bd      	mov	sp, r7
 800a530:	f85d 7b04 	ldr.w	r7, [sp], #4
 800a534:	4770      	bx	lr
 800a536:	bf00      	nop

0800a538 <prvTCPStatusAgeCheck>:
/*-----------------------------------------------------------*/

#if( ipconfigTCP_HANG_PROTECTION == 1 )

	static BaseType_t prvTCPStatusAgeCheck( FreeRTOS_Socket_t *pxSocket )
	{
 800a538:	b580      	push	{r7, lr}
 800a53a:	b084      	sub	sp, #16
 800a53c:	af00      	add	r7, sp, #0
 800a53e:	6078      	str	r0, [r7, #4]
	BaseType_t xResult;
		switch( pxSocket->u.xTCP.ucTCPState )
 800a540:	687b      	ldr	r3, [r7, #4]
 800a542:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800a546:	2b08      	cmp	r3, #8
 800a548:	d81a      	bhi.n	800a580 <prvTCPStatusAgeCheck+0x48>
 800a54a:	a201      	add	r2, pc, #4	; (adr r2, 800a550 <prvTCPStatusAgeCheck+0x18>)
 800a54c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800a550:	0800a57b 	.word	0x0800a57b
 800a554:	0800a57b 	.word	0x0800a57b
 800a558:	0800a581 	.word	0x0800a581
 800a55c:	0800a581 	.word	0x0800a581
 800a560:	0800a581 	.word	0x0800a581
 800a564:	0800a575 	.word	0x0800a575
 800a568:	0800a581 	.word	0x0800a581
 800a56c:	0800a581 	.word	0x0800a581
 800a570:	0800a57b 	.word	0x0800a57b
		{
		case eESTABLISHED:
			/* If the 'ipconfigTCP_KEEP_ALIVE' option is enabled, sockets in
			state ESTABLISHED can be protected using keep-alive messages. */
			xResult = pdFALSE;
 800a574:	2300      	movs	r3, #0
 800a576:	60fb      	str	r3, [r7, #12]
			break;
 800a578:	e005      	b.n	800a586 <prvTCPStatusAgeCheck+0x4e>
		case eCLOSED:
		case eTCP_LISTEN:
		case eCLOSE_WAIT:
			/* These 3 states may last for ever, up to the owner. */
			xResult = pdFALSE;
 800a57a:	2300      	movs	r3, #0
 800a57c:	60fb      	str	r3, [r7, #12]
			break;
 800a57e:	e002      	b.n	800a586 <prvTCPStatusAgeCheck+0x4e>
		default:
			/* All other (non-connected) states will get anti-hanging
			protection. */
			xResult = pdTRUE;
 800a580:	2301      	movs	r3, #1
 800a582:	60fb      	str	r3, [r7, #12]
			break;
 800a584:	bf00      	nop
		}
		if( xResult != pdFALSE )
 800a586:	68fb      	ldr	r3, [r7, #12]
 800a588:	2b00      	cmp	r3, #0
 800a58a:	d025      	beq.n	800a5d8 <prvTCPStatusAgeCheck+0xa0>
		{
			/* How much time has past since the last active moment which is
			defined as A) a state change or B) a packet has arrived. */
			TickType_t xAge = xTaskGetTickCount( ) - pxSocket->u.xTCP.xLastActTime;
 800a58c:	f7fa fffa 	bl	8005584 <xTaskGetTickCount>
 800a590:	4602      	mov	r2, r0
 800a592:	687b      	ldr	r3, [r7, #4]
 800a594:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800a596:	1ad3      	subs	r3, r2, r3
 800a598:	60bb      	str	r3, [r7, #8]

			/* ipconfigTCP_HANG_PROTECTION_TIME is in units of seconds. */
			if( xAge > ( ipconfigTCP_HANG_PROTECTION_TIME * configTICK_RATE_HZ ) )
 800a59a:	68bb      	ldr	r3, [r7, #8]
 800a59c:	f247 5230 	movw	r2, #30000	; 0x7530
 800a5a0:	4293      	cmp	r3, r2
 800a5a2:	d919      	bls.n	800a5d8 <prvTCPStatusAgeCheck+0xa0>
						FreeRTOS_GetTCPStateName( ( UBaseType_t ) pxSocket->u.xTCP.ucTCPState ) ) );
				}
				#endif /* ipconfigHAS_DEBUG_PRINTF */

				/* Move to eCLOSE_WAIT, user may close the socket. */
				vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800a5a4:	6878      	ldr	r0, [r7, #4]
 800a5a6:	2108      	movs	r1, #8
 800a5a8:	f000 fd56 	bl	800b058 <vTCPStateChange>

				/* When 'bPassQueued' true, this socket is an orphan until it
				gets connected. */
				if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 800a5ac:	687b      	ldr	r3, [r7, #4]
 800a5ae:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800a5b2:	f003 0304 	and.w	r3, r3, #4
 800a5b6:	b2db      	uxtb	r3, r3
 800a5b8:	2b00      	cmp	r3, #0
 800a5ba:	d00d      	beq.n	800a5d8 <prvTCPStatusAgeCheck+0xa0>
				{
					if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 800a5bc:	687b      	ldr	r3, [r7, #4]
 800a5be:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800a5c2:	f003 0308 	and.w	r3, r3, #8
 800a5c6:	b2db      	uxtb	r3, r3
 800a5c8:	2b00      	cmp	r3, #0
 800a5ca:	d102      	bne.n	800a5d2 <prvTCPStatusAgeCheck+0x9a>
					{
						/* As it did not get connected, and the user can never
						accept() it anymore, it will be deleted now.  Called from
						the IP-task, so it's safe to call the internal Close
						function: vSocketClose(). */
						vSocketClose( pxSocket );
 800a5cc:	6878      	ldr	r0, [r7, #4]
 800a5ce:	f7fe fe57 	bl	8009280 <vSocketClose>
					}
					/* Return a negative value to tell to inform the caller
					xTCPTimerCheck()
					that the socket got closed and may not be accessed anymore. */
					xResult = -1;
 800a5d2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800a5d6:	60fb      	str	r3, [r7, #12]
				}
			}
		}
		return xResult;
 800a5d8:	68fb      	ldr	r3, [r7, #12]
	}
 800a5da:	4618      	mov	r0, r3
 800a5dc:	3710      	adds	r7, #16
 800a5de:	46bd      	mov	sp, r7
 800a5e0:	bd80      	pop	{r7, pc}
 800a5e2:	bf00      	nop

0800a5e4 <xTCPSocketCheck>:
 *		prvTCPSendRepeated()			// Send at most 8 messages on a row
 *			prvTCPReturnPacket()		// Prepare for returning
 *			xNetworkInterfaceOutput()	// Sends data to the NIC ( declared in portable/NetworkInterface/xxx )
 */
BaseType_t xTCPSocketCheck( FreeRTOS_Socket_t *pxSocket )
{
 800a5e4:	b580      	push	{r7, lr}
 800a5e6:	b084      	sub	sp, #16
 800a5e8:	af00      	add	r7, sp, #0
 800a5ea:	6078      	str	r0, [r7, #4]
BaseType_t xResult = 0;
 800a5ec:	2300      	movs	r3, #0
 800a5ee:	60fb      	str	r3, [r7, #12]
BaseType_t xReady = pdFALSE;
 800a5f0:	2300      	movs	r3, #0
 800a5f2:	60bb      	str	r3, [r7, #8]

	if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) && ( pxSocket->u.xTCP.txStream != NULL ) )
 800a5f4:	687b      	ldr	r3, [r7, #4]
 800a5f6:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800a5fa:	2b04      	cmp	r3, #4
 800a5fc:	d906      	bls.n	800a60c <xTCPSocketCheck+0x28>
 800a5fe:	687b      	ldr	r3, [r7, #4]
 800a600:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800a602:	2b00      	cmp	r3, #0
 800a604:	d002      	beq.n	800a60c <xTCPSocketCheck+0x28>
	{
		/* The API FreeRTOS_send() might have added data to the TX stream.  Add
		this data to the windowing system to it can be transmitted. */
		prvTCPAddTxData( pxSocket );
 800a606:	6878      	ldr	r0, [r7, #4]
 800a608:	f001 f852 	bl	800b6b0 <prvTCPAddTxData>
	}

	#if ipconfigUSE_TCP_WIN == 1
	{
		if( pxSocket->u.xTCP.pxAckMessage != NULL )
 800a60c:	687b      	ldr	r3, [r7, #4]
 800a60e:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800a610:	2b00      	cmp	r3, #0
 800a612:	d02e      	beq.n	800a672 <xTCPSocketCheck+0x8e>
		{
			/* The first task of this regular socket check is to send-out delayed
			ACK's. */
			if( pxSocket->u.xTCP.bits.bUserShutdown == pdFALSE_UNSIGNED )
 800a614:	687b      	ldr	r3, [r7, #4]
 800a616:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800a61a:	f003 0320 	and.w	r3, r3, #32
 800a61e:	b2db      	uxtb	r3, r3
 800a620:	2b00      	cmp	r3, #0
 800a622:	d11a      	bne.n	800a65a <xTCPSocketCheck+0x76>
			{
				/* Earlier data was received but not yet acknowledged.  This
				function is called when the TCP timer for the socket expires, the
				ACK may be sent now. */
				if( pxSocket->u.xTCP.ucTCPState != eCLOSED )
 800a624:	687b      	ldr	r3, [r7, #4]
 800a626:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800a62a:	2b00      	cmp	r3, #0
 800a62c:	d00d      	beq.n	800a64a <xTCPSocketCheck+0x66>
				{
					if( xTCPWindowLoggingLevel > 1 && ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) )
 800a62e:	4b1f      	ldr	r3, [pc, #124]	; (800a6ac <xTCPSocketCheck+0xc8>)
 800a630:	681b      	ldr	r3, [r3, #0]
 800a632:	2b01      	cmp	r3, #1
							pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber,
							pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber   - pxSocket->u.xTCP.xTCPWindow.tx.ulFirstSequenceNumber,
							ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ) );
					}

					prvTCPReturnPacket( pxSocket, pxSocket->u.xTCP.pxAckMessage, ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER, ipconfigZERO_COPY_TX_DRIVER );
 800a634:	687b      	ldr	r3, [r7, #4]
 800a636:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800a638:	6878      	ldr	r0, [r7, #4]
 800a63a:	4619      	mov	r1, r3
 800a63c:	2228      	movs	r2, #40	; 0x28
 800a63e:	2301      	movs	r3, #1
 800a640:	f000 f8c4 	bl	800a7cc <prvTCPReturnPacket>

					#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
					{
						/* The ownership has been passed to the SEND routine,
						clear the pointer to it. */
						pxSocket->u.xTCP.pxAckMessage = NULL;
 800a644:	687b      	ldr	r3, [r7, #4]
 800a646:	2200      	movs	r2, #0
 800a648:	67da      	str	r2, [r3, #124]	; 0x7c
					}
					#endif /* ipconfigZERO_COPY_TX_DRIVER */
				}
				if( prvTCPNextTimeout( pxSocket ) > 1 )
 800a64a:	6878      	ldr	r0, [r7, #4]
 800a64c:	f000 ffb0 	bl	800b5b0 <prvTCPNextTimeout>
 800a650:	4603      	mov	r3, r0
 800a652:	2b01      	cmp	r3, #1
 800a654:	d901      	bls.n	800a65a <xTCPSocketCheck+0x76>
				{
					/* Tell the code below that this function is ready. */
					xReady = pdTRUE;
 800a656:	2301      	movs	r3, #1
 800a658:	60bb      	str	r3, [r7, #8]
				/* The user wants to perform an active shutdown(), skip sending
				the	delayed	ACK.  The function prvTCPSendPacket() will send the
				FIN	along with the ACK's. */
			}

			if( pxSocket->u.xTCP.pxAckMessage != NULL )
 800a65a:	687b      	ldr	r3, [r7, #4]
 800a65c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800a65e:	2b00      	cmp	r3, #0
 800a660:	d007      	beq.n	800a672 <xTCPSocketCheck+0x8e>
			{
				vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 800a662:	687b      	ldr	r3, [r7, #4]
 800a664:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800a666:	4618      	mov	r0, r3
 800a668:	f7fd f8b8 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
				pxSocket->u.xTCP.pxAckMessage = NULL;
 800a66c:	687b      	ldr	r3, [r7, #4]
 800a66e:	2200      	movs	r2, #0
 800a670:	67da      	str	r2, [r3, #124]	; 0x7c
			}
		}
	}
	#endif /* ipconfigUSE_TCP_WIN */

	if( xReady == pdFALSE )
 800a672:	68bb      	ldr	r3, [r7, #8]
 800a674:	2b00      	cmp	r3, #0
 800a676:	d113      	bne.n	800a6a0 <xTCPSocketCheck+0xbc>
	{
		/* The second task of this regular socket check is sending out data. */
		if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) ||
 800a678:	687b      	ldr	r3, [r7, #4]
 800a67a:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800a67e:	2b04      	cmp	r3, #4
 800a680:	d804      	bhi.n	800a68c <xTCPSocketCheck+0xa8>
			( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN ) )
 800a682:	687b      	ldr	r3, [r7, #4]
 800a684:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
	#endif /* ipconfigUSE_TCP_WIN */

	if( xReady == pdFALSE )
	{
		/* The second task of this regular socket check is sending out data. */
		if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) ||
 800a688:	2b02      	cmp	r3, #2
 800a68a:	d102      	bne.n	800a692 <xTCPSocketCheck+0xae>
			( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN ) )
		{
			prvTCPSendPacket( pxSocket );
 800a68c:	6878      	ldr	r0, [r7, #4]
 800a68e:	f000 f80f 	bl	800a6b0 <prvTCPSendPacket>
		}

		/* Set the time-out for the next wakeup for this socket. */
		prvTCPNextTimeout( pxSocket );
 800a692:	6878      	ldr	r0, [r7, #4]
 800a694:	f000 ff8c 	bl	800b5b0 <prvTCPNextTimeout>

		#if( ipconfigTCP_HANG_PROTECTION == 1 )
		{
			/* In all (non-connected) states in which keep-alive messages can not be sent
			the anti-hang protocol will close sockets that are 'hanging'. */
			xResult = prvTCPStatusAgeCheck( pxSocket );
 800a698:	6878      	ldr	r0, [r7, #4]
 800a69a:	f7ff ff4d 	bl	800a538 <prvTCPStatusAgeCheck>
 800a69e:	60f8      	str	r0, [r7, #12]
		}
		#endif
	}

	return xResult;
 800a6a0:	68fb      	ldr	r3, [r7, #12]
}
 800a6a2:	4618      	mov	r0, r3
 800a6a4:	3710      	adds	r7, #16
 800a6a6:	46bd      	mov	sp, r7
 800a6a8:	bd80      	pop	{r7, pc}
 800a6aa:	bf00      	nop
 800a6ac:	2000c2b4 	.word	0x2000c2b4

0800a6b0 <prvTCPSendPacket>:
/*
 * prvTCPSendPacket() will be called when the socket time-out has been reached.
 * It is only called by xTCPSocketCheck().
 */
static int32_t prvTCPSendPacket( FreeRTOS_Socket_t *pxSocket )
{
 800a6b0:	b580      	push	{r7, lr}
 800a6b2:	b086      	sub	sp, #24
 800a6b4:	af00      	add	r7, sp, #0
 800a6b6:	6078      	str	r0, [r7, #4]
int32_t lResult = 0;
 800a6b8:	2300      	movs	r3, #0
 800a6ba:	617b      	str	r3, [r7, #20]
UBaseType_t uxOptionsLength;
TCPPacket_t *pxTCPPacket;
NetworkBufferDescriptor_t *pxNetworkBuffer;

	if( pxSocket->u.xTCP.ucTCPState != eCONNECT_SYN )
 800a6bc:	687b      	ldr	r3, [r7, #4]
 800a6be:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800a6c2:	2b02      	cmp	r3, #2
 800a6c4:	d010      	beq.n	800a6e8 <prvTCPSendPacket+0x38>
	{
		/* The connection is in s state other than SYN. */
		pxNetworkBuffer = NULL;
 800a6c6:	2300      	movs	r3, #0
 800a6c8:	60bb      	str	r3, [r7, #8]

		/* prvTCPSendRepeated() will only create a network buffer if necessary,
		i.e. when data must be sent to the peer. */
		lResult = prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
 800a6ca:	f107 0308 	add.w	r3, r7, #8
 800a6ce:	6878      	ldr	r0, [r7, #4]
 800a6d0:	4619      	mov	r1, r3
 800a6d2:	f000 f849 	bl	800a768 <prvTCPSendRepeated>
 800a6d6:	6178      	str	r0, [r7, #20]

		if( pxNetworkBuffer != NULL )
 800a6d8:	68bb      	ldr	r3, [r7, #8]
 800a6da:	2b00      	cmp	r3, #0
 800a6dc:	d03f      	beq.n	800a75e <prvTCPSendPacket+0xae>
		{
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800a6de:	68bb      	ldr	r3, [r7, #8]
 800a6e0:	4618      	mov	r0, r3
 800a6e2:	f7fd f87b 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
 800a6e6:	e03a      	b.n	800a75e <prvTCPSendPacket+0xae>
		}
	}
	else
	{
		if( pxSocket->u.xTCP.ucRepCount >= 3u )
 800a6e8:	687b      	ldr	r3, [r7, #4]
 800a6ea:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
 800a6ee:	2b02      	cmp	r3, #2
 800a6f0:	d904      	bls.n	800a6fc <prvTCPSendPacket+0x4c>
			to most 3 times.  When there is no response, the socket get the
			status 'eCLOSE_WAIT'. */
			FreeRTOS_debug_printf( ( "Connect: giving up %lxip:%u\n",
				pxSocket->u.xTCP.ulRemoteIP,		/* IP address of remote machine. */
				pxSocket->u.xTCP.usRemotePort ) );	/* Port on remote machine. */
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800a6f2:	6878      	ldr	r0, [r7, #4]
 800a6f4:	2108      	movs	r1, #8
 800a6f6:	f000 fcaf 	bl	800b058 <vTCPStateChange>
 800a6fa:	e030      	b.n	800a75e <prvTCPSendPacket+0xae>
		}
		else if( ( pxSocket->u.xTCP.bits.bConnPrepared != pdFALSE_UNSIGNED ) || ( prvTCPPrepareConnect( pxSocket ) == pdTRUE ) )
 800a6fc:	687b      	ldr	r3, [r7, #4]
 800a6fe:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800a702:	f003 0308 	and.w	r3, r3, #8
 800a706:	b2db      	uxtb	r3, r3
 800a708:	2b00      	cmp	r3, #0
 800a70a:	d105      	bne.n	800a718 <prvTCPSendPacket+0x68>
 800a70c:	6878      	ldr	r0, [r7, #4]
 800a70e:	f000 fa3d 	bl	800ab8c <prvTCPPrepareConnect>
 800a712:	4603      	mov	r3, r0
 800a714:	2b01      	cmp	r3, #1
 800a716:	d122      	bne.n	800a75e <prvTCPSendPacket+0xae>
		{
			/* Or else, if the connection has been prepared, or can be prepared
			now, proceed to send the packet with the SYN flag.
			prvTCPPrepareConnect() prepares 'xPacket' and returns pdTRUE if
			the Ethernet address of the peer or the gateway is found. */
			pxTCPPacket = ( TCPPacket_t * )pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 800a718:	687b      	ldr	r3, [r7, #4]
 800a71a:	3382      	adds	r3, #130	; 0x82
 800a71c:	613b      	str	r3, [r7, #16]
			#endif

			/* About to send a SYN packet.  Call prvSetSynAckOptions() to set
			the proper options: The size of MSS and whether SACK's are
			allowed. */
			uxOptionsLength = prvSetSynAckOptions( pxSocket, pxTCPPacket );
 800a71e:	6878      	ldr	r0, [r7, #4]
 800a720:	6939      	ldr	r1, [r7, #16]
 800a722:	f000 fc21 	bl	800af68 <prvSetSynAckOptions>
 800a726:	60f8      	str	r0, [r7, #12]

			/* Return the number of bytes to be sent. */
			lResult = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 800a728:	68fb      	ldr	r3, [r7, #12]
 800a72a:	3328      	adds	r3, #40	; 0x28
 800a72c:	617b      	str	r3, [r7, #20]

			/* Set the TCP offset field:  ipSIZE_OF_TCP_HEADER equals 20 and
			uxOptionsLength is always a multiple of 4.  The complete expression
			would be:
			ucTCPOffset = ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) / 4 ) << 4 */
			pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800a72e:	68fb      	ldr	r3, [r7, #12]
 800a730:	b2db      	uxtb	r3, r3
 800a732:	3314      	adds	r3, #20
 800a734:	b2db      	uxtb	r3, r3
 800a736:	009b      	lsls	r3, r3, #2
 800a738:	b2da      	uxtb	r2, r3
 800a73a:	693b      	ldr	r3, [r7, #16]
 800a73c:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

			/* Repeat Count is used for a connecting socket, to limit the number
			of tries. */
			pxSocket->u.xTCP.ucRepCount++;
 800a740:	687b      	ldr	r3, [r7, #4]
 800a742:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
 800a746:	3301      	adds	r3, #1
 800a748:	b2da      	uxtb	r2, r3
 800a74a:	687b      	ldr	r3, [r7, #4]
 800a74c:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52

			/* Send the SYN message to make a connection.  The messages is
			stored in the socket field 'xPacket'.  It will be wrapped in a
			pseudo network buffer descriptor before it will be sent. */
			prvTCPReturnPacket( pxSocket, NULL, ( uint32_t ) lResult, pdFALSE );
 800a750:	697b      	ldr	r3, [r7, #20]
 800a752:	6878      	ldr	r0, [r7, #4]
 800a754:	2100      	movs	r1, #0
 800a756:	461a      	mov	r2, r3
 800a758:	2300      	movs	r3, #0
 800a75a:	f000 f837 	bl	800a7cc <prvTCPReturnPacket>
		}
	}

	/* Return the total number of bytes sent. */
	return lResult;
 800a75e:	697b      	ldr	r3, [r7, #20]
}
 800a760:	4618      	mov	r0, r3
 800a762:	3718      	adds	r7, #24
 800a764:	46bd      	mov	sp, r7
 800a766:	bd80      	pop	{r7, pc}

0800a768 <prvTCPSendRepeated>:
/*
 * prvTCPSendRepeated will try to send a series of messages, as long as there is
 * data to be sent and as long as the transmit window isn't full.
 */
static int32_t prvTCPSendRepeated( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer )
{
 800a768:	b580      	push	{r7, lr}
 800a76a:	b086      	sub	sp, #24
 800a76c:	af00      	add	r7, sp, #0
 800a76e:	6078      	str	r0, [r7, #4]
 800a770:	6039      	str	r1, [r7, #0]
UBaseType_t uxIndex;
int32_t lResult = 0;
 800a772:	2300      	movs	r3, #0
 800a774:	613b      	str	r3, [r7, #16]
UBaseType_t uxOptionsLength = 0u;
 800a776:	2300      	movs	r3, #0
 800a778:	60fb      	str	r3, [r7, #12]
int32_t xSendLength;

	for( uxIndex = 0u; uxIndex < ( UBaseType_t ) SEND_REPEATED_COUNT; uxIndex++ )
 800a77a:	2300      	movs	r3, #0
 800a77c:	617b      	str	r3, [r7, #20]
 800a77e:	e01c      	b.n	800a7ba <prvTCPSendRepeated+0x52>
	{
		/* prvTCPPrepareSend() might allocate a network buffer if there is data
		to be sent. */
		xSendLength = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
 800a780:	6878      	ldr	r0, [r7, #4]
 800a782:	6839      	ldr	r1, [r7, #0]
 800a784:	68fa      	ldr	r2, [r7, #12]
 800a786:	f000 fda5 	bl	800b2d4 <prvTCPPrepareSend>
 800a78a:	60b8      	str	r0, [r7, #8]
		if( xSendLength <= 0 )
 800a78c:	68bb      	ldr	r3, [r7, #8]
 800a78e:	2b00      	cmp	r3, #0
 800a790:	dc00      	bgt.n	800a794 <prvTCPSendRepeated+0x2c>
		{
			break;
 800a792:	e015      	b.n	800a7c0 <prvTCPSendRepeated+0x58>
		}

		/* And return the packet to the peer. */
		prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_DRIVER );
 800a794:	683b      	ldr	r3, [r7, #0]
 800a796:	681a      	ldr	r2, [r3, #0]
 800a798:	68bb      	ldr	r3, [r7, #8]
 800a79a:	6878      	ldr	r0, [r7, #4]
 800a79c:	4611      	mov	r1, r2
 800a79e:	461a      	mov	r2, r3
 800a7a0:	2301      	movs	r3, #1
 800a7a2:	f000 f813 	bl	800a7cc <prvTCPReturnPacket>

		#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
		{
			*ppxNetworkBuffer = NULL;
 800a7a6:	683b      	ldr	r3, [r7, #0]
 800a7a8:	2200      	movs	r2, #0
 800a7aa:	601a      	str	r2, [r3, #0]
		}
		#endif /* ipconfigZERO_COPY_TX_DRIVER */

		lResult += xSendLength;
 800a7ac:	693a      	ldr	r2, [r7, #16]
 800a7ae:	68bb      	ldr	r3, [r7, #8]
 800a7b0:	4413      	add	r3, r2
 800a7b2:	613b      	str	r3, [r7, #16]
UBaseType_t uxIndex;
int32_t lResult = 0;
UBaseType_t uxOptionsLength = 0u;
int32_t xSendLength;

	for( uxIndex = 0u; uxIndex < ( UBaseType_t ) SEND_REPEATED_COUNT; uxIndex++ )
 800a7b4:	697b      	ldr	r3, [r7, #20]
 800a7b6:	3301      	adds	r3, #1
 800a7b8:	617b      	str	r3, [r7, #20]
 800a7ba:	697b      	ldr	r3, [r7, #20]
 800a7bc:	2b07      	cmp	r3, #7
 800a7be:	d9df      	bls.n	800a780 <prvTCPSendRepeated+0x18>

		lResult += xSendLength;
	}

	/* Return the total number of bytes sent. */
	return lResult;
 800a7c0:	693b      	ldr	r3, [r7, #16]
}
 800a7c2:	4618      	mov	r0, r3
 800a7c4:	3718      	adds	r7, #24
 800a7c6:	46bd      	mov	sp, r7
 800a7c8:	bd80      	pop	{r7, pc}
 800a7ca:	bf00      	nop

0800a7cc <prvTCPReturnPacket>:
 * which may either point to a real network buffer or to a TCP socket field
 * called 'xTCP.xPacket'.   A temporary xNetworkBuffer will be used to pass
 * the data to the NIC.
 */
static void prvTCPReturnPacket( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer, uint32_t ulLen, BaseType_t xReleaseAfterSend )
{
 800a7cc:	b580      	push	{r7, lr}
 800a7ce:	b098      	sub	sp, #96	; 0x60
 800a7d0:	af00      	add	r7, sp, #0
 800a7d2:	60f8      	str	r0, [r7, #12]
 800a7d4:	60b9      	str	r1, [r7, #8]
 800a7d6:	607a      	str	r2, [r7, #4]
 800a7d8:	603b      	str	r3, [r7, #0]
uint32_t ulFrontSpace, ulSpace, ulSourceAddress, ulWinSize;
TCPWindow_t *pxTCPWindow;
NetworkBufferDescriptor_t xTempBuffer;
/* For sending, a pseudo network buffer will be used, as explained above. */

	if( pxNetworkBuffer == NULL )
 800a7da:	68bb      	ldr	r3, [r7, #8]
 800a7dc:	2b00      	cmp	r3, #0
 800a7de:	d109      	bne.n	800a7f4 <prvTCPReturnPacket+0x28>
	{
		pxNetworkBuffer = &xTempBuffer;
 800a7e0:	f107 0310 	add.w	r3, r7, #16
 800a7e4:	60bb      	str	r3, [r7, #8]
		#if( ipconfigUSE_LINKED_RX_MESSAGES != 0 )
		{
			xTempBuffer.pxNextBuffer = NULL;
		}
		#endif
		xTempBuffer.pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 800a7e6:	68fb      	ldr	r3, [r7, #12]
 800a7e8:	3382      	adds	r3, #130	; 0x82
 800a7ea:	62bb      	str	r3, [r7, #40]	; 0x28
		xTempBuffer.xDataLength = sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
 800a7ec:	2346      	movs	r3, #70	; 0x46
 800a7ee:	62fb      	str	r3, [r7, #44]	; 0x2c
		xReleaseAfterSend = pdFALSE;
 800a7f0:	2300      	movs	r3, #0
 800a7f2:	603b      	str	r3, [r7, #0]
	}

	#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
	{
		if( xReleaseAfterSend == pdFALSE )
 800a7f4:	683b      	ldr	r3, [r7, #0]
 800a7f6:	2b00      	cmp	r3, #0
 800a7f8:	d108      	bne.n	800a80c <prvTCPReturnPacket+0x40>
		{
			pxNetworkBuffer = pxDuplicateNetworkBufferWithDescriptor( pxNetworkBuffer, ( BaseType_t ) pxNetworkBuffer->xDataLength );
 800a7fa:	68bb      	ldr	r3, [r7, #8]
 800a7fc:	69db      	ldr	r3, [r3, #28]
 800a7fe:	68b8      	ldr	r0, [r7, #8]
 800a800:	4619      	mov	r1, r3
 800a802:	f7fd fa25 	bl	8007c50 <pxDuplicateNetworkBufferWithDescriptor>
 800a806:	60b8      	str	r0, [r7, #8]
			if( pxNetworkBuffer == NULL )
			{
				FreeRTOS_debug_printf( ( "prvTCPReturnPacket: duplicate failed\n" ) );
			}
			xReleaseAfterSend = pdTRUE;
 800a808:	2301      	movs	r3, #1
 800a80a:	603b      	str	r3, [r7, #0]
		}
	}
	#endif /* ipconfigZERO_COPY_TX_DRIVER */

	if( pxNetworkBuffer != NULL )
 800a80c:	68bb      	ldr	r3, [r7, #8]
 800a80e:	2b00      	cmp	r3, #0
 800a810:	f000 818c 	beq.w	800ab2c <prvTCPReturnPacket+0x360>
	{
		pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800a814:	68bb      	ldr	r3, [r7, #8]
 800a816:	699b      	ldr	r3, [r3, #24]
 800a818:	64fb      	str	r3, [r7, #76]	; 0x4c
		pxIPHeader = &pxTCPPacket->xIPHeader;
 800a81a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a81c:	330e      	adds	r3, #14
 800a81e:	64bb      	str	r3, [r7, #72]	; 0x48
		pxEthernetHeader = &pxTCPPacket->xEthernetHeader;
 800a820:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a822:	647b      	str	r3, [r7, #68]	; 0x44

		/* Fill the packet, using hton translations. */
		if( pxSocket != NULL )
 800a824:	68fb      	ldr	r3, [r7, #12]
 800a826:	2b00      	cmp	r3, #0
 800a828:	f000 80ed 	beq.w	800aa06 <prvTCPReturnPacket+0x23a>
		{
			/* Calculate the space in the RX buffer in order to advertise the
			size of this socket's reception window. */
			pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
 800a82c:	68fb      	ldr	r3, [r7, #12]
 800a82e:	33dc      	adds	r3, #220	; 0xdc
 800a830:	643b      	str	r3, [r7, #64]	; 0x40

			if( pxSocket->u.xTCP.rxStream != NULL )
 800a832:	68fb      	ldr	r3, [r7, #12]
 800a834:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a836:	2b00      	cmp	r3, #0
 800a838:	d006      	beq.n	800a848 <prvTCPReturnPacket+0x7c>
			{
				/* An RX stream was created already, see how much space is
				available. */
				ulFrontSpace = ( uint32_t ) uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 800a83a:	68fb      	ldr	r3, [r7, #12]
 800a83c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800a83e:	4618      	mov	r0, r3
 800a840:	f7ff fdce 	bl	800a3e0 <uxStreamBufferFrontSpace>
 800a844:	65f8      	str	r0, [r7, #92]	; 0x5c
 800a846:	e002      	b.n	800a84e <prvTCPReturnPacket+0x82>
			}
			else
			{
				/* No RX stream has been created, the full stream size is
				available. */
				ulFrontSpace = ( uint32_t ) pxSocket->u.xTCP.uxRxStreamSize;
 800a848:	68fb      	ldr	r3, [r7, #12]
 800a84a:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800a84c:	65fb      	str	r3, [r7, #92]	; 0x5c
			}

			/* Take the minimum of the RX buffer space and the RX window size. */
			ulSpace = FreeRTOS_min_uint32( pxSocket->u.xTCP.ulRxCurWinSize, pxTCPWindow->xSize.ulRxWindowLength );
 800a84e:	68fb      	ldr	r3, [r7, #12]
 800a850:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
 800a854:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a856:	685b      	ldr	r3, [r3, #4]
 800a858:	4610      	mov	r0, r2
 800a85a:	4619      	mov	r1, r3
 800a85c:	f7ff fd5e 	bl	800a31c <FreeRTOS_min_uint32>
 800a860:	65b8      	str	r0, [r7, #88]	; 0x58

			if( ( pxSocket->u.xTCP.bits.bLowWater != pdFALSE_UNSIGNED ) || ( pxSocket->u.xTCP.bits.bRxStopped != pdFALSE_UNSIGNED ) )
 800a862:	68fb      	ldr	r3, [r7, #12]
 800a864:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800a868:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800a86c:	b2db      	uxtb	r3, r3
 800a86e:	2b00      	cmp	r3, #0
 800a870:	d107      	bne.n	800a882 <prvTCPReturnPacket+0xb6>
 800a872:	68fb      	ldr	r3, [r7, #12]
 800a874:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 800a878:	f003 0304 	and.w	r3, r3, #4
 800a87c:	b2db      	uxtb	r3, r3
 800a87e:	2b00      	cmp	r3, #0
 800a880:	d001      	beq.n	800a886 <prvTCPReturnPacket+0xba>
			{
				/* The low-water mark was reached, meaning there was little
				space left.  The socket will wait until the application has read
				or flushed the incoming data, and 'zero-window' will be
				advertised. */
				ulSpace = 0u;
 800a882:	2300      	movs	r3, #0
 800a884:	65bb      	str	r3, [r7, #88]	; 0x58
			}

			/* If possible, advertise an RX window size of at least 1 MSS, otherwise
			the peer might start 'zero window probing', i.e. sending small packets
			(1, 2, 4, 8... bytes). */
			if( ( ulSpace < pxSocket->u.xTCP.usCurMSS ) && ( ulFrontSpace >= pxSocket->u.xTCP.usCurMSS ) )
 800a886:	68fb      	ldr	r3, [r7, #12]
 800a888:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 800a88c:	461a      	mov	r2, r3
 800a88e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800a890:	429a      	cmp	r2, r3
 800a892:	d90a      	bls.n	800a8aa <prvTCPReturnPacket+0xde>
 800a894:	68fb      	ldr	r3, [r7, #12]
 800a896:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 800a89a:	461a      	mov	r2, r3
 800a89c:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 800a89e:	429a      	cmp	r2, r3
 800a8a0:	d803      	bhi.n	800a8aa <prvTCPReturnPacket+0xde>
			{
				ulSpace = pxSocket->u.xTCP.usCurMSS;
 800a8a2:	68fb      	ldr	r3, [r7, #12]
 800a8a4:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 800a8a8:	65bb      	str	r3, [r7, #88]	; 0x58
			}

			/* Avoid overflow of the 16-bit win field. */
			ulWinSize = ( ulSpace >> pxSocket->u.xTCP.ucMyWinScaleFactor );
 800a8aa:	68fb      	ldr	r3, [r7, #12]
 800a8ac:	f893 30c9 	ldrb.w	r3, [r3, #201]	; 0xc9
 800a8b0:	461a      	mov	r2, r3
 800a8b2:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800a8b4:	40d3      	lsrs	r3, r2
 800a8b6:	653b      	str	r3, [r7, #80]	; 0x50
			if( ulWinSize > 0xfffcUL )
 800a8b8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a8ba:	f64f 72fc 	movw	r2, #65532	; 0xfffc
 800a8be:	4293      	cmp	r3, r2
 800a8c0:	d902      	bls.n	800a8c8 <prvTCPReturnPacket+0xfc>
			{
				ulWinSize = 0xfffcUL;
 800a8c2:	f64f 73fc 	movw	r3, #65532	; 0xfffc
 800a8c6:	653b      	str	r3, [r7, #80]	; 0x50
			}

			pxTCPPacket->xTCPHeader.usWindow = FreeRTOS_htons( ( uint16_t ) ulWinSize );
 800a8c8:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a8ca:	b29b      	uxth	r3, r3
 800a8cc:	021b      	lsls	r3, r3, #8
 800a8ce:	b29a      	uxth	r2, r3
 800a8d0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800a8d2:	b29b      	uxth	r3, r3
 800a8d4:	0a1b      	lsrs	r3, r3, #8
 800a8d6:	b29b      	uxth	r3, r3
 800a8d8:	b29b      	uxth	r3, r3
 800a8da:	4313      	orrs	r3, r2
 800a8dc:	b29b      	uxth	r3, r3
 800a8de:	b29a      	uxth	r2, r3
 800a8e0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a8e2:	861a      	strh	r2, [r3, #48]	; 0x30
				}
			}
			#endif /* ipconfigHAS_DEBUG_PRINTF != 0 */

			/* The new window size has been advertised, switch off the flag. */
			pxSocket->u.xTCP.bits.bWinChange = pdFALSE_UNSIGNED;
 800a8e4:	68fa      	ldr	r2, [r7, #12]
 800a8e6:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800a8ea:	f36f 0300 	bfc	r3, #0, #1
 800a8ee:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41

			/* Later on, when deciding to delay an ACK, a precise estimate is needed
			of the free RX space.  At this moment, 'ulHighestRxAllowed' would be the
			highest sequence number minus 1 that the socket will accept. */
			pxSocket->u.xTCP.ulHighestRxAllowed = pxTCPWindow->rx.ulCurrentSequenceNumber + ulSpace;
 800a8f2:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a8f4:	691a      	ldr	r2, [r3, #16]
 800a8f6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 800a8f8:	441a      	add	r2, r3
 800a8fa:	68fb      	ldr	r3, [r7, #12]
 800a8fc:	645a      	str	r2, [r3, #68]	; 0x44

			#if( ipconfigTCP_KEEP_ALIVE == 1 )
				if( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED )
 800a8fe:	68fb      	ldr	r3, [r7, #12]
 800a900:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800a904:	f003 0302 	and.w	r3, r3, #2
 800a908:	b2db      	uxtb	r3, r3
 800a90a:	2b00      	cmp	r3, #0
 800a90c:	d02f      	beq.n	800a96e <prvTCPReturnPacket+0x1a2>
				{
					/* Sending a keep-alive packet, send the current sequence number
					minus 1, which will	be recognised as a keep-alive packet an
					responded to by acknowledging the last byte. */
					pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 800a90e:	68fa      	ldr	r2, [r7, #12]
 800a910:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800a914:	f36f 0341 	bfc	r3, #1, #1
 800a918:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
					pxSocket->u.xTCP.bits.bWaitKeepAlive = pdTRUE_UNSIGNED;
 800a91c:	68fa      	ldr	r2, [r7, #12]
 800a91e:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800a922:	f043 0304 	orr.w	r3, r3, #4
 800a926:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41

					pxTCPPacket->xTCPHeader.ulSequenceNumber = pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber - 1UL;
 800a92a:	68fb      	ldr	r3, [r7, #12]
 800a92c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800a930:	1e5a      	subs	r2, r3, #1
 800a932:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a934:	f8c3 2026 	str.w	r2, [r3, #38]	; 0x26
					pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxTCPPacket->xTCPHeader.ulSequenceNumber );
 800a938:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a93a:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
 800a93e:	061a      	lsls	r2, r3, #24
 800a940:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a942:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
 800a946:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800a94a:	021b      	lsls	r3, r3, #8
 800a94c:	431a      	orrs	r2, r3
 800a94e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a950:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
 800a954:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800a958:	0a1b      	lsrs	r3, r3, #8
 800a95a:	431a      	orrs	r2, r3
 800a95c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a95e:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
 800a962:	0e1b      	lsrs	r3, r3, #24
 800a964:	431a      	orrs	r2, r3
 800a966:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a968:	f8c3 2026 	str.w	r2, [r3, #38]	; 0x26
 800a96c:	e034      	b.n	800a9d8 <prvTCPReturnPacket+0x20c>
				}
				else
			#endif
			{
				pxTCPPacket->xTCPHeader.ulSequenceNumber = FreeRTOS_htonl( pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber );
 800a96e:	68fb      	ldr	r3, [r7, #12]
 800a970:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800a974:	061a      	lsls	r2, r3, #24
 800a976:	68fb      	ldr	r3, [r7, #12]
 800a978:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800a97c:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800a980:	021b      	lsls	r3, r3, #8
 800a982:	431a      	orrs	r2, r3
 800a984:	68fb      	ldr	r3, [r7, #12]
 800a986:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800a98a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800a98e:	0a1b      	lsrs	r3, r3, #8
 800a990:	431a      	orrs	r2, r3
 800a992:	68fb      	ldr	r3, [r7, #12]
 800a994:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
 800a998:	0e1b      	lsrs	r3, r3, #24
 800a99a:	431a      	orrs	r2, r3
 800a99c:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a99e:	f8c3 2026 	str.w	r2, [r3, #38]	; 0x26

				if( ( pxTCPPacket->xTCPHeader.ucTCPFlags & ( uint8_t ) ipTCP_FLAG_FIN ) != 0u )
 800a9a2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9a4:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800a9a8:	f003 0301 	and.w	r3, r3, #1
 800a9ac:	2b00      	cmp	r3, #0
 800a9ae:	d013      	beq.n	800a9d8 <prvTCPReturnPacket+0x20c>
				{
					/* Suppress FIN in case this packet carries earlier data to be
					retransmitted. */
					uint32_t ulDataLen = ( uint32_t ) ( ulLen - ( ipSIZE_OF_TCP_HEADER + ipSIZE_OF_IPv4_HEADER ) );
 800a9b0:	687b      	ldr	r3, [r7, #4]
 800a9b2:	3b28      	subs	r3, #40	; 0x28
 800a9b4:	63fb      	str	r3, [r7, #60]	; 0x3c
					if( ( pxTCPWindow->ulOurSequenceNumber + ulDataLen ) != pxTCPWindow->tx.ulFINSequenceNumber )
 800a9b6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a9b8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800a9ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800a9bc:	441a      	add	r2, r3
 800a9be:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a9c0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800a9c2:	429a      	cmp	r2, r3
 800a9c4:	d008      	beq.n	800a9d8 <prvTCPReturnPacket+0x20c>
					{
						pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_FIN );
 800a9c6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9c8:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800a9cc:	f023 0301 	bic.w	r3, r3, #1
 800a9d0:	b2da      	uxtb	r2, r3
 800a9d2:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800a9d4:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
					}
				}
			}

			/* Tell which sequence number is expected next time */
			pxTCPPacket->xTCPHeader.ulAckNr = FreeRTOS_htonl( pxTCPWindow->rx.ulCurrentSequenceNumber );
 800a9d8:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a9da:	691b      	ldr	r3, [r3, #16]
 800a9dc:	061a      	lsls	r2, r3, #24
 800a9de:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a9e0:	691b      	ldr	r3, [r3, #16]
 800a9e2:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800a9e6:	021b      	lsls	r3, r3, #8
 800a9e8:	431a      	orrs	r2, r3
 800a9ea:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a9ec:	691b      	ldr	r3, [r3, #16]
 800a9ee:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800a9f2:	0a1b      	lsrs	r3, r3, #8
 800a9f4:	431a      	orrs	r2, r3
 800a9f6:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a9f8:	691b      	ldr	r3, [r3, #16]
 800a9fa:	0e1b      	lsrs	r3, r3, #24
 800a9fc:	431a      	orrs	r2, r3
 800a9fe:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa00:	f8c3 202a 	str.w	r2, [r3, #42]	; 0x2a
 800aa04:	e00d      	b.n	800aa22 <prvTCPReturnPacket+0x256>
		}
		else
		{
			/* Sending data without a socket, probably replying with a RST flag
			Just swap the two sequence numbers. */
			vFlip_32( pxTCPPacket->xTCPHeader.ulSequenceNumber, pxTCPPacket->xTCPHeader.ulAckNr );
 800aa06:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa08:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
 800aa0c:	63bb      	str	r3, [r7, #56]	; 0x38
 800aa0e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa10:	f8d3 202a 	ldr.w	r2, [r3, #42]	; 0x2a
 800aa14:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa16:	f8c3 2026 	str.w	r2, [r3, #38]	; 0x26
 800aa1a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa1c:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800aa1e:	f8c3 202a 	str.w	r2, [r3, #42]	; 0x2a
		}

		pxIPHeader->ucTimeToLive           = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 800aa22:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800aa24:	2280      	movs	r2, #128	; 0x80
 800aa26:	721a      	strb	r2, [r3, #8]
		pxIPHeader->usLength               = FreeRTOS_htons( ulLen );
 800aa28:	687b      	ldr	r3, [r7, #4]
 800aa2a:	b29b      	uxth	r3, r3
 800aa2c:	021b      	lsls	r3, r3, #8
 800aa2e:	b29a      	uxth	r2, r3
 800aa30:	687b      	ldr	r3, [r7, #4]
 800aa32:	0a1b      	lsrs	r3, r3, #8
 800aa34:	b29b      	uxth	r3, r3
 800aa36:	4313      	orrs	r3, r2
 800aa38:	b29a      	uxth	r2, r3
 800aa3a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800aa3c:	805a      	strh	r2, [r3, #2]
		if( ( pxSocket == NULL ) || ( *ipLOCAL_IP_ADDRESS_POINTER == 0ul ) )
 800aa3e:	68fb      	ldr	r3, [r7, #12]
 800aa40:	2b00      	cmp	r3, #0
 800aa42:	d003      	beq.n	800aa4c <prvTCPReturnPacket+0x280>
 800aa44:	4b3b      	ldr	r3, [pc, #236]	; (800ab34 <prvTCPReturnPacket+0x368>)
 800aa46:	695b      	ldr	r3, [r3, #20]
 800aa48:	2b00      	cmp	r3, #0
 800aa4a:	d103      	bne.n	800aa54 <prvTCPReturnPacket+0x288>
		{
			/* When pxSocket is NULL, this function is called by prvTCPSendReset()
			and the IP-addresses must be swapped.
			Also swap the IP-addresses in case the IP-tack doesn't have an
			IP-address yet, i.e. when ( *ipLOCAL_IP_ADDRESS_POINTER == 0ul ). */
			ulSourceAddress = pxIPHeader->ulDestinationIPAddress;
 800aa4c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800aa4e:	691b      	ldr	r3, [r3, #16]
 800aa50:	657b      	str	r3, [r7, #84]	; 0x54
 800aa52:	e002      	b.n	800aa5a <prvTCPReturnPacket+0x28e>
		}
		else
		{
			ulSourceAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 800aa54:	4b37      	ldr	r3, [pc, #220]	; (800ab34 <prvTCPReturnPacket+0x368>)
 800aa56:	695b      	ldr	r3, [r3, #20]
 800aa58:	657b      	str	r3, [r7, #84]	; 0x54
		}
		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 800aa5a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800aa5c:	68da      	ldr	r2, [r3, #12]
 800aa5e:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800aa60:	611a      	str	r2, [r3, #16]
		pxIPHeader->ulSourceIPAddress = ulSourceAddress;
 800aa62:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800aa64:	6d7a      	ldr	r2, [r7, #84]	; 0x54
 800aa66:	60da      	str	r2, [r3, #12]
		vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort );
 800aa68:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa6a:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 800aa6e:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 800aa72:	021b      	lsls	r3, r3, #8
 800aa74:	4313      	orrs	r3, r2
 800aa76:	86fb      	strh	r3, [r7, #54]	; 0x36
 800aa78:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa7a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800aa7c:	b29a      	uxth	r2, r3
 800aa7e:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa80:	845a      	strh	r2, [r3, #34]	; 0x22
 800aa82:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aa84:	8efa      	ldrh	r2, [r7, #54]	; 0x36
 800aa86:	849a      	strh	r2, [r3, #36]	; 0x24

		/* Just an increasing number. */
		pxIPHeader->usIdentification = FreeRTOS_htons( usPacketIdentifier );
 800aa88:	4b2b      	ldr	r3, [pc, #172]	; (800ab38 <prvTCPReturnPacket+0x36c>)
 800aa8a:	881b      	ldrh	r3, [r3, #0]
 800aa8c:	021b      	lsls	r3, r3, #8
 800aa8e:	b29a      	uxth	r2, r3
 800aa90:	4b29      	ldr	r3, [pc, #164]	; (800ab38 <prvTCPReturnPacket+0x36c>)
 800aa92:	881b      	ldrh	r3, [r3, #0]
 800aa94:	0a1b      	lsrs	r3, r3, #8
 800aa96:	b29b      	uxth	r3, r3
 800aa98:	b29b      	uxth	r3, r3
 800aa9a:	4313      	orrs	r3, r2
 800aa9c:	b29b      	uxth	r3, r3
 800aa9e:	b29a      	uxth	r2, r3
 800aaa0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800aaa2:	809a      	strh	r2, [r3, #4]
		usPacketIdentifier++;
 800aaa4:	4b24      	ldr	r3, [pc, #144]	; (800ab38 <prvTCPReturnPacket+0x36c>)
 800aaa6:	881b      	ldrh	r3, [r3, #0]
 800aaa8:	3301      	adds	r3, #1
 800aaaa:	b29a      	uxth	r2, r3
 800aaac:	4b22      	ldr	r3, [pc, #136]	; (800ab38 <prvTCPReturnPacket+0x36c>)
 800aaae:	801a      	strh	r2, [r3, #0]
		pxIPHeader->usFragmentOffset = 0u;
 800aab0:	6cbb      	ldr	r3, [r7, #72]	; 0x48
 800aab2:	2200      	movs	r2, #0
 800aab4:	719a      	strb	r2, [r3, #6]
 800aab6:	2200      	movs	r2, #0
 800aab8:	71da      	strb	r2, [r3, #7]
	#if( ipconfigUSE_LINKED_RX_MESSAGES != 0 )
		pxNetworkBuffer->pxNextBuffer = NULL;
	#endif

		/* Important: tell NIC driver how many bytes must be sent. */
		pxNetworkBuffer->xDataLength = ulLen + ipSIZE_OF_ETH_HEADER;
 800aaba:	687b      	ldr	r3, [r7, #4]
 800aabc:	f103 020e 	add.w	r2, r3, #14
 800aac0:	68bb      	ldr	r3, [r7, #8]
 800aac2:	61da      	str	r2, [r3, #28]

		/* Fill in the destination MAC addresses. */
		memcpy( ( void * ) &( pxEthernetHeader->xDestinationAddress ), ( void * ) &( pxEthernetHeader->xSourceAddress ),
 800aac4:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800aac6:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800aac8:	3306      	adds	r3, #6
 800aaca:	4610      	mov	r0, r2
 800aacc:	4619      	mov	r1, r3
 800aace:	2206      	movs	r2, #6
 800aad0:	f005 faea 	bl	80100a8 <memcpy>
			sizeof( pxEthernetHeader->xDestinationAddress ) );

		/* The source MAC addresses is fixed to 'ipLOCAL_MAC_ADDRESS'. */
		memcpy( ( void * ) &( pxEthernetHeader->xSourceAddress) , ( void * ) ipLOCAL_MAC_ADDRESS, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 800aad4:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800aad6:	3306      	adds	r3, #6
 800aad8:	4618      	mov	r0, r3
 800aada:	4916      	ldr	r1, [pc, #88]	; (800ab34 <prvTCPReturnPacket+0x368>)
 800aadc:	2206      	movs	r2, #6
 800aade:	f005 fae3 	bl	80100a8 <memcpy>
			}
		}
		#endif

		/* Send! */
		xNetworkInterfaceOutput( pxNetworkBuffer, xReleaseAfterSend );
 800aae2:	68b8      	ldr	r0, [r7, #8]
 800aae4:	6839      	ldr	r1, [r7, #0]
 800aae6:	f7fc f921 	bl	8006d2c <xNetworkInterfaceOutput>

		if( xReleaseAfterSend == pdFALSE )
 800aaea:	683b      	ldr	r3, [r7, #0]
 800aaec:	2b00      	cmp	r3, #0
 800aaee:	d11d      	bne.n	800ab2c <prvTCPReturnPacket+0x360>
		{
			/* Swap-back some fields, as pxBuffer probably points to a socket field
			containing the packet header. */
			vFlip_16( pxTCPPacket->xTCPHeader.usSourcePort, pxTCPPacket->xTCPHeader.usDestinationPort);
 800aaf0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800aaf2:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 800aaf6:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 800aafa:	021b      	lsls	r3, r3, #8
 800aafc:	4313      	orrs	r3, r2
 800aafe:	86bb      	strh	r3, [r7, #52]	; 0x34
 800ab00:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ab02:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800ab04:	b29a      	uxth	r2, r3
 800ab06:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ab08:	845a      	strh	r2, [r3, #34]	; 0x22
 800ab0a:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ab0c:	8eba      	ldrh	r2, [r7, #52]	; 0x34
 800ab0e:	849a      	strh	r2, [r3, #36]	; 0x24
			pxTCPPacket->xIPHeader.ulSourceIPAddress = pxTCPPacket->xIPHeader.ulDestinationIPAddress;
 800ab10:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ab12:	f8d3 201e 	ldr.w	r2, [r3, #30]
 800ab16:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
 800ab18:	f8c3 201a 	str.w	r2, [r3, #26]
			memcpy( pxEthernetHeader->xSourceAddress.ucBytes, pxEthernetHeader->xDestinationAddress.ucBytes, ( size_t ) ipMAC_ADDRESS_LENGTH_BYTES );
 800ab1c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ab1e:	1d9a      	adds	r2, r3, #6
 800ab20:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800ab22:	4610      	mov	r0, r2
 800ab24:	4619      	mov	r1, r3
 800ab26:	2206      	movs	r2, #6
 800ab28:	f005 fabe 	bl	80100a8 <memcpy>
		else
		{
			/* Nothing to do: the buffer has been passed to DMA and will be released after use */
		}
	} /* if( pxNetworkBuffer != NULL ) */
}
 800ab2c:	3760      	adds	r7, #96	; 0x60
 800ab2e:	46bd      	mov	sp, r7
 800ab30:	bd80      	pop	{r7, pc}
 800ab32:	bf00      	nop
 800ab34:	2000bb08 	.word	0x2000bb08
 800ab38:	2000c1c0 	.word	0x2000c1c0

0800ab3c <prvTCPCreateWindow>:
 * random starting value, are being synchronised.  The sliding window manager
 * (in FreeRTOS_TCP_WIN.c) needs to know them, along with the Maximum Segment
 * Size (MSS) in use.
 */
static void prvTCPCreateWindow( FreeRTOS_Socket_t *pxSocket )
{
 800ab3c:	b5b0      	push	{r4, r5, r7, lr}
 800ab3e:	b084      	sub	sp, #16
 800ab40:	af02      	add	r7, sp, #8
 800ab42:	6078      	str	r0, [r7, #4]
		FreeRTOS_debug_printf( ( "Limits (using): TCP Win size %lu Water %lu <= %lu <= %lu\n",
			pxSocket->u.xTCP.uxRxWinSize * ipconfigTCP_MSS,
			pxSocket->u.xTCP.uxLittleSpace ,
			pxSocket->u.xTCP.uxEnoughSpace,
			pxSocket->u.xTCP.uxRxStreamSize ) );
	vTCPWindowCreate(
 800ab44:	687b      	ldr	r3, [r7, #4]
 800ab46:	f103 00dc 	add.w	r0, r3, #220	; 0xdc
		&pxSocket->u.xTCP.xTCPWindow,
		ipconfigTCP_MSS * pxSocket->u.xTCP.uxRxWinSize,
 800ab4a:	687b      	ldr	r3, [r7, #4]
 800ab4c:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800ab50:	f240 52b4 	movw	r2, #1460	; 0x5b4
 800ab54:	fb02 f103 	mul.w	r1, r2, r3
		ipconfigTCP_MSS * pxSocket->u.xTCP.uxTxWinSize,
 800ab58:	687b      	ldr	r3, [r7, #4]
 800ab5a:	f8d3 30d8 	ldr.w	r3, [r3, #216]	; 0xd8
 800ab5e:	f240 52b4 	movw	r2, #1460	; 0x5b4
 800ab62:	fb02 f503 	mul.w	r5, r2, r3
		FreeRTOS_debug_printf( ( "Limits (using): TCP Win size %lu Water %lu <= %lu <= %lu\n",
			pxSocket->u.xTCP.uxRxWinSize * ipconfigTCP_MSS,
			pxSocket->u.xTCP.uxLittleSpace ,
			pxSocket->u.xTCP.uxEnoughSpace,
			pxSocket->u.xTCP.uxRxStreamSize ) );
	vTCPWindowCreate(
 800ab66:	687b      	ldr	r3, [r7, #4]
 800ab68:	f8d3 40ec 	ldr.w	r4, [r3, #236]	; 0xec
 800ab6c:	687b      	ldr	r3, [r7, #4]
 800ab6e:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
		&pxSocket->u.xTCP.xTCPWindow,
		ipconfigTCP_MSS * pxSocket->u.xTCP.uxRxWinSize,
		ipconfigTCP_MSS * pxSocket->u.xTCP.uxTxWinSize,
		pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber,
		pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber,
		( uint32_t ) pxSocket->u.xTCP.usInitMSS );
 800ab72:	687a      	ldr	r2, [r7, #4]
 800ab74:	f8b2 204c 	ldrh.w	r2, [r2, #76]	; 0x4c
		FreeRTOS_debug_printf( ( "Limits (using): TCP Win size %lu Water %lu <= %lu <= %lu\n",
			pxSocket->u.xTCP.uxRxWinSize * ipconfigTCP_MSS,
			pxSocket->u.xTCP.uxLittleSpace ,
			pxSocket->u.xTCP.uxEnoughSpace,
			pxSocket->u.xTCP.uxRxStreamSize ) );
	vTCPWindowCreate(
 800ab78:	9300      	str	r3, [sp, #0]
 800ab7a:	9201      	str	r2, [sp, #4]
 800ab7c:	462a      	mov	r2, r5
 800ab7e:	4623      	mov	r3, r4
 800ab80:	f002 f8b2 	bl	800cce8 <vTCPWindowCreate>
		ipconfigTCP_MSS * pxSocket->u.xTCP.uxRxWinSize,
		ipconfigTCP_MSS * pxSocket->u.xTCP.uxTxWinSize,
		pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber,
		pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber,
		( uint32_t ) pxSocket->u.xTCP.usInitMSS );
}
 800ab84:	3708      	adds	r7, #8
 800ab86:	46bd      	mov	sp, r7
 800ab88:	bdb0      	pop	{r4, r5, r7, pc}
 800ab8a:	bf00      	nop

0800ab8c <prvTCPPrepareConnect>:
 * the Ethernet address of the target will be found using ARP.  In case the
 * target IP address is not within the netmask, the hardware address of the
 * gateway will be used.
 */
static BaseType_t prvTCPPrepareConnect( FreeRTOS_Socket_t *pxSocket )
{
 800ab8c:	b580      	push	{r7, lr}
 800ab8e:	b08a      	sub	sp, #40	; 0x28
 800ab90:	af00      	add	r7, sp, #0
 800ab92:	6078      	str	r0, [r7, #4]
TCPPacket_t *pxTCPPacket;
IPHeader_t *pxIPHeader;
eARPLookupResult_t eReturned;
uint32_t ulRemoteIP;
MACAddress_t xEthAddress;
BaseType_t xReturn = pdTRUE;
 800ab94:	2301      	movs	r3, #1
 800ab96:	627b      	str	r3, [r7, #36]	; 0x24

	#if( ipconfigHAS_PRINTF != 0 )
	{
		/* Only necessary for nicer logging. */
		memset( xEthAddress.ucBytes, '\0', sizeof( xEthAddress.ucBytes ) );
 800ab98:	f107 030c 	add.w	r3, r7, #12
 800ab9c:	4618      	mov	r0, r3
 800ab9e:	2100      	movs	r1, #0
 800aba0:	2206      	movs	r2, #6
 800aba2:	f005 fb81 	bl	80102a8 <memset>
	}
	#endif /* ipconfigHAS_PRINTF != 0 */

	ulRemoteIP = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
 800aba6:	687b      	ldr	r3, [r7, #4]
 800aba8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800abaa:	061a      	lsls	r2, r3, #24
 800abac:	687b      	ldr	r3, [r7, #4]
 800abae:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800abb0:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800abb4:	021b      	lsls	r3, r3, #8
 800abb6:	431a      	orrs	r2, r3
 800abb8:	687b      	ldr	r3, [r7, #4]
 800abba:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800abbc:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800abc0:	0a1b      	lsrs	r3, r3, #8
 800abc2:	431a      	orrs	r2, r3
 800abc4:	687b      	ldr	r3, [r7, #4]
 800abc6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800abc8:	0e1b      	lsrs	r3, r3, #24
 800abca:	4313      	orrs	r3, r2
 800abcc:	617b      	str	r3, [r7, #20]

	/* Determine the ARP cache status for the requested IP address. */
	eReturned = eARPGetCacheEntry( &( ulRemoteIP ), &( xEthAddress ) );
 800abce:	f107 0214 	add.w	r2, r7, #20
 800abd2:	f107 030c 	add.w	r3, r7, #12
 800abd6:	4610      	mov	r0, r2
 800abd8:	4619      	mov	r1, r3
 800abda:	f7fd fe41 	bl	8008860 <eARPGetCacheEntry>
 800abde:	4603      	mov	r3, r0
 800abe0:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23

	switch( eReturned )
 800abe4:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 800abe8:	2b01      	cmp	r3, #1
 800abea:	d00e      	beq.n	800ac0a <prvTCPPrepareConnect+0x7e>
		break;				/* We can now prepare the SYN packet. */
	case eARPCacheMiss:		/* An ARP table lookup did not find a valid entry. */
	case eCantSendPacket:	/* There is no IP address, or an ARP is still in progress. */
	default:
		/* Count the number of times it couldn't find the ARP address. */
		pxSocket->u.xTCP.ucRepCount++;
 800abec:	687b      	ldr	r3, [r7, #4]
 800abee:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
 800abf2:	3301      	adds	r3, #1
 800abf4:	b2da      	uxtb	r2, r3
 800abf6:	687b      	ldr	r3, [r7, #4]
 800abf8:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
			xEthAddress.ucBytes[ 3 ],
			xEthAddress.ucBytes[ 4 ],
			xEthAddress.ucBytes[ 5 ] ) );

		/* And issue a (new) ARP request */
		FreeRTOS_OutputARPRequest( ulRemoteIP );
 800abfc:	697b      	ldr	r3, [r7, #20]
 800abfe:	4618      	mov	r0, r3
 800ac00:	f7fd ff64 	bl	8008acc <FreeRTOS_OutputARPRequest>

		xReturn = pdFALSE;
 800ac04:	2300      	movs	r3, #0
 800ac06:	627b      	str	r3, [r7, #36]	; 0x24
 800ac08:	e000      	b.n	800ac0c <prvTCPPrepareConnect+0x80>
	eReturned = eARPGetCacheEntry( &( ulRemoteIP ), &( xEthAddress ) );

	switch( eReturned )
	{
	case eARPCacheHit:		/* An ARP table lookup found a valid entry. */
		break;				/* We can now prepare the SYN packet. */
 800ac0a:	bf00      	nop
		FreeRTOS_OutputARPRequest( ulRemoteIP );

		xReturn = pdFALSE;
	}

	if( xReturn != pdFALSE )
 800ac0c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ac0e:	2b00      	cmp	r3, #0
 800ac10:	f000 8091 	beq.w	800ad36 <prvTCPPrepareConnect+0x1aa>
	{
		/* The MAC-address of the peer (or gateway) has been found,
		now prepare the initial TCP packet and some fields in the socket. */
		pxTCPPacket = ( TCPPacket_t * )pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 800ac14:	687b      	ldr	r3, [r7, #4]
 800ac16:	3382      	adds	r3, #130	; 0x82
 800ac18:	61fb      	str	r3, [r7, #28]
		pxIPHeader = &pxTCPPacket->xIPHeader;
 800ac1a:	69fb      	ldr	r3, [r7, #28]
 800ac1c:	330e      	adds	r3, #14
 800ac1e:	61bb      	str	r3, [r7, #24]

		/* reset the retry counter to zero. */
		pxSocket->u.xTCP.ucRepCount = 0u;
 800ac20:	687b      	ldr	r3, [r7, #4]
 800ac22:	2200      	movs	r2, #0
 800ac24:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52

		/* And remember that the connect/SYN data are prepared. */
		pxSocket->u.xTCP.bits.bConnPrepared = pdTRUE_UNSIGNED;
 800ac28:	687a      	ldr	r2, [r7, #4]
 800ac2a:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800ac2e:	f043 0308 	orr.w	r3, r3, #8
 800ac32:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41

		/* Now that the Ethernet address is known, the initial packet can be
		prepared. */
		memset( pxSocket->u.xTCP.xPacket.u.ucLastPacket, '\0', sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 800ac36:	687b      	ldr	r3, [r7, #4]
 800ac38:	3382      	adds	r3, #130	; 0x82
 800ac3a:	4618      	mov	r0, r3
 800ac3c:	2100      	movs	r1, #0
 800ac3e:	2246      	movs	r2, #70	; 0x46
 800ac40:	f005 fb32 	bl	80102a8 <memset>

		/* Write the Ethernet address in Source, because it will be swapped by
		prvTCPReturnPacket(). */
		memcpy( &pxTCPPacket->xEthernetHeader.xSourceAddress, &xEthAddress, sizeof( xEthAddress ) );
 800ac44:	69fb      	ldr	r3, [r7, #28]
 800ac46:	1d9a      	adds	r2, r3, #6
 800ac48:	f107 030c 	add.w	r3, r7, #12
 800ac4c:	4610      	mov	r0, r2
 800ac4e:	4619      	mov	r1, r3
 800ac50:	2206      	movs	r2, #6
 800ac52:	f005 fa29 	bl	80100a8 <memcpy>

		/* 'ipIPv4_FRAME_TYPE' is already in network-byte-order. */
		pxTCPPacket->xEthernetHeader.usFrameType = ipIPv4_FRAME_TYPE;
 800ac56:	69fb      	ldr	r3, [r7, #28]
 800ac58:	2200      	movs	r2, #0
 800ac5a:	f042 0208 	orr.w	r2, r2, #8
 800ac5e:	731a      	strb	r2, [r3, #12]
 800ac60:	2200      	movs	r2, #0
 800ac62:	735a      	strb	r2, [r3, #13]

		pxIPHeader->ucVersionHeaderLength = 0x45u;
 800ac64:	69bb      	ldr	r3, [r7, #24]
 800ac66:	2245      	movs	r2, #69	; 0x45
 800ac68:	701a      	strb	r2, [r3, #0]
		pxIPHeader->usLength = FreeRTOS_htons( sizeof( TCPPacket_t ) - sizeof( pxTCPPacket->xEthernetHeader ) );
 800ac6a:	69bb      	ldr	r3, [r7, #24]
 800ac6c:	2200      	movs	r2, #0
 800ac6e:	709a      	strb	r2, [r3, #2]
 800ac70:	2200      	movs	r2, #0
 800ac72:	f042 0238 	orr.w	r2, r2, #56	; 0x38
 800ac76:	70da      	strb	r2, [r3, #3]
		pxIPHeader->ucTimeToLive = ( uint8_t ) ipconfigTCP_TIME_TO_LIVE;
 800ac78:	69bb      	ldr	r3, [r7, #24]
 800ac7a:	2280      	movs	r2, #128	; 0x80
 800ac7c:	721a      	strb	r2, [r3, #8]

		pxIPHeader->ucProtocol = ( uint8_t ) ipPROTOCOL_TCP;
 800ac7e:	69bb      	ldr	r3, [r7, #24]
 800ac80:	2206      	movs	r2, #6
 800ac82:	725a      	strb	r2, [r3, #9]

		/* Addresses and ports will be stored swapped because prvTCPReturnPacket
		will swap them back while replying. */
		pxIPHeader->ulDestinationIPAddress = *ipLOCAL_IP_ADDRESS_POINTER;
 800ac84:	4b2e      	ldr	r3, [pc, #184]	; (800ad40 <prvTCPPrepareConnect+0x1b4>)
 800ac86:	695a      	ldr	r2, [r3, #20]
 800ac88:	69bb      	ldr	r3, [r7, #24]
 800ac8a:	611a      	str	r2, [r3, #16]
		pxIPHeader->ulSourceIPAddress = FreeRTOS_htonl( pxSocket->u.xTCP.ulRemoteIP );
 800ac8c:	687b      	ldr	r3, [r7, #4]
 800ac8e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ac90:	061a      	lsls	r2, r3, #24
 800ac92:	687b      	ldr	r3, [r7, #4]
 800ac94:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800ac96:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800ac9a:	021b      	lsls	r3, r3, #8
 800ac9c:	431a      	orrs	r2, r3
 800ac9e:	687b      	ldr	r3, [r7, #4]
 800aca0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800aca2:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800aca6:	0a1b      	lsrs	r3, r3, #8
 800aca8:	431a      	orrs	r2, r3
 800acaa:	687b      	ldr	r3, [r7, #4]
 800acac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800acae:	0e1b      	lsrs	r3, r3, #24
 800acb0:	431a      	orrs	r2, r3
 800acb2:	69bb      	ldr	r3, [r7, #24]
 800acb4:	60da      	str	r2, [r3, #12]

		pxTCPPacket->xTCPHeader.usSourcePort = FreeRTOS_htons( pxSocket->u.xTCP.usRemotePort );
 800acb6:	687b      	ldr	r3, [r7, #4]
 800acb8:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 800acba:	021b      	lsls	r3, r3, #8
 800acbc:	b29a      	uxth	r2, r3
 800acbe:	687b      	ldr	r3, [r7, #4]
 800acc0:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 800acc2:	0a1b      	lsrs	r3, r3, #8
 800acc4:	b29b      	uxth	r3, r3
 800acc6:	b29b      	uxth	r3, r3
 800acc8:	4313      	orrs	r3, r2
 800acca:	b29b      	uxth	r3, r3
 800accc:	b29a      	uxth	r2, r3
 800acce:	69fb      	ldr	r3, [r7, #28]
 800acd0:	845a      	strh	r2, [r3, #34]	; 0x22
		pxTCPPacket->xTCPHeader.usDestinationPort = FreeRTOS_htons( pxSocket->usLocalPort );
 800acd2:	687b      	ldr	r3, [r7, #4]
 800acd4:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800acd6:	021b      	lsls	r3, r3, #8
 800acd8:	b29a      	uxth	r2, r3
 800acda:	687b      	ldr	r3, [r7, #4]
 800acdc:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800acde:	0a1b      	lsrs	r3, r3, #8
 800ace0:	b29b      	uxth	r3, r3
 800ace2:	b29b      	uxth	r3, r3
 800ace4:	4313      	orrs	r3, r2
 800ace6:	b29b      	uxth	r3, r3
 800ace8:	b29a      	uxth	r2, r3
 800acea:	69fb      	ldr	r3, [r7, #28]
 800acec:	849a      	strh	r2, [r3, #36]	; 0x24

		/* We are actively connecting, so the peer's Initial Sequence Number (ISN)
		isn't known yet. */
		pxSocket->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = 0ul;
 800acee:	687b      	ldr	r3, [r7, #4]
 800acf0:	2200      	movs	r2, #0
 800acf2:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec

		/* Start with ISN (Initial Sequence Number). */
		pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulNextInitialSequenceNumber;
 800acf6:	4b13      	ldr	r3, [pc, #76]	; (800ad44 <prvTCPPrepareConnect+0x1b8>)
 800acf8:	681a      	ldr	r2, [r3, #0]
 800acfa:	687b      	ldr	r3, [r7, #4]
 800acfc:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108

		/* And increment it with 268 for the next new connection, which is
		recommended value. */
		ulNextInitialSequenceNumber += 0x102UL;
 800ad00:	4b10      	ldr	r3, [pc, #64]	; (800ad44 <prvTCPPrepareConnect+0x1b8>)
 800ad02:	681b      	ldr	r3, [r3, #0]
 800ad04:	f503 7381 	add.w	r3, r3, #258	; 0x102
 800ad08:	4a0e      	ldr	r2, [pc, #56]	; (800ad44 <prvTCPPrepareConnect+0x1b8>)
 800ad0a:	6013      	str	r3, [r2, #0]

		/* The TCP header size is 20 bytes, divided by 4 equals 5, which is put in
		the high nibble of the TCP offset field. */
		pxTCPPacket->xTCPHeader.ucTCPOffset = 0x50u;
 800ad0c:	69fb      	ldr	r3, [r7, #28]
 800ad0e:	2250      	movs	r2, #80	; 0x50
 800ad10:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

		/* Only set the SYN flag. */
		pxTCPPacket->xTCPHeader.ucTCPFlags = ipTCP_FLAG_SYN;
 800ad14:	69fb      	ldr	r3, [r7, #28]
 800ad16:	2202      	movs	r2, #2
 800ad18:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

		/* Set the values of usInitMSS / usCurMSS for this socket. */
		prvSocketSetMSS( pxSocket );
 800ad1c:	6878      	ldr	r0, [r7, #4]
 800ad1e:	f001 faa3 	bl	800c268 <prvSocketSetMSS>

		/* For now this is also the advertised window size. */
		pxSocket->u.xTCP.ulRxCurWinSize = pxSocket->u.xTCP.usInitMSS;
 800ad22:	687b      	ldr	r3, [r7, #4]
 800ad24:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 800ad28:	461a      	mov	r2, r3
 800ad2a:	687b      	ldr	r3, [r7, #4]
 800ad2c:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0

		/* The initial sequence numbers at our side are known.  Later
		vTCPWindowInit() will be called to fill in the peer's sequence numbers, but
		first wait for a SYN+ACK reply. */
		prvTCPCreateWindow( pxSocket );
 800ad30:	6878      	ldr	r0, [r7, #4]
 800ad32:	f7ff ff03 	bl	800ab3c <prvTCPCreateWindow>
	}

	return xReturn;
 800ad36:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 800ad38:	4618      	mov	r0, r3
 800ad3a:	3728      	adds	r7, #40	; 0x28
 800ad3c:	46bd      	mov	sp, r7
 800ad3e:	bd80      	pop	{r7, pc}
 800ad40:	2000bb08 	.word	0x2000bb08
 800ad44:	2000c298 	.word	0x2000c298

0800ad48 <prvCheckOptions>:
 * Parse the TCP option(s) received, if present.  It has already been verified
 * that: ((pxTCPHeader->ucTCPOffset & 0xf0) > 0x50), meaning that the TP header
 * is longer than the usual 20 (5 x 4) bytes.
 */
static void prvCheckOptions( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer )
{
 800ad48:	b580      	push	{r7, lr}
 800ad4a:	b08e      	sub	sp, #56	; 0x38
 800ad4c:	af02      	add	r7, sp, #8
 800ad4e:	6078      	str	r0, [r7, #4]
 800ad50:	6039      	str	r1, [r7, #0]
const unsigned char *pucPtr;
const unsigned char *pucLast;
TCPWindow_t *pxTCPWindow;
UBaseType_t uxNewMSS;

	pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800ad52:	683b      	ldr	r3, [r7, #0]
 800ad54:	699b      	ldr	r3, [r3, #24]
 800ad56:	627b      	str	r3, [r7, #36]	; 0x24
	pxTCPHeader = &pxTCPPacket->xTCPHeader;
 800ad58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ad5a:	3322      	adds	r3, #34	; 0x22
 800ad5c:	623b      	str	r3, [r7, #32]

	/* A character pointer to iterate through the option data */
	pucPtr = pxTCPHeader->ucOptdata;
 800ad5e:	6a3b      	ldr	r3, [r7, #32]
 800ad60:	3314      	adds	r3, #20
 800ad62:	62fb      	str	r3, [r7, #44]	; 0x2c
	pucLast = pucPtr + (((pxTCPHeader->ucTCPOffset >> 4) - 5) << 2);
 800ad64:	6a3b      	ldr	r3, [r7, #32]
 800ad66:	7b1b      	ldrb	r3, [r3, #12]
 800ad68:	091b      	lsrs	r3, r3, #4
 800ad6a:	b2db      	uxtb	r3, r3
 800ad6c:	3b05      	subs	r3, #5
 800ad6e:	009b      	lsls	r3, r3, #2
 800ad70:	461a      	mov	r2, r3
 800ad72:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ad74:	4413      	add	r3, r2
 800ad76:	61fb      	str	r3, [r7, #28]
	pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 800ad78:	687b      	ldr	r3, [r7, #4]
 800ad7a:	33dc      	adds	r3, #220	; 0xdc
 800ad7c:	61bb      	str	r3, [r7, #24]

	/* The comparison with pucLast is only necessary in case the option data are
	corrupted, we don't like to run into invalid memory and crash. */
	while( pucPtr < pucLast )
 800ad7e:	e0c9      	b.n	800af14 <prvCheckOptions+0x1cc>
	{
		if( pucPtr[ 0 ] == TCP_OPT_END )
 800ad80:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ad82:	781b      	ldrb	r3, [r3, #0]
 800ad84:	2b00      	cmp	r3, #0
 800ad86:	d100      	bne.n	800ad8a <prvCheckOptions+0x42>
		{
			/* End of options. */
			return;
 800ad88:	e0c9      	b.n	800af1e <prvCheckOptions+0x1d6>
		}
		if( pucPtr[ 0 ] == TCP_OPT_NOOP)
 800ad8a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ad8c:	781b      	ldrb	r3, [r3, #0]
 800ad8e:	2b01      	cmp	r3, #1
 800ad90:	d103      	bne.n	800ad9a <prvCheckOptions+0x52>
		{
			pucPtr++;
 800ad92:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ad94:	3301      	adds	r3, #1
 800ad96:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ad98:	e0bc      	b.n	800af14 <prvCheckOptions+0x1cc>

			/* NOP option, inserted to make the length a multiple of 4. */
		}
#if( ipconfigUSE_TCP_WIN != 0 )
		else if( ( pucPtr[ 0 ] == TCP_OPT_WSOPT ) && ( pucPtr[ 1 ] == TCP_OPT_WSOPT_LEN ) )
 800ad9a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ad9c:	781b      	ldrb	r3, [r3, #0]
 800ad9e:	2b03      	cmp	r3, #3
 800ada0:	d114      	bne.n	800adcc <prvCheckOptions+0x84>
 800ada2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ada4:	3301      	adds	r3, #1
 800ada6:	781b      	ldrb	r3, [r3, #0]
 800ada8:	2b03      	cmp	r3, #3
 800adaa:	d10f      	bne.n	800adcc <prvCheckOptions+0x84>
		{
			pxSocket->u.xTCP.ucPeerWinScaleFactor = pucPtr[ 2 ];
 800adac:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800adae:	789a      	ldrb	r2, [r3, #2]
 800adb0:	687b      	ldr	r3, [r7, #4]
 800adb2:	f883 20ca 	strb.w	r2, [r3, #202]	; 0xca
			pxSocket->u.xTCP.bits.bWinScaling = pdTRUE_UNSIGNED;
 800adb6:	687a      	ldr	r2, [r7, #4]
 800adb8:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
 800adbc:	f043 0310 	orr.w	r3, r3, #16
 800adc0:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
			pucPtr += TCP_OPT_WSOPT_LEN;
 800adc4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800adc6:	3303      	adds	r3, #3
 800adc8:	62fb      	str	r3, [r7, #44]	; 0x2c
 800adca:	e0a3      	b.n	800af14 <prvCheckOptions+0x1cc>
		}
#endif	/* ipconfigUSE_TCP_WIN */
		else if( ( pucPtr[ 0 ] == TCP_OPT_MSS ) && ( pucPtr[ 1 ] == TCP_OPT_MSS_LEN ) )
 800adcc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800adce:	781b      	ldrb	r3, [r3, #0]
 800add0:	2b02      	cmp	r3, #2
 800add2:	d14a      	bne.n	800ae6a <prvCheckOptions+0x122>
 800add4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800add6:	3301      	adds	r3, #1
 800add8:	781b      	ldrb	r3, [r3, #0]
 800adda:	2b04      	cmp	r3, #4
 800addc:	d145      	bne.n	800ae6a <prvCheckOptions+0x122>
		{
			/* An MSS option with the correct option length.  FreeRTOS_htons()
			is not needed here because usChar2u16() already returns a host
			endian number. */
			uxNewMSS = usChar2u16( pucPtr + 2 );
 800adde:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ade0:	3302      	adds	r3, #2
 800ade2:	4618      	mov	r0, r3
 800ade4:	f7ff fb66 	bl	800a4b4 <usChar2u16>
 800ade8:	4603      	mov	r3, r0
 800adea:	617b      	str	r3, [r7, #20]
			if( pxSocket->u.xTCP.usInitMSS != uxNewMSS )
			{
				FreeRTOS_debug_printf( ( "MSS change %u -> %lu\n", pxSocket->u.xTCP.usInitMSS, uxNewMSS ) );
			}

			if( pxSocket->u.xTCP.usInitMSS > uxNewMSS )
 800adec:	687b      	ldr	r3, [r7, #4]
 800adee:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 800adf2:	461a      	mov	r2, r3
 800adf4:	697b      	ldr	r3, [r7, #20]
 800adf6:	429a      	cmp	r2, r3
 800adf8:	d933      	bls.n	800ae62 <prvCheckOptions+0x11a>
			{
				/* our MSS was bigger than the MSS of the other party: adapt it. */
				pxSocket->u.xTCP.bits.bMssChange = pdTRUE_UNSIGNED;
 800adfa:	687a      	ldr	r2, [r7, #4]
 800adfc:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 800ae00:	f043 0301 	orr.w	r3, r3, #1
 800ae04:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
				if( ( pxTCPWindow != NULL ) && ( pxSocket->u.xTCP.usCurMSS > uxNewMSS ) )
 800ae08:	69bb      	ldr	r3, [r7, #24]
 800ae0a:	2b00      	cmp	r3, #0
 800ae0c:	d00b      	beq.n	800ae26 <prvCheckOptions+0xde>
 800ae0e:	687b      	ldr	r3, [r7, #4]
 800ae10:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 800ae14:	461a      	mov	r2, r3
 800ae16:	697b      	ldr	r3, [r7, #20]
 800ae18:	429a      	cmp	r2, r3
 800ae1a:	d904      	bls.n	800ae26 <prvCheckOptions+0xde>
				{
					/* The peer advertises a smaller MSS than this socket was
					using.  Use that as well. */
					FreeRTOS_debug_printf( ( "Change mss %d => %lu\n", pxSocket->u.xTCP.usCurMSS, uxNewMSS ) );
					pxSocket->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
 800ae1c:	697b      	ldr	r3, [r7, #20]
 800ae1e:	b29a      	uxth	r2, r3
 800ae20:	687b      	ldr	r3, [r7, #4]
 800ae22:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
				}
				pxTCPWindow->xSize.ulRxWindowLength = ( ( uint32_t ) uxNewMSS ) * ( pxTCPWindow->xSize.ulRxWindowLength / ( ( uint32_t ) uxNewMSS ) );
 800ae26:	69bb      	ldr	r3, [r7, #24]
 800ae28:	685a      	ldr	r2, [r3, #4]
 800ae2a:	697b      	ldr	r3, [r7, #20]
 800ae2c:	fbb2 f3f3 	udiv	r3, r2, r3
 800ae30:	697a      	ldr	r2, [r7, #20]
 800ae32:	fb02 f203 	mul.w	r2, r2, r3
 800ae36:	69bb      	ldr	r3, [r7, #24]
 800ae38:	605a      	str	r2, [r3, #4]
				pxTCPWindow->usMSSInit = ( uint16_t ) uxNewMSS;
 800ae3a:	697b      	ldr	r3, [r7, #20]
 800ae3c:	b29a      	uxth	r2, r3
 800ae3e:	69bb      	ldr	r3, [r7, #24]
 800ae40:	f8a3 20be 	strh.w	r2, [r3, #190]	; 0xbe
				pxTCPWindow->usMSS = ( uint16_t ) uxNewMSS;
 800ae44:	697b      	ldr	r3, [r7, #20]
 800ae46:	b29a      	uxth	r2, r3
 800ae48:	69bb      	ldr	r3, [r7, #24]
 800ae4a:	f8a3 20bc 	strh.w	r2, [r3, #188]	; 0xbc
				pxSocket->u.xTCP.usInitMSS = ( uint16_t ) uxNewMSS;
 800ae4e:	697b      	ldr	r3, [r7, #20]
 800ae50:	b29a      	uxth	r2, r3
 800ae52:	687b      	ldr	r3, [r7, #4]
 800ae54:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
				pxSocket->u.xTCP.usCurMSS = ( uint16_t ) uxNewMSS;
 800ae58:	697b      	ldr	r3, [r7, #20]
 800ae5a:	b29a      	uxth	r2, r3
 800ae5c:	687b      	ldr	r3, [r7, #4]
 800ae5e:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
			#if( ipconfigUSE_TCP_WIN != 1 )
				/* Without scaled windows, MSS is the only interesting option. */
				break;
			#else
				/* Or else we continue to check another option: selective ACK. */
				pucPtr += TCP_OPT_MSS_LEN;
 800ae62:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae64:	3304      	adds	r3, #4
 800ae66:	62fb      	str	r3, [r7, #44]	; 0x2c
 800ae68:	e054      	b.n	800af14 <prvCheckOptions+0x1cc>
		}
		else
		{
			/* All other options have a length field, so that we easily
			can skip past them. */
			int len = ( int )pucPtr[ 1 ];
 800ae6a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae6c:	3301      	adds	r3, #1
 800ae6e:	781b      	ldrb	r3, [r3, #0]
 800ae70:	62bb      	str	r3, [r7, #40]	; 0x28
			if( len == 0 )
 800ae72:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae74:	2b00      	cmp	r3, #0
 800ae76:	d100      	bne.n	800ae7a <prvCheckOptions+0x132>
			{
				/* If the length field is zero, the options are malformed
				and we don't process them further. */
				break;
 800ae78:	e051      	b.n	800af1e <prvCheckOptions+0x1d6>
			#if( ipconfigUSE_TCP_WIN == 1 )
			{
				/* Selective ACK: the peer has received a packet but it is missing earlier
				packets.  At least this packet does not need retransmission anymore
				ulTCPWindowTxSack( ) takes care of this administration. */
				if( pucPtr[0] == TCP_OPT_SACK_A )
 800ae7a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae7c:	781b      	ldrb	r3, [r3, #0]
 800ae7e:	2b05      	cmp	r3, #5
 800ae80:	d144      	bne.n	800af0c <prvCheckOptions+0x1c4>
				{
					len -= 2;
 800ae82:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800ae84:	3b02      	subs	r3, #2
 800ae86:	62bb      	str	r3, [r7, #40]	; 0x28
					pucPtr += 2;
 800ae88:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae8a:	3302      	adds	r3, #2
 800ae8c:	62fb      	str	r3, [r7, #44]	; 0x2c

					while( len >= 8 )
 800ae8e:	e03a      	b.n	800af06 <prvCheckOptions+0x1be>
					{
					uint32_t ulFirst = ulChar2u32( pucPtr );
 800ae90:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800ae92:	f7ff faf3 	bl	800a47c <ulChar2u32>
 800ae96:	6138      	str	r0, [r7, #16]
					uint32_t ulLast  = ulChar2u32( pucPtr + 4 );
 800ae98:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800ae9a:	3304      	adds	r3, #4
 800ae9c:	4618      	mov	r0, r3
 800ae9e:	f7ff faed 	bl	800a47c <ulChar2u32>
 800aea2:	60f8      	str	r0, [r7, #12]
					uint32_t ulCount = ulTCPWindowTxSack( &pxSocket->u.xTCP.xTCPWindow, ulFirst, ulLast );
 800aea4:	687b      	ldr	r3, [r7, #4]
 800aea6:	33dc      	adds	r3, #220	; 0xdc
 800aea8:	4618      	mov	r0, r3
 800aeaa:	6939      	ldr	r1, [r7, #16]
 800aeac:	68fa      	ldr	r2, [r7, #12]
 800aeae:	f002 fc67 	bl	800d780 <ulTCPWindowTxSack>
 800aeb2:	60b8      	str	r0, [r7, #8]
						/* ulTCPWindowTxSack( ) returns the number of bytes which have been acked
						starting from the head position.
						Advance the tail pointer in txStream. */
						if( ( pxSocket->u.xTCP.txStream  != NULL ) && ( ulCount > 0 ) )
 800aeb4:	687b      	ldr	r3, [r7, #4]
 800aeb6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800aeb8:	2b00      	cmp	r3, #0
 800aeba:	d01e      	beq.n	800aefa <prvCheckOptions+0x1b2>
 800aebc:	68bb      	ldr	r3, [r7, #8]
 800aebe:	2b00      	cmp	r3, #0
 800aec0:	d01b      	beq.n	800aefa <prvCheckOptions+0x1b2>
						{
							/* Just advancing the tail index, 'ulCount' bytes have been confirmed. */
							uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0, NULL, ( size_t ) ulCount, pdFALSE );
 800aec2:	687b      	ldr	r3, [r7, #4]
 800aec4:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800aec6:	2300      	movs	r3, #0
 800aec8:	9300      	str	r3, [sp, #0]
 800aeca:	4610      	mov	r0, r2
 800aecc:	2100      	movs	r1, #0
 800aece:	2200      	movs	r2, #0
 800aed0:	68bb      	ldr	r3, [r7, #8]
 800aed2:	f002 fda3 	bl	800da1c <uxStreamBufferGet>
							pxSocket->xEventBits |= eSOCKET_SEND;
 800aed6:	687b      	ldr	r3, [r7, #4]
 800aed8:	681b      	ldr	r3, [r3, #0]
 800aeda:	f043 0202 	orr.w	r2, r3, #2
 800aede:	687b      	ldr	r3, [r7, #4]
 800aee0:	601a      	str	r2, [r3, #0]

							#if ipconfigSUPPORT_SELECT_FUNCTION == 1
							{
								if( pxSocket->xSelectBits & eSELECT_WRITE )
 800aee2:	687b      	ldr	r3, [r7, #4]
 800aee4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800aee6:	f003 0302 	and.w	r3, r3, #2
 800aeea:	2b00      	cmp	r3, #0
 800aeec:	d005      	beq.n	800aefa <prvCheckOptions+0x1b2>
								{
									/* The field 'xEventBits' is used to store regular socket events (at most 8),
									as well as 'select events', which will be left-shifted */
									pxSocket->xEventBits |= ( eSELECT_WRITE << SOCKET_EVENT_BIT_COUNT );
 800aeee:	687b      	ldr	r3, [r7, #4]
 800aef0:	681b      	ldr	r3, [r3, #0]
 800aef2:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 800aef6:	687b      	ldr	r3, [r7, #4]
 800aef8:	601a      	str	r2, [r3, #0]
									pxSocket->u.xTCP.pxHandleSent( (Socket_t *)pxSocket, ulCount );
								}
							}
							#endif /* ipconfigUSE_CALLBACKS == 1  */
						}
						pucPtr += 8;
 800aefa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800aefc:	3308      	adds	r3, #8
 800aefe:	62fb      	str	r3, [r7, #44]	; 0x2c
						len -= 8;
 800af00:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800af02:	3b08      	subs	r3, #8
 800af04:	62bb      	str	r3, [r7, #40]	; 0x28
				if( pucPtr[0] == TCP_OPT_SACK_A )
				{
					len -= 2;
					pucPtr += 2;

					while( len >= 8 )
 800af06:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800af08:	2b07      	cmp	r3, #7
 800af0a:	dcc1      	bgt.n	800ae90 <prvCheckOptions+0x148>
					}
				#endif	/* ipconfigUSE_TCP_TIMESTAMPS == 1 */
			}
			#endif	/* ipconfigUSE_TCP_WIN == 1 */

			pucPtr += len;
 800af0c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800af0e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800af10:	4413      	add	r3, r2
 800af12:	62fb      	str	r3, [r7, #44]	; 0x2c
	pucLast = pucPtr + (((pxTCPHeader->ucTCPOffset >> 4) - 5) << 2);
	pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;

	/* The comparison with pucLast is only necessary in case the option data are
	corrupted, we don't like to run into invalid memory and crash. */
	while( pucPtr < pucLast )
 800af14:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800af16:	69fb      	ldr	r3, [r7, #28]
 800af18:	429a      	cmp	r2, r3
 800af1a:	f4ff af31 	bcc.w	800ad80 <prvCheckOptions+0x38>
			#endif	/* ipconfigUSE_TCP_WIN == 1 */

			pucPtr += len;
		}
	}
}
 800af1e:	3730      	adds	r7, #48	; 0x30
 800af20:	46bd      	mov	sp, r7
 800af22:	bd80      	pop	{r7, pc}

0800af24 <prvWinScaleFactor>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN != 0 )

	static uint8_t prvWinScaleFactor( FreeRTOS_Socket_t *pxSocket )
	{
 800af24:	b480      	push	{r7}
 800af26:	b085      	sub	sp, #20
 800af28:	af00      	add	r7, sp, #0
 800af2a:	6078      	str	r0, [r7, #4]
	size_t uxWinSize;
	uint8_t ucFactor;

		/* 'xTCP.uxRxWinSize' is the size of the reception window in units of MSS. */
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
 800af2c:	687b      	ldr	r3, [r7, #4]
 800af2e:	f8d3 30d4 	ldr.w	r3, [r3, #212]	; 0xd4
 800af32:	687a      	ldr	r2, [r7, #4]
 800af34:	f8b2 204c 	ldrh.w	r2, [r2, #76]	; 0x4c
 800af38:	fb02 f303 	mul.w	r3, r2, r3
 800af3c:	60fb      	str	r3, [r7, #12]
		ucFactor = 0u;
 800af3e:	2300      	movs	r3, #0
 800af40:	72fb      	strb	r3, [r7, #11]
		while( uxWinSize > 0xfffful )
 800af42:	e005      	b.n	800af50 <prvWinScaleFactor+0x2c>
		{
			/* Divide by two and increase the binary factor by 1. */
			uxWinSize >>= 1;
 800af44:	68fb      	ldr	r3, [r7, #12]
 800af46:	085b      	lsrs	r3, r3, #1
 800af48:	60fb      	str	r3, [r7, #12]
			ucFactor++;
 800af4a:	7afb      	ldrb	r3, [r7, #11]
 800af4c:	3301      	adds	r3, #1
 800af4e:	72fb      	strb	r3, [r7, #11]
	uint8_t ucFactor;

		/* 'xTCP.uxRxWinSize' is the size of the reception window in units of MSS. */
		uxWinSize = pxSocket->u.xTCP.uxRxWinSize * ( size_t ) pxSocket->u.xTCP.usInitMSS;
		ucFactor = 0u;
		while( uxWinSize > 0xfffful )
 800af50:	68fb      	ldr	r3, [r7, #12]
 800af52:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800af56:	d2f5      	bcs.n	800af44 <prvWinScaleFactor+0x20>
		FreeRTOS_debug_printf( ( "prvWinScaleFactor: uxRxWinSize %lu MSS %lu Factor %u\n",
			pxSocket->u.xTCP.uxRxWinSize,
			pxSocket->u.xTCP.usInitMSS,
			ucFactor ) );

		return ucFactor;
 800af58:	7afb      	ldrb	r3, [r7, #11]
	}
 800af5a:	4618      	mov	r0, r3
 800af5c:	3714      	adds	r7, #20
 800af5e:	46bd      	mov	sp, r7
 800af60:	f85d 7b04 	ldr.w	r7, [sp], #4
 800af64:	4770      	bx	lr
 800af66:	bf00      	nop

0800af68 <prvSetSynAckOptions>:
 * When opening a TCP connection, while SYN's are being sent, the  parties may
 * communicate what MSS (Maximum Segment Size) they intend to use.   MSS is the
 * nett size of the payload, always smaller than MTU.
*/
static UBaseType_t prvSetSynAckOptions( FreeRTOS_Socket_t *pxSocket, TCPPacket_t * pxTCPPacket )
{
 800af68:	b580      	push	{r7, lr}
 800af6a:	b086      	sub	sp, #24
 800af6c:	af00      	add	r7, sp, #0
 800af6e:	6078      	str	r0, [r7, #4]
 800af70:	6039      	str	r1, [r7, #0]
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
 800af72:	683b      	ldr	r3, [r7, #0]
 800af74:	3322      	adds	r3, #34	; 0x22
 800af76:	617b      	str	r3, [r7, #20]
uint16_t usMSS = pxSocket->u.xTCP.usInitMSS;
 800af78:	687b      	ldr	r3, [r7, #4]
 800af7a:	f8b3 304c 	ldrh.w	r3, [r3, #76]	; 0x4c
 800af7e:	827b      	strh	r3, [r7, #18]
	UBaseType_t uxOptionsLength;
#endif

	/* We send out the TCP Maximum Segment Size option with our SYN[+ACK]. */

	pxTCPHeader->ucOptdata[ 0 ] = ( uint8_t ) TCP_OPT_MSS;
 800af80:	697b      	ldr	r3, [r7, #20]
 800af82:	2202      	movs	r2, #2
 800af84:	751a      	strb	r2, [r3, #20]
	pxTCPHeader->ucOptdata[ 1 ] = ( uint8_t ) TCP_OPT_MSS_LEN;
 800af86:	697b      	ldr	r3, [r7, #20]
 800af88:	2204      	movs	r2, #4
 800af8a:	755a      	strb	r2, [r3, #21]
	pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( usMSS >> 8 );
 800af8c:	8a7b      	ldrh	r3, [r7, #18]
 800af8e:	0a1b      	lsrs	r3, r3, #8
 800af90:	b29b      	uxth	r3, r3
 800af92:	b2da      	uxtb	r2, r3
 800af94:	697b      	ldr	r3, [r7, #20]
 800af96:	759a      	strb	r2, [r3, #22]
	pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( usMSS & 0xffu );
 800af98:	8a7b      	ldrh	r3, [r7, #18]
 800af9a:	b2da      	uxtb	r2, r3
 800af9c:	697b      	ldr	r3, [r7, #20]
 800af9e:	75da      	strb	r2, [r3, #23]

	#if( ipconfigUSE_TCP_WIN != 0 )
	{
		pxSocket->u.xTCP.ucMyWinScaleFactor = prvWinScaleFactor( pxSocket );
 800afa0:	6878      	ldr	r0, [r7, #4]
 800afa2:	f7ff ffbf 	bl	800af24 <prvWinScaleFactor>
 800afa6:	4603      	mov	r3, r0
 800afa8:	461a      	mov	r2, r3
 800afaa:	687b      	ldr	r3, [r7, #4]
 800afac:	f883 20c9 	strb.w	r2, [r3, #201]	; 0xc9

		pxTCPHeader->ucOptdata[ 4 ] = TCP_OPT_NOOP;
 800afb0:	697b      	ldr	r3, [r7, #20]
 800afb2:	2201      	movs	r2, #1
 800afb4:	761a      	strb	r2, [r3, #24]
		pxTCPHeader->ucOptdata[ 5 ] = ( uint8_t ) ( TCP_OPT_WSOPT );
 800afb6:	697b      	ldr	r3, [r7, #20]
 800afb8:	2203      	movs	r2, #3
 800afba:	765a      	strb	r2, [r3, #25]
		pxTCPHeader->ucOptdata[ 6 ] = ( uint8_t ) ( TCP_OPT_WSOPT_LEN );
 800afbc:	697b      	ldr	r3, [r7, #20]
 800afbe:	2203      	movs	r2, #3
 800afc0:	769a      	strb	r2, [r3, #26]
		pxTCPHeader->ucOptdata[ 7 ] = ( uint8_t ) pxSocket->u.xTCP.ucMyWinScaleFactor;
 800afc2:	687b      	ldr	r3, [r7, #4]
 800afc4:	f893 20c9 	ldrb.w	r2, [r3, #201]	; 0xc9
 800afc8:	697b      	ldr	r3, [r7, #20]
 800afca:	76da      	strb	r2, [r3, #27]
		uxOptionsLength = 8u;
 800afcc:	2308      	movs	r3, #8
 800afce:	60fb      	str	r3, [r7, #12]
				uxOptionsLength += 2u;
			}
			else
		#endif
		{
			pxTCPHeader->ucOptdata[ uxOptionsLength + 0 ] = TCP_OPT_NOOP;
 800afd0:	697a      	ldr	r2, [r7, #20]
 800afd2:	68fb      	ldr	r3, [r7, #12]
 800afd4:	4413      	add	r3, r2
 800afd6:	3310      	adds	r3, #16
 800afd8:	2201      	movs	r2, #1
 800afda:	711a      	strb	r2, [r3, #4]
			pxTCPHeader->ucOptdata[ uxOptionsLength + 1 ] = TCP_OPT_NOOP;
 800afdc:	68fb      	ldr	r3, [r7, #12]
 800afde:	3301      	adds	r3, #1
 800afe0:	697a      	ldr	r2, [r7, #20]
 800afe2:	4413      	add	r3, r2
 800afe4:	2201      	movs	r2, #1
 800afe6:	751a      	strb	r2, [r3, #20]
			pxTCPHeader->ucOptdata[ uxOptionsLength + 2 ] = TCP_OPT_SACK_P;	/* 4: Sack-Permitted Option. */
 800afe8:	68fb      	ldr	r3, [r7, #12]
 800afea:	3302      	adds	r3, #2
 800afec:	697a      	ldr	r2, [r7, #20]
 800afee:	4413      	add	r3, r2
 800aff0:	2204      	movs	r2, #4
 800aff2:	751a      	strb	r2, [r3, #20]
			pxTCPHeader->ucOptdata[ uxOptionsLength + 3 ] = 2;	/* 2: length of this option. */
 800aff4:	68fb      	ldr	r3, [r7, #12]
 800aff6:	3303      	adds	r3, #3
 800aff8:	697a      	ldr	r2, [r7, #20]
 800affa:	4413      	add	r3, r2
 800affc:	2202      	movs	r2, #2
 800affe:	751a      	strb	r2, [r3, #20]
			uxOptionsLength += 4u;
 800b000:	68fb      	ldr	r3, [r7, #12]
 800b002:	3304      	adds	r3, #4
 800b004:	60fb      	str	r3, [r7, #12]
		}
		return uxOptionsLength; /* bytes, not words. */
 800b006:	68fb      	ldr	r3, [r7, #12]
	}
	#endif	/* ipconfigUSE_TCP_WIN == 0 */
}
 800b008:	4618      	mov	r0, r3
 800b00a:	3718      	adds	r7, #24
 800b00c:	46bd      	mov	sp, r7
 800b00e:	bd80      	pop	{r7, pc}

0800b010 <prvTCPTouchSocket>:
 * For anti-hanging protection and TCP keep-alive messages.  Called in two
 * places: after receiving a packet and after a state change.  The socket's
 * alive timer may be reset.
 */
static void prvTCPTouchSocket( FreeRTOS_Socket_t *pxSocket )
{
 800b010:	b580      	push	{r7, lr}
 800b012:	b082      	sub	sp, #8
 800b014:	af00      	add	r7, sp, #0
 800b016:	6078      	str	r0, [r7, #4]
	#if( ipconfigTCP_HANG_PROTECTION == 1 )
	{
		pxSocket->u.xTCP.xLastActTime = xTaskGetTickCount( );
 800b018:	f7fa fab4 	bl	8005584 <xTaskGetTickCount>
 800b01c:	4602      	mov	r2, r0
 800b01e:	687b      	ldr	r3, [r7, #4]
 800b020:	661a      	str	r2, [r3, #96]	; 0x60
	}
	#endif

	#if( ipconfigTCP_KEEP_ALIVE == 1 )
	{
		pxSocket->u.xTCP.bits.bWaitKeepAlive = pdFALSE_UNSIGNED;
 800b022:	687a      	ldr	r2, [r7, #4]
 800b024:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800b028:	f36f 0382 	bfc	r3, #2, #1
 800b02c:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
		pxSocket->u.xTCP.bits.bSendKeepAlive = pdFALSE_UNSIGNED;
 800b030:	687a      	ldr	r2, [r7, #4]
 800b032:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800b036:	f36f 0341 	bfc	r3, #1, #1
 800b03a:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
		pxSocket->u.xTCP.ucKeepRepCount = 0u;
 800b03e:	687b      	ldr	r3, [r7, #4]
 800b040:	2200      	movs	r2, #0
 800b042:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
		pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 800b046:	f7fa fa9d 	bl	8005584 <xTaskGetTickCount>
 800b04a:	4602      	mov	r2, r0
 800b04c:	687b      	ldr	r3, [r7, #4]
 800b04e:	65da      	str	r2, [r3, #92]	; 0x5c
	}
	#endif

	( void ) pxSocket;
}
 800b050:	3708      	adds	r7, #8
 800b052:	46bd      	mov	sp, r7
 800b054:	bd80      	pop	{r7, pc}
 800b056:	bf00      	nop

0800b058 <vTCPStateChange>:
 * resetting the alive timer, calling the user's OnConnect handler to notify
 * that a socket has got (dis)connected, and setting bit to unblock a call to
 * FreeRTOS_select()
 */
void vTCPStateChange( FreeRTOS_Socket_t *pxSocket, enum eTCP_STATE eTCPState )
{
 800b058:	b580      	push	{r7, lr}
 800b05a:	b086      	sub	sp, #24
 800b05c:	af00      	add	r7, sp, #0
 800b05e:	6078      	str	r0, [r7, #4]
 800b060:	460b      	mov	r3, r1
 800b062:	70fb      	strb	r3, [r7, #3]
FreeRTOS_Socket_t *xParent = NULL;
 800b064:	2300      	movs	r3, #0
 800b066:	617b      	str	r3, [r7, #20]
BaseType_t bBefore = ( BaseType_t ) NOW_CONNECTED( pxSocket->u.xTCP.ucTCPState );	/* Was it connected ? */
 800b068:	687b      	ldr	r3, [r7, #4]
 800b06a:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800b06e:	2b04      	cmp	r3, #4
 800b070:	d906      	bls.n	800b080 <vTCPStateChange+0x28>
 800b072:	687b      	ldr	r3, [r7, #4]
 800b074:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800b078:	2b08      	cmp	r3, #8
 800b07a:	d001      	beq.n	800b080 <vTCPStateChange+0x28>
 800b07c:	2301      	movs	r3, #1
 800b07e:	e000      	b.n	800b082 <vTCPStateChange+0x2a>
 800b080:	2300      	movs	r3, #0
 800b082:	613b      	str	r3, [r7, #16]
BaseType_t bAfter  = ( BaseType_t ) NOW_CONNECTED( eTCPState );						/* Is it connected now ? */
 800b084:	78fb      	ldrb	r3, [r7, #3]
 800b086:	2b04      	cmp	r3, #4
 800b088:	d904      	bls.n	800b094 <vTCPStateChange+0x3c>
 800b08a:	78fb      	ldrb	r3, [r7, #3]
 800b08c:	2b08      	cmp	r3, #8
 800b08e:	d001      	beq.n	800b094 <vTCPStateChange+0x3c>
 800b090:	2301      	movs	r3, #1
 800b092:	e000      	b.n	800b096 <vTCPStateChange+0x3e>
 800b094:	2300      	movs	r3, #0
 800b096:	60fb      	str	r3, [r7, #12]
#if( ipconfigUSE_CALLBACKS == 1 )
	FreeRTOS_Socket_t *xConnected = NULL;
#endif

	/* Has the connected status changed? */
	if( bBefore != bAfter )
 800b098:	693a      	ldr	r2, [r7, #16]
 800b09a:	68fb      	ldr	r3, [r7, #12]
 800b09c:	429a      	cmp	r2, r3
 800b09e:	f000 8087 	beq.w	800b1b0 <vTCPStateChange+0x158>
	{
		/* Is the socket connected now ? */
		if( bAfter != pdFALSE )
 800b0a2:	68fb      	ldr	r3, [r7, #12]
 800b0a4:	2b00      	cmp	r3, #0
 800b0a6:	d063      	beq.n	800b170 <vTCPStateChange+0x118>
		{
			/* if bPassQueued is true, this socket is an orphan until it gets connected. */
			if( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED )
 800b0a8:	687b      	ldr	r3, [r7, #4]
 800b0aa:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800b0ae:	f003 0304 	and.w	r3, r3, #4
 800b0b2:	b2db      	uxtb	r3, r3
 800b0b4:	2b00      	cmp	r3, #0
 800b0b6:	d048      	beq.n	800b14a <vTCPStateChange+0xf2>
			{
				/* Now that it is connected, find it's parent. */
				if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 800b0b8:	687b      	ldr	r3, [r7, #4]
 800b0ba:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800b0be:	f003 0308 	and.w	r3, r3, #8
 800b0c2:	b2db      	uxtb	r3, r3
 800b0c4:	2b00      	cmp	r3, #0
 800b0c6:	d002      	beq.n	800b0ce <vTCPStateChange+0x76>
				{
					xParent = pxSocket;
 800b0c8:	687b      	ldr	r3, [r7, #4]
 800b0ca:	617b      	str	r3, [r7, #20]
 800b0cc:	e00f      	b.n	800b0ee <vTCPStateChange+0x96>
				}
				else
				{
					xParent = pxSocket->u.xTCP.pxPeerSocket;
 800b0ce:	687b      	ldr	r3, [r7, #4]
 800b0d0:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b0d2:	617b      	str	r3, [r7, #20]
					configASSERT( xParent != NULL );
 800b0d4:	697b      	ldr	r3, [r7, #20]
 800b0d6:	2b00      	cmp	r3, #0
 800b0d8:	d109      	bne.n	800b0ee <vTCPStateChange+0x96>
 800b0da:	f04f 0350 	mov.w	r3, #80	; 0x50
 800b0de:	f383 8811 	msr	BASEPRI, r3
 800b0e2:	f3bf 8f6f 	isb	sy
 800b0e6:	f3bf 8f4f 	dsb	sy
 800b0ea:	60bb      	str	r3, [r7, #8]
 800b0ec:	e7fe      	b.n	800b0ec <vTCPStateChange+0x94>
				}
				if( xParent != NULL )
 800b0ee:	697b      	ldr	r3, [r7, #20]
 800b0f0:	2b00      	cmp	r3, #0
 800b0f2:	d018      	beq.n	800b126 <vTCPStateChange+0xce>
				{
					if( xParent->u.xTCP.pxPeerSocket == NULL )
 800b0f4:	697b      	ldr	r3, [r7, #20]
 800b0f6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800b0f8:	2b00      	cmp	r3, #0
 800b0fa:	d102      	bne.n	800b102 <vTCPStateChange+0xaa>
					{
						xParent->u.xTCP.pxPeerSocket = pxSocket;
 800b0fc:	697b      	ldr	r3, [r7, #20]
 800b0fe:	687a      	ldr	r2, [r7, #4]
 800b100:	655a      	str	r2, [r3, #84]	; 0x54
					}

					xParent->xEventBits |= eSOCKET_ACCEPT;
 800b102:	697b      	ldr	r3, [r7, #20]
 800b104:	681b      	ldr	r3, [r3, #0]
 800b106:	f043 0204 	orr.w	r2, r3, #4
 800b10a:	697b      	ldr	r3, [r7, #20]
 800b10c:	601a      	str	r2, [r3, #0]

					#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
					{
						/* Library support FreeRTOS_select().  Receiving a new
						connection is being translated as a READ event. */
						if( ( xParent->xSelectBits & eSELECT_READ ) != 0 )
 800b10e:	697b      	ldr	r3, [r7, #20]
 800b110:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b112:	f003 0301 	and.w	r3, r3, #1
 800b116:	2b00      	cmp	r3, #0
 800b118:	d005      	beq.n	800b126 <vTCPStateChange+0xce>
						{
							xParent->xEventBits |= ( eSELECT_READ << SOCKET_EVENT_BIT_COUNT );
 800b11a:	697b      	ldr	r3, [r7, #20]
 800b11c:	681b      	ldr	r3, [r3, #0]
 800b11e:	f443 7280 	orr.w	r2, r3, #256	; 0x100
 800b122:	697b      	ldr	r3, [r7, #20]
 800b124:	601a      	str	r2, [r3, #0]
					#endif
				}

				/* Don't need to access the parent socket anymore, so the
				reference 'pxPeerSocket' may be cleared. */
				pxSocket->u.xTCP.pxPeerSocket = NULL;
 800b126:	687b      	ldr	r3, [r7, #4]
 800b128:	2200      	movs	r2, #0
 800b12a:	655a      	str	r2, [r3, #84]	; 0x54
				pxSocket->u.xTCP.bits.bPassQueued = pdFALSE_UNSIGNED;
 800b12c:	687a      	ldr	r2, [r7, #4]
 800b12e:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 800b132:	f36f 0382 	bfc	r3, #2, #1
 800b136:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40

				/* When true, this socket may be returned in a call to accept(). */
				pxSocket->u.xTCP.bits.bPassAccept = pdTRUE_UNSIGNED;
 800b13a:	687a      	ldr	r2, [r7, #4]
 800b13c:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 800b140:	f043 0302 	orr.w	r3, r3, #2
 800b144:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
 800b148:	e024      	b.n	800b194 <vTCPStateChange+0x13c>
			}
			else
			{
				pxSocket->xEventBits |= eSOCKET_CONNECT;
 800b14a:	687b      	ldr	r3, [r7, #4]
 800b14c:	681b      	ldr	r3, [r3, #0]
 800b14e:	f043 0208 	orr.w	r2, r3, #8
 800b152:	687b      	ldr	r3, [r7, #4]
 800b154:	601a      	str	r2, [r3, #0]

				#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
				{
					if( pxSocket->xSelectBits & eSELECT_WRITE )
 800b156:	687b      	ldr	r3, [r7, #4]
 800b158:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b15a:	f003 0302 	and.w	r3, r3, #2
 800b15e:	2b00      	cmp	r3, #0
 800b160:	d018      	beq.n	800b194 <vTCPStateChange+0x13c>
					{
						pxSocket->xEventBits |= ( eSELECT_WRITE << SOCKET_EVENT_BIT_COUNT );
 800b162:	687b      	ldr	r3, [r7, #4]
 800b164:	681b      	ldr	r3, [r3, #0]
 800b166:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 800b16a:	687b      	ldr	r3, [r7, #4]
 800b16c:	601a      	str	r2, [r3, #0]
 800b16e:	e011      	b.n	800b194 <vTCPStateChange+0x13c>
			}
		}
		else  /* bAfter == pdFALSE, connection is closed. */
		{
			/* Notify/wake-up the socket-owner by setting a semaphore. */
			pxSocket->xEventBits |= eSOCKET_CLOSED;
 800b170:	687b      	ldr	r3, [r7, #4]
 800b172:	681b      	ldr	r3, [r3, #0]
 800b174:	f043 0220 	orr.w	r2, r3, #32
 800b178:	687b      	ldr	r3, [r7, #4]
 800b17a:	601a      	str	r2, [r3, #0]

			#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
			{
				if( ( pxSocket->xSelectBits & eSELECT_EXCEPT ) != 0 )
 800b17c:	687b      	ldr	r3, [r7, #4]
 800b17e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b180:	f003 0304 	and.w	r3, r3, #4
 800b184:	2b00      	cmp	r3, #0
 800b186:	d005      	beq.n	800b194 <vTCPStateChange+0x13c>
				{
					pxSocket->xEventBits |= ( eSELECT_EXCEPT << SOCKET_EVENT_BIT_COUNT );
 800b188:	687b      	ldr	r3, [r7, #4]
 800b18a:	681b      	ldr	r3, [r3, #0]
 800b18c:	f443 6280 	orr.w	r2, r3, #1024	; 0x400
 800b190:	687b      	ldr	r3, [r7, #4]
 800b192:	601a      	str	r2, [r3, #0]
				xConnected = pxSocket;
			}
		}
		#endif /* ipconfigUSE_CALLBACKS */

		if( prvTCPSocketIsActive( ( UBaseType_t ) pxSocket->u.xTCP.ucTCPState ) == pdFALSE )
 800b194:	687b      	ldr	r3, [r7, #4]
 800b196:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800b19a:	4618      	mov	r0, r3
 800b19c:	f7ff f9a0 	bl	800a4e0 <prvTCPSocketIsActive>
 800b1a0:	4603      	mov	r3, r0
 800b1a2:	2b00      	cmp	r3, #0
 800b1a4:	d122      	bne.n	800b1ec <vTCPStateChange+0x194>
		{
			/* Now the socket isn't in an active state anymore so it
			won't need further attention of the IP-task.
			Setting time-out to zero means that the socket won't get checked during
			timer events. */
			pxSocket->u.xTCP.usTimeout = 0u;
 800b1a6:	687b      	ldr	r3, [r7, #4]
 800b1a8:	2200      	movs	r2, #0
 800b1aa:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
 800b1ae:	e01d      	b.n	800b1ec <vTCPStateChange+0x194>
		}
	}
	else
	{
		if( eTCPState == eCLOSED )
 800b1b0:	78fb      	ldrb	r3, [r7, #3]
 800b1b2:	2b00      	cmp	r3, #0
 800b1b4:	d11a      	bne.n	800b1ec <vTCPStateChange+0x194>
		{
			/* Socket goes to status eCLOSED because of a RST.
			When nobody owns the socket yet, delete it. */
			if( ( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED ) ||
 800b1b6:	687b      	ldr	r3, [r7, #4]
 800b1b8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800b1bc:	f003 0304 	and.w	r3, r3, #4
 800b1c0:	b2db      	uxtb	r3, r3
 800b1c2:	2b00      	cmp	r3, #0
 800b1c4:	d107      	bne.n	800b1d6 <vTCPStateChange+0x17e>
				( pxSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
 800b1c6:	687b      	ldr	r3, [r7, #4]
 800b1c8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800b1cc:	f003 0302 	and.w	r3, r3, #2
 800b1d0:	b2db      	uxtb	r3, r3
	{
		if( eTCPState == eCLOSED )
		{
			/* Socket goes to status eCLOSED because of a RST.
			When nobody owns the socket yet, delete it. */
			if( ( pxSocket->u.xTCP.bits.bPassQueued != pdFALSE_UNSIGNED ) ||
 800b1d2:	2b00      	cmp	r3, #0
 800b1d4:	d00a      	beq.n	800b1ec <vTCPStateChange+0x194>
				( pxSocket->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
			{
				FreeRTOS_debug_printf( ( "vTCPStateChange: Closing socket\n" ) );
				if( pxSocket->u.xTCP.bits.bReuseSocket == pdFALSE_UNSIGNED )
 800b1d6:	687b      	ldr	r3, [r7, #4]
 800b1d8:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800b1dc:	f003 0308 	and.w	r3, r3, #8
 800b1e0:	b2db      	uxtb	r3, r3
 800b1e2:	2b00      	cmp	r3, #0
 800b1e4:	d102      	bne.n	800b1ec <vTCPStateChange+0x194>
				{
					FreeRTOS_closesocket( pxSocket );
 800b1e6:	6878      	ldr	r0, [r7, #4]
 800b1e8:	f7fe f824 	bl	8009234 <FreeRTOS_closesocket>
			}
		}
	}

	/* Fill in the new state. */
	pxSocket->u.xTCP.ucTCPState = ( uint8_t ) eTCPState;
 800b1ec:	687b      	ldr	r3, [r7, #4]
 800b1ee:	78fa      	ldrb	r2, [r7, #3]
 800b1f0:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53

	/* touch the alive timers because moving to another state. */
	prvTCPTouchSocket( pxSocket );
 800b1f4:	6878      	ldr	r0, [r7, #4]
 800b1f6:	f7ff ff0b 	bl	800b010 <prvTCPTouchSocket>
			/* The 'connected' state has changed, call the OnConnect handler of the parent. */
			xConnected->u.xTCP.pxHandleConnected( ( Socket_t * ) xConnected, bAfter );
		}
	}
	#endif
	if( xParent != NULL )
 800b1fa:	697b      	ldr	r3, [r7, #20]
 800b1fc:	2b00      	cmp	r3, #0
 800b1fe:	d002      	beq.n	800b206 <vTCPStateChange+0x1ae>
	{
		vSocketWakeUpUser( xParent );
 800b200:	6978      	ldr	r0, [r7, #20]
 800b202:	f7fe fb0b 	bl	800981c <vSocketWakeUpUser>
	}
}
 800b206:	3718      	adds	r7, #24
 800b208:	46bd      	mov	sp, r7
 800b20a:	bd80      	pop	{r7, pc}

0800b20c <prvTCPBufferResize>:
/*-----------------------------------------------------------*/

static NetworkBufferDescriptor_t *prvTCPBufferResize( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer,
	int32_t lDataLen, UBaseType_t uxOptionsLength )
{
 800b20c:	b580      	push	{r7, lr}
 800b20e:	b088      	sub	sp, #32
 800b210:	af00      	add	r7, sp, #0
 800b212:	60f8      	str	r0, [r7, #12]
 800b214:	60b9      	str	r1, [r7, #8]
 800b216:	607a      	str	r2, [r7, #4]
 800b218:	603b      	str	r3, [r7, #0]
NetworkBufferDescriptor_t *pxReturn;
int32_t lNeeded;
BaseType_t xResize;

	if( xBufferAllocFixedSize != pdFALSE )
 800b21a:	4b2d      	ldr	r3, [pc, #180]	; (800b2d0 <prvTCPBufferResize+0xc4>)
 800b21c:	681b      	ldr	r3, [r3, #0]
 800b21e:	2b00      	cmp	r3, #0
 800b220:	d00a      	beq.n	800b238 <prvTCPBufferResize+0x2c>
	{
		/* Network buffers are created with a fixed size and can hold the largest
		MTU. */
		lNeeded = ( int32_t ) ipTOTAL_ETHERNET_FRAME_SIZE;
 800b222:	f240 53f2 	movw	r3, #1522	; 0x5f2
 800b226:	61bb      	str	r3, [r7, #24]
		/* and therefore, the buffer won't be too small.
		Only ask for a new network buffer in case none was supplied. */
		xResize = ( pxNetworkBuffer == NULL );
 800b228:	68bb      	ldr	r3, [r7, #8]
 800b22a:	2b00      	cmp	r3, #0
 800b22c:	bf0c      	ite	eq
 800b22e:	2301      	moveq	r3, #1
 800b230:	2300      	movne	r3, #0
 800b232:	b2db      	uxtb	r3, r3
 800b234:	617b      	str	r3, [r7, #20]
 800b236:	e014      	b.n	800b262 <prvTCPBufferResize+0x56>
	else
	{
		/* Network buffers are created with a variable size. See if it must
		grow. */
		lNeeded = FreeRTOS_max_int32( ( int32_t ) sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ),
			( int32_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + lDataLen );
 800b238:	687a      	ldr	r2, [r7, #4]
 800b23a:	683b      	ldr	r3, [r7, #0]
 800b23c:	4413      	add	r3, r2
 800b23e:	3336      	adds	r3, #54	; 0x36
	}
	else
	{
		/* Network buffers are created with a variable size. See if it must
		grow. */
		lNeeded = FreeRTOS_max_int32( ( int32_t ) sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ),
 800b240:	2046      	movs	r0, #70	; 0x46
 800b242:	4619      	mov	r1, r3
 800b244:	f7ff f84a 	bl	800a2dc <FreeRTOS_max_int32>
 800b248:	61b8      	str	r0, [r7, #24]
			( int32_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + lDataLen );
		/* In case we were called from a TCP timer event, a buffer must be
		created.  Otherwise, test 'xDataLength' of the provided buffer. */
		xResize = ( pxNetworkBuffer == NULL ) || ( pxNetworkBuffer->xDataLength < (size_t)lNeeded );
 800b24a:	68bb      	ldr	r3, [r7, #8]
 800b24c:	2b00      	cmp	r3, #0
 800b24e:	d004      	beq.n	800b25a <prvTCPBufferResize+0x4e>
 800b250:	68bb      	ldr	r3, [r7, #8]
 800b252:	69da      	ldr	r2, [r3, #28]
 800b254:	69bb      	ldr	r3, [r7, #24]
 800b256:	429a      	cmp	r2, r3
 800b258:	d201      	bcs.n	800b25e <prvTCPBufferResize+0x52>
 800b25a:	2301      	movs	r3, #1
 800b25c:	e000      	b.n	800b260 <prvTCPBufferResize+0x54>
 800b25e:	2300      	movs	r3, #0
 800b260:	617b      	str	r3, [r7, #20]
	}

	if( xResize != pdFALSE )
 800b262:	697b      	ldr	r3, [r7, #20]
 800b264:	2b00      	cmp	r3, #0
 800b266:	d024      	beq.n	800b2b2 <prvTCPBufferResize+0xa6>
	{
		/* The caller didn't provide a network buffer or the provided buffer is
		too small.  As we must send-out a data packet, a buffer will be created
		here. */
		pxReturn = pxGetNetworkBufferWithDescriptor( ( uint32_t ) lNeeded, 0u );
 800b268:	69bb      	ldr	r3, [r7, #24]
 800b26a:	4618      	mov	r0, r3
 800b26c:	2100      	movs	r1, #0
 800b26e:	f7fc fa3b 	bl	80076e8 <pxGetNetworkBufferWithDescriptor>
 800b272:	61f8      	str	r0, [r7, #28]

		if( pxReturn != NULL )
 800b274:	69fb      	ldr	r3, [r7, #28]
 800b276:	2b00      	cmp	r3, #0
 800b278:	d024      	beq.n	800b2c4 <prvTCPBufferResize+0xb8>
		{
			/* Copy the existing data to the new created buffer. */
			if( pxNetworkBuffer )
 800b27a:	68bb      	ldr	r3, [r7, #8]
 800b27c:	2b00      	cmp	r3, #0
 800b27e:	d00e      	beq.n	800b29e <prvTCPBufferResize+0x92>
			{
				/* Either from the previous buffer... */
				memcpy( pxReturn->pucEthernetBuffer, pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength );
 800b280:	69fb      	ldr	r3, [r7, #28]
 800b282:	6999      	ldr	r1, [r3, #24]
 800b284:	68bb      	ldr	r3, [r7, #8]
 800b286:	699a      	ldr	r2, [r3, #24]
 800b288:	68bb      	ldr	r3, [r7, #8]
 800b28a:	69db      	ldr	r3, [r3, #28]
 800b28c:	4608      	mov	r0, r1
 800b28e:	4611      	mov	r1, r2
 800b290:	461a      	mov	r2, r3
 800b292:	f004 ff09 	bl	80100a8 <memcpy>

				/* ...and release it. */
				vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800b296:	68b8      	ldr	r0, [r7, #8]
 800b298:	f7fc faa0 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
 800b29c:	e012      	b.n	800b2c4 <prvTCPBufferResize+0xb8>
			}
			else
			{
				/* Or from the socket field 'xTCP.xPacket'. */
				memcpy( pxReturn->pucEthernetBuffer, pxSocket->u.xTCP.xPacket.u.ucLastPacket, sizeof( pxSocket->u.xTCP.xPacket.u.ucLastPacket ) );
 800b29e:	69fb      	ldr	r3, [r7, #28]
 800b2a0:	699a      	ldr	r2, [r3, #24]
 800b2a2:	68fb      	ldr	r3, [r7, #12]
 800b2a4:	3382      	adds	r3, #130	; 0x82
 800b2a6:	4610      	mov	r0, r2
 800b2a8:	4619      	mov	r1, r3
 800b2aa:	2246      	movs	r2, #70	; 0x46
 800b2ac:	f004 fefc 	bl	80100a8 <memcpy>
 800b2b0:	e008      	b.n	800b2c4 <prvTCPBufferResize+0xb8>
		}
	}
	else
	{
		/* xResize is false, the network buffer provided was big enough. */
		pxReturn = pxNetworkBuffer;
 800b2b2:	68bb      	ldr	r3, [r7, #8]
 800b2b4:	61fb      	str	r3, [r7, #28]

		/* Thanks to Andrey Ivanov from swissEmbedded for reporting that the
		xDataLength member must get the correct length too! */
		pxNetworkBuffer->xDataLength = ( size_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength ) + ( size_t ) lDataLen;
 800b2b6:	687a      	ldr	r2, [r7, #4]
 800b2b8:	683b      	ldr	r3, [r7, #0]
 800b2ba:	4413      	add	r3, r2
 800b2bc:	f103 0236 	add.w	r2, r3, #54	; 0x36
 800b2c0:	68bb      	ldr	r3, [r7, #8]
 800b2c2:	61da      	str	r2, [r3, #28]
	}

	return pxReturn;
 800b2c4:	69fb      	ldr	r3, [r7, #28]
}
 800b2c6:	4618      	mov	r0, r3
 800b2c8:	3720      	adds	r7, #32
 800b2ca:	46bd      	mov	sp, r7
 800b2cc:	bd80      	pop	{r7, pc}
 800b2ce:	bf00      	nop
 800b2d0:	08012a08 	.word	0x08012a08

0800b2d4 <prvTCPPrepareSend>:

/*
 * Prepare an outgoing message, in case anything has to be sent.
 */
static int32_t prvTCPPrepareSend( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer, UBaseType_t uxOptionsLength )
{
 800b2d4:	b590      	push	{r4, r7, lr}
 800b2d6:	b093      	sub	sp, #76	; 0x4c
 800b2d8:	af02      	add	r7, sp, #8
 800b2da:	60f8      	str	r0, [r7, #12]
 800b2dc:	60b9      	str	r1, [r7, #8]
 800b2de:	607a      	str	r2, [r7, #4]
uint32_t ulDataGot, ulDistance;
TCPWindow_t *pxTCPWindow;
NetworkBufferDescriptor_t *pxNewBuffer;
int32_t lStreamPos;

	if( ( *ppxNetworkBuffer ) != NULL )
 800b2e0:	68bb      	ldr	r3, [r7, #8]
 800b2e2:	681b      	ldr	r3, [r3, #0]
 800b2e4:	2b00      	cmp	r3, #0
 800b2e6:	d004      	beq.n	800b2f2 <prvTCPPrepareSend+0x1e>
	{
		/* A network buffer descriptor was already supplied */
		pucEthernetBuffer = ( *ppxNetworkBuffer )->pucEthernetBuffer;
 800b2e8:	68bb      	ldr	r3, [r7, #8]
 800b2ea:	681b      	ldr	r3, [r3, #0]
 800b2ec:	699b      	ldr	r3, [r3, #24]
 800b2ee:	63bb      	str	r3, [r7, #56]	; 0x38
 800b2f0:	e002      	b.n	800b2f8 <prvTCPPrepareSend+0x24>
	}
	else
	{
		/* For now let it point to the last packet header */
		pucEthernetBuffer = pxSocket->u.xTCP.xPacket.u.ucLastPacket;
 800b2f2:	68fb      	ldr	r3, [r7, #12]
 800b2f4:	3382      	adds	r3, #130	; 0x82
 800b2f6:	63bb      	str	r3, [r7, #56]	; 0x38
	}

	pxTCPPacket = ( TCPPacket_t * ) ( pucEthernetBuffer );
 800b2f8:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b2fa:	637b      	str	r3, [r7, #52]	; 0x34
	pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 800b2fc:	68fb      	ldr	r3, [r7, #12]
 800b2fe:	33dc      	adds	r3, #220	; 0xdc
 800b300:	62fb      	str	r3, [r7, #44]	; 0x2c
	lDataLen = 0;
 800b302:	2300      	movs	r3, #0
 800b304:	63fb      	str	r3, [r7, #60]	; 0x3c
	lStreamPos = 0;
 800b306:	2300      	movs	r3, #0
 800b308:	613b      	str	r3, [r7, #16]
	pxTCPPacket->xTCPHeader.ucTCPFlags |= ipTCP_FLAG_ACK;
 800b30a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b30c:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800b310:	f043 0310 	orr.w	r3, r3, #16
 800b314:	b2da      	uxtb	r2, r3
 800b316:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b318:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

	if( pxSocket->u.xTCP.txStream != NULL )
 800b31c:	68fb      	ldr	r3, [r7, #12]
 800b31e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b320:	2b00      	cmp	r3, #0
 800b322:	d07f      	beq.n	800b424 <prvTCPPrepareSend+0x150>
	{
		/* ulTCPWindowTxGet will return the amount of data which may be sent
		along with the position in the txStream.
		Why check for MSS > 1 ?
		Because some TCP-stacks (like uIP) use it for flow-control. */
		if( pxSocket->u.xTCP.usCurMSS > 1u )
 800b324:	68fb      	ldr	r3, [r7, #12]
 800b326:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 800b32a:	2b01      	cmp	r3, #1
 800b32c:	d90b      	bls.n	800b346 <prvTCPPrepareSend+0x72>
		{
			lDataLen = ( int32_t ) ulTCPWindowTxGet( pxTCPWindow, pxSocket->u.xTCP.ulWindowSize, &lStreamPos );
 800b32e:	68fb      	ldr	r3, [r7, #12]
 800b330:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
 800b334:	f107 0310 	add.w	r3, r7, #16
 800b338:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b33a:	4611      	mov	r1, r2
 800b33c:	461a      	mov	r2, r3
 800b33e:	f002 f815 	bl	800d36c <ulTCPWindowTxGet>
 800b342:	4603      	mov	r3, r0
 800b344:	63fb      	str	r3, [r7, #60]	; 0x3c
		}

		if( lDataLen > 0 )
 800b346:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b348:	2b00      	cmp	r3, #0
 800b34a:	dd6b      	ble.n	800b424 <prvTCPPrepareSend+0x150>
		{
			/* Check if the current network buffer is big enough, if not,
			resize it. */
			pxNewBuffer = prvTCPBufferResize( pxSocket, *ppxNetworkBuffer, lDataLen, uxOptionsLength );
 800b34c:	68bb      	ldr	r3, [r7, #8]
 800b34e:	681b      	ldr	r3, [r3, #0]
 800b350:	68f8      	ldr	r0, [r7, #12]
 800b352:	4619      	mov	r1, r3
 800b354:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b356:	687b      	ldr	r3, [r7, #4]
 800b358:	f7ff ff58 	bl	800b20c <prvTCPBufferResize>
 800b35c:	62b8      	str	r0, [r7, #40]	; 0x28

			if( pxNewBuffer != NULL )
 800b35e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b360:	2b00      	cmp	r3, #0
 800b362:	d05c      	beq.n	800b41e <prvTCPPrepareSend+0x14a>
			{
				*ppxNetworkBuffer = pxNewBuffer;
 800b364:	68bb      	ldr	r3, [r7, #8]
 800b366:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800b368:	601a      	str	r2, [r3, #0]
				pucEthernetBuffer = pxNewBuffer->pucEthernetBuffer;
 800b36a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b36c:	699b      	ldr	r3, [r3, #24]
 800b36e:	63bb      	str	r3, [r7, #56]	; 0x38
				pxTCPPacket = ( TCPPacket_t * ) ( pucEthernetBuffer );
 800b370:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800b372:	637b      	str	r3, [r7, #52]	; 0x34

				pucSendData = pucEthernetBuffer + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength;
 800b374:	687b      	ldr	r3, [r7, #4]
 800b376:	3336      	adds	r3, #54	; 0x36
 800b378:	6bba      	ldr	r2, [r7, #56]	; 0x38
 800b37a:	4413      	add	r3, r2
 800b37c:	627b      	str	r3, [r7, #36]	; 0x24

				/* Translate the position in txStream to an offset from the tail
				marker. */
				uxOffset = uxStreamBufferDistance( pxSocket->u.xTCP.txStream, pxSocket->u.xTCP.txStream->uxTail, ( size_t ) lStreamPos );
 800b37e:	68fb      	ldr	r3, [r7, #12]
 800b380:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800b382:	68fb      	ldr	r3, [r7, #12]
 800b384:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b386:	681b      	ldr	r3, [r3, #0]
 800b388:	6939      	ldr	r1, [r7, #16]
 800b38a:	460c      	mov	r4, r1
 800b38c:	4610      	mov	r0, r2
 800b38e:	4619      	mov	r1, r3
 800b390:	4622      	mov	r2, r4
 800b392:	f7fe fff3 	bl	800a37c <uxStreamBufferDistance>
 800b396:	6238      	str	r0, [r7, #32]

				/* Here data is copied from the txStream in 'peek' mode.  Only
				when the packets are acked, the tail marker will be updated. */
				ulDataGot = ( uint32_t ) uxStreamBufferGet( pxSocket->u.xTCP.txStream, uxOffset, pucSendData, ( size_t ) lDataLen, pdTRUE );
 800b398:	68fb      	ldr	r3, [r7, #12]
 800b39a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800b39c:	6bfc      	ldr	r4, [r7, #60]	; 0x3c
 800b39e:	2301      	movs	r3, #1
 800b3a0:	9300      	str	r3, [sp, #0]
 800b3a2:	4610      	mov	r0, r2
 800b3a4:	6a39      	ldr	r1, [r7, #32]
 800b3a6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800b3a8:	4623      	mov	r3, r4
 800b3aa:	f002 fb37 	bl	800da1c <uxStreamBufferGet>
 800b3ae:	61f8      	str	r0, [r7, #28]
				}
				#endif

				/* If the owner of the socket requests a closure, add the FIN
				flag to the last packet. */
				if( ( pxSocket->u.xTCP.bits.bCloseRequested != pdFALSE_UNSIGNED ) && ( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) )
 800b3b0:	68fb      	ldr	r3, [r7, #12]
 800b3b2:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800b3b6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b3ba:	b2db      	uxtb	r3, r3
 800b3bc:	2b00      	cmp	r3, #0
 800b3be:	d031      	beq.n	800b424 <prvTCPPrepareSend+0x150>
 800b3c0:	68fb      	ldr	r3, [r7, #12]
 800b3c2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800b3c6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b3ca:	b2db      	uxtb	r3, r3
 800b3cc:	2b00      	cmp	r3, #0
 800b3ce:	d129      	bne.n	800b424 <prvTCPPrepareSend+0x150>
				{
					ulDistance = ( uint32_t ) uxStreamBufferDistance( pxSocket->u.xTCP.txStream, ( size_t ) lStreamPos, pxSocket->u.xTCP.txStream->uxHead );
 800b3d0:	68fb      	ldr	r3, [r7, #12]
 800b3d2:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800b3d4:	693b      	ldr	r3, [r7, #16]
 800b3d6:	4619      	mov	r1, r3
 800b3d8:	68fb      	ldr	r3, [r7, #12]
 800b3da:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b3dc:	689b      	ldr	r3, [r3, #8]
 800b3de:	4610      	mov	r0, r2
 800b3e0:	461a      	mov	r2, r3
 800b3e2:	f7fe ffcb 	bl	800a37c <uxStreamBufferDistance>
 800b3e6:	61b8      	str	r0, [r7, #24]

					if( ulDistance == ulDataGot )
 800b3e8:	69ba      	ldr	r2, [r7, #24]
 800b3ea:	69fb      	ldr	r3, [r7, #28]
 800b3ec:	429a      	cmp	r2, r3
 800b3ee:	d119      	bne.n	800b424 <prvTCPPrepareSend+0x150>
						}
						#endif
						/* Although the socket sends a FIN, it will stay in
						ESTABLISHED until all current data has been received or
						delivered. */
						pxTCPPacket->xTCPHeader.ucTCPFlags |= ipTCP_FLAG_FIN;
 800b3f0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b3f2:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800b3f6:	f043 0301 	orr.w	r3, r3, #1
 800b3fa:	b2da      	uxtb	r2, r3
 800b3fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b3fe:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
						pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->ulOurSequenceNumber + ( uint32_t ) lDataLen;
 800b402:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b404:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800b406:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b408:	441a      	add	r2, r3
 800b40a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b40c:	625a      	str	r2, [r3, #36]	; 0x24
						pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 800b40e:	68fa      	ldr	r2, [r7, #12]
 800b410:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800b414:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b418:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
 800b41c:	e002      	b.n	800b424 <prvTCPPrepareSend+0x150>
					}
				}
			}
			else
			{
				lDataLen = -1;
 800b41e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800b422:	63fb      	str	r3, [r7, #60]	; 0x3c
			}
		}
	}

	if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) )
 800b424:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b426:	2b00      	cmp	r3, #0
 800b428:	db7e      	blt.n	800b528 <prvTCPPrepareSend+0x254>
 800b42a:	68fb      	ldr	r3, [r7, #12]
 800b42c:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800b430:	2b05      	cmp	r3, #5
 800b432:	d179      	bne.n	800b528 <prvTCPPrepareSend+0x254>
	{
		/* See if the socket owner wants to shutdown this connection. */
		if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
 800b434:	68fb      	ldr	r3, [r7, #12]
 800b436:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800b43a:	f003 0320 	and.w	r3, r3, #32
 800b43e:	b2db      	uxtb	r3, r3
 800b440:	2b00      	cmp	r3, #0
 800b442:	d02b      	beq.n	800b49c <prvTCPPrepareSend+0x1c8>
			( xTCPWindowTxDone( pxTCPWindow ) != pdFALSE ) )
 800b444:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800b446:	f001 fed9 	bl	800d1fc <xTCPWindowTxDone>
 800b44a:	4603      	mov	r3, r0
	}

	if( ( lDataLen >= 0 ) && ( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) )
	{
		/* See if the socket owner wants to shutdown this connection. */
		if( ( pxSocket->u.xTCP.bits.bUserShutdown != pdFALSE_UNSIGNED ) &&
 800b44c:	2b00      	cmp	r3, #0
 800b44e:	d025      	beq.n	800b49c <prvTCPPrepareSend+0x1c8>
			( xTCPWindowTxDone( pxTCPWindow ) != pdFALSE ) )
		{
			pxSocket->u.xTCP.bits.bUserShutdown = pdFALSE_UNSIGNED;
 800b450:	68fa      	ldr	r2, [r7, #12]
 800b452:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 800b456:	f36f 1345 	bfc	r3, #5, #1
 800b45a:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
			pxTCPPacket->xTCPHeader.ucTCPFlags |= ipTCP_FLAG_FIN;
 800b45e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b460:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800b464:	f043 0301 	orr.w	r3, r3, #1
 800b468:	b2da      	uxtb	r2, r3
 800b46a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b46c:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
			pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 800b470:	68fa      	ldr	r2, [r7, #12]
 800b472:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800b476:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b47a:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 800b47e:	68fa      	ldr	r2, [r7, #12]
 800b480:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800b484:	f043 0301 	orr.w	r3, r3, #1
 800b488:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
			pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 800b48c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b48e:	6a1a      	ldr	r2, [r3, #32]
 800b490:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b492:	625a      	str	r2, [r3, #36]	; 0x24
			vTCPStateChange( pxSocket, eFIN_WAIT_1 );
 800b494:	68f8      	ldr	r0, [r7, #12]
 800b496:	2106      	movs	r1, #6
 800b498:	f7ff fdde 	bl	800b058 <vTCPStateChange>
		}

		#if( ipconfigTCP_KEEP_ALIVE != 0 )
		{
			if( pxSocket->u.xTCP.ucKeepRepCount > 3u )
 800b49c:	68fb      	ldr	r3, [r7, #12]
 800b49e:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 800b4a2:	2b03      	cmp	r3, #3
 800b4a4:	d906      	bls.n	800b4b4 <prvTCPPrepareSend+0x1e0>
			{
				FreeRTOS_debug_printf( ( "keep-alive: giving up %lxip:%u\n",
					pxSocket->u.xTCP.ulRemoteIP,			/* IP address of remote machine. */
					pxSocket->u.xTCP.usRemotePort ) );	/* Port on remote machine. */
				vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800b4a6:	68f8      	ldr	r0, [r7, #12]
 800b4a8:	2108      	movs	r1, #8
 800b4aa:	f7ff fdd5 	bl	800b058 <vTCPStateChange>
				lDataLen = -1;
 800b4ae:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800b4b2:	63fb      	str	r3, [r7, #60]	; 0x3c
			}
			if( ( lDataLen == 0 ) && ( pxSocket->u.xTCP.bits.bWinChange == pdFALSE_UNSIGNED ) )
 800b4b4:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b4b6:	2b00      	cmp	r3, #0
 800b4b8:	d136      	bne.n	800b528 <prvTCPPrepareSend+0x254>
 800b4ba:	68fb      	ldr	r3, [r7, #12]
 800b4bc:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800b4c0:	f003 0301 	and.w	r3, r3, #1
 800b4c4:	b2db      	uxtb	r3, r3
 800b4c6:	2b00      	cmp	r3, #0
 800b4c8:	d12e      	bne.n	800b528 <prvTCPPrepareSend+0x254>
			{
				/* If there is no data to be sent, and no window-update message,
				we might want to send a keep-alive message. */
				TickType_t xAge = xTaskGetTickCount( ) - pxSocket->u.xTCP.xLastAliveTime;
 800b4ca:	f7fa f85b 	bl	8005584 <xTaskGetTickCount>
 800b4ce:	4602      	mov	r2, r0
 800b4d0:	68fb      	ldr	r3, [r7, #12]
 800b4d2:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800b4d4:	1ad3      	subs	r3, r2, r3
 800b4d6:	617b      	str	r3, [r7, #20]
				TickType_t xMax;
				xMax = ( ( TickType_t ) ipconfigTCP_KEEP_ALIVE_INTERVAL * configTICK_RATE_HZ );
 800b4d8:	f644 6320 	movw	r3, #20000	; 0x4e20
 800b4dc:	633b      	str	r3, [r7, #48]	; 0x30
				if( pxSocket->u.xTCP.ucKeepRepCount )
 800b4de:	68fb      	ldr	r3, [r7, #12]
 800b4e0:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 800b4e4:	2b00      	cmp	r3, #0
 800b4e6:	d002      	beq.n	800b4ee <prvTCPPrepareSend+0x21a>
				{
					xMax = ( 3u * configTICK_RATE_HZ );
 800b4e8:	f640 33b8 	movw	r3, #3000	; 0xbb8
 800b4ec:	633b      	str	r3, [r7, #48]	; 0x30
				}
				if( xAge > xMax )
 800b4ee:	697a      	ldr	r2, [r7, #20]
 800b4f0:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800b4f2:	429a      	cmp	r2, r3
 800b4f4:	d918      	bls.n	800b528 <prvTCPPrepareSend+0x254>
				{
					pxSocket->u.xTCP.xLastAliveTime = xTaskGetTickCount( );
 800b4f6:	f7fa f845 	bl	8005584 <xTaskGetTickCount>
 800b4fa:	4602      	mov	r2, r0
 800b4fc:	68fb      	ldr	r3, [r7, #12]
 800b4fe:	65da      	str	r2, [r3, #92]	; 0x5c
					if( xTCPWindowLoggingLevel )
						FreeRTOS_debug_printf( ( "keep-alive: %lxip:%u count %u\n",
							pxSocket->u.xTCP.ulRemoteIP,
							pxSocket->u.xTCP.usRemotePort,
							pxSocket->u.xTCP.ucKeepRepCount ) );
					pxSocket->u.xTCP.bits.bSendKeepAlive = pdTRUE_UNSIGNED;
 800b500:	68fa      	ldr	r2, [r7, #12]
 800b502:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800b506:	f043 0302 	orr.w	r3, r3, #2
 800b50a:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
					pxSocket->u.xTCP.usTimeout = ( ( uint16_t ) pdMS_TO_TICKS( 2500 ) );
 800b50e:	68fb      	ldr	r3, [r7, #12]
 800b510:	f640 12c4 	movw	r2, #2500	; 0x9c4
 800b514:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
					pxSocket->u.xTCP.ucKeepRepCount++;
 800b518:	68fb      	ldr	r3, [r7, #12]
 800b51a:	f893 3058 	ldrb.w	r3, [r3, #88]	; 0x58
 800b51e:	3301      	adds	r3, #1
 800b520:	b2da      	uxtb	r2, r3
 800b522:	68fb      	ldr	r3, [r7, #12]
 800b524:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
		#endif /* ipconfigTCP_KEEP_ALIVE */
	}

	/* Anything to send, a change of the advertised window size, or maybe send a
	keep-alive message? */
	if( ( lDataLen > 0 ) ||
 800b528:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b52a:	2b00      	cmp	r3, #0
 800b52c:	dc0f      	bgt.n	800b54e <prvTCPPrepareSend+0x27a>
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 800b52e:	68fb      	ldr	r3, [r7, #12]
 800b530:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800b534:	f003 0301 	and.w	r3, r3, #1
 800b538:	b2db      	uxtb	r3, r3
		#endif /* ipconfigTCP_KEEP_ALIVE */
	}

	/* Anything to send, a change of the advertised window size, or maybe send a
	keep-alive message? */
	if( ( lDataLen > 0 ) ||
 800b53a:	2b00      	cmp	r3, #0
 800b53c:	d107      	bne.n	800b54e <prvTCPPrepareSend+0x27a>
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
		( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED ) )
 800b53e:	68fb      	ldr	r3, [r7, #12]
 800b540:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800b544:	f003 0302 	and.w	r3, r3, #2
 800b548:	b2db      	uxtb	r3, r3
	}

	/* Anything to send, a change of the advertised window size, or maybe send a
	keep-alive message? */
	if( ( lDataLen > 0 ) ||
		( pxSocket->u.xTCP.bits.bWinChange != pdFALSE_UNSIGNED ) ||
 800b54a:	2b00      	cmp	r3, #0
 800b54c:	d02b      	beq.n	800b5a6 <prvTCPPrepareSend+0x2d2>
		( pxSocket->u.xTCP.bits.bSendKeepAlive != pdFALSE_UNSIGNED ) )
	{
		pxTCPPacket->xTCPHeader.ucTCPFlags &= ( ( uint8_t ) ~ipTCP_FLAG_PSH );
 800b54e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b550:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800b554:	f023 0308 	bic.w	r3, r3, #8
 800b558:	b2da      	uxtb	r2, r3
 800b55a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b55c:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800b560:	687b      	ldr	r3, [r7, #4]
 800b562:	b2db      	uxtb	r3, r3
 800b564:	3314      	adds	r3, #20
 800b566:	b2db      	uxtb	r3, r3
 800b568:	009b      	lsls	r3, r3, #2
 800b56a:	b2da      	uxtb	r2, r3
 800b56c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b56e:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

		pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_ACK;
 800b572:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b574:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800b578:	f043 0310 	orr.w	r3, r3, #16
 800b57c:	b2da      	uxtb	r2, r3
 800b57e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b580:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

		if( lDataLen != 0l )
 800b584:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 800b586:	2b00      	cmp	r3, #0
 800b588:	d008      	beq.n	800b59c <prvTCPPrepareSend+0x2c8>
		{
			pxTCPPacket->xTCPHeader.ucTCPFlags |= ( uint8_t ) ipTCP_FLAG_PSH;
 800b58a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b58c:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800b590:	f043 0308 	orr.w	r3, r3, #8
 800b594:	b2da      	uxtb	r2, r3
 800b596:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b598:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
				}
			}
		}
		#endif

		lDataLen += ( int32_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 800b59c:	6bfa      	ldr	r2, [r7, #60]	; 0x3c
 800b59e:	687b      	ldr	r3, [r7, #4]
 800b5a0:	4413      	add	r3, r2
 800b5a2:	3328      	adds	r3, #40	; 0x28
 800b5a4:	63fb      	str	r3, [r7, #60]	; 0x3c
	}

	return lDataLen;
 800b5a6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
 800b5a8:	4618      	mov	r0, r3
 800b5aa:	3744      	adds	r7, #68	; 0x44
 800b5ac:	46bd      	mov	sp, r7
 800b5ae:	bd90      	pop	{r4, r7, pc}

0800b5b0 <prvTCPNextTimeout>:

/*
 * Calculate after how much time this socket needs to be checked again.
 */
static TickType_t prvTCPNextTimeout ( FreeRTOS_Socket_t *pxSocket )
{
 800b5b0:	b580      	push	{r7, lr}
 800b5b2:	b084      	sub	sp, #16
 800b5b4:	af00      	add	r7, sp, #0
 800b5b6:	6078      	str	r0, [r7, #4]
TickType_t ulDelayMs = ( TickType_t ) 20000;
 800b5b8:	f644 6320 	movw	r3, #20000	; 0x4e20
 800b5bc:	60bb      	str	r3, [r7, #8]

	if( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN )
 800b5be:	687b      	ldr	r3, [r7, #4]
 800b5c0:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800b5c4:	2b02      	cmp	r3, #2
 800b5c6:	d135      	bne.n	800b634 <prvTCPNextTimeout+0x84>
	{
		/* The socket is actively connecting to a peer. */
		if( pxSocket->u.xTCP.bits.bConnPrepared )
 800b5c8:	687b      	ldr	r3, [r7, #4]
 800b5ca:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800b5ce:	f003 0308 	and.w	r3, r3, #8
 800b5d2:	b2db      	uxtb	r3, r3
 800b5d4:	2b00      	cmp	r3, #0
 800b5d6:	d012      	beq.n	800b5fe <prvTCPNextTimeout+0x4e>
		{
			/* Ethernet address has been found, use progressive timeout for
			active connect(). */
			if( pxSocket->u.xTCP.ucRepCount < 3u )
 800b5d8:	687b      	ldr	r3, [r7, #4]
 800b5da:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
 800b5de:	2b02      	cmp	r3, #2
 800b5e0:	d809      	bhi.n	800b5f6 <prvTCPNextTimeout+0x46>
			{
				ulDelayMs = ( 3000UL << ( pxSocket->u.xTCP.ucRepCount - 1u ) );
 800b5e2:	687b      	ldr	r3, [r7, #4]
 800b5e4:	f893 3052 	ldrb.w	r3, [r3, #82]	; 0x52
 800b5e8:	3b01      	subs	r3, #1
 800b5ea:	461a      	mov	r2, r3
 800b5ec:	f640 33b8 	movw	r3, #3000	; 0xbb8
 800b5f0:	4093      	lsls	r3, r2
 800b5f2:	60bb      	str	r3, [r7, #8]
 800b5f4:	e006      	b.n	800b604 <prvTCPNextTimeout+0x54>
			}
			else
			{
				ulDelayMs = 11000UL;
 800b5f6:	f642 23f8 	movw	r3, #11000	; 0x2af8
 800b5fa:	60bb      	str	r3, [r7, #8]
 800b5fc:	e002      	b.n	800b604 <prvTCPNextTimeout+0x54>
			}
		}
		else
		{
			/* Still in the ARP phase: check every half second. */
			ulDelayMs = 500UL;
 800b5fe:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 800b602:	60bb      	str	r3, [r7, #8]
		}

		FreeRTOS_debug_printf( ( "Connect[%lxip:%u]: next timeout %u: %lu ms\n",
			pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort,
			pxSocket->u.xTCP.ucRepCount, ulDelayMs ) );
		pxSocket->u.xTCP.usTimeout = ( uint16_t )pdMS_TO_MIN_TICKS( ulDelayMs );
 800b604:	68bb      	ldr	r3, [r7, #8]
 800b606:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b60a:	fb02 f303 	mul.w	r3, r2, r3
 800b60e:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800b612:	d30a      	bcc.n	800b62a <prvTCPNextTimeout+0x7a>
 800b614:	68bb      	ldr	r3, [r7, #8]
 800b616:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b61a:	fb02 f303 	mul.w	r3, r2, r3
 800b61e:	4a23      	ldr	r2, [pc, #140]	; (800b6ac <prvTCPNextTimeout+0xfc>)
 800b620:	fba2 2303 	umull	r2, r3, r2, r3
 800b624:	099b      	lsrs	r3, r3, #6
 800b626:	b29a      	uxth	r2, r3
 800b628:	e000      	b.n	800b62c <prvTCPNextTimeout+0x7c>
 800b62a:	2201      	movs	r2, #1
 800b62c:	687b      	ldr	r3, [r7, #4]
 800b62e:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
 800b632:	e034      	b.n	800b69e <prvTCPNextTimeout+0xee>
	}
	else if( pxSocket->u.xTCP.usTimeout == 0u )
 800b634:	687b      	ldr	r3, [r7, #4]
 800b636:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
 800b63a:	2b00      	cmp	r3, #0
 800b63c:	d12f      	bne.n	800b69e <prvTCPNextTimeout+0xee>
	{
		/* Let the sliding window mechanism decide what time-out is appropriate. */
		BaseType_t xResult = xTCPWindowTxHasData( &pxSocket->u.xTCP.xTCPWindow, pxSocket->u.xTCP.ulWindowSize, &ulDelayMs );
 800b63e:	687b      	ldr	r3, [r7, #4]
 800b640:	f103 01dc 	add.w	r1, r3, #220	; 0xdc
 800b644:	687b      	ldr	r3, [r7, #4]
 800b646:	f8d3 20cc 	ldr.w	r2, [r3, #204]	; 0xcc
 800b64a:	f107 0308 	add.w	r3, r7, #8
 800b64e:	4608      	mov	r0, r1
 800b650:	4611      	mov	r1, r2
 800b652:	461a      	mov	r2, r3
 800b654:	f001 fe2a 	bl	800d2ac <xTCPWindowTxHasData>
 800b658:	60f8      	str	r0, [r7, #12]
		if( ulDelayMs == 0u )
 800b65a:	68bb      	ldr	r3, [r7, #8]
 800b65c:	2b00      	cmp	r3, #0
 800b65e:	d107      	bne.n	800b670 <prvTCPNextTimeout+0xc0>
		{
			ulDelayMs = xResult ? 1UL : 20000UL;
 800b660:	68fb      	ldr	r3, [r7, #12]
 800b662:	2b00      	cmp	r3, #0
 800b664:	d001      	beq.n	800b66a <prvTCPNextTimeout+0xba>
 800b666:	2301      	movs	r3, #1
 800b668:	e001      	b.n	800b66e <prvTCPNextTimeout+0xbe>
 800b66a:	f644 6320 	movw	r3, #20000	; 0x4e20
 800b66e:	60bb      	str	r3, [r7, #8]
		}
		else
		{
			/* ulDelayMs contains the time to wait before a re-transmission. */
		}
		pxSocket->u.xTCP.usTimeout = ( uint16_t )pdMS_TO_MIN_TICKS( ulDelayMs );
 800b670:	68bb      	ldr	r3, [r7, #8]
 800b672:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b676:	fb02 f303 	mul.w	r3, r2, r3
 800b67a:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 800b67e:	d30a      	bcc.n	800b696 <prvTCPNextTimeout+0xe6>
 800b680:	68bb      	ldr	r3, [r7, #8]
 800b682:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800b686:	fb02 f303 	mul.w	r3, r2, r3
 800b68a:	4a08      	ldr	r2, [pc, #32]	; (800b6ac <prvTCPNextTimeout+0xfc>)
 800b68c:	fba2 2303 	umull	r2, r3, r2, r3
 800b690:	099b      	lsrs	r3, r3, #6
 800b692:	b29a      	uxth	r2, r3
 800b694:	e000      	b.n	800b698 <prvTCPNextTimeout+0xe8>
 800b696:	2201      	movs	r2, #1
 800b698:	687b      	ldr	r3, [r7, #4]
 800b69a:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
		/* field '.usTimeout' has already been set (by the
		keep-alive/delayed-ACK mechanism). */
	}

	/* Return the number of clock ticks before the timer expires. */
	return ( TickType_t ) pxSocket->u.xTCP.usTimeout;
 800b69e:	687b      	ldr	r3, [r7, #4]
 800b6a0:	f8b3 3048 	ldrh.w	r3, [r3, #72]	; 0x48
}
 800b6a4:	4618      	mov	r0, r3
 800b6a6:	3710      	adds	r7, #16
 800b6a8:	46bd      	mov	sp, r7
 800b6aa:	bd80      	pop	{r7, pc}
 800b6ac:	10624dd3 	.word	0x10624dd3

0800b6b0 <prvTCPAddTxData>:
/*-----------------------------------------------------------*/

static void prvTCPAddTxData( FreeRTOS_Socket_t *pxSocket )
{
 800b6b0:	b590      	push	{r4, r7, lr}
 800b6b2:	b085      	sub	sp, #20
 800b6b4:	af00      	add	r7, sp, #0
 800b6b6:	6078      	str	r0, [r7, #4]
	the sliding window.

	uxStreamBufferMidSpace() returns the distance between rxHead and rxMid.  It contains new
	Tx data which has not been passed to the sliding window yet.  The oldest
	data not-yet-confirmed can be found at rxTail. */
	lLength = ( int32_t ) uxStreamBufferMidSpace( pxSocket->u.xTCP.txStream );
 800b6b8:	687b      	ldr	r3, [r7, #4]
 800b6ba:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b6bc:	4618      	mov	r0, r3
 800b6be:	f7fe fea3 	bl	800a408 <uxStreamBufferMidSpace>
 800b6c2:	4603      	mov	r3, r0
 800b6c4:	60fb      	str	r3, [r7, #12]

	if( lLength > 0 )
 800b6c6:	68fb      	ldr	r3, [r7, #12]
 800b6c8:	2b00      	cmp	r3, #0
 800b6ca:	dd1a      	ble.n	800b702 <prvTCPAddTxData+0x52>
		window manager, so it can start transmitting them.

		Hand over the new data to the sliding window handler.  It will be
		split-up in chunks of 1460 bytes each (or less, depending on
		ipconfigTCP_MSS). */
		lCount = lTCPWindowTxAdd(	&pxSocket->u.xTCP.xTCPWindow,
 800b6cc:	687b      	ldr	r3, [r7, #4]
 800b6ce:	f103 01dc 	add.w	r1, r3, #220	; 0xdc
 800b6d2:	68fa      	ldr	r2, [r7, #12]
								( uint32_t ) lLength,
								( int32_t ) pxSocket->u.xTCP.txStream->uxMid,
 800b6d4:	687b      	ldr	r3, [r7, #4]
 800b6d6:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b6d8:	685b      	ldr	r3, [r3, #4]
		window manager, so it can start transmitting them.

		Hand over the new data to the sliding window handler.  It will be
		split-up in chunks of 1460 bytes each (or less, depending on
		ipconfigTCP_MSS). */
		lCount = lTCPWindowTxAdd(	&pxSocket->u.xTCP.xTCPWindow,
 800b6da:	461c      	mov	r4, r3
								( uint32_t ) lLength,
								( int32_t ) pxSocket->u.xTCP.txStream->uxMid,
								( int32_t ) pxSocket->u.xTCP.txStream->LENGTH );
 800b6dc:	687b      	ldr	r3, [r7, #4]
 800b6de:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800b6e0:	691b      	ldr	r3, [r3, #16]
		window manager, so it can start transmitting them.

		Hand over the new data to the sliding window handler.  It will be
		split-up in chunks of 1460 bytes each (or less, depending on
		ipconfigTCP_MSS). */
		lCount = lTCPWindowTxAdd(	&pxSocket->u.xTCP.xTCPWindow,
 800b6e2:	4608      	mov	r0, r1
 800b6e4:	4611      	mov	r1, r2
 800b6e6:	4622      	mov	r2, r4
 800b6e8:	f001 fcd6 	bl	800d098 <lTCPWindowTxAdd>
 800b6ec:	60b8      	str	r0, [r7, #8]
								( uint32_t ) lLength,
								( int32_t ) pxSocket->u.xTCP.txStream->uxMid,
								( int32_t ) pxSocket->u.xTCP.txStream->LENGTH );

		/* Move the rxMid pointer forward up to rxHead. */
		if( lCount > 0 )
 800b6ee:	68bb      	ldr	r3, [r7, #8]
 800b6f0:	2b00      	cmp	r3, #0
 800b6f2:	dd06      	ble.n	800b702 <prvTCPAddTxData+0x52>
		{
			vStreamBufferMoveMid( pxSocket->u.xTCP.txStream, ( size_t ) lCount );
 800b6f4:	687b      	ldr	r3, [r7, #4]
 800b6f6:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800b6f8:	68bb      	ldr	r3, [r7, #8]
 800b6fa:	4610      	mov	r0, r2
 800b6fc:	4619      	mov	r1, r3
 800b6fe:	f7fe fe97 	bl	800a430 <vStreamBufferMoveMid>
		}
	}
}
 800b702:	3714      	adds	r7, #20
 800b704:	46bd      	mov	sp, r7
 800b706:	bd90      	pop	{r4, r7, pc}

0800b708 <prvTCPHandleFin>:
 * Or when the socket has sent a FIN flag to the peer
 * Before being called, it has been checked that both reception and transmission
 * are complete.
 */
static BaseType_t prvTCPHandleFin( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer )
{
 800b708:	b580      	push	{r7, lr}
 800b70a:	b088      	sub	sp, #32
 800b70c:	af00      	add	r7, sp, #0
 800b70e:	6078      	str	r0, [r7, #4]
 800b710:	6039      	str	r1, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800b712:	683b      	ldr	r3, [r7, #0]
 800b714:	699b      	ldr	r3, [r3, #24]
 800b716:	61bb      	str	r3, [r7, #24]
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
 800b718:	69bb      	ldr	r3, [r7, #24]
 800b71a:	3322      	adds	r3, #34	; 0x22
 800b71c:	617b      	str	r3, [r7, #20]
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 800b71e:	697b      	ldr	r3, [r7, #20]
 800b720:	7b5b      	ldrb	r3, [r3, #13]
 800b722:	74fb      	strb	r3, [r7, #19]
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 800b724:	687b      	ldr	r3, [r7, #4]
 800b726:	33dc      	adds	r3, #220	; 0xdc
 800b728:	60fb      	str	r3, [r7, #12]
BaseType_t xSendLength = 0;
 800b72a:	2300      	movs	r3, #0
 800b72c:	61fb      	str	r3, [r7, #28]
uint32_t ulAckNr = FreeRTOS_ntohl( pxTCPHeader->ulAckNr );
 800b72e:	697b      	ldr	r3, [r7, #20]
 800b730:	689b      	ldr	r3, [r3, #8]
 800b732:	061a      	lsls	r2, r3, #24
 800b734:	697b      	ldr	r3, [r7, #20]
 800b736:	689b      	ldr	r3, [r3, #8]
 800b738:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800b73c:	021b      	lsls	r3, r3, #8
 800b73e:	431a      	orrs	r2, r3
 800b740:	697b      	ldr	r3, [r7, #20]
 800b742:	689b      	ldr	r3, [r3, #8]
 800b744:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800b748:	0a1b      	lsrs	r3, r3, #8
 800b74a:	431a      	orrs	r2, r3
 800b74c:	697b      	ldr	r3, [r7, #20]
 800b74e:	689b      	ldr	r3, [r3, #8]
 800b750:	0e1b      	lsrs	r3, r3, #24
 800b752:	4313      	orrs	r3, r2
 800b754:	60bb      	str	r3, [r7, #8]

	if( ( ucTCPFlags & ipTCP_FLAG_FIN ) != 0u )
 800b756:	7cfb      	ldrb	r3, [r7, #19]
 800b758:	f003 0301 	and.w	r3, r3, #1
 800b75c:	2b00      	cmp	r3, #0
 800b75e:	d004      	beq.n	800b76a <prvTCPHandleFin+0x62>
	{
		pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulFINSequenceNumber + 1u;
 800b760:	68fb      	ldr	r3, [r7, #12]
 800b762:	695b      	ldr	r3, [r3, #20]
 800b764:	1c5a      	adds	r2, r3, #1
 800b766:	68fb      	ldr	r3, [r7, #12]
 800b768:	611a      	str	r2, [r3, #16]
	}
	if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 800b76a:	687b      	ldr	r3, [r7, #4]
 800b76c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800b770:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b774:	b2db      	uxtb	r3, r3
 800b776:	2b00      	cmp	r3, #0
 800b778:	d10b      	bne.n	800b792 <prvTCPHandleFin+0x8a>
	{
		/* We haven't yet replied with a FIN, do so now. */
		pxTCPWindow->tx.ulFINSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 800b77a:	68fb      	ldr	r3, [r7, #12]
 800b77c:	6a1a      	ldr	r2, [r3, #32]
 800b77e:	68fb      	ldr	r3, [r7, #12]
 800b780:	625a      	str	r2, [r3, #36]	; 0x24
		pxSocket->u.xTCP.bits.bFinSent = pdTRUE_UNSIGNED;
 800b782:	687a      	ldr	r2, [r7, #4]
 800b784:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800b788:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b78c:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
 800b790:	e00c      	b.n	800b7ac <prvTCPHandleFin+0xa4>
	}
	else
	{
		/* We did send a FIN already, see if it's ACK'd. */
		if( ulAckNr == pxTCPWindow->tx.ulFINSequenceNumber + 1u )
 800b792:	68fb      	ldr	r3, [r7, #12]
 800b794:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b796:	1c5a      	adds	r2, r3, #1
 800b798:	68bb      	ldr	r3, [r7, #8]
 800b79a:	429a      	cmp	r2, r3
 800b79c:	d106      	bne.n	800b7ac <prvTCPHandleFin+0xa4>
		{
			pxSocket->u.xTCP.bits.bFinAcked = pdTRUE_UNSIGNED;
 800b79e:	687a      	ldr	r2, [r7, #4]
 800b7a0:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
 800b7a4:	f043 0301 	orr.w	r3, r3, #1
 800b7a8:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
		}
	}

	if( pxSocket->u.xTCP.bits.bFinAcked == pdFALSE_UNSIGNED )
 800b7ac:	687b      	ldr	r3, [r7, #4]
 800b7ae:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 800b7b2:	f003 0301 	and.w	r3, r3, #1
 800b7b6:	b2db      	uxtb	r3, r3
 800b7b8:	2b00      	cmp	r3, #0
 800b7ba:	d10b      	bne.n	800b7d4 <prvTCPHandleFin+0xcc>
	{
		pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
 800b7bc:	68fb      	ldr	r3, [r7, #12]
 800b7be:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800b7c0:	68fb      	ldr	r3, [r7, #12]
 800b7c2:	621a      	str	r2, [r3, #32]
		pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK | ipTCP_FLAG_FIN;
 800b7c4:	697b      	ldr	r3, [r7, #20]
 800b7c6:	2211      	movs	r2, #17
 800b7c8:	735a      	strb	r2, [r3, #13]

		/* And wait for the final ACK. */
		vTCPStateChange( pxSocket, eLAST_ACK );
 800b7ca:	6878      	ldr	r0, [r7, #4]
 800b7cc:	210a      	movs	r1, #10
 800b7ce:	f7ff fc43 	bl	800b058 <vTCPStateChange>
 800b7d2:	e023      	b.n	800b81c <prvTCPHandleFin+0x114>
	}
	else
	{
		/* Our FIN has been ACK'd, the outgoing sequence number is now fixed. */
		pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber + 1u;
 800b7d4:	68fb      	ldr	r3, [r7, #12]
 800b7d6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b7d8:	1c5a      	adds	r2, r3, #1
 800b7da:	68fb      	ldr	r3, [r7, #12]
 800b7dc:	621a      	str	r2, [r3, #32]
		if( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED )
 800b7de:	687b      	ldr	r3, [r7, #4]
 800b7e0:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800b7e4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800b7e8:	b2db      	uxtb	r3, r3
 800b7ea:	2b00      	cmp	r3, #0
 800b7ec:	d103      	bne.n	800b7f6 <prvTCPHandleFin+0xee>
		{
			/* We have sent out a FIN but the peer hasn't replied with a FIN
			yet. Do nothing for the moment. */
			pxTCPHeader->ucTCPFlags = 0u;
 800b7ee:	697b      	ldr	r3, [r7, #20]
 800b7f0:	2200      	movs	r2, #0
 800b7f2:	735a      	strb	r2, [r3, #13]
 800b7f4:	e012      	b.n	800b81c <prvTCPHandleFin+0x114>
		}
		else
		{
			if( pxSocket->u.xTCP.bits.bFinLast == pdFALSE_UNSIGNED )
 800b7f6:	687b      	ldr	r3, [r7, #4]
 800b7f8:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 800b7fc:	f003 0302 	and.w	r3, r3, #2
 800b800:	b2db      	uxtb	r3, r3
 800b802:	2b00      	cmp	r3, #0
 800b804:	d103      	bne.n	800b80e <prvTCPHandleFin+0x106>
			{
				/* This is the third of the three-way hand shake: the last
				ACK. */
				pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK;
 800b806:	697b      	ldr	r3, [r7, #20]
 800b808:	2210      	movs	r2, #16
 800b80a:	735a      	strb	r2, [r3, #13]
 800b80c:	e002      	b.n	800b814 <prvTCPHandleFin+0x10c>
			}
			else
			{
				/* The other party started the closure, so we just wait for the
				last ACK. */
				pxTCPHeader->ucTCPFlags = 0u;
 800b80e:	697b      	ldr	r3, [r7, #20]
 800b810:	2200      	movs	r2, #0
 800b812:	735a      	strb	r2, [r3, #13]
			}

			/* And wait for the user to close this socket. */
			vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800b814:	6878      	ldr	r0, [r7, #4]
 800b816:	2108      	movs	r1, #8
 800b818:	f7ff fc1e 	bl	800b058 <vTCPStateChange>
		}
	}

	pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 800b81c:	68fb      	ldr	r3, [r7, #12]
 800b81e:	6a1a      	ldr	r2, [r3, #32]
 800b820:	68fb      	ldr	r3, [r7, #12]
 800b822:	62da      	str	r2, [r3, #44]	; 0x2c

	if( pxTCPHeader->ucTCPFlags != 0u )
 800b824:	697b      	ldr	r3, [r7, #20]
 800b826:	7b5b      	ldrb	r3, [r3, #13]
 800b828:	2b00      	cmp	r3, #0
 800b82a:	d004      	beq.n	800b836 <prvTCPHandleFin+0x12e>
	{
		xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength );
 800b82c:	68fb      	ldr	r3, [r7, #12]
 800b82e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800b832:	3328      	adds	r3, #40	; 0x28
 800b834:	61fb      	str	r3, [r7, #28]
	}

	pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + pxTCPWindow->ucOptionLength ) << 2 );
 800b836:	68fb      	ldr	r3, [r7, #12]
 800b838:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800b83c:	3314      	adds	r3, #20
 800b83e:	b2db      	uxtb	r3, r3
 800b840:	009b      	lsls	r3, r3, #2
 800b842:	b2da      	uxtb	r2, r3
 800b844:	697b      	ldr	r3, [r7, #20]
 800b846:	731a      	strb	r2, [r3, #12]
			pxTCPWindow->ulNextTxSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
			pxTCPWindow->ulOurSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
			pxTCPWindow->rx.ulCurrentSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber ) );
	}

	return xSendLength;
 800b848:	69fb      	ldr	r3, [r7, #28]
}
 800b84a:	4618      	mov	r0, r3
 800b84c:	3720      	adds	r7, #32
 800b84e:	46bd      	mov	sp, r7
 800b850:	bd80      	pop	{r7, pc}
 800b852:	bf00      	nop

0800b854 <prvCheckRxData>:
 *
 * The first thing that will be done is find the TCP payload data
 * and check the length of this data.
 */
static BaseType_t prvCheckRxData( NetworkBufferDescriptor_t *pxNetworkBuffer, uint8_t **ppucRecvData )
{
 800b854:	b580      	push	{r7, lr}
 800b856:	b088      	sub	sp, #32
 800b858:	af00      	add	r7, sp, #0
 800b85a:	6078      	str	r0, [r7, #4]
 800b85c:	6039      	str	r1, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800b85e:	687b      	ldr	r3, [r7, #4]
 800b860:	699b      	ldr	r3, [r3, #24]
 800b862:	61bb      	str	r3, [r7, #24]
TCPHeader_t *pxTCPHeader = &( pxTCPPacket->xTCPHeader );
 800b864:	69bb      	ldr	r3, [r7, #24]
 800b866:	3322      	adds	r3, #34	; 0x22
 800b868:	617b      	str	r3, [r7, #20]
	node.

	The size of the TCP header is given in a multiple of 4-byte words (single
	byte, needs no ntoh() translation).  A shift-right 2: is the same as
	(offset >> 4) * 4. */
    lTCPHeaderLength = ( BaseType_t ) ( ( pxTCPHeader->ucTCPOffset & VALID_BITS_IN_TCP_OFFSET_BYTE ) >> 2 );
 800b86a:	697b      	ldr	r3, [r7, #20]
 800b86c:	7b1b      	ldrb	r3, [r3, #12]
 800b86e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800b872:	089b      	lsrs	r3, r3, #2
 800b874:	613b      	str	r3, [r7, #16]

	/* Let pucRecvData point to the first byte received. */
	*ppucRecvData = pxNetworkBuffer->pucEthernetBuffer + ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER + lTCPHeaderLength;
 800b876:	687b      	ldr	r3, [r7, #4]
 800b878:	699a      	ldr	r2, [r3, #24]
 800b87a:	693b      	ldr	r3, [r7, #16]
 800b87c:	3322      	adds	r3, #34	; 0x22
 800b87e:	441a      	add	r2, r3
 800b880:	683b      	ldr	r3, [r7, #0]
 800b882:	601a      	str	r2, [r3, #0]

	/* Calculate lReceiveLength - the length of the TCP data received.  This is
	equal to the total packet length minus:
	( LinkLayer length (14) + IP header length (20) + size of TCP header(20 +) ).*/
	lReceiveLength = ( ( int32_t ) pxNetworkBuffer->xDataLength ) - ( int32_t ) ipSIZE_OF_ETH_HEADER;
 800b884:	687b      	ldr	r3, [r7, #4]
 800b886:	69db      	ldr	r3, [r3, #28]
 800b888:	3b0e      	subs	r3, #14
 800b88a:	61fb      	str	r3, [r7, #28]
	lLength =  ( int32_t )FreeRTOS_htons( pxTCPPacket->xIPHeader.usLength );
 800b88c:	69bb      	ldr	r3, [r7, #24]
 800b88e:	8a1b      	ldrh	r3, [r3, #16]
 800b890:	b29b      	uxth	r3, r3
 800b892:	021b      	lsls	r3, r3, #8
 800b894:	b29a      	uxth	r2, r3
 800b896:	69bb      	ldr	r3, [r7, #24]
 800b898:	8a1b      	ldrh	r3, [r3, #16]
 800b89a:	b29b      	uxth	r3, r3
 800b89c:	0a1b      	lsrs	r3, r3, #8
 800b89e:	b29b      	uxth	r3, r3
 800b8a0:	b29b      	uxth	r3, r3
 800b8a2:	4313      	orrs	r3, r2
 800b8a4:	b29b      	uxth	r3, r3
 800b8a6:	b29b      	uxth	r3, r3
 800b8a8:	60fb      	str	r3, [r7, #12]

	if( lReceiveLength > lLength )
 800b8aa:	69fa      	ldr	r2, [r7, #28]
 800b8ac:	68fb      	ldr	r3, [r7, #12]
 800b8ae:	429a      	cmp	r2, r3
 800b8b0:	dd01      	ble.n	800b8b6 <prvCheckRxData+0x62>
	{
		/* More bytes were received than the reported length, often because of
		padding bytes at the end. */
		lReceiveLength = lLength;
 800b8b2:	68fb      	ldr	r3, [r7, #12]
 800b8b4:	61fb      	str	r3, [r7, #28]
	}

	/* Subtract the size of the TCP and IP headers and the actual data size is
	known. */
	if( lReceiveLength > ( lTCPHeaderLength + ( int32_t ) ipSIZE_OF_IPv4_HEADER ) )
 800b8b6:	693b      	ldr	r3, [r7, #16]
 800b8b8:	f103 0214 	add.w	r2, r3, #20
 800b8bc:	69fb      	ldr	r3, [r7, #28]
 800b8be:	429a      	cmp	r2, r3
 800b8c0:	da07      	bge.n	800b8d2 <prvCheckRxData+0x7e>
	{
		lReceiveLength -= ( lTCPHeaderLength + ( int32_t ) ipSIZE_OF_IPv4_HEADER );
 800b8c2:	693a      	ldr	r2, [r7, #16]
 800b8c4:	f06f 0313 	mvn.w	r3, #19
 800b8c8:	1a9b      	subs	r3, r3, r2
 800b8ca:	69fa      	ldr	r2, [r7, #28]
 800b8cc:	4413      	add	r3, r2
 800b8ce:	61fb      	str	r3, [r7, #28]
 800b8d0:	e001      	b.n	800b8d6 <prvCheckRxData+0x82>
	}
	else
	{
		lReceiveLength = 0;
 800b8d2:	2300      	movs	r3, #0
 800b8d4:	61fb      	str	r3, [r7, #28]
	This field communicates the current value of the urgent pointer as a
	positive offset from the sequence number in this segment.  The urgent
	pointer points to the sequence number of the octet following the urgent
	data.  This field is only be interpreted in segments with the URG control
	bit set. */
	if( ( pxTCPHeader->ucTCPFlags & ipTCP_FLAG_URG ) != 0u )
 800b8d6:	697b      	ldr	r3, [r7, #20]
 800b8d8:	7b5b      	ldrb	r3, [r3, #13]
 800b8da:	f003 0320 	and.w	r3, r3, #32
 800b8de:	2b00      	cmp	r3, #0
 800b8e0:	d01c      	beq.n	800b91c <prvCheckRxData+0xc8>
	{
		/* Although we ignore the urgent data, we have to skip it. */
		lUrgentLength = ( int32_t ) FreeRTOS_htons( pxTCPHeader->usUrgent );
 800b8e2:	697b      	ldr	r3, [r7, #20]
 800b8e4:	8a5b      	ldrh	r3, [r3, #18]
 800b8e6:	b29b      	uxth	r3, r3
 800b8e8:	021b      	lsls	r3, r3, #8
 800b8ea:	b29a      	uxth	r2, r3
 800b8ec:	697b      	ldr	r3, [r7, #20]
 800b8ee:	8a5b      	ldrh	r3, [r3, #18]
 800b8f0:	b29b      	uxth	r3, r3
 800b8f2:	0a1b      	lsrs	r3, r3, #8
 800b8f4:	b29b      	uxth	r3, r3
 800b8f6:	b29b      	uxth	r3, r3
 800b8f8:	4313      	orrs	r3, r2
 800b8fa:	b29b      	uxth	r3, r3
 800b8fc:	b29b      	uxth	r3, r3
 800b8fe:	60bb      	str	r3, [r7, #8]
		*ppucRecvData += lUrgentLength;
 800b900:	683b      	ldr	r3, [r7, #0]
 800b902:	681a      	ldr	r2, [r3, #0]
 800b904:	68bb      	ldr	r3, [r7, #8]
 800b906:	441a      	add	r2, r3
 800b908:	683b      	ldr	r3, [r7, #0]
 800b90a:	601a      	str	r2, [r3, #0]
		lReceiveLength -= FreeRTOS_min_int32( lReceiveLength, lUrgentLength );
 800b90c:	69f8      	ldr	r0, [r7, #28]
 800b90e:	68b9      	ldr	r1, [r7, #8]
 800b910:	f7fe fcf4 	bl	800a2fc <FreeRTOS_min_int32>
 800b914:	4602      	mov	r2, r0
 800b916:	69fb      	ldr	r3, [r7, #28]
 800b918:	1a9b      	subs	r3, r3, r2
 800b91a:	61fb      	str	r3, [r7, #28]
	}

	return ( BaseType_t ) lReceiveLength;
 800b91c:	69fb      	ldr	r3, [r7, #28]
}
 800b91e:	4618      	mov	r0, r3
 800b920:	3720      	adds	r7, #32
 800b922:	46bd      	mov	sp, r7
 800b924:	bd80      	pop	{r7, pc}
 800b926:	bf00      	nop

0800b928 <prvStoreRxData>:
 * The second thing is to do is check if the payload data may be accepted
 * If so, they will be added to the reception queue.
 */
static BaseType_t prvStoreRxData( FreeRTOS_Socket_t *pxSocket, uint8_t *pucRecvData,
	NetworkBufferDescriptor_t *pxNetworkBuffer, uint32_t ulReceiveLength )
{
 800b928:	b580      	push	{r7, lr}
 800b92a:	b08c      	sub	sp, #48	; 0x30
 800b92c:	af00      	add	r7, sp, #0
 800b92e:	60f8      	str	r0, [r7, #12]
 800b930:	60b9      	str	r1, [r7, #8]
 800b932:	607a      	str	r2, [r7, #4]
 800b934:	603b      	str	r3, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800b936:	687b      	ldr	r3, [r7, #4]
 800b938:	699b      	ldr	r3, [r3, #24]
 800b93a:	627b      	str	r3, [r7, #36]	; 0x24
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
 800b93c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800b93e:	3322      	adds	r3, #34	; 0x22
 800b940:	623b      	str	r3, [r7, #32]
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 800b942:	68fb      	ldr	r3, [r7, #12]
 800b944:	33dc      	adds	r3, #220	; 0xdc
 800b946:	61fb      	str	r3, [r7, #28]
uint32_t ulSequenceNumber, ulSpace;
int32_t lOffset, lStored;
BaseType_t xResult = 0;
 800b948:	2300      	movs	r3, #0
 800b94a:	62bb      	str	r3, [r7, #40]	; 0x28

	ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 800b94c:	6a3b      	ldr	r3, [r7, #32]
 800b94e:	685b      	ldr	r3, [r3, #4]
 800b950:	061a      	lsls	r2, r3, #24
 800b952:	6a3b      	ldr	r3, [r7, #32]
 800b954:	685b      	ldr	r3, [r3, #4]
 800b956:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800b95a:	021b      	lsls	r3, r3, #8
 800b95c:	431a      	orrs	r2, r3
 800b95e:	6a3b      	ldr	r3, [r7, #32]
 800b960:	685b      	ldr	r3, [r3, #4]
 800b962:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800b966:	0a1b      	lsrs	r3, r3, #8
 800b968:	431a      	orrs	r2, r3
 800b96a:	6a3b      	ldr	r3, [r7, #32]
 800b96c:	685b      	ldr	r3, [r3, #4]
 800b96e:	0e1b      	lsrs	r3, r3, #24
 800b970:	4313      	orrs	r3, r2
 800b972:	61bb      	str	r3, [r7, #24]

	if( ( ulReceiveLength > 0u ) && ( pxSocket->u.xTCP.ucTCPState >= eSYN_RECEIVED ) )
 800b974:	683b      	ldr	r3, [r7, #0]
 800b976:	2b00      	cmp	r3, #0
 800b978:	d041      	beq.n	800b9fe <prvStoreRxData+0xd6>
 800b97a:	68fb      	ldr	r3, [r7, #12]
 800b97c:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800b980:	2b03      	cmp	r3, #3
 800b982:	d93c      	bls.n	800b9fe <prvStoreRxData+0xd6>

		If it can't be "accept"ed it may have to be stored and send a selective
		ack (SACK) option to confirm it.  In that case, xTCPWindowRxStore() will be
		called later to store an out-of-order packet (in case lOffset is
		negative). */
		if ( pxSocket->u.xTCP.rxStream )
 800b984:	68fb      	ldr	r3, [r7, #12]
 800b986:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b988:	2b00      	cmp	r3, #0
 800b98a:	d006      	beq.n	800b99a <prvStoreRxData+0x72>
		{
			ulSpace = ( uint32_t )uxStreamBufferGetSpace ( pxSocket->u.xTCP.rxStream );
 800b98c:	68fb      	ldr	r3, [r7, #12]
 800b98e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b990:	4618      	mov	r0, r3
 800b992:	f7fe fd11 	bl	800a3b8 <uxStreamBufferGetSpace>
 800b996:	62f8      	str	r0, [r7, #44]	; 0x2c
 800b998:	e002      	b.n	800b9a0 <prvStoreRxData+0x78>
		}
		else
		{
			ulSpace = ( uint32_t )pxSocket->u.xTCP.uxRxStreamSize;
 800b99a:	68fb      	ldr	r3, [r7, #12]
 800b99c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800b99e:	62fb      	str	r3, [r7, #44]	; 0x2c
		}

		lOffset = lTCPWindowRxCheck( pxTCPWindow, ulSequenceNumber, ulReceiveLength, ulSpace );
 800b9a0:	69f8      	ldr	r0, [r7, #28]
 800b9a2:	69b9      	ldr	r1, [r7, #24]
 800b9a4:	683a      	ldr	r2, [r7, #0]
 800b9a6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b9a8:	f001 fa7c 	bl	800cea4 <lTCPWindowRxCheck>
 800b9ac:	6178      	str	r0, [r7, #20]

		if( lOffset >= 0 )
 800b9ae:	697b      	ldr	r3, [r7, #20]
 800b9b0:	2b00      	cmp	r3, #0
 800b9b2:	db11      	blt.n	800b9d8 <prvStoreRxData+0xb0>
		{
			/* New data has arrived and may be made available to the user.  See
			if the head marker in rxStream may be advanced,	only if lOffset == 0.
			In case the low-water mark is reached, bLowWater will be set
			"low-water" here stands for "little space". */
			lStored = lTCPAddRxdata( pxSocket, ( uint32_t ) lOffset, pucRecvData, ulReceiveLength );
 800b9b4:	697b      	ldr	r3, [r7, #20]
 800b9b6:	68f8      	ldr	r0, [r7, #12]
 800b9b8:	4619      	mov	r1, r3
 800b9ba:	68ba      	ldr	r2, [r7, #8]
 800b9bc:	683b      	ldr	r3, [r7, #0]
 800b9be:	f7fe f87d 	bl	8009abc <lTCPAddRxdata>
 800b9c2:	6138      	str	r0, [r7, #16]

			if( lStored != ( int32_t ) ulReceiveLength )
 800b9c4:	683a      	ldr	r2, [r7, #0]
 800b9c6:	693b      	ldr	r3, [r7, #16]
 800b9c8:	429a      	cmp	r2, r3
 800b9ca:	d005      	beq.n	800b9d8 <prvStoreRxData+0xb0>
				FreeRTOS_debug_printf( ( "lTCPAddRxdata: stored %ld / %lu bytes??\n", lStored, ulReceiveLength ) );

				/* Received data could not be stored.  The socket's flag
				bMallocError has been set.  The socket now has the status
				eCLOSE_WAIT and a RST packet will be sent back. */
				prvTCPSendReset( pxNetworkBuffer );
 800b9cc:	6878      	ldr	r0, [r7, #4]
 800b9ce:	f000 fc2d 	bl	800c22c <prvTCPSendReset>
				xResult = -1;
 800b9d2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800b9d6:	62bb      	str	r3, [r7, #40]	; 0x28
		#if( ipconfigUSE_TCP_WIN == 1 )
		{
			/* Now lTCPAddRxdata() will move the rxHead pointer forward
			so data becomes available to the user immediately
			In case the low-water mark is reached, bLowWater will be set. */
			if( ( xResult == 0 ) && ( pxTCPWindow->ulUserDataLength > 0 ) )
 800b9d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800b9da:	2b00      	cmp	r3, #0
 800b9dc:	d10e      	bne.n	800b9fc <prvStoreRxData+0xd4>
 800b9de:	69fb      	ldr	r3, [r7, #28]
 800b9e0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b9e2:	2b00      	cmp	r3, #0
 800b9e4:	d00a      	beq.n	800b9fc <prvStoreRxData+0xd4>
			{
				lTCPAddRxdata( pxSocket, 0ul, NULL, pxTCPWindow->ulUserDataLength );
 800b9e6:	69fb      	ldr	r3, [r7, #28]
 800b9e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800b9ea:	68f8      	ldr	r0, [r7, #12]
 800b9ec:	2100      	movs	r1, #0
 800b9ee:	2200      	movs	r2, #0
 800b9f0:	f7fe f864 	bl	8009abc <lTCPAddRxdata>
				pxTCPWindow->ulUserDataLength = 0;
 800b9f4:	69fb      	ldr	r3, [r7, #28]
 800b9f6:	2200      	movs	r2, #0
 800b9f8:	631a      	str	r2, [r3, #48]	; 0x30
		#if( ipconfigUSE_TCP_WIN == 1 )
		{
			/* Now lTCPAddRxdata() will move the rxHead pointer forward
			so data becomes available to the user immediately
			In case the low-water mark is reached, bLowWater will be set. */
			if( ( xResult == 0 ) && ( pxTCPWindow->ulUserDataLength > 0 ) )
 800b9fa:	e004      	b.n	800ba06 <prvStoreRxData+0xde>
 800b9fc:	e003      	b.n	800ba06 <prvStoreRxData+0xde>
		}
		#endif /* ipconfigUSE_TCP_WIN */
	}
	else
	{
		pxTCPWindow->ucOptionLength = 0u;
 800b9fe:	69fb      	ldr	r3, [r7, #28]
 800ba00:	2200      	movs	r2, #0
 800ba02:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
	}

	return xResult;
 800ba06:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
 800ba08:	4618      	mov	r0, r3
 800ba0a:	3730      	adds	r7, #48	; 0x30
 800ba0c:	46bd      	mov	sp, r7
 800ba0e:	bd80      	pop	{r7, pc}

0800ba10 <prvSetOptions>:
/*-----------------------------------------------------------*/

/* Set the TCP options (if any) for the outgoing packet. */
static UBaseType_t prvSetOptions( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer )
{
 800ba10:	b580      	push	{r7, lr}
 800ba12:	b086      	sub	sp, #24
 800ba14:	af00      	add	r7, sp, #0
 800ba16:	6078      	str	r0, [r7, #4]
 800ba18:	6039      	str	r1, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800ba1a:	683b      	ldr	r3, [r7, #0]
 800ba1c:	699b      	ldr	r3, [r3, #24]
 800ba1e:	613b      	str	r3, [r7, #16]
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
 800ba20:	693b      	ldr	r3, [r7, #16]
 800ba22:	3322      	adds	r3, #34	; 0x22
 800ba24:	60fb      	str	r3, [r7, #12]
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 800ba26:	687b      	ldr	r3, [r7, #4]
 800ba28:	33dc      	adds	r3, #220	; 0xdc
 800ba2a:	60bb      	str	r3, [r7, #8]
UBaseType_t uxOptionsLength = pxTCPWindow->ucOptionLength;
 800ba2c:	68bb      	ldr	r3, [r7, #8]
 800ba2e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
 800ba32:	617b      	str	r3, [r7, #20]

	#if(	ipconfigUSE_TCP_WIN == 1 )
		if( uxOptionsLength != 0u )
 800ba34:	697b      	ldr	r3, [r7, #20]
 800ba36:	2b00      	cmp	r3, #0
 800ba38:	d012      	beq.n	800ba60 <prvSetOptions+0x50>
					pxSocket->usLocalPort,
					pxSocket->u.xTCP.usRemotePort,
					uxOptionsLength,
					FreeRTOS_ntohl( pxTCPWindow->ulOptionsData[ 1 ] ) - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber,
					FreeRTOS_ntohl( pxTCPWindow->ulOptionsData[ 2 ] ) - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber ) );
			memcpy( pxTCPHeader->ucOptdata, pxTCPWindow->ulOptionsData, ( size_t ) uxOptionsLength );
 800ba3a:	68fb      	ldr	r3, [r7, #12]
 800ba3c:	f103 0214 	add.w	r2, r3, #20
 800ba40:	68bb      	ldr	r3, [r7, #8]
 800ba42:	3380      	adds	r3, #128	; 0x80
 800ba44:	4610      	mov	r0, r2
 800ba46:	4619      	mov	r1, r3
 800ba48:	697a      	ldr	r2, [r7, #20]
 800ba4a:	f004 fb2d 	bl	80100a8 <memcpy>

			/* The header length divided by 4, goes into the higher nibble,
			effectively a shift-left 2. */
			pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800ba4e:	697b      	ldr	r3, [r7, #20]
 800ba50:	b2db      	uxtb	r3, r3
 800ba52:	3314      	adds	r3, #20
 800ba54:	b2db      	uxtb	r3, r3
 800ba56:	009b      	lsls	r3, r3, #2
 800ba58:	b2da      	uxtb	r2, r3
 800ba5a:	68fb      	ldr	r3, [r7, #12]
 800ba5c:	731a      	strb	r2, [r3, #12]
 800ba5e:	e031      	b.n	800bac4 <prvSetOptions+0xb4>
		}
		else
	#endif	/* ipconfigUSE_TCP_WIN */
	if( ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) && ( pxSocket->u.xTCP.bits.bMssChange != pdFALSE_UNSIGNED ) )
 800ba60:	687b      	ldr	r3, [r7, #4]
 800ba62:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800ba66:	2b04      	cmp	r3, #4
 800ba68:	d92c      	bls.n	800bac4 <prvSetOptions+0xb4>
 800ba6a:	687b      	ldr	r3, [r7, #4]
 800ba6c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800ba70:	f003 0301 	and.w	r3, r3, #1
 800ba74:	b2db      	uxtb	r3, r3
 800ba76:	2b00      	cmp	r3, #0
 800ba78:	d024      	beq.n	800bac4 <prvSetOptions+0xb4>
	{
		/* TCP options must be sent because the MSS has changed. */
		pxSocket->u.xTCP.bits.bMssChange = pdFALSE_UNSIGNED;
 800ba7a:	687a      	ldr	r2, [r7, #4]
 800ba7c:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 800ba80:	f36f 0300 	bfc	r3, #0, #1
 800ba84:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
		if( xTCPWindowLoggingLevel >= 0 )
		{
			FreeRTOS_debug_printf( ( "MSS: sending %d\n", pxSocket->u.xTCP.usCurMSS ) );
		}

		pxTCPHeader->ucOptdata[ 0 ] = TCP_OPT_MSS;
 800ba88:	68fb      	ldr	r3, [r7, #12]
 800ba8a:	2202      	movs	r2, #2
 800ba8c:	751a      	strb	r2, [r3, #20]
		pxTCPHeader->ucOptdata[ 1 ] = TCP_OPT_MSS_LEN;
 800ba8e:	68fb      	ldr	r3, [r7, #12]
 800ba90:	2204      	movs	r2, #4
 800ba92:	755a      	strb	r2, [r3, #21]
		pxTCPHeader->ucOptdata[ 2 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) >> 8 );
 800ba94:	687b      	ldr	r3, [r7, #4]
 800ba96:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 800ba9a:	0a1b      	lsrs	r3, r3, #8
 800ba9c:	b29b      	uxth	r3, r3
 800ba9e:	b2da      	uxtb	r2, r3
 800baa0:	68fb      	ldr	r3, [r7, #12]
 800baa2:	759a      	strb	r2, [r3, #22]
		pxTCPHeader->ucOptdata[ 3 ] = ( uint8_t ) ( ( pxSocket->u.xTCP.usCurMSS ) & 0xffu );
 800baa4:	687b      	ldr	r3, [r7, #4]
 800baa6:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 800baaa:	b2da      	uxtb	r2, r3
 800baac:	68fb      	ldr	r3, [r7, #12]
 800baae:	75da      	strb	r2, [r3, #23]
		uxOptionsLength = 4u;
 800bab0:	2304      	movs	r3, #4
 800bab2:	617b      	str	r3, [r7, #20]
		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800bab4:	697b      	ldr	r3, [r7, #20]
 800bab6:	b2db      	uxtb	r3, r3
 800bab8:	3314      	adds	r3, #20
 800baba:	b2db      	uxtb	r3, r3
 800babc:	009b      	lsls	r3, r3, #2
 800babe:	b2da      	uxtb	r2, r3
 800bac0:	68fb      	ldr	r3, [r7, #12]
 800bac2:	731a      	strb	r2, [r3, #12]
			uxOptionsLength += prvTCPSetTimeStamp( xOptionsLength, pxSocket, pxTCPHeader );
		}
	}
	#endif	/* ipconfigUSE_TCP_TIMESTAMPS == 1 */

	return uxOptionsLength;
 800bac4:	697b      	ldr	r3, [r7, #20]
}
 800bac6:	4618      	mov	r0, r3
 800bac8:	3718      	adds	r7, #24
 800baca:	46bd      	mov	sp, r7
 800bacc:	bd80      	pop	{r7, pc}
 800bace:	bf00      	nop

0800bad0 <prvHandleSynReceived>:
 * Called from the states: eSYN_RECEIVED and eCONNECT_SYN
 * If the flags received are correct, the socket will move to eESTABLISHED.
 */
static BaseType_t prvHandleSynReceived( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer,
	uint32_t ulReceiveLength, UBaseType_t uxOptionsLength )
{
 800bad0:	b580      	push	{r7, lr}
 800bad2:	b08c      	sub	sp, #48	; 0x30
 800bad4:	af00      	add	r7, sp, #0
 800bad6:	60f8      	str	r0, [r7, #12]
 800bad8:	60b9      	str	r1, [r7, #8]
 800bada:	607a      	str	r2, [r7, #4]
 800badc:	603b      	str	r3, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 800bade:	68bb      	ldr	r3, [r7, #8]
 800bae0:	681b      	ldr	r3, [r3, #0]
 800bae2:	699b      	ldr	r3, [r3, #24]
 800bae4:	627b      	str	r3, [r7, #36]	; 0x24
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
 800bae6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800bae8:	3322      	adds	r3, #34	; 0x22
 800baea:	623b      	str	r3, [r7, #32]
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 800baec:	68fb      	ldr	r3, [r7, #12]
 800baee:	33dc      	adds	r3, #220	; 0xdc
 800baf0:	61fb      	str	r3, [r7, #28]
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 800baf2:	6a3b      	ldr	r3, [r7, #32]
 800baf4:	7b5b      	ldrb	r3, [r3, #13]
 800baf6:	76fb      	strb	r3, [r7, #27]
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber );
 800baf8:	6a3b      	ldr	r3, [r7, #32]
 800bafa:	685b      	ldr	r3, [r3, #4]
 800bafc:	061a      	lsls	r2, r3, #24
 800bafe:	6a3b      	ldr	r3, [r7, #32]
 800bb00:	685b      	ldr	r3, [r3, #4]
 800bb02:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800bb06:	021b      	lsls	r3, r3, #8
 800bb08:	431a      	orrs	r2, r3
 800bb0a:	6a3b      	ldr	r3, [r7, #32]
 800bb0c:	685b      	ldr	r3, [r3, #4]
 800bb0e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800bb12:	0a1b      	lsrs	r3, r3, #8
 800bb14:	431a      	orrs	r2, r3
 800bb16:	6a3b      	ldr	r3, [r7, #32]
 800bb18:	685b      	ldr	r3, [r3, #4]
 800bb1a:	0e1b      	lsrs	r3, r3, #24
 800bb1c:	4313      	orrs	r3, r2
 800bb1e:	617b      	str	r3, [r7, #20]
BaseType_t xSendLength = 0;
 800bb20:	2300      	movs	r3, #0
 800bb22:	62fb      	str	r3, [r7, #44]	; 0x2c

	/* Either expect a ACK or a SYN+ACK. */
	uint16_t usExpect = ( uint16_t ) ipTCP_FLAG_ACK;
 800bb24:	2310      	movs	r3, #16
 800bb26:	857b      	strh	r3, [r7, #42]	; 0x2a
	if( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN )
 800bb28:	68fb      	ldr	r3, [r7, #12]
 800bb2a:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800bb2e:	2b02      	cmp	r3, #2
 800bb30:	d103      	bne.n	800bb3a <prvHandleSynReceived+0x6a>
	{
		usExpect |= ( uint16_t ) ipTCP_FLAG_SYN;
 800bb32:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800bb34:	f043 0302 	orr.w	r3, r3, #2
 800bb38:	857b      	strh	r3, [r7, #42]	; 0x2a
	}

	if( ( ucTCPFlags & 0x17u ) != usExpect )
 800bb3a:	7efb      	ldrb	r3, [r7, #27]
 800bb3c:	f003 0217 	and.w	r2, r3, #23
 800bb40:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800bb42:	429a      	cmp	r2, r3
 800bb44:	d016      	beq.n	800bb74 <prvHandleSynReceived+0xa4>
		/* eSYN_RECEIVED: flags 0010 expected, not 0002. */
		/* eSYN_RECEIVED: flags ACK  expected, not SYN. */
		FreeRTOS_debug_printf( ( "%s: flags %04X expected, not %04X\n",
			pxSocket->u.xTCP.ucTCPState == eSYN_RECEIVED ? "eSYN_RECEIVED" : "eCONNECT_SYN",
			usExpect, ucTCPFlags ) );
		vTCPStateChange( pxSocket, eCLOSE_WAIT );
 800bb46:	68f8      	ldr	r0, [r7, #12]
 800bb48:	2108      	movs	r1, #8
 800bb4a:	f7ff fa85 	bl	800b058 <vTCPStateChange>
		pxTCPHeader->ucTCPFlags |= ipTCP_FLAG_RST;
 800bb4e:	6a3b      	ldr	r3, [r7, #32]
 800bb50:	7b5b      	ldrb	r3, [r3, #13]
 800bb52:	f043 0304 	orr.w	r3, r3, #4
 800bb56:	b2da      	uxtb	r2, r3
 800bb58:	6a3b      	ldr	r3, [r7, #32]
 800bb5a:	735a      	strb	r2, [r3, #13]
		xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 800bb5c:	683b      	ldr	r3, [r7, #0]
 800bb5e:	3328      	adds	r3, #40	; 0x28
 800bb60:	62fb      	str	r3, [r7, #44]	; 0x2c
		pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800bb62:	683b      	ldr	r3, [r7, #0]
 800bb64:	b2db      	uxtb	r3, r3
 800bb66:	3314      	adds	r3, #20
 800bb68:	b2db      	uxtb	r3, r3
 800bb6a:	009b      	lsls	r3, r3, #2
 800bb6c:	b2da      	uxtb	r2, r3
 800bb6e:	6a3b      	ldr	r3, [r7, #32]
 800bb70:	731a      	strb	r2, [r3, #12]
 800bb72:	e06a      	b.n	800bc4a <prvHandleSynReceived+0x17a>
	}
	else
	{
		pxTCPWindow->usPeerPortNumber = pxSocket->u.xTCP.usRemotePort;
 800bb74:	68fb      	ldr	r3, [r7, #12]
 800bb76:	8f9a      	ldrh	r2, [r3, #60]	; 0x3c
 800bb78:	69fb      	ldr	r3, [r7, #28]
 800bb7a:	f8a3 20ba 	strh.w	r2, [r3, #186]	; 0xba
		pxTCPWindow->usOurPortNumber = pxSocket->usLocalPort;
 800bb7e:	68fb      	ldr	r3, [r7, #12]
 800bb80:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 800bb82:	69fb      	ldr	r3, [r7, #28]
 800bb84:	f8a3 20b8 	strh.w	r2, [r3, #184]	; 0xb8

		if( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN )
 800bb88:	68fb      	ldr	r3, [r7, #12]
 800bb8a:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800bb8e:	2b02      	cmp	r3, #2
 800bb90:	d126      	bne.n	800bbe0 <prvHandleSynReceived+0x110>
		{
			TCPPacket_t *pxLastTCPPacket = ( TCPPacket_t * ) ( pxSocket->u.xTCP.xPacket.u.ucLastPacket );
 800bb92:	68fb      	ldr	r3, [r7, #12]
 800bb94:	3382      	adds	r3, #130	; 0x82
 800bb96:	613b      	str	r3, [r7, #16]

			/* Clear the SYN flag in lastPacket. */
			pxLastTCPPacket->xTCPHeader.ucTCPFlags = ipTCP_FLAG_ACK;
 800bb98:	693b      	ldr	r3, [r7, #16]
 800bb9a:	2210      	movs	r2, #16
 800bb9c:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f

			/* This socket was the one connecting actively so now perofmr the
			synchronisation. */
			vTCPWindowInit( &pxSocket->u.xTCP.xTCPWindow,
 800bba0:	68fb      	ldr	r3, [r7, #12]
 800bba2:	f103 01dc 	add.w	r1, r3, #220	; 0xdc
 800bba6:	68fb      	ldr	r3, [r7, #12]
 800bba8:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
				ulSequenceNumber, pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber, ( uint32_t ) pxSocket->u.xTCP.usCurMSS );
 800bbac:	68fb      	ldr	r3, [r7, #12]
 800bbae:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
			/* Clear the SYN flag in lastPacket. */
			pxLastTCPPacket->xTCPHeader.ucTCPFlags = ipTCP_FLAG_ACK;

			/* This socket was the one connecting actively so now perofmr the
			synchronisation. */
			vTCPWindowInit( &pxSocket->u.xTCP.xTCPWindow,
 800bbb2:	4608      	mov	r0, r1
 800bbb4:	6979      	ldr	r1, [r7, #20]
 800bbb6:	f001 f8cf 	bl	800cd58 <vTCPWindowInit>
				ulSequenceNumber, pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber, ( uint32_t ) pxSocket->u.xTCP.usCurMSS );
			pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1u;
 800bbba:	697b      	ldr	r3, [r7, #20]
 800bbbc:	1c5a      	adds	r2, r3, #1
 800bbbe:	69fb      	ldr	r3, [r7, #28]
 800bbc0:	619a      	str	r2, [r3, #24]
 800bbc2:	69fb      	ldr	r3, [r7, #28]
 800bbc4:	699a      	ldr	r2, [r3, #24]
 800bbc6:	69fb      	ldr	r3, [r7, #28]
 800bbc8:	611a      	str	r2, [r3, #16]
			pxTCPWindow->tx.ulCurrentSequenceNumber++; /* because we send a TCP_SYN [ | TCP_ACK ]; */
 800bbca:	69fb      	ldr	r3, [r7, #28]
 800bbcc:	6a1b      	ldr	r3, [r3, #32]
 800bbce:	1c5a      	adds	r2, r3, #1
 800bbd0:	69fb      	ldr	r3, [r7, #28]
 800bbd2:	621a      	str	r2, [r3, #32]
			pxTCPWindow->ulNextTxSequenceNumber++;
 800bbd4:	69fb      	ldr	r3, [r7, #28]
 800bbd6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800bbd8:	1c5a      	adds	r2, r3, #1
 800bbda:	69fb      	ldr	r3, [r7, #28]
 800bbdc:	635a      	str	r2, [r3, #52]	; 0x34
 800bbde:	e005      	b.n	800bbec <prvHandleSynReceived+0x11c>
		}
		else if( ulReceiveLength == 0u )
 800bbe0:	687b      	ldr	r3, [r7, #4]
 800bbe2:	2b00      	cmp	r3, #0
 800bbe4:	d102      	bne.n	800bbec <prvHandleSynReceived+0x11c>
		{
			pxTCPWindow->rx.ulCurrentSequenceNumber = ulSequenceNumber;
 800bbe6:	69fb      	ldr	r3, [r7, #28]
 800bbe8:	697a      	ldr	r2, [r7, #20]
 800bbea:	611a      	str	r2, [r3, #16]
		}

		/* The SYN+ACK has been confirmed, increase the next sequence number by
		1. */
		pxTCPWindow->ulOurSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u;
 800bbec:	69fb      	ldr	r3, [r7, #28]
 800bbee:	69db      	ldr	r3, [r3, #28]
 800bbf0:	1c5a      	adds	r2, r3, #1
 800bbf2:	69fb      	ldr	r3, [r7, #28]
 800bbf4:	62da      	str	r2, [r3, #44]	; 0x2c
				pxSocket->u.xTCP.usRemotePort,
				( unsigned ) pxSocket->u.xTCP.bits.bWinScaling ) );
		}
		#endif /* ipconfigUSE_TCP_WIN */

		if( ( pxSocket->u.xTCP.ucTCPState == eCONNECT_SYN ) || ( ulReceiveLength != 0u ) )
 800bbf6:	68fb      	ldr	r3, [r7, #12]
 800bbf8:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800bbfc:	2b02      	cmp	r3, #2
 800bbfe:	d002      	beq.n	800bc06 <prvHandleSynReceived+0x136>
 800bc00:	687b      	ldr	r3, [r7, #4]
 800bc02:	2b00      	cmp	r3, #0
 800bc04:	d00d      	beq.n	800bc22 <prvHandleSynReceived+0x152>
		{
			pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK;
 800bc06:	6a3b      	ldr	r3, [r7, #32]
 800bc08:	2210      	movs	r2, #16
 800bc0a:	735a      	strb	r2, [r3, #13]
			xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 800bc0c:	683b      	ldr	r3, [r7, #0]
 800bc0e:	3328      	adds	r3, #40	; 0x28
 800bc10:	62fb      	str	r3, [r7, #44]	; 0x2c
			pxTCPHeader->ucTCPOffset = ( uint8_t ) ( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800bc12:	683b      	ldr	r3, [r7, #0]
 800bc14:	b2db      	uxtb	r3, r3
 800bc16:	3314      	adds	r3, #20
 800bc18:	b2db      	uxtb	r3, r3
 800bc1a:	009b      	lsls	r3, r3, #2
 800bc1c:	b2da      	uxtb	r2, r3
 800bc1e:	6a3b      	ldr	r3, [r7, #32]
 800bc20:	731a      	strb	r2, [r3, #12]
		}

		if( pxSocket->u.xTCP.bits.bWinScaling == pdFALSE_UNSIGNED )
 800bc22:	68fb      	ldr	r3, [r7, #12]
 800bc24:	f893 3042 	ldrb.w	r3, [r3, #66]	; 0x42
 800bc28:	f003 0310 	and.w	r3, r3, #16
 800bc2c:	b2db      	uxtb	r3, r3
 800bc2e:	2b00      	cmp	r3, #0
 800bc30:	d107      	bne.n	800bc42 <prvHandleSynReceived+0x172>
		{
			/* The other party did not send a scaling factor.
			A shifting factor in this side must be canceled. */
			pxSocket->u.xTCP.ucMyWinScaleFactor = 0;
 800bc32:	68fb      	ldr	r3, [r7, #12]
 800bc34:	2200      	movs	r2, #0
 800bc36:	f883 20c9 	strb.w	r2, [r3, #201]	; 0xc9
			pxSocket->u.xTCP.ucPeerWinScaleFactor = 0;
 800bc3a:	68fb      	ldr	r3, [r7, #12]
 800bc3c:	2200      	movs	r2, #0
 800bc3e:	f883 20ca 	strb.w	r2, [r3, #202]	; 0xca
		}
		/* This was the third step of connecting: SYN, SYN+ACK, ACK	so now the
		connection is established. */
		vTCPStateChange( pxSocket, eESTABLISHED );
 800bc42:	68f8      	ldr	r0, [r7, #12]
 800bc44:	2105      	movs	r1, #5
 800bc46:	f7ff fa07 	bl	800b058 <vTCPStateChange>
	}

	return xSendLength;
 800bc4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800bc4c:	4618      	mov	r0, r3
 800bc4e:	3730      	adds	r7, #48	; 0x30
 800bc50:	46bd      	mov	sp, r7
 800bc52:	bd80      	pop	{r7, pc}

0800bc54 <prvHandleEstablished>:
 * the code will check if it may be accepted, i.e. if all expected data has been
 * completely received.
 */
static BaseType_t prvHandleEstablished( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer,
	uint32_t ulReceiveLength, UBaseType_t uxOptionsLength )
{
 800bc54:	b580      	push	{r7, lr}
 800bc56:	b092      	sub	sp, #72	; 0x48
 800bc58:	af02      	add	r7, sp, #8
 800bc5a:	60f8      	str	r0, [r7, #12]
 800bc5c:	60b9      	str	r1, [r7, #8]
 800bc5e:	607a      	str	r2, [r7, #4]
 800bc60:	603b      	str	r3, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 800bc62:	68bb      	ldr	r3, [r7, #8]
 800bc64:	681b      	ldr	r3, [r3, #0]
 800bc66:	699b      	ldr	r3, [r3, #24]
 800bc68:	637b      	str	r3, [r7, #52]	; 0x34
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
 800bc6a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bc6c:	3322      	adds	r3, #34	; 0x22
 800bc6e:	633b      	str	r3, [r7, #48]	; 0x30
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 800bc70:	68fb      	ldr	r3, [r7, #12]
 800bc72:	33dc      	adds	r3, #220	; 0xdc
 800bc74:	62fb      	str	r3, [r7, #44]	; 0x2c
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 800bc76:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bc78:	7b5b      	ldrb	r3, [r3, #13]
 800bc7a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
uint32_t ulSequenceNumber = FreeRTOS_ntohl( pxTCPHeader->ulSequenceNumber ), ulCount;
 800bc7e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bc80:	685b      	ldr	r3, [r3, #4]
 800bc82:	061a      	lsls	r2, r3, #24
 800bc84:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bc86:	685b      	ldr	r3, [r3, #4]
 800bc88:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800bc8c:	021b      	lsls	r3, r3, #8
 800bc8e:	431a      	orrs	r2, r3
 800bc90:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bc92:	685b      	ldr	r3, [r3, #4]
 800bc94:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800bc98:	0a1b      	lsrs	r3, r3, #8
 800bc9a:	431a      	orrs	r2, r3
 800bc9c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bc9e:	685b      	ldr	r3, [r3, #4]
 800bca0:	0e1b      	lsrs	r3, r3, #24
 800bca2:	4313      	orrs	r3, r2
 800bca4:	627b      	str	r3, [r7, #36]	; 0x24
BaseType_t xSendLength = 0, xMayClose = pdFALSE, bRxComplete, bTxDone;
 800bca6:	2300      	movs	r3, #0
 800bca8:	63fb      	str	r3, [r7, #60]	; 0x3c
 800bcaa:	2300      	movs	r3, #0
 800bcac:	63bb      	str	r3, [r7, #56]	; 0x38
int32_t lDistance, lSendResult;

	/* Remember the window size the peer is advertising. */
	pxSocket->u.xTCP.ulWindowSize = FreeRTOS_ntohs( pxTCPHeader->usWindow );
 800bcae:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bcb0:	89db      	ldrh	r3, [r3, #14]
 800bcb2:	b29b      	uxth	r3, r3
 800bcb4:	021b      	lsls	r3, r3, #8
 800bcb6:	b29a      	uxth	r2, r3
 800bcb8:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800bcba:	89db      	ldrh	r3, [r3, #14]
 800bcbc:	b29b      	uxth	r3, r3
 800bcbe:	0a1b      	lsrs	r3, r3, #8
 800bcc0:	b29b      	uxth	r3, r3
 800bcc2:	b29b      	uxth	r3, r3
 800bcc4:	4313      	orrs	r3, r2
 800bcc6:	b29b      	uxth	r3, r3
 800bcc8:	b29b      	uxth	r3, r3
 800bcca:	461a      	mov	r2, r3
 800bccc:	68fb      	ldr	r3, [r7, #12]
 800bcce:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
	pxSocket->u.xTCP.ulWindowSize =
		( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
 800bcd2:	68fb      	ldr	r3, [r7, #12]
 800bcd4:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800bcd8:	68fa      	ldr	r2, [r7, #12]
 800bcda:	f892 20ca 	ldrb.w	r2, [r2, #202]	; 0xca
 800bcde:	fa03 f202 	lsl.w	r2, r3, r2
BaseType_t xSendLength = 0, xMayClose = pdFALSE, bRxComplete, bTxDone;
int32_t lDistance, lSendResult;

	/* Remember the window size the peer is advertising. */
	pxSocket->u.xTCP.ulWindowSize = FreeRTOS_ntohs( pxTCPHeader->usWindow );
	pxSocket->u.xTCP.ulWindowSize =
 800bce2:	68fb      	ldr	r3, [r7, #12]
 800bce4:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
		( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );

	if( ( ucTCPFlags & ( uint8_t ) ipTCP_FLAG_ACK ) != 0u )
 800bce8:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 800bcec:	f003 0310 	and.w	r3, r3, #16
 800bcf0:	2b00      	cmp	r3, #0
 800bcf2:	d041      	beq.n	800bd78 <prvHandleEstablished+0x124>
	{
		ulCount = ulTCPWindowTxAck( pxTCPWindow, FreeRTOS_ntohl( pxTCPPacket->xTCPHeader.ulAckNr ) );
 800bcf4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bcf6:	f8d3 302a 	ldr.w	r3, [r3, #42]	; 0x2a
 800bcfa:	061a      	lsls	r2, r3, #24
 800bcfc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bcfe:	f8d3 302a 	ldr.w	r3, [r3, #42]	; 0x2a
 800bd02:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800bd06:	021b      	lsls	r3, r3, #8
 800bd08:	431a      	orrs	r2, r3
 800bd0a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bd0c:	f8d3 302a 	ldr.w	r3, [r3, #42]	; 0x2a
 800bd10:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800bd14:	0a1b      	lsrs	r3, r3, #8
 800bd16:	431a      	orrs	r2, r3
 800bd18:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800bd1a:	f8d3 302a 	ldr.w	r3, [r3, #42]	; 0x2a
 800bd1e:	0e1b      	lsrs	r3, r3, #24
 800bd20:	4313      	orrs	r3, r2
 800bd22:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800bd24:	4619      	mov	r1, r3
 800bd26:	f001 fd0d 	bl	800d744 <ulTCPWindowTxAck>
 800bd2a:	6238      	str	r0, [r7, #32]

		/* ulTCPWindowTxAck() returns the number of bytes which have been acked,
		starting at 'tx.ulCurrentSequenceNumber'.  Advance the tail pointer in
		txStream. */
		if( ( pxSocket->u.xTCP.txStream != NULL ) && ( ulCount > 0u ) )
 800bd2c:	68fb      	ldr	r3, [r7, #12]
 800bd2e:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800bd30:	2b00      	cmp	r3, #0
 800bd32:	d021      	beq.n	800bd78 <prvHandleEstablished+0x124>
 800bd34:	6a3b      	ldr	r3, [r7, #32]
 800bd36:	2b00      	cmp	r3, #0
 800bd38:	d01e      	beq.n	800bd78 <prvHandleEstablished+0x124>
		{
			/* Just advancing the tail index, 'ulCount' bytes have been
			confirmed, and because there is new space in the txStream, the
			user/owner should be woken up. */
			/* _HT_ : only in case the socket's waiting? */
			if( uxStreamBufferGet( pxSocket->u.xTCP.txStream, 0u, NULL, ( size_t ) ulCount, pdFALSE ) != 0u )
 800bd3a:	68fb      	ldr	r3, [r7, #12]
 800bd3c:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800bd3e:	2300      	movs	r3, #0
 800bd40:	9300      	str	r3, [sp, #0]
 800bd42:	4610      	mov	r0, r2
 800bd44:	2100      	movs	r1, #0
 800bd46:	2200      	movs	r2, #0
 800bd48:	6a3b      	ldr	r3, [r7, #32]
 800bd4a:	f001 fe67 	bl	800da1c <uxStreamBufferGet>
 800bd4e:	4603      	mov	r3, r0
 800bd50:	2b00      	cmp	r3, #0
 800bd52:	d011      	beq.n	800bd78 <prvHandleEstablished+0x124>
			{
				pxSocket->xEventBits |= eSOCKET_SEND;
 800bd54:	68fb      	ldr	r3, [r7, #12]
 800bd56:	681b      	ldr	r3, [r3, #0]
 800bd58:	f043 0202 	orr.w	r2, r3, #2
 800bd5c:	68fb      	ldr	r3, [r7, #12]
 800bd5e:	601a      	str	r2, [r3, #0]

				#if ipconfigSUPPORT_SELECT_FUNCTION == 1
				{
					if( ( pxSocket->xSelectBits & eSELECT_WRITE ) != 0 )
 800bd60:	68fb      	ldr	r3, [r7, #12]
 800bd62:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800bd64:	f003 0302 	and.w	r3, r3, #2
 800bd68:	2b00      	cmp	r3, #0
 800bd6a:	d005      	beq.n	800bd78 <prvHandleEstablished+0x124>
					{
						pxSocket->xEventBits |= ( eSELECT_WRITE << SOCKET_EVENT_BIT_COUNT );
 800bd6c:	68fb      	ldr	r3, [r7, #12]
 800bd6e:	681b      	ldr	r3, [r3, #0]
 800bd70:	f443 7200 	orr.w	r2, r3, #512	; 0x200
 800bd74:	68fb      	ldr	r3, [r7, #12]
 800bd76:	601a      	str	r2, [r3, #0]
		}
	}

	/* If this socket has a stream for transmission, add the data to the
	outgoing segment(s). */
	if( pxSocket->u.xTCP.txStream != NULL )
 800bd78:	68fb      	ldr	r3, [r7, #12]
 800bd7a:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 800bd7c:	2b00      	cmp	r3, #0
 800bd7e:	d002      	beq.n	800bd86 <prvHandleEstablished+0x132>
	{
		prvTCPAddTxData( pxSocket );
 800bd80:	68f8      	ldr	r0, [r7, #12]
 800bd82:	f7ff fc95 	bl	800b6b0 <prvTCPAddTxData>
	}

	pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber = pxTCPWindow->tx.ulCurrentSequenceNumber;
 800bd86:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bd88:	6a1a      	ldr	r2, [r3, #32]
 800bd8a:	68fb      	ldr	r3, [r7, #12]
 800bd8c:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108

	if( ( pxSocket->u.xTCP.bits.bFinAccepted != pdFALSE_UNSIGNED ) || ( ( ucTCPFlags & ( uint8_t ) ipTCP_FLAG_FIN ) != 0u ) )
 800bd90:	68fb      	ldr	r3, [r7, #12]
 800bd92:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800bd96:	f003 0320 	and.w	r3, r3, #32
 800bd9a:	b2db      	uxtb	r3, r3
 800bd9c:	2b00      	cmp	r3, #0
 800bd9e:	d105      	bne.n	800bdac <prvHandleEstablished+0x158>
 800bda0:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
 800bda4:	f003 0301 	and.w	r3, r3, #1
 800bda8:	2b00      	cmp	r3, #0
 800bdaa:	d037      	beq.n	800be1c <prvHandleEstablished+0x1c8>
	{
		/* Peer is requesting to stop, see if we're really finished. */
		xMayClose = pdTRUE;
 800bdac:	2301      	movs	r3, #1
 800bdae:	63bb      	str	r3, [r7, #56]	; 0x38

		/* Checks are only necessary if we haven't sent a FIN yet. */
		if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 800bdb0:	68fb      	ldr	r3, [r7, #12]
 800bdb2:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800bdb6:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800bdba:	b2db      	uxtb	r3, r3
 800bdbc:	2b00      	cmp	r3, #0
 800bdbe:	d11c      	bne.n	800bdfa <prvHandleEstablished+0x1a6>
		{
			/* xTCPWindowTxDone returns true when all Tx queues are empty. */
			bRxComplete = xTCPWindowRxEmpty( pxTCPWindow );
 800bdc0:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800bdc2:	f000 fed9 	bl	800cb78 <xTCPWindowRxEmpty>
 800bdc6:	61f8      	str	r0, [r7, #28]
			bTxDone     = xTCPWindowTxDone( pxTCPWindow );
 800bdc8:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800bdca:	f001 fa17 	bl	800d1fc <xTCPWindowTxDone>
 800bdce:	61b8      	str	r0, [r7, #24]

			if( ( bRxComplete == 0 ) || ( bTxDone == 0 ) )
 800bdd0:	69fb      	ldr	r3, [r7, #28]
 800bdd2:	2b00      	cmp	r3, #0
 800bdd4:	d002      	beq.n	800bddc <prvHandleEstablished+0x188>
 800bdd6:	69bb      	ldr	r3, [r7, #24]
 800bdd8:	2b00      	cmp	r3, #0
 800bdda:	d102      	bne.n	800bde2 <prvHandleEstablished+0x18e>
				/* Refusing FIN: Rx incomp 1 optlen 4 tx done 1. */
				FreeRTOS_debug_printf( ( "Refusing FIN[%u,%u]: RxCompl %lu tx done %ld\n",
					pxSocket->usLocalPort,
					pxSocket->u.xTCP.usRemotePort,
					bRxComplete, bTxDone ) );
				xMayClose = pdFALSE;
 800bddc:	2300      	movs	r3, #0
 800bdde:	63bb      	str	r3, [r7, #56]	; 0x38
 800bde0:	e00b      	b.n	800bdfa <prvHandleEstablished+0x1a6>
			}
			else
			{
				lDistance = ( int32_t ) ( ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulCurrentSequenceNumber );
 800bde2:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800bde4:	687b      	ldr	r3, [r7, #4]
 800bde6:	441a      	add	r2, r3
 800bde8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800bdea:	691b      	ldr	r3, [r3, #16]
 800bdec:	1ad3      	subs	r3, r2, r3
 800bdee:	617b      	str	r3, [r7, #20]

				if( lDistance > 1 )
 800bdf0:	697b      	ldr	r3, [r7, #20]
 800bdf2:	2b01      	cmp	r3, #1
 800bdf4:	dd01      	ble.n	800bdfa <prvHandleEstablished+0x1a6>
				{
					FreeRTOS_debug_printf( ( "Refusing FIN: Rx not complete %ld (cur %lu high %lu)\n",
						lDistance, pxTCPWindow->rx.ulCurrentSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber,
						pxTCPWindow->rx.ulHighestSequenceNumber - pxTCPWindow->rx.ulFirstSequenceNumber ) );

					xMayClose = pdFALSE;
 800bdf6:	2300      	movs	r3, #0
 800bdf8:	63bb      	str	r3, [r7, #56]	; 0x38
			FreeRTOS_debug_printf( ( "TCP: FIN received, mayClose = %ld (Rx %lu Len %ld, Tx %lu)\n",
				xMayClose, ulSequenceNumber - pxSocket->u.xTCP.xTCPWindow.rx.ulFirstSequenceNumber, ulReceiveLength,
				pxTCPWindow->tx.ulCurrentSequenceNumber - pxSocket->u.xTCP.xTCPWindow.tx.ulFirstSequenceNumber ) );
		}

		if( xMayClose != pdFALSE )
 800bdfa:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800bdfc:	2b00      	cmp	r3, #0
 800bdfe:	d00d      	beq.n	800be1c <prvHandleEstablished+0x1c8>
		{
			pxSocket->u.xTCP.bits.bFinAccepted = pdTRUE_UNSIGNED;
 800be00:	68fa      	ldr	r2, [r7, #12]
 800be02:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800be06:	f043 0320 	orr.w	r3, r3, #32
 800be0a:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
 800be0e:	68bb      	ldr	r3, [r7, #8]
 800be10:	681b      	ldr	r3, [r3, #0]
 800be12:	68f8      	ldr	r0, [r7, #12]
 800be14:	4619      	mov	r1, r3
 800be16:	f7ff fc77 	bl	800b708 <prvTCPHandleFin>
 800be1a:	63f8      	str	r0, [r7, #60]	; 0x3c
		}
	}

	if( xMayClose == pdFALSE )
 800be1c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800be1e:	2b00      	cmp	r3, #0
 800be20:	d12a      	bne.n	800be78 <prvHandleEstablished+0x224>
	{
		pxTCPHeader->ucTCPFlags = ipTCP_FLAG_ACK;
 800be22:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800be24:	2210      	movs	r2, #16
 800be26:	735a      	strb	r2, [r3, #13]

		if( ulReceiveLength != 0u )
 800be28:	687b      	ldr	r3, [r7, #4]
 800be2a:	2b00      	cmp	r3, #0
 800be2c:	d016      	beq.n	800be5c <prvHandleEstablished+0x208>
		{
			xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 800be2e:	683b      	ldr	r3, [r7, #0]
 800be30:	3328      	adds	r3, #40	; 0x28
 800be32:	63fb      	str	r3, [r7, #60]	; 0x3c
			/* TCP-offsett equals '( ( length / 4 ) << 4 )', resulting in a shift-left 2 */
			pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800be34:	683b      	ldr	r3, [r7, #0]
 800be36:	b2db      	uxtb	r3, r3
 800be38:	3314      	adds	r3, #20
 800be3a:	b2db      	uxtb	r3, r3
 800be3c:	009b      	lsls	r3, r3, #2
 800be3e:	b2da      	uxtb	r2, r3
 800be40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800be42:	731a      	strb	r2, [r3, #12]

			if( pxSocket->u.xTCP.bits.bFinSent != pdFALSE_UNSIGNED )
 800be44:	68fb      	ldr	r3, [r7, #12]
 800be46:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800be4a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800be4e:	b2db      	uxtb	r3, r3
 800be50:	2b00      	cmp	r3, #0
 800be52:	d003      	beq.n	800be5c <prvHandleEstablished+0x208>
			{
				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->tx.ulFINSequenceNumber;
 800be54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be56:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800be58:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800be5a:	621a      	str	r2, [r3, #32]
		/* Now get data to be transmitted. */
		/* _HT_ patch: since the MTU has be fixed at 1500 in stead of 1526, TCP
		can not	send-out both TCP options and also a full packet. Sending
		options (SACK) is always more urgent than sending data, which can be
		sent later. */
		if( uxOptionsLength == 0u )
 800be5c:	683b      	ldr	r3, [r7, #0]
 800be5e:	2b00      	cmp	r3, #0
 800be60:	d10a      	bne.n	800be78 <prvHandleEstablished+0x224>
		{
			/* prvTCPPrepareSend might allocate a bigger network buffer, if
			necessary. */
			lSendResult = prvTCPPrepareSend( pxSocket, ppxNetworkBuffer, uxOptionsLength );
 800be62:	68f8      	ldr	r0, [r7, #12]
 800be64:	68b9      	ldr	r1, [r7, #8]
 800be66:	683a      	ldr	r2, [r7, #0]
 800be68:	f7ff fa34 	bl	800b2d4 <prvTCPPrepareSend>
 800be6c:	6138      	str	r0, [r7, #16]
			if( lSendResult > 0 )
 800be6e:	693b      	ldr	r3, [r7, #16]
 800be70:	2b00      	cmp	r3, #0
 800be72:	dd01      	ble.n	800be78 <prvHandleEstablished+0x224>
			{
				xSendLength = ( BaseType_t ) lSendResult;
 800be74:	693b      	ldr	r3, [r7, #16]
 800be76:	63fb      	str	r3, [r7, #60]	; 0x3c
			}
		}
	}

	return xSendLength;
 800be78:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
}
 800be7a:	4618      	mov	r0, r3
 800be7c:	3740      	adds	r7, #64	; 0x40
 800be7e:	46bd      	mov	sp, r7
 800be80:	bd80      	pop	{r7, pc}
 800be82:	bf00      	nop

0800be84 <prvSendData>:
 * ipconfigUSE_TCP_WIN is defined, and if only an ACK must be sent, it will be
 * checked if it would better be postponed for efficiency.
 */
static BaseType_t prvSendData( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer,
	uint32_t ulReceiveLength, BaseType_t xSendLength )
{
 800be84:	b580      	push	{r7, lr}
 800be86:	b08a      	sub	sp, #40	; 0x28
 800be88:	af00      	add	r7, sp, #0
 800be8a:	60f8      	str	r0, [r7, #12]
 800be8c:	60b9      	str	r1, [r7, #8]
 800be8e:	607a      	str	r2, [r7, #4]
 800be90:	603b      	str	r3, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 800be92:	68bb      	ldr	r3, [r7, #8]
 800be94:	681b      	ldr	r3, [r3, #0]
 800be96:	699b      	ldr	r3, [r3, #24]
 800be98:	623b      	str	r3, [r7, #32]
TCPHeader_t *pxTCPHeader = &pxTCPPacket->xTCPHeader;
 800be9a:	6a3b      	ldr	r3, [r7, #32]
 800be9c:	3322      	adds	r3, #34	; 0x22
 800be9e:	61fb      	str	r3, [r7, #28]
TCPWindow_t *pxTCPWindow = &pxSocket->u.xTCP.xTCPWindow;
 800bea0:	68fb      	ldr	r3, [r7, #12]
 800bea2:	33dc      	adds	r3, #220	; 0xdc
 800bea4:	61bb      	str	r3, [r7, #24]
		const int32_t lMinLength = 0;
	#else
		int32_t lMinLength;
	#endif
#endif
	pxSocket->u.xTCP.ulRxCurWinSize = pxTCPWindow->xSize.ulRxWindowLength -
 800bea6:	69bb      	ldr	r3, [r7, #24]
 800bea8:	685a      	ldr	r2, [r3, #4]
									 ( pxTCPWindow->rx.ulHighestSequenceNumber - pxTCPWindow->rx.ulCurrentSequenceNumber );
 800beaa:	69bb      	ldr	r3, [r7, #24]
 800beac:	6919      	ldr	r1, [r3, #16]
 800beae:	69bb      	ldr	r3, [r7, #24]
 800beb0:	699b      	ldr	r3, [r3, #24]
 800beb2:	1acb      	subs	r3, r1, r3
		const int32_t lMinLength = 0;
	#else
		int32_t lMinLength;
	#endif
#endif
	pxSocket->u.xTCP.ulRxCurWinSize = pxTCPWindow->xSize.ulRxWindowLength -
 800beb4:	441a      	add	r2, r3
 800beb6:	68fb      	ldr	r3, [r7, #12]
 800beb8:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
									 ( pxTCPWindow->rx.ulHighestSequenceNumber - pxTCPWindow->rx.ulCurrentSequenceNumber );

	/* Free space in rxStream. */
	if( pxSocket->u.xTCP.rxStream != NULL )
 800bebc:	68fb      	ldr	r3, [r7, #12]
 800bebe:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bec0:	2b00      	cmp	r3, #0
 800bec2:	d006      	beq.n	800bed2 <prvSendData+0x4e>
	{
		ulFrontSpace = ( uint32_t ) uxStreamBufferFrontSpace( pxSocket->u.xTCP.rxStream );
 800bec4:	68fb      	ldr	r3, [r7, #12]
 800bec6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bec8:	4618      	mov	r0, r3
 800beca:	f7fe fa89 	bl	800a3e0 <uxStreamBufferFrontSpace>
 800bece:	6278      	str	r0, [r7, #36]	; 0x24
 800bed0:	e002      	b.n	800bed8 <prvSendData+0x54>
	}
	else
	{
		ulFrontSpace = ( uint32_t ) pxSocket->u.xTCP.uxRxStreamSize;
 800bed2:	68fb      	ldr	r3, [r7, #12]
 800bed4:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800bed6:	627b      	str	r3, [r7, #36]	; 0x24
	}

	pxSocket->u.xTCP.ulRxCurWinSize = FreeRTOS_min_uint32( ulFrontSpace, pxSocket->u.xTCP.ulRxCurWinSize );
 800bed8:	68fb      	ldr	r3, [r7, #12]
 800beda:	f8d3 30d0 	ldr.w	r3, [r3, #208]	; 0xd0
 800bede:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800bee0:	4619      	mov	r1, r3
 800bee2:	f7fe fa1b 	bl	800a31c <FreeRTOS_min_uint32>
 800bee6:	4602      	mov	r2, r0
 800bee8:	68fb      	ldr	r3, [r7, #12]
 800beea:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0

	/* Set the time-out field, so that we'll be called by the IP-task in case no
	next message will be received. */
	lRxSpace = (int32_t)( pxSocket->u.xTCP.ulHighestRxAllowed - pxTCPWindow->rx.ulCurrentSequenceNumber );
 800beee:	68fb      	ldr	r3, [r7, #12]
 800bef0:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800bef2:	69bb      	ldr	r3, [r7, #24]
 800bef4:	691b      	ldr	r3, [r3, #16]
 800bef6:	1ad3      	subs	r3, r2, r3
 800bef8:	617b      	str	r3, [r7, #20]
	#if ipconfigUSE_TCP_WIN == 1
	{

		#if( ipconfigTCP_ACK_EARLIER_PACKET != 0 )
		{
			lMinLength = ( ( int32_t ) 2 ) * ( ( int32_t ) pxSocket->u.xTCP.usCurMSS );
 800befa:	68fb      	ldr	r3, [r7, #12]
 800befc:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 800bf00:	005b      	lsls	r3, r3, #1
 800bf02:	613b      	str	r3, [r7, #16]
		}
		#endif /* ipconfigTCP_ACK_EARLIER_PACKET */

		/* In case we're receiving data continuously, we might postpone sending
		an ACK to gain performance. */
		if( ( ulReceiveLength > 0 ) &&							/* Data was sent to this socket. */
 800bf04:	687b      	ldr	r3, [r7, #4]
 800bf06:	2b00      	cmp	r3, #0
 800bf08:	d04f      	beq.n	800bfaa <prvSendData+0x126>
 800bf0a:	697a      	ldr	r2, [r7, #20]
 800bf0c:	693b      	ldr	r3, [r7, #16]
 800bf0e:	429a      	cmp	r2, r3
 800bf10:	db4b      	blt.n	800bfaa <prvSendData+0x126>
			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
 800bf12:	68fb      	ldr	r3, [r7, #12]
 800bf14:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800bf18:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800bf1c:	b2db      	uxtb	r3, r3
		#endif /* ipconfigTCP_ACK_EARLIER_PACKET */

		/* In case we're receiving data continuously, we might postpone sending
		an ACK to gain performance. */
		if( ( ulReceiveLength > 0 ) &&							/* Data was sent to this socket. */
			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
 800bf1e:	2b00      	cmp	r3, #0
 800bf20:	d143      	bne.n	800bfaa <prvSendData+0x126>
			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
 800bf22:	683b      	ldr	r3, [r7, #0]
 800bf24:	2b28      	cmp	r3, #40	; 0x28
 800bf26:	d140      	bne.n	800bfaa <prvSendData+0x126>
			( xSendLength == ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ) ) && /* No Tx data or options to be sent. */
			( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) &&	/* Connection established. */
 800bf28:	68fb      	ldr	r3, [r7, #12]
 800bf2a:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
		/* In case we're receiving data continuously, we might postpone sending
		an ACK to gain performance. */
		if( ( ulReceiveLength > 0 ) &&							/* Data was sent to this socket. */
			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
			( xSendLength == ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ) ) && /* No Tx data or options to be sent. */
 800bf2e:	2b05      	cmp	r3, #5
 800bf30:	d13b      	bne.n	800bfaa <prvSendData+0x126>
			( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) &&	/* Connection established. */
			( pxTCPHeader->ucTCPFlags == ipTCP_FLAG_ACK ) )		/* There are no other flags than an ACK. */
 800bf32:	69fb      	ldr	r3, [r7, #28]
 800bf34:	7b5b      	ldrb	r3, [r3, #13]
		an ACK to gain performance. */
		if( ( ulReceiveLength > 0 ) &&							/* Data was sent to this socket. */
			( lRxSpace >= lMinLength ) &&						/* There is Rx space for more data. */
			( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED ) &&	/* Not in a closure phase. */
			( xSendLength == ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER ) ) && /* No Tx data or options to be sent. */
			( pxSocket->u.xTCP.ucTCPState == eESTABLISHED ) &&	/* Connection established. */
 800bf36:	2b10      	cmp	r3, #16
 800bf38:	d137      	bne.n	800bfaa <prvSendData+0x126>
			( pxTCPHeader->ucTCPFlags == ipTCP_FLAG_ACK ) )		/* There are no other flags than an ACK. */
		{
			if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
 800bf3a:	68fb      	ldr	r3, [r7, #12]
 800bf3c:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 800bf3e:	68bb      	ldr	r3, [r7, #8]
 800bf40:	681b      	ldr	r3, [r3, #0]
 800bf42:	429a      	cmp	r2, r3
 800bf44:	d00c      	beq.n	800bf60 <prvSendData+0xdc>
			{
				/* There was still a delayed in queue, delete it. */
				if( pxSocket->u.xTCP.pxAckMessage != 0 )
 800bf46:	68fb      	ldr	r3, [r7, #12]
 800bf48:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800bf4a:	2b00      	cmp	r3, #0
 800bf4c:	d004      	beq.n	800bf58 <prvSendData+0xd4>
				{
					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 800bf4e:	68fb      	ldr	r3, [r7, #12]
 800bf50:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800bf52:	4618      	mov	r0, r3
 800bf54:	f7fb fc42 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
				}

				pxSocket->u.xTCP.pxAckMessage = *ppxNetworkBuffer;
 800bf58:	68bb      	ldr	r3, [r7, #8]
 800bf5a:	681a      	ldr	r2, [r3, #0]
 800bf5c:	68fb      	ldr	r3, [r7, #12]
 800bf5e:	67da      	str	r2, [r3, #124]	; 0x7c
			}
			if( ( ulReceiveLength < ( uint32_t ) pxSocket->u.xTCP.usCurMSS ) ||	/* Received a small message. */
 800bf60:	68fb      	ldr	r3, [r7, #12]
 800bf62:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 800bf66:	461a      	mov	r2, r3
 800bf68:	687b      	ldr	r3, [r7, #4]
 800bf6a:	429a      	cmp	r2, r3
 800bf6c:	d807      	bhi.n	800bf7e <prvSendData+0xfa>
				( lRxSpace < ( int32_t ) ( 2U * pxSocket->u.xTCP.usCurMSS ) ) )	/* There are less than 2 x MSS space in the Rx buffer. */
 800bf6e:	68fb      	ldr	r3, [r7, #12]
 800bf70:	f8b3 304a 	ldrh.w	r3, [r3, #74]	; 0x4a
 800bf74:	005b      	lsls	r3, r3, #1
 800bf76:	461a      	mov	r2, r3
					vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
				}

				pxSocket->u.xTCP.pxAckMessage = *ppxNetworkBuffer;
			}
			if( ( ulReceiveLength < ( uint32_t ) pxSocket->u.xTCP.usCurMSS ) ||	/* Received a small message. */
 800bf78:	697b      	ldr	r3, [r7, #20]
 800bf7a:	429a      	cmp	r2, r3
 800bf7c:	dd04      	ble.n	800bf88 <prvSendData+0x104>
				( lRxSpace < ( int32_t ) ( 2U * pxSocket->u.xTCP.usCurMSS ) ) )	/* There are less than 2 x MSS space in the Rx buffer. */
			{
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) pdMS_TO_MIN_TICKS( DELAYED_ACK_SHORT_DELAY_MS );
 800bf7e:	68fb      	ldr	r3, [r7, #12]
 800bf80:	2202      	movs	r2, #2
 800bf82:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
 800bf86:	e003      	b.n	800bf90 <prvSendData+0x10c>
			else
			{
				/* Normally a delayed ACK should wait 200 ms for a next incoming
				packet.  Only wait 20 ms here to gain performance.  A slow ACK
				for full-size message. */
				pxSocket->u.xTCP.usTimeout = ( uint16_t ) pdMS_TO_MIN_TICKS( DELAYED_ACK_LONGER_DELAY_MS );
 800bf88:	68fb      	ldr	r3, [r7, #12]
 800bf8a:	2214      	movs	r2, #20
 800bf8c:	f8a3 2048 	strh.w	r2, [r3, #72]	; 0x48
			}

			if( ( xTCPWindowLoggingLevel > 1 ) && ( ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) != pdFALSE ) )
 800bf90:	4b1c      	ldr	r3, [pc, #112]	; (800c004 <prvSendData+0x180>)
 800bf92:	681b      	ldr	r3, [r3, #0]
 800bf94:	2b01      	cmp	r3, #1
 800bf96:	dd02      	ble.n	800bf9e <prvSendData+0x11a>
 800bf98:	68fb      	ldr	r3, [r7, #12]
 800bf9a:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800bf9c:	2b17      	cmp	r3, #23
					pxSocket->u.xTCP.xTCPWindow.ulOurSequenceNumber - pxTCPWindow->tx.ulFirstSequenceNumber,
					xSendLength,
					pxSocket->u.xTCP.usTimeout, lRxSpace ) );
			}

			*ppxNetworkBuffer = NULL;
 800bf9e:	68bb      	ldr	r3, [r7, #8]
 800bfa0:	2200      	movs	r2, #0
 800bfa2:	601a      	str	r2, [r3, #0]
			xSendLength = 0;
 800bfa4:	2300      	movs	r3, #0
 800bfa6:	603b      	str	r3, [r7, #0]
 800bfa8:	e011      	b.n	800bfce <prvSendData+0x14a>
		}
		else if( pxSocket->u.xTCP.pxAckMessage != NULL )
 800bfaa:	68fb      	ldr	r3, [r7, #12]
 800bfac:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800bfae:	2b00      	cmp	r3, #0
 800bfb0:	d00d      	beq.n	800bfce <prvSendData+0x14a>
		{
			/* As an ACK is not being delayed, remove any earlier delayed ACK
			message. */
			if( pxSocket->u.xTCP.pxAckMessage != *ppxNetworkBuffer )
 800bfb2:	68fb      	ldr	r3, [r7, #12]
 800bfb4:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 800bfb6:	68bb      	ldr	r3, [r7, #8]
 800bfb8:	681b      	ldr	r3, [r3, #0]
 800bfba:	429a      	cmp	r2, r3
 800bfbc:	d004      	beq.n	800bfc8 <prvSendData+0x144>
			{
				vReleaseNetworkBufferAndDescriptor( pxSocket->u.xTCP.pxAckMessage );
 800bfbe:	68fb      	ldr	r3, [r7, #12]
 800bfc0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800bfc2:	4618      	mov	r0, r3
 800bfc4:	f7fb fc0a 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
			}

			pxSocket->u.xTCP.pxAckMessage = NULL;
 800bfc8:	68fb      	ldr	r3, [r7, #12]
 800bfca:	2200      	movs	r2, #0
 800bfcc:	67da      	str	r2, [r3, #124]	; 0x7c
		( void ) pxTCPHeader;
		( void ) lRxSpace;
	}
	#endif /* ipconfigUSE_TCP_WIN */

	if( xSendLength != 0 )
 800bfce:	683b      	ldr	r3, [r7, #0]
 800bfd0:	2b00      	cmp	r3, #0
 800bfd2:	d012      	beq.n	800bffa <prvSendData+0x176>
	{
		if( ( xTCPWindowLoggingLevel > 1 ) && ( ipconfigTCP_MAY_LOG_PORT( pxSocket->usLocalPort ) != pdFALSE ) )
 800bfd4:	4b0b      	ldr	r3, [pc, #44]	; (800c004 <prvSendData+0x180>)
 800bfd6:	681b      	ldr	r3, [r3, #0]
 800bfd8:	2b01      	cmp	r3, #1
 800bfda:	dd02      	ble.n	800bfe2 <prvSendData+0x15e>
 800bfdc:	68fb      	ldr	r3, [r7, #12]
 800bfde:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800bfe0:	2b17      	cmp	r3, #23
				xSendLength ) );
		}

		/* Set the parameter 'xReleaseAfterSend' to the value of
		ipconfigZERO_COPY_TX_DRIVER. */
		prvTCPReturnPacket( pxSocket, *ppxNetworkBuffer, ( uint32_t ) xSendLength, ipconfigZERO_COPY_TX_DRIVER );
 800bfe2:	68bb      	ldr	r3, [r7, #8]
 800bfe4:	681a      	ldr	r2, [r3, #0]
 800bfe6:	683b      	ldr	r3, [r7, #0]
 800bfe8:	68f8      	ldr	r0, [r7, #12]
 800bfea:	4611      	mov	r1, r2
 800bfec:	461a      	mov	r2, r3
 800bfee:	2301      	movs	r3, #1
 800bff0:	f7fe fbec 	bl	800a7cc <prvTCPReturnPacket>
		#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
		{
			/* The driver has taken ownership of the Network Buffer. */
			*ppxNetworkBuffer = NULL;
 800bff4:	68bb      	ldr	r3, [r7, #8]
 800bff6:	2200      	movs	r2, #0
 800bff8:	601a      	str	r2, [r3, #0]
		}
		#endif
	}

	return xSendLength;
 800bffa:	683b      	ldr	r3, [r7, #0]
}
 800bffc:	4618      	mov	r0, r3
 800bffe:	3728      	adds	r7, #40	; 0x28
 800c000:	46bd      	mov	sp, r7
 800c002:	bd80      	pop	{r7, pc}
 800c004:	2000c2b4 	.word	0x2000c2b4

0800c008 <prvTCPHandleState>:
 *
 * As these functions are declared static, and they're called from one location
 * only, most compilers will inline them, thus avoiding a call and return.
 */
static BaseType_t prvTCPHandleState( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t **ppxNetworkBuffer )
{
 800c008:	b580      	push	{r7, lr}
 800c00a:	b08c      	sub	sp, #48	; 0x30
 800c00c:	af00      	add	r7, sp, #0
 800c00e:	6078      	str	r0, [r7, #4]
 800c010:	6039      	str	r1, [r7, #0]
TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( (*ppxNetworkBuffer)->pucEthernetBuffer );
 800c012:	683b      	ldr	r3, [r7, #0]
 800c014:	681b      	ldr	r3, [r3, #0]
 800c016:	699b      	ldr	r3, [r3, #24]
 800c018:	62bb      	str	r3, [r7, #40]	; 0x28
TCPHeader_t *pxTCPHeader = &( pxTCPPacket->xTCPHeader );
 800c01a:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c01c:	3322      	adds	r3, #34	; 0x22
 800c01e:	627b      	str	r3, [r7, #36]	; 0x24
BaseType_t xSendLength = 0;
 800c020:	2300      	movs	r3, #0
 800c022:	62fb      	str	r3, [r7, #44]	; 0x2c
uint32_t ulReceiveLength;	/* Number of bytes contained in the TCP message. */
uint8_t *pucRecvData;
uint32_t ulSequenceNumber = FreeRTOS_ntohl (pxTCPHeader->ulSequenceNumber);
 800c024:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c026:	685b      	ldr	r3, [r3, #4]
 800c028:	061a      	lsls	r2, r3, #24
 800c02a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c02c:	685b      	ldr	r3, [r3, #4]
 800c02e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800c032:	021b      	lsls	r3, r3, #8
 800c034:	431a      	orrs	r2, r3
 800c036:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c038:	685b      	ldr	r3, [r3, #4]
 800c03a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800c03e:	0a1b      	lsrs	r3, r3, #8
 800c040:	431a      	orrs	r2, r3
 800c042:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c044:	685b      	ldr	r3, [r3, #4]
 800c046:	0e1b      	lsrs	r3, r3, #24
 800c048:	4313      	orrs	r3, r2
 800c04a:	623b      	str	r3, [r7, #32]
	/* xOptionsLength: the size of the options to be sent (always a multiple of
	4 bytes)
	1. in the SYN phase, we shall communicate the MSS
	2. in case of a SACK, Selective ACK, ack a segment which comes in
	out-of-order. */
UBaseType_t uxOptionsLength = 0u;
 800c04c:	2300      	movs	r3, #0
 800c04e:	61fb      	str	r3, [r7, #28]
uint8_t ucTCPFlags = pxTCPHeader->ucTCPFlags;
 800c050:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c052:	7b5b      	ldrb	r3, [r3, #13]
 800c054:	76fb      	strb	r3, [r7, #27]
TCPWindow_t *pxTCPWindow = &( pxSocket->u.xTCP.xTCPWindow );
 800c056:	687b      	ldr	r3, [r7, #4]
 800c058:	33dc      	adds	r3, #220	; 0xdc
 800c05a:	617b      	str	r3, [r7, #20]

	/* First get the length and the position of the received data, if any.
	pucRecvData will point to the first byte of the TCP payload. */
	ulReceiveLength = ( uint32_t ) prvCheckRxData( *ppxNetworkBuffer, &pucRecvData );
 800c05c:	683b      	ldr	r3, [r7, #0]
 800c05e:	681a      	ldr	r2, [r3, #0]
 800c060:	f107 030c 	add.w	r3, r7, #12
 800c064:	4610      	mov	r0, r2
 800c066:	4619      	mov	r1, r3
 800c068:	f7ff fbf4 	bl	800b854 <prvCheckRxData>
 800c06c:	4603      	mov	r3, r0
 800c06e:	613b      	str	r3, [r7, #16]

	if( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED )
 800c070:	687b      	ldr	r3, [r7, #4]
 800c072:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800c076:	2b04      	cmp	r3, #4
 800c078:	d90c      	bls.n	800c094 <prvTCPHandleState+0x8c>
	{
		if ( pxTCPWindow->rx.ulCurrentSequenceNumber == ulSequenceNumber + 1u )
 800c07a:	697b      	ldr	r3, [r7, #20]
 800c07c:	691a      	ldr	r2, [r3, #16]
 800c07e:	6a3b      	ldr	r3, [r7, #32]
 800c080:	3301      	adds	r3, #1
 800c082:	429a      	cmp	r2, r3
 800c084:	d106      	bne.n	800c094 <prvTCPHandleState+0x8c>
		{
			/* This is most probably a keep-alive message from peer.  Setting
			'bWinChange' doesn't cause a window-size-change, the flag is used
			here to force sending an immediate ACK. */
			pxSocket->u.xTCP.bits.bWinChange = pdTRUE_UNSIGNED;
 800c086:	687a      	ldr	r2, [r7, #4]
 800c088:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800c08c:	f043 0301 	orr.w	r3, r3, #1
 800c090:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41
		}
	}

	/* Keep track of the highest sequence number that might be expected within
	this connection. */
	if( ( ( int32_t ) ( ulSequenceNumber + ulReceiveLength - pxTCPWindow->rx.ulHighestSequenceNumber ) ) > 0 )
 800c094:	6a3a      	ldr	r2, [r7, #32]
 800c096:	693b      	ldr	r3, [r7, #16]
 800c098:	441a      	add	r2, r3
 800c09a:	697b      	ldr	r3, [r7, #20]
 800c09c:	699b      	ldr	r3, [r3, #24]
 800c09e:	1ad3      	subs	r3, r2, r3
 800c0a0:	2b00      	cmp	r3, #0
 800c0a2:	dd04      	ble.n	800c0ae <prvTCPHandleState+0xa6>
	{
		pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + ulReceiveLength;
 800c0a4:	6a3a      	ldr	r2, [r7, #32]
 800c0a6:	693b      	ldr	r3, [r7, #16]
 800c0a8:	441a      	add	r2, r3
 800c0aa:	697b      	ldr	r3, [r7, #20]
 800c0ac:	619a      	str	r2, [r3, #24]
	}

	/* Storing data may result in a fatal error if malloc() fails. */
	if( prvStoreRxData( pxSocket, pucRecvData, *ppxNetworkBuffer, ulReceiveLength ) < 0 )
 800c0ae:	68fa      	ldr	r2, [r7, #12]
 800c0b0:	683b      	ldr	r3, [r7, #0]
 800c0b2:	681b      	ldr	r3, [r3, #0]
 800c0b4:	6878      	ldr	r0, [r7, #4]
 800c0b6:	4611      	mov	r1, r2
 800c0b8:	461a      	mov	r2, r3
 800c0ba:	693b      	ldr	r3, [r7, #16]
 800c0bc:	f7ff fc34 	bl	800b928 <prvStoreRxData>
 800c0c0:	4603      	mov	r3, r0
 800c0c2:	2b00      	cmp	r3, #0
 800c0c4:	da03      	bge.n	800c0ce <prvTCPHandleState+0xc6>
	{
		xSendLength = -1;
 800c0c6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800c0ca:	62fb      	str	r3, [r7, #44]	; 0x2c
 800c0cc:	e09e      	b.n	800c20c <prvTCPHandleState+0x204>
	}
	else
	{
		uxOptionsLength = prvSetOptions( pxSocket, *ppxNetworkBuffer );
 800c0ce:	683b      	ldr	r3, [r7, #0]
 800c0d0:	681b      	ldr	r3, [r3, #0]
 800c0d2:	6878      	ldr	r0, [r7, #4]
 800c0d4:	4619      	mov	r1, r3
 800c0d6:	f7ff fc9b 	bl	800ba10 <prvSetOptions>
 800c0da:	61f8      	str	r0, [r7, #28]

		if( ( pxSocket->u.xTCP.ucTCPState == eSYN_RECEIVED ) && ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) == ipTCP_FLAG_SYN ) )
 800c0dc:	687b      	ldr	r3, [r7, #4]
 800c0de:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800c0e2:	2b04      	cmp	r3, #4
 800c0e4:	d108      	bne.n	800c0f8 <prvTCPHandleState+0xf0>
 800c0e6:	7efb      	ldrb	r3, [r7, #27]
 800c0e8:	f003 031f 	and.w	r3, r3, #31
 800c0ec:	2b02      	cmp	r3, #2
 800c0ee:	d103      	bne.n	800c0f8 <prvTCPHandleState+0xf0>

			/* In eSYN_RECEIVED a simple ACK is expected, but apparently the
			'SYN+ACK' didn't arrive.  Step back to the previous state in which
			a first incoming SYN is handled.  The SYN was counted already so
			decrease it first. */
			vTCPStateChange( pxSocket, eSYN_FIRST );
 800c0f0:	6878      	ldr	r0, [r7, #4]
 800c0f2:	2103      	movs	r1, #3
 800c0f4:	f7fe ffb0 	bl	800b058 <vTCPStateChange>
		}

		if( ( ( ucTCPFlags & ipTCP_FLAG_FIN ) != 0u ) && ( pxSocket->u.xTCP.bits.bFinRecv == pdFALSE_UNSIGNED ) )
 800c0f8:	7efb      	ldrb	r3, [r7, #27]
 800c0fa:	f003 0301 	and.w	r3, r3, #1
 800c0fe:	2b00      	cmp	r3, #0
 800c100:	d022      	beq.n	800c148 <prvTCPHandleState+0x140>
 800c102:	687b      	ldr	r3, [r7, #4]
 800c104:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800c108:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 800c10c:	b2db      	uxtb	r3, r3
 800c10e:	2b00      	cmp	r3, #0
 800c110:	d11a      	bne.n	800c148 <prvTCPHandleState+0x140>
		{
			/* It's the first time a FIN has been received, remember its
			sequence number. */
			pxTCPWindow->rx.ulFINSequenceNumber = ulSequenceNumber + ulReceiveLength;
 800c112:	6a3a      	ldr	r2, [r7, #32]
 800c114:	693b      	ldr	r3, [r7, #16]
 800c116:	441a      	add	r2, r3
 800c118:	697b      	ldr	r3, [r7, #20]
 800c11a:	615a      	str	r2, [r3, #20]
			pxSocket->u.xTCP.bits.bFinRecv = pdTRUE_UNSIGNED;
 800c11c:	687a      	ldr	r2, [r7, #4]
 800c11e:	f892 3041 	ldrb.w	r3, [r2, #65]	; 0x41
 800c122:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800c126:	f882 3041 	strb.w	r3, [r2, #65]	; 0x41

			/* Was peer the first one to send a FIN? */
			if( pxSocket->u.xTCP.bits.bFinSent == pdFALSE_UNSIGNED )
 800c12a:	687b      	ldr	r3, [r7, #4]
 800c12c:	f893 3041 	ldrb.w	r3, [r3, #65]	; 0x41
 800c130:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800c134:	b2db      	uxtb	r3, r3
 800c136:	2b00      	cmp	r3, #0
 800c138:	d106      	bne.n	800c148 <prvTCPHandleState+0x140>
			{
				/* If so, don't send the-last-ACK. */
				pxSocket->u.xTCP.bits.bFinLast = pdTRUE_UNSIGNED;
 800c13a:	687a      	ldr	r2, [r7, #4]
 800c13c:	f892 3042 	ldrb.w	r3, [r2, #66]	; 0x42
 800c140:	f043 0302 	orr.w	r3, r3, #2
 800c144:	f882 3042 	strb.w	r3, [r2, #66]	; 0x42
			}
		}

		switch (pxSocket->u.xTCP.ucTCPState)
 800c148:	687b      	ldr	r3, [r7, #4]
 800c14a:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800c14e:	2b0b      	cmp	r3, #11
 800c150:	d85b      	bhi.n	800c20a <prvTCPHandleState+0x202>
 800c152:	a201      	add	r2, pc, #4	; (adr r2, 800c158 <prvTCPHandleState+0x150>)
 800c154:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800c158:	0800c20b 	.word	0x0800c20b
 800c15c:	0800c20b 	.word	0x0800c20b
 800c160:	0800c1db 	.word	0x0800c1db
 800c164:	0800c189 	.word	0x0800c189
 800c168:	0800c1db 	.word	0x0800c1db
 800c16c:	0800c1eb 	.word	0x0800c1eb
 800c170:	0800c1fb 	.word	0x0800c1fb
 800c174:	0800c1fb 	.word	0x0800c1fb
 800c178:	0800c20b 	.word	0x0800c20b
 800c17c:	0800c20b 	.word	0x0800c20b
 800c180:	0800c1fb 	.word	0x0800c1fb
 800c184:	0800c20b 	.word	0x0800c20b
							socket. */
			{
				/* A new socket has been created, reply with a SYN+ACK.
				Acknowledge with seq+1 because the SYN is seen as pseudo data
				with len = 1. */
				uxOptionsLength = prvSetSynAckOptions( pxSocket, pxTCPPacket );
 800c188:	6878      	ldr	r0, [r7, #4]
 800c18a:	6ab9      	ldr	r1, [r7, #40]	; 0x28
 800c18c:	f7fe feec 	bl	800af68 <prvSetSynAckOptions>
 800c190:	61f8      	str	r0, [r7, #28]
				pxTCPHeader->ucTCPFlags = ipTCP_FLAG_SYN | ipTCP_FLAG_ACK;
 800c192:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c194:	2212      	movs	r2, #18
 800c196:	735a      	strb	r2, [r3, #13]

				xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + uxOptionsLength );
 800c198:	69fb      	ldr	r3, [r7, #28]
 800c19a:	3328      	adds	r3, #40	; 0x28
 800c19c:	62fb      	str	r3, [r7, #44]	; 0x2c

				/* Set the TCP offset field:  ipSIZE_OF_TCP_HEADER equals 20 and
				xOptionsLength is a multiple of 4.  The complete expression is:
				ucTCPOffset = ( ( ipSIZE_OF_TCP_HEADER + xOptionsLength ) / 4 ) << 4 */
				pxTCPHeader->ucTCPOffset = ( uint8_t )( ( ipSIZE_OF_TCP_HEADER + uxOptionsLength ) << 2 );
 800c19e:	69fb      	ldr	r3, [r7, #28]
 800c1a0:	b2db      	uxtb	r3, r3
 800c1a2:	3314      	adds	r3, #20
 800c1a4:	b2db      	uxtb	r3, r3
 800c1a6:	009b      	lsls	r3, r3, #2
 800c1a8:	b2da      	uxtb	r2, r3
 800c1aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c1ac:	731a      	strb	r2, [r3, #12]
				vTCPStateChange( pxSocket, eSYN_RECEIVED );
 800c1ae:	6878      	ldr	r0, [r7, #4]
 800c1b0:	2104      	movs	r1, #4
 800c1b2:	f7fe ff51 	bl	800b058 <vTCPStateChange>

				pxTCPWindow->rx.ulCurrentSequenceNumber = pxTCPWindow->rx.ulHighestSequenceNumber = ulSequenceNumber + 1u;
 800c1b6:	6a3b      	ldr	r3, [r7, #32]
 800c1b8:	1c5a      	adds	r2, r3, #1
 800c1ba:	697b      	ldr	r3, [r7, #20]
 800c1bc:	619a      	str	r2, [r3, #24]
 800c1be:	697b      	ldr	r3, [r7, #20]
 800c1c0:	699a      	ldr	r2, [r3, #24]
 800c1c2:	697b      	ldr	r3, [r7, #20]
 800c1c4:	611a      	str	r2, [r3, #16]
				pxTCPWindow->tx.ulCurrentSequenceNumber = pxTCPWindow->ulNextTxSequenceNumber = pxTCPWindow->tx.ulFirstSequenceNumber + 1u; /* because we send a TCP_SYN. */
 800c1c6:	697b      	ldr	r3, [r7, #20]
 800c1c8:	69db      	ldr	r3, [r3, #28]
 800c1ca:	1c5a      	adds	r2, r3, #1
 800c1cc:	697b      	ldr	r3, [r7, #20]
 800c1ce:	635a      	str	r2, [r3, #52]	; 0x34
 800c1d0:	697b      	ldr	r3, [r7, #20]
 800c1d2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800c1d4:	697b      	ldr	r3, [r7, #20]
 800c1d6:	621a      	str	r2, [r3, #32]
			}
			break;
 800c1d8:	e018      	b.n	800c20c <prvTCPHandleState+0x204>
		case eCONNECT_SYN:	/* (client) also called SYN_SENT: we've just send a
							SYN, expect	a SYN+ACK and send a ACK now. */
			/* Fall through */
		case eSYN_RECEIVED:	/* (server) we've had a SYN, replied with SYN+SCK
							expect a ACK and do nothing. */
			xSendLength = prvHandleSynReceived( pxSocket, ppxNetworkBuffer, ulReceiveLength, uxOptionsLength );
 800c1da:	6878      	ldr	r0, [r7, #4]
 800c1dc:	6839      	ldr	r1, [r7, #0]
 800c1de:	693a      	ldr	r2, [r7, #16]
 800c1e0:	69fb      	ldr	r3, [r7, #28]
 800c1e2:	f7ff fc75 	bl	800bad0 <prvHandleSynReceived>
 800c1e6:	62f8      	str	r0, [r7, #44]	; 0x2c
			break;
 800c1e8:	e010      	b.n	800c20c <prvTCPHandleState+0x204>
		case eESTABLISHED:	/* (server + client) an open connection, data
							received can be	delivered to the user. The normal
							state for the data transfer phase of the connection
							The closing states are also handled here with the
							use of some flags. */
			xSendLength = prvHandleEstablished( pxSocket, ppxNetworkBuffer, ulReceiveLength, uxOptionsLength );
 800c1ea:	6878      	ldr	r0, [r7, #4]
 800c1ec:	6839      	ldr	r1, [r7, #0]
 800c1ee:	693a      	ldr	r2, [r7, #16]
 800c1f0:	69fb      	ldr	r3, [r7, #28]
 800c1f2:	f7ff fd2f 	bl	800bc54 <prvHandleEstablished>
 800c1f6:	62f8      	str	r0, [r7, #44]	; 0x2c
			break;
 800c1f8:	e008      	b.n	800c20c <prvTCPHandleState+0x204>
			/* Fall through */
		case eFIN_WAIT_1:	/* (server + client) waiting for a connection termination request from the remote TCP,
							 * or an acknowledgement of the connection termination request previously sent. */
			/* Fall through */
		case eFIN_WAIT_2:	/* (server + client) waiting for a connection termination request from the remote TCP. */
			xSendLength = prvTCPHandleFin( pxSocket, *ppxNetworkBuffer );
 800c1fa:	683b      	ldr	r3, [r7, #0]
 800c1fc:	681b      	ldr	r3, [r3, #0]
 800c1fe:	6878      	ldr	r0, [r7, #4]
 800c200:	4619      	mov	r1, r3
 800c202:	f7ff fa81 	bl	800b708 <prvTCPHandleFin>
 800c206:	62f8      	str	r0, [r7, #44]	; 0x2c
			break;
 800c208:	e000      	b.n	800c20c <prvTCPHandleState+0x204>
							a MSL (maximum segment lifetime).]  These states are
							implemented implicitly by settings flags like
							'bFinSent', 'bFinRecv', and 'bFinAcked'. */
			break;
		default:
			break;
 800c20a:	bf00      	nop
		}
	}

	if( xSendLength > 0 )
 800c20c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c20e:	2b00      	cmp	r3, #0
 800c210:	dd06      	ble.n	800c220 <prvTCPHandleState+0x218>
	{
		xSendLength = prvSendData( pxSocket, ppxNetworkBuffer, ulReceiveLength, xSendLength );
 800c212:	6878      	ldr	r0, [r7, #4]
 800c214:	6839      	ldr	r1, [r7, #0]
 800c216:	693a      	ldr	r2, [r7, #16]
 800c218:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c21a:	f7ff fe33 	bl	800be84 <prvSendData>
 800c21e:	62f8      	str	r0, [r7, #44]	; 0x2c
	}

	return xSendLength;
 800c220:	6afb      	ldr	r3, [r7, #44]	; 0x2c
}
 800c222:	4618      	mov	r0, r3
 800c224:	3730      	adds	r7, #48	; 0x30
 800c226:	46bd      	mov	sp, r7
 800c228:	bd80      	pop	{r7, pc}
 800c22a:	bf00      	nop

0800c22c <prvTCPSendReset>:
/*-----------------------------------------------------------*/

static BaseType_t prvTCPSendReset( NetworkBufferDescriptor_t *pxNetworkBuffer )
{
 800c22c:	b580      	push	{r7, lr}
 800c22e:	b084      	sub	sp, #16
 800c230:	af00      	add	r7, sp, #0
 800c232:	6078      	str	r0, [r7, #4]
	#if( ipconfigIGNORE_UNKNOWN_PACKETS == 0 )
	{
	TCPPacket_t *pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800c234:	687b      	ldr	r3, [r7, #4]
 800c236:	699b      	ldr	r3, [r3, #24]
 800c238:	60fb      	str	r3, [r7, #12]
	const BaseType_t xSendLength = ( BaseType_t ) ( ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_TCP_HEADER + 0u );	/* Plus 0 options. */
 800c23a:	2328      	movs	r3, #40	; 0x28
 800c23c:	60bb      	str	r3, [r7, #8]

		pxTCPPacket->xTCPHeader.ucTCPFlags = ipTCP_FLAG_ACK | ipTCP_FLAG_RST;
 800c23e:	68fb      	ldr	r3, [r7, #12]
 800c240:	2214      	movs	r2, #20
 800c242:	f883 202f 	strb.w	r2, [r3, #47]	; 0x2f
		pxTCPPacket->xTCPHeader.ucTCPOffset = ( ipSIZE_OF_TCP_HEADER + 0u ) << 2;
 800c246:	68fb      	ldr	r3, [r7, #12]
 800c248:	2250      	movs	r2, #80	; 0x50
 800c24a:	f883 202e 	strb.w	r2, [r3, #46]	; 0x2e

		prvTCPReturnPacket( NULL, pxNetworkBuffer, ( uint32_t ) xSendLength, pdFALSE );
 800c24e:	68bb      	ldr	r3, [r7, #8]
 800c250:	2000      	movs	r0, #0
 800c252:	6879      	ldr	r1, [r7, #4]
 800c254:	461a      	mov	r2, r3
 800c256:	2300      	movs	r3, #0
 800c258:	f7fe fab8 	bl	800a7cc <prvTCPReturnPacket>

	/* Remove compiler warnings if ipconfigIGNORE_UNKNOWN_PACKETS == 1. */
	( void ) pxNetworkBuffer;

	/* The packet was not consumed. */
	return pdFAIL;
 800c25c:	2300      	movs	r3, #0
}
 800c25e:	4618      	mov	r0, r3
 800c260:	3710      	adds	r7, #16
 800c262:	46bd      	mov	sp, r7
 800c264:	bd80      	pop	{r7, pc}
 800c266:	bf00      	nop

0800c268 <prvSocketSetMSS>:
/*-----------------------------------------------------------*/

static void prvSocketSetMSS( FreeRTOS_Socket_t *pxSocket )
{
 800c268:	b580      	push	{r7, lr}
 800c26a:	b084      	sub	sp, #16
 800c26c:	af00      	add	r7, sp, #0
 800c26e:	6078      	str	r0, [r7, #4]
uint32_t ulMSS = ipconfigTCP_MSS;
 800c270:	f240 53b4 	movw	r3, #1460	; 0x5b4
 800c274:	60fb      	str	r3, [r7, #12]

	if( ( ( FreeRTOS_ntohl( pxSocket->u.xTCP.ulRemoteIP ) ^ *ipLOCAL_IP_ADDRESS_POINTER ) & xNetworkAddressing.ulNetMask ) != 0ul )
 800c276:	687b      	ldr	r3, [r7, #4]
 800c278:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c27a:	061a      	lsls	r2, r3, #24
 800c27c:	687b      	ldr	r3, [r7, #4]
 800c27e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c280:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800c284:	021b      	lsls	r3, r3, #8
 800c286:	431a      	orrs	r2, r3
 800c288:	687b      	ldr	r3, [r7, #4]
 800c28a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c28c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800c290:	0a1b      	lsrs	r3, r3, #8
 800c292:	431a      	orrs	r2, r3
 800c294:	687b      	ldr	r3, [r7, #4]
 800c296:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800c298:	0e1b      	lsrs	r3, r3, #24
 800c29a:	431a      	orrs	r2, r3
 800c29c:	4b0d      	ldr	r3, [pc, #52]	; (800c2d4 <prvSocketSetMSS+0x6c>)
 800c29e:	695b      	ldr	r3, [r3, #20]
 800c2a0:	405a      	eors	r2, r3
 800c2a2:	4b0d      	ldr	r3, [pc, #52]	; (800c2d8 <prvSocketSetMSS+0x70>)
 800c2a4:	685b      	ldr	r3, [r3, #4]
 800c2a6:	4013      	ands	r3, r2
 800c2a8:	2b00      	cmp	r3, #0
 800c2aa:	d005      	beq.n	800c2b8 <prvSocketSetMSS+0x50>
	{
		/* Data for this peer will pass through a router, and maybe through
		the internet.  Limit the MSS to 1400 bytes or less. */
		ulMSS = FreeRTOS_min_uint32( ( uint32_t ) REDUCED_MSS_THROUGH_INTERNET, ulMSS );
 800c2ac:	f44f 60af 	mov.w	r0, #1400	; 0x578
 800c2b0:	68f9      	ldr	r1, [r7, #12]
 800c2b2:	f7fe f833 	bl	800a31c <FreeRTOS_min_uint32>
 800c2b6:	60f8      	str	r0, [r7, #12]
	}

	FreeRTOS_debug_printf( ( "prvSocketSetMSS: %lu bytes for %lxip:%u\n", ulMSS, pxSocket->u.xTCP.ulRemoteIP, pxSocket->u.xTCP.usRemotePort ) );

	pxSocket->u.xTCP.usInitMSS = pxSocket->u.xTCP.usCurMSS = ( uint16_t ) ulMSS;
 800c2b8:	68fb      	ldr	r3, [r7, #12]
 800c2ba:	b29a      	uxth	r2, r3
 800c2bc:	687b      	ldr	r3, [r7, #4]
 800c2be:	f8a3 204a 	strh.w	r2, [r3, #74]	; 0x4a
 800c2c2:	687b      	ldr	r3, [r7, #4]
 800c2c4:	f8b3 204a 	ldrh.w	r2, [r3, #74]	; 0x4a
 800c2c8:	687b      	ldr	r3, [r7, #4]
 800c2ca:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
}
 800c2ce:	3710      	adds	r7, #16
 800c2d0:	46bd      	mov	sp, r7
 800c2d2:	bd80      	pop	{r7, pc}
 800c2d4:	2000bb08 	.word	0x2000bb08
 800c2d8:	2000c1c4 	.word	0x2000c1c4

0800c2dc <xProcessReceivedTCPPacket>:
 *		prvTCPSendRepeated()
 *			prvTCPReturnPacket()		// Prepare for returning
 *			xNetworkInterfaceOutput()	// Sends data to the NIC
*/
BaseType_t xProcessReceivedTCPPacket( NetworkBufferDescriptor_t *pxNetworkBuffer )
{
 800c2dc:	b580      	push	{r7, lr}
 800c2de:	b08c      	sub	sp, #48	; 0x30
 800c2e0:	af00      	add	r7, sp, #0
 800c2e2:	6078      	str	r0, [r7, #4]
FreeRTOS_Socket_t *pxSocket;
TCPPacket_t * pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800c2e4:	687b      	ldr	r3, [r7, #4]
 800c2e6:	699b      	ldr	r3, [r3, #24]
 800c2e8:	627b      	str	r3, [r7, #36]	; 0x24
uint16_t ucTCPFlags = pxTCPPacket->xTCPHeader.ucTCPFlags;
 800c2ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c2ec:	f893 302f 	ldrb.w	r3, [r3, #47]	; 0x2f
 800c2f0:	847b      	strh	r3, [r7, #34]	; 0x22
uint32_t ulLocalIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulDestinationIPAddress );
 800c2f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c2f4:	f8d3 301e 	ldr.w	r3, [r3, #30]
 800c2f8:	061a      	lsls	r2, r3, #24
 800c2fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c2fc:	f8d3 301e 	ldr.w	r3, [r3, #30]
 800c300:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800c304:	021b      	lsls	r3, r3, #8
 800c306:	431a      	orrs	r2, r3
 800c308:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c30a:	f8d3 301e 	ldr.w	r3, [r3, #30]
 800c30e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800c312:	0a1b      	lsrs	r3, r3, #8
 800c314:	431a      	orrs	r2, r3
 800c316:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c318:	f8d3 301e 	ldr.w	r3, [r3, #30]
 800c31c:	0e1b      	lsrs	r3, r3, #24
 800c31e:	4313      	orrs	r3, r2
 800c320:	61fb      	str	r3, [r7, #28]
uint16_t xLocalPort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usDestinationPort );
 800c322:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c324:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800c326:	b29b      	uxth	r3, r3
 800c328:	021b      	lsls	r3, r3, #8
 800c32a:	b29a      	uxth	r2, r3
 800c32c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c32e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800c330:	b29b      	uxth	r3, r3
 800c332:	0a1b      	lsrs	r3, r3, #8
 800c334:	b29b      	uxth	r3, r3
 800c336:	b29b      	uxth	r3, r3
 800c338:	4313      	orrs	r3, r2
 800c33a:	b29b      	uxth	r3, r3
 800c33c:	837b      	strh	r3, [r7, #26]
uint32_t ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
 800c33e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c340:	f8d3 301a 	ldr.w	r3, [r3, #26]
 800c344:	061a      	lsls	r2, r3, #24
 800c346:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c348:	f8d3 301a 	ldr.w	r3, [r3, #26]
 800c34c:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800c350:	021b      	lsls	r3, r3, #8
 800c352:	431a      	orrs	r2, r3
 800c354:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c356:	f8d3 301a 	ldr.w	r3, [r3, #26]
 800c35a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800c35e:	0a1b      	lsrs	r3, r3, #8
 800c360:	431a      	orrs	r2, r3
 800c362:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c364:	f8d3 301a 	ldr.w	r3, [r3, #26]
 800c368:	0e1b      	lsrs	r3, r3, #24
 800c36a:	4313      	orrs	r3, r2
 800c36c:	617b      	str	r3, [r7, #20]
uint16_t xRemotePort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usSourcePort );
 800c36e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c370:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 800c372:	b29b      	uxth	r3, r3
 800c374:	021b      	lsls	r3, r3, #8
 800c376:	b29a      	uxth	r2, r3
 800c378:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c37a:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 800c37c:	b29b      	uxth	r3, r3
 800c37e:	0a1b      	lsrs	r3, r3, #8
 800c380:	b29b      	uxth	r3, r3
 800c382:	b29b      	uxth	r3, r3
 800c384:	4313      	orrs	r3, r2
 800c386:	b29b      	uxth	r3, r3
 800c388:	827b      	strh	r3, [r7, #18]
BaseType_t xResult = pdPASS;
 800c38a:	2301      	movs	r3, #1
 800c38c:	62bb      	str	r3, [r7, #40]	; 0x28

	/* Find the destination socket, and if not found: return a socket listing to
	the destination PORT. */
	pxSocket = ( FreeRTOS_Socket_t * ) pxTCPSocketLookup( ulLocalIP, xLocalPort, ulRemoteIP, xRemotePort );
 800c38e:	8b7a      	ldrh	r2, [r7, #26]
 800c390:	8a7b      	ldrh	r3, [r7, #18]
 800c392:	69f8      	ldr	r0, [r7, #28]
 800c394:	4611      	mov	r1, r2
 800c396:	697a      	ldr	r2, [r7, #20]
 800c398:	f7fd faec 	bl	8009974 <pxTCPSocketLookup>
 800c39c:	62f8      	str	r0, [r7, #44]	; 0x2c

	if( ( pxSocket == NULL ) || ( prvTCPSocketIsActive( ( UBaseType_t ) pxSocket->u.xTCP.ucTCPState ) == pdFALSE ) )
 800c39e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c3a0:	2b00      	cmp	r3, #0
 800c3a2:	d008      	beq.n	800c3b6 <xProcessReceivedTCPPacket+0xda>
 800c3a4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c3a6:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800c3aa:	4618      	mov	r0, r3
 800c3ac:	f7fe f898 	bl	800a4e0 <prvTCPSocketIsActive>
 800c3b0:	4603      	mov	r3, r0
 800c3b2:	2b00      	cmp	r3, #0
 800c3b4:	d110      	bne.n	800c3d8 <xProcessReceivedTCPPacket+0xfc>
		the other party will get a ECONN error.  There are two exceptions:
		1) A packet that already has the RST flag set.
		2) A packet that only has the ACK flag set.
		A packet with only the ACK flag set might be the last ACK in
	 	a three-way hand-shake that closes a connection. */
		if( ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) != ipTCP_FLAG_ACK ) &&
 800c3b6:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800c3b8:	f003 031f 	and.w	r3, r3, #31
 800c3bc:	2b10      	cmp	r3, #16
 800c3be:	d008      	beq.n	800c3d2 <xProcessReceivedTCPPacket+0xf6>
			( ( ucTCPFlags & ipTCP_FLAG_RST ) == 0u ) )
 800c3c0:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800c3c2:	f003 0304 	and.w	r3, r3, #4
		the other party will get a ECONN error.  There are two exceptions:
		1) A packet that already has the RST flag set.
		2) A packet that only has the ACK flag set.
		A packet with only the ACK flag set might be the last ACK in
	 	a three-way hand-shake that closes a connection. */
		if( ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) != ipTCP_FLAG_ACK ) &&
 800c3c6:	2b00      	cmp	r3, #0
 800c3c8:	d103      	bne.n	800c3d2 <xProcessReceivedTCPPacket+0xf6>
			( ( ucTCPFlags & ipTCP_FLAG_RST ) == 0u ) )
		{
			prvTCPSendReset( pxNetworkBuffer );
 800c3ca:	687b      	ldr	r3, [r7, #4]
 800c3cc:	4618      	mov	r0, r3
 800c3ce:	f7ff ff2d 	bl	800c22c <prvTCPSendReset>
		}

		/* The packet can't be handled. */
		xResult = pdFAIL;
 800c3d2:	2300      	movs	r3, #0
 800c3d4:	62bb      	str	r3, [r7, #40]	; 0x28
 800c3d6:	e04e      	b.n	800c476 <xProcessReceivedTCPPacket+0x19a>
	}
	else
	{
		pxSocket->u.xTCP.ucRepCount = 0u;
 800c3d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c3da:	2200      	movs	r2, #0
 800c3dc:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52

		if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN )
 800c3e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c3e2:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800c3e6:	2b01      	cmp	r3, #1
 800c3e8:	d11c      	bne.n	800c424 <xProcessReceivedTCPPacket+0x148>
		{
			/* The matching socket is in a listening state.  Test if the peer
			has set the SYN flag. */
			if( ( ucTCPFlags & ipTCP_FLAG_CTRL ) != ipTCP_FLAG_SYN )
 800c3ea:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800c3ec:	f003 031f 	and.w	r3, r3, #31
 800c3f0:	2b02      	cmp	r3, #2
 800c3f2:	d00b      	beq.n	800c40c <xProcessReceivedTCPPacket+0x130>
				FreeRTOS_debug_printf( ( "TCP: Server can't handle flags: %s from %lxip:%u to port %u\n",
					prvTCPFlagMeaning( ( UBaseType_t ) ucTCPFlags ), ulRemoteIP, xRemotePort, xLocalPort ) );
				}
				#endif /* ipconfigHAS_DEBUG_PRINTF */

				if( ( ucTCPFlags & ipTCP_FLAG_RST ) == 0u )
 800c3f4:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800c3f6:	f003 0304 	and.w	r3, r3, #4
 800c3fa:	2b00      	cmp	r3, #0
 800c3fc:	d103      	bne.n	800c406 <xProcessReceivedTCPPacket+0x12a>
				{
					prvTCPSendReset( pxNetworkBuffer );
 800c3fe:	687b      	ldr	r3, [r7, #4]
 800c400:	4618      	mov	r0, r3
 800c402:	f7ff ff13 	bl	800c22c <prvTCPSendReset>
				}
				xResult = pdFAIL;
 800c406:	2300      	movs	r3, #0
 800c408:	62bb      	str	r3, [r7, #40]	; 0x28
 800c40a:	e034      	b.n	800c476 <xProcessReceivedTCPPacket+0x19a>
			else
			{
				/* prvHandleListen() will either return a newly created socket
				(if bReuseSocket is false), otherwise it returns the current
				socket which will later get connected. */
				pxSocket = prvHandleListen( pxSocket, pxNetworkBuffer );
 800c40c:	687b      	ldr	r3, [r7, #4]
 800c40e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c410:	4619      	mov	r1, r3
 800c412:	f000 f87f 	bl	800c514 <prvHandleListen>
 800c416:	62f8      	str	r0, [r7, #44]	; 0x2c

				if( pxSocket == NULL )
 800c418:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c41a:	2b00      	cmp	r3, #0
 800c41c:	d12b      	bne.n	800c476 <xProcessReceivedTCPPacket+0x19a>
				{
					xResult = pdFAIL;
 800c41e:	2300      	movs	r3, #0
 800c420:	62bb      	str	r3, [r7, #40]	; 0x28
 800c422:	e028      	b.n	800c476 <xProcessReceivedTCPPacket+0x19a>
		}	/* if( pxSocket->u.xTCP.ucTCPState == eTCP_LISTEN ). */
		else
		{
			/* This is not a socket in listening mode. Check for the RST
			flag. */
			if( ( ucTCPFlags & ipTCP_FLAG_RST ) != 0u )
 800c424:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800c426:	f003 0304 	and.w	r3, r3, #4
 800c42a:	2b00      	cmp	r3, #0
 800c42c:	d006      	beq.n	800c43c <xProcessReceivedTCPPacket+0x160>
			{
				/* The target socket is not in a listening state, any RST packet
				will cause the socket to be closed. */
				FreeRTOS_debug_printf( ( "TCP: RST received from %lxip:%u for %u\n", ulRemoteIP, xRemotePort, xLocalPort ) );
				vTCPStateChange( pxSocket, eCLOSED );
 800c42e:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c430:	2100      	movs	r1, #0
 800c432:	f7fe fe11 	bl	800b058 <vTCPStateChange>

				/* The packet cannot be handled. */
				xResult = pdFAIL;
 800c436:	2300      	movs	r3, #0
 800c438:	62bb      	str	r3, [r7, #40]	; 0x28
 800c43a:	e01c      	b.n	800c476 <xProcessReceivedTCPPacket+0x19a>
			}
			else if( ( ( ucTCPFlags & ipTCP_FLAG_CTRL ) == ipTCP_FLAG_SYN ) && ( pxSocket->u.xTCP.ucTCPState >= eESTABLISHED ) )
 800c43c:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 800c43e:	f003 031f 	and.w	r3, r3, #31
 800c442:	2b02      	cmp	r3, #2
 800c444:	d107      	bne.n	800c456 <xProcessReceivedTCPPacket+0x17a>
 800c446:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c448:	f893 3053 	ldrb.w	r3, [r3, #83]	; 0x53
 800c44c:	2b04      	cmp	r3, #4
 800c44e:	d902      	bls.n	800c456 <xProcessReceivedTCPPacket+0x17a>
			{
				/* SYN flag while this socket is already connected. */
				FreeRTOS_debug_printf( ( "TCP: SYN unexpected from %lxip:%u\n", ulRemoteIP, xRemotePort ) );

				/* The packet cannot be handled. */
				xResult = pdFAIL;
 800c450:	2300      	movs	r3, #0
 800c452:	62bb      	str	r3, [r7, #40]	; 0x28
 800c454:	e00f      	b.n	800c476 <xProcessReceivedTCPPacket+0x19a>
			else
			{
				/* Update the copy of the TCP header only (skipping eth and IP
				headers).  It might be used later on, whenever data must be sent
				to the peer. */
				const BaseType_t lOffset = ( BaseType_t ) ( ipSIZE_OF_ETH_HEADER + ipSIZE_OF_IPv4_HEADER );
 800c456:	2322      	movs	r3, #34	; 0x22
 800c458:	60fb      	str	r3, [r7, #12]
				memcpy( pxSocket->u.xTCP.xPacket.u.ucLastPacket + lOffset, pxNetworkBuffer->pucEthernetBuffer + lOffset, ipSIZE_OF_TCP_HEADER );
 800c45a:	68fb      	ldr	r3, [r7, #12]
 800c45c:	3380      	adds	r3, #128	; 0x80
 800c45e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c460:	4413      	add	r3, r2
 800c462:	1c99      	adds	r1, r3, #2
 800c464:	687b      	ldr	r3, [r7, #4]
 800c466:	699a      	ldr	r2, [r3, #24]
 800c468:	68fb      	ldr	r3, [r7, #12]
 800c46a:	4413      	add	r3, r2
 800c46c:	4608      	mov	r0, r1
 800c46e:	4619      	mov	r1, r3
 800c470:	2214      	movs	r2, #20
 800c472:	f003 fe19 	bl	80100a8 <memcpy>
			}
		}
	}

	if( xResult != pdFAIL )
 800c476:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800c478:	2b00      	cmp	r3, #0
 800c47a:	d046      	beq.n	800c50a <xProcessReceivedTCPPacket+0x22e>
	{
		/* Touch the alive timers because we received a message	for this
		socket. */
		prvTCPTouchSocket( pxSocket );
 800c47c:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c47e:	f7fe fdc7 	bl	800b010 <prvTCPTouchSocket>
		/* _HT_ : if we're in the SYN phase, and peer does not send a MSS option,
		then we MUST assume an MSS size of 536 bytes for backward compatibility. */

		/* When there are no TCP options, the TCP offset equals 20 bytes, which is stored as
		the number 5 (words) in the higher niblle of the TCP-offset byte. */
		if( ( pxTCPPacket->xTCPHeader.ucTCPOffset & TCP_OFFSET_LENGTH_BITS ) > TCP_OFFSET_STANDARD_LENGTH )
 800c482:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c484:	f893 302e 	ldrb.w	r3, [r3, #46]	; 0x2e
 800c488:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 800c48c:	2b50      	cmp	r3, #80	; 0x50
 800c48e:	d904      	bls.n	800c49a <xProcessReceivedTCPPacket+0x1be>
		{
			prvCheckOptions( pxSocket, pxNetworkBuffer );
 800c490:	687b      	ldr	r3, [r7, #4]
 800c492:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c494:	4619      	mov	r1, r3
 800c496:	f7fe fc57 	bl	800ad48 <prvCheckOptions>
		}


		#if( ipconfigUSE_TCP_WIN == 1 )
		{
			pxSocket->u.xTCP.ulWindowSize = FreeRTOS_ntohs( pxTCPPacket->xTCPHeader.usWindow );
 800c49a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c49c:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 800c49e:	b29b      	uxth	r3, r3
 800c4a0:	021b      	lsls	r3, r3, #8
 800c4a2:	b29a      	uxth	r2, r3
 800c4a4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800c4a6:	8e1b      	ldrh	r3, [r3, #48]	; 0x30
 800c4a8:	b29b      	uxth	r3, r3
 800c4aa:	0a1b      	lsrs	r3, r3, #8
 800c4ac:	b29b      	uxth	r3, r3
 800c4ae:	b29b      	uxth	r3, r3
 800c4b0:	4313      	orrs	r3, r2
 800c4b2:	b29b      	uxth	r3, r3
 800c4b4:	b29b      	uxth	r3, r3
 800c4b6:	461a      	mov	r2, r3
 800c4b8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c4ba:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
			pxSocket->u.xTCP.ulWindowSize =
				( pxSocket->u.xTCP.ulWindowSize << pxSocket->u.xTCP.ucPeerWinScaleFactor );
 800c4be:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c4c0:	f8d3 30cc 	ldr.w	r3, [r3, #204]	; 0xcc
 800c4c4:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800c4c6:	f892 20ca 	ldrb.w	r2, [r2, #202]	; 0xca
 800c4ca:	fa03 f202 	lsl.w	r2, r3, r2


		#if( ipconfigUSE_TCP_WIN == 1 )
		{
			pxSocket->u.xTCP.ulWindowSize = FreeRTOS_ntohs( pxTCPPacket->xTCPHeader.usWindow );
			pxSocket->u.xTCP.ulWindowSize =
 800c4ce:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800c4d0:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
		}
		#endif

		/* In prvTCPHandleState() the incoming messages will be handled
		depending on the current state of the connection. */
		if( prvTCPHandleState( pxSocket, &pxNetworkBuffer ) > 0 )
 800c4d4:	1d3b      	adds	r3, r7, #4
 800c4d6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c4d8:	4619      	mov	r1, r3
 800c4da:	f7ff fd95 	bl	800c008 <prvTCPHandleState>
 800c4de:	4603      	mov	r3, r0
 800c4e0:	2b00      	cmp	r3, #0
 800c4e2:	dd04      	ble.n	800c4ee <xProcessReceivedTCPPacket+0x212>
		{
			/* prvTCPHandleState() has sent a message, see if there are more to
			be transmitted. */
			#if( ipconfigUSE_TCP_WIN == 1 )
			{
				prvTCPSendRepeated( pxSocket, &pxNetworkBuffer );
 800c4e4:	1d3b      	adds	r3, r7, #4
 800c4e6:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c4e8:	4619      	mov	r1, r3
 800c4ea:	f7fe f93d 	bl	800a768 <prvTCPSendRepeated>
			}
			#endif /* ipconfigUSE_TCP_WIN */
		}

		if( pxNetworkBuffer != NULL )
 800c4ee:	687b      	ldr	r3, [r7, #4]
 800c4f0:	2b00      	cmp	r3, #0
 800c4f2:	d005      	beq.n	800c500 <xProcessReceivedTCPPacket+0x224>
		{
			/* We must check if the buffer is unequal to NULL, because the
			socket might keep a reference to it in case a delayed ACK must be
			sent. */
			vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
 800c4f4:	687b      	ldr	r3, [r7, #4]
 800c4f6:	4618      	mov	r0, r3
 800c4f8:	f7fb f970 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
			pxNetworkBuffer = NULL;
 800c4fc:	2300      	movs	r3, #0
 800c4fe:	607b      	str	r3, [r7, #4]
		}

		/* And finally, calculate when this socket wants to be woken up. */
		prvTCPNextTimeout ( pxSocket );
 800c500:	6af8      	ldr	r0, [r7, #44]	; 0x2c
 800c502:	f7ff f855 	bl	800b5b0 <prvTCPNextTimeout>
		/* Return pdPASS to tell that the network buffer is 'consumed'. */
		xResult = pdPASS;
 800c506:	2301      	movs	r3, #1
 800c508:	62bb      	str	r3, [r7, #40]	; 0x28
	}

	/* pdPASS being returned means the buffer has been consumed. */
	return xResult;
 800c50a:	6abb      	ldr	r3, [r7, #40]	; 0x28
}
 800c50c:	4618      	mov	r0, r3
 800c50e:	3730      	adds	r7, #48	; 0x30
 800c510:	46bd      	mov	sp, r7
 800c512:	bd80      	pop	{r7, pc}

0800c514 <prvHandleListen>:
/*-----------------------------------------------------------*/

static FreeRTOS_Socket_t *prvHandleListen( FreeRTOS_Socket_t *pxSocket, NetworkBufferDescriptor_t *pxNetworkBuffer )
{
 800c514:	b590      	push	{r4, r7, lr}
 800c516:	b089      	sub	sp, #36	; 0x24
 800c518:	af02      	add	r7, sp, #8
 800c51a:	6078      	str	r0, [r7, #4]
 800c51c:	6039      	str	r1, [r7, #0]
TCPPacket_t * pxTCPPacket = ( TCPPacket_t * ) ( pxNetworkBuffer->pucEthernetBuffer );
 800c51e:	683b      	ldr	r3, [r7, #0]
 800c520:	699b      	ldr	r3, [r3, #24]
 800c522:	613b      	str	r3, [r7, #16]
FreeRTOS_Socket_t *pxReturn;

	/* A pure SYN (without ACK) has come in, create a new socket to answer
	it. */
	if( pxSocket->u.xTCP.bits.bReuseSocket != pdFALSE_UNSIGNED )
 800c524:	687b      	ldr	r3, [r7, #4]
 800c526:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800c52a:	f003 0308 	and.w	r3, r3, #8
 800c52e:	b2db      	uxtb	r3, r3
 800c530:	2b00      	cmp	r3, #0
 800c532:	d00c      	beq.n	800c54e <prvHandleListen+0x3a>
	{
		/* The flag bReuseSocket indicates that the same instance of the
		listening socket should be used for the connection. */
		pxReturn = pxSocket;
 800c534:	687b      	ldr	r3, [r7, #4]
 800c536:	617b      	str	r3, [r7, #20]
		pxSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 800c538:	687a      	ldr	r2, [r7, #4]
 800c53a:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 800c53e:	f043 0304 	orr.w	r3, r3, #4
 800c542:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
		pxSocket->u.xTCP.pxPeerSocket = pxSocket;
 800c546:	687b      	ldr	r3, [r7, #4]
 800c548:	687a      	ldr	r2, [r7, #4]
 800c54a:	655a      	str	r2, [r3, #84]	; 0x54
 800c54c:	e03f      	b.n	800c5ce <prvHandleListen+0xba>
	}
	else
	{
		/* The socket does not have the bReuseSocket flag set meaning create a
		new socket when a connection comes in. */
		pxReturn = NULL;
 800c54e:	2300      	movs	r3, #0
 800c550:	617b      	str	r3, [r7, #20]

		if( pxSocket->u.xTCP.usChildCount >= pxSocket->u.xTCP.usBacklog )
 800c552:	687b      	ldr	r3, [r7, #4]
 800c554:	f8b3 204e 	ldrh.w	r2, [r3, #78]	; 0x4e
 800c558:	687b      	ldr	r3, [r7, #4]
 800c55a:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800c55e:	429a      	cmp	r2, r3
 800c560:	d31b      	bcc.n	800c59a <prvHandleListen+0x86>
		{
			FreeRTOS_printf( ( "Check: Socket %u already has %u / %u child%s\n",
 800c562:	687b      	ldr	r3, [r7, #4]
 800c564:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800c566:	4619      	mov	r1, r3
 800c568:	687b      	ldr	r3, [r7, #4]
 800c56a:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
 800c56e:	461a      	mov	r2, r3
 800c570:	687b      	ldr	r3, [r7, #4]
 800c572:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 800c576:	461c      	mov	r4, r3
 800c578:	687b      	ldr	r3, [r7, #4]
 800c57a:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
 800c57e:	2b01      	cmp	r3, #1
 800c580:	d101      	bne.n	800c586 <prvHandleListen+0x72>
 800c582:	4b48      	ldr	r3, [pc, #288]	; (800c6a4 <prvHandleListen+0x190>)
 800c584:	e000      	b.n	800c588 <prvHandleListen+0x74>
 800c586:	4b48      	ldr	r3, [pc, #288]	; (800c6a8 <prvHandleListen+0x194>)
 800c588:	9300      	str	r3, [sp, #0]
 800c58a:	4848      	ldr	r0, [pc, #288]	; (800c6ac <prvHandleListen+0x198>)
 800c58c:	4623      	mov	r3, r4
 800c58e:	f002 fcab 	bl	800eee8 <lUDPLoggingPrintf>
				pxSocket->usLocalPort,
				pxSocket->u.xTCP.usChildCount,
				pxSocket->u.xTCP.usBacklog,
				pxSocket->u.xTCP.usChildCount == 1 ? "" : "ren" ) );
			prvTCPSendReset( pxNetworkBuffer );
 800c592:	6838      	ldr	r0, [r7, #0]
 800c594:	f7ff fe4a 	bl	800c22c <prvTCPSendReset>
 800c598:	e019      	b.n	800c5ce <prvHandleListen+0xba>
		}
		else
		{
			FreeRTOS_Socket_t *pxNewSocket = (FreeRTOS_Socket_t *)
 800c59a:	2002      	movs	r0, #2
 800c59c:	2101      	movs	r1, #1
 800c59e:	2206      	movs	r2, #6
 800c5a0:	f7fc fc20 	bl	8008de4 <FreeRTOS_socket>
 800c5a4:	60f8      	str	r0, [r7, #12]
				FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_STREAM, FREERTOS_IPPROTO_TCP );

			if( ( pxNewSocket == NULL ) || ( pxNewSocket == FREERTOS_INVALID_SOCKET ) )
 800c5a6:	68fb      	ldr	r3, [r7, #12]
 800c5a8:	2b00      	cmp	r3, #0
 800c5aa:	d003      	beq.n	800c5b4 <prvHandleListen+0xa0>
 800c5ac:	68fb      	ldr	r3, [r7, #12]
 800c5ae:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800c5b2:	d103      	bne.n	800c5bc <prvHandleListen+0xa8>
			{
				FreeRTOS_debug_printf( ( "TCP: Listen: new socket failed\n" ) );
				prvTCPSendReset( pxNetworkBuffer );
 800c5b4:	6838      	ldr	r0, [r7, #0]
 800c5b6:	f7ff fe39 	bl	800c22c <prvTCPSendReset>
 800c5ba:	e008      	b.n	800c5ce <prvHandleListen+0xba>
			}
			else if( prvTCPSocketCopy( pxNewSocket, pxSocket ) != pdFALSE )
 800c5bc:	68f8      	ldr	r0, [r7, #12]
 800c5be:	6879      	ldr	r1, [r7, #4]
 800c5c0:	f000 f878 	bl	800c6b4 <prvTCPSocketCopy>
 800c5c4:	4603      	mov	r3, r0
 800c5c6:	2b00      	cmp	r3, #0
 800c5c8:	d001      	beq.n	800c5ce <prvHandleListen+0xba>
			{
				/* The socket will be connected immediately, no time for the
				owner to setsockopt's, therefore copy properties of the server
				socket to the new socket.  Only the binding might fail (due to
				lack of resources). */
				pxReturn = pxNewSocket;
 800c5ca:	68fb      	ldr	r3, [r7, #12]
 800c5cc:	617b      	str	r3, [r7, #20]
			}
		}
	}

	if( pxReturn != NULL )
 800c5ce:	697b      	ldr	r3, [r7, #20]
 800c5d0:	2b00      	cmp	r3, #0
 800c5d2:	d061      	beq.n	800c698 <prvHandleListen+0x184>
	{
		pxReturn->u.xTCP.usRemotePort = FreeRTOS_htons( pxTCPPacket->xTCPHeader.usSourcePort );
 800c5d4:	693b      	ldr	r3, [r7, #16]
 800c5d6:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 800c5d8:	b29b      	uxth	r3, r3
 800c5da:	021b      	lsls	r3, r3, #8
 800c5dc:	b29a      	uxth	r2, r3
 800c5de:	693b      	ldr	r3, [r7, #16]
 800c5e0:	8c5b      	ldrh	r3, [r3, #34]	; 0x22
 800c5e2:	b29b      	uxth	r3, r3
 800c5e4:	0a1b      	lsrs	r3, r3, #8
 800c5e6:	b29b      	uxth	r3, r3
 800c5e8:	b29b      	uxth	r3, r3
 800c5ea:	4313      	orrs	r3, r2
 800c5ec:	b29b      	uxth	r3, r3
 800c5ee:	b29a      	uxth	r2, r3
 800c5f0:	697b      	ldr	r3, [r7, #20]
 800c5f2:	879a      	strh	r2, [r3, #60]	; 0x3c
		pxReturn->u.xTCP.ulRemoteIP = FreeRTOS_htonl( pxTCPPacket->xIPHeader.ulSourceIPAddress );
 800c5f4:	693b      	ldr	r3, [r7, #16]
 800c5f6:	f8d3 301a 	ldr.w	r3, [r3, #26]
 800c5fa:	061a      	lsls	r2, r3, #24
 800c5fc:	693b      	ldr	r3, [r7, #16]
 800c5fe:	f8d3 301a 	ldr.w	r3, [r3, #26]
 800c602:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800c606:	021b      	lsls	r3, r3, #8
 800c608:	431a      	orrs	r2, r3
 800c60a:	693b      	ldr	r3, [r7, #16]
 800c60c:	f8d3 301a 	ldr.w	r3, [r3, #26]
 800c610:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800c614:	0a1b      	lsrs	r3, r3, #8
 800c616:	431a      	orrs	r2, r3
 800c618:	693b      	ldr	r3, [r7, #16]
 800c61a:	f8d3 301a 	ldr.w	r3, [r3, #26]
 800c61e:	0e1b      	lsrs	r3, r3, #24
 800c620:	431a      	orrs	r2, r3
 800c622:	697b      	ldr	r3, [r7, #20]
 800c624:	639a      	str	r2, [r3, #56]	; 0x38
		pxReturn->u.xTCP.xTCPWindow.ulOurSequenceNumber = ulNextInitialSequenceNumber;
 800c626:	4b22      	ldr	r3, [pc, #136]	; (800c6b0 <prvHandleListen+0x19c>)
 800c628:	681a      	ldr	r2, [r3, #0]
 800c62a:	697b      	ldr	r3, [r7, #20]
 800c62c:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108

		/* Here is the SYN action. */
		pxReturn->u.xTCP.xTCPWindow.rx.ulCurrentSequenceNumber = FreeRTOS_ntohl( pxTCPPacket->xTCPHeader.ulSequenceNumber );
 800c630:	693b      	ldr	r3, [r7, #16]
 800c632:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
 800c636:	061a      	lsls	r2, r3, #24
 800c638:	693b      	ldr	r3, [r7, #16]
 800c63a:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
 800c63e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800c642:	021b      	lsls	r3, r3, #8
 800c644:	431a      	orrs	r2, r3
 800c646:	693b      	ldr	r3, [r7, #16]
 800c648:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
 800c64c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800c650:	0a1b      	lsrs	r3, r3, #8
 800c652:	431a      	orrs	r2, r3
 800c654:	693b      	ldr	r3, [r7, #16]
 800c656:	f8d3 3026 	ldr.w	r3, [r3, #38]	; 0x26
 800c65a:	0e1b      	lsrs	r3, r3, #24
 800c65c:	431a      	orrs	r2, r3
 800c65e:	697b      	ldr	r3, [r7, #20]
 800c660:	f8c3 20ec 	str.w	r2, [r3, #236]	; 0xec
		prvSocketSetMSS( pxReturn );
 800c664:	6978      	ldr	r0, [r7, #20]
 800c666:	f7ff fdff 	bl	800c268 <prvSocketSetMSS>

		prvTCPCreateWindow( pxReturn );
 800c66a:	6978      	ldr	r0, [r7, #20]
 800c66c:	f7fe fa66 	bl	800ab3c <prvTCPCreateWindow>

		/* It is recommended to increase the ISS for each new connection with a value of 0x102. */
		ulNextInitialSequenceNumber += INITIAL_SEQUENCE_NUMBER_INCREMENT;
 800c670:	4b0f      	ldr	r3, [pc, #60]	; (800c6b0 <prvHandleListen+0x19c>)
 800c672:	681b      	ldr	r3, [r3, #0]
 800c674:	f503 7381 	add.w	r3, r3, #258	; 0x102
 800c678:	4a0d      	ldr	r2, [pc, #52]	; (800c6b0 <prvHandleListen+0x19c>)
 800c67a:	6013      	str	r3, [r2, #0]

		vTCPStateChange( pxReturn, eSYN_FIRST );
 800c67c:	6978      	ldr	r0, [r7, #20]
 800c67e:	2103      	movs	r1, #3
 800c680:	f7fe fcea 	bl	800b058 <vTCPStateChange>

		/* Make a copy of the header up to the TCP header.  It is needed later
		on, whenever data must be sent to the peer. */
		memcpy( pxReturn->u.xTCP.xPacket.u.ucLastPacket, pxNetworkBuffer->pucEthernetBuffer, sizeof( pxReturn->u.xTCP.xPacket.u.ucLastPacket ) );
 800c684:	697b      	ldr	r3, [r7, #20]
 800c686:	f103 0282 	add.w	r2, r3, #130	; 0x82
 800c68a:	683b      	ldr	r3, [r7, #0]
 800c68c:	699b      	ldr	r3, [r3, #24]
 800c68e:	4610      	mov	r0, r2
 800c690:	4619      	mov	r1, r3
 800c692:	2246      	movs	r2, #70	; 0x46
 800c694:	f003 fd08 	bl	80100a8 <memcpy>
	}
	return pxReturn;
 800c698:	697b      	ldr	r3, [r7, #20]
}
 800c69a:	4618      	mov	r0, r3
 800c69c:	371c      	adds	r7, #28
 800c69e:	46bd      	mov	sp, r7
 800c6a0:	bd90      	pop	{r4, r7, pc}
 800c6a2:	bf00      	nop
 800c6a4:	080127c8 	.word	0x080127c8
 800c6a8:	080127cc 	.word	0x080127cc
 800c6ac:	080127d0 	.word	0x080127d0
 800c6b0:	2000c298 	.word	0x2000c298

0800c6b4 <prvTCPSocketCopy>:

/*
 * Duplicates a socket after a listening socket receives a connection.
 */
static BaseType_t prvTCPSocketCopy( FreeRTOS_Socket_t *pxNewSocket, FreeRTOS_Socket_t *pxSocket )
{
 800c6b4:	b580      	push	{r7, lr}
 800c6b6:	b084      	sub	sp, #16
 800c6b8:	af00      	add	r7, sp, #0
 800c6ba:	6078      	str	r0, [r7, #4]
 800c6bc:	6039      	str	r1, [r7, #0]
struct freertos_sockaddr xAddress;

	pxNewSocket->xReceiveBlockTime = pxSocket->xReceiveBlockTime;
 800c6be:	683b      	ldr	r3, [r7, #0]
 800c6c0:	69da      	ldr	r2, [r3, #28]
 800c6c2:	687b      	ldr	r3, [r7, #4]
 800c6c4:	61da      	str	r2, [r3, #28]
	pxNewSocket->xSendBlockTime = pxSocket->xSendBlockTime;
 800c6c6:	683b      	ldr	r3, [r7, #0]
 800c6c8:	6a1a      	ldr	r2, [r3, #32]
 800c6ca:	687b      	ldr	r3, [r7, #4]
 800c6cc:	621a      	str	r2, [r3, #32]
	pxNewSocket->ucSocketOptions = pxSocket->ucSocketOptions;
 800c6ce:	683b      	ldr	r3, [r7, #0]
 800c6d0:	f893 2026 	ldrb.w	r2, [r3, #38]	; 0x26
 800c6d4:	687b      	ldr	r3, [r7, #4]
 800c6d6:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
	pxNewSocket->u.xTCP.uxRxStreamSize = pxSocket->u.xTCP.uxRxStreamSize;
 800c6da:	683b      	ldr	r3, [r7, #0]
 800c6dc:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800c6de:	687b      	ldr	r3, [r7, #4]
 800c6e0:	66da      	str	r2, [r3, #108]	; 0x6c
	pxNewSocket->u.xTCP.uxTxStreamSize = pxSocket->u.xTCP.uxTxStreamSize;
 800c6e2:	683b      	ldr	r3, [r7, #0]
 800c6e4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
 800c6e6:	687b      	ldr	r3, [r7, #4]
 800c6e8:	671a      	str	r2, [r3, #112]	; 0x70
	pxNewSocket->u.xTCP.uxLittleSpace = pxSocket->u.xTCP.uxLittleSpace;
 800c6ea:	683b      	ldr	r3, [r7, #0]
 800c6ec:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 800c6ee:	687b      	ldr	r3, [r7, #4]
 800c6f0:	665a      	str	r2, [r3, #100]	; 0x64
	pxNewSocket->u.xTCP.uxEnoughSpace = pxSocket->u.xTCP.uxEnoughSpace;
 800c6f2:	683b      	ldr	r3, [r7, #0]
 800c6f4:	6e9a      	ldr	r2, [r3, #104]	; 0x68
 800c6f6:	687b      	ldr	r3, [r7, #4]
 800c6f8:	669a      	str	r2, [r3, #104]	; 0x68
	pxNewSocket->u.xTCP.uxRxWinSize  = pxSocket->u.xTCP.uxRxWinSize;
 800c6fa:	683b      	ldr	r3, [r7, #0]
 800c6fc:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 800c700:	687b      	ldr	r3, [r7, #4]
 800c702:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
	pxNewSocket->u.xTCP.uxTxWinSize  = pxSocket->u.xTCP.uxTxWinSize;
 800c706:	683b      	ldr	r3, [r7, #0]
 800c708:	f8d3 20d8 	ldr.w	r2, [r3, #216]	; 0xd8
 800c70c:	687b      	ldr	r3, [r7, #4]
 800c70e:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

	#if( ipconfigSUPPORT_SELECT_FUNCTION == 1 )
	{
		/* Child socket of listening sockets will inherit the Socket Set
		Otherwise the owner has no chance of including it into the set. */
		if( pxSocket->pxSocketSet )
 800c712:	683b      	ldr	r3, [r7, #0]
 800c714:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800c716:	2b00      	cmp	r3, #0
 800c718:	d009      	beq.n	800c72e <prvTCPSocketCopy+0x7a>
		{
			pxNewSocket->pxSocketSet = pxSocket->pxSocketSet;
 800c71a:	683b      	ldr	r3, [r7, #0]
 800c71c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800c71e:	687b      	ldr	r3, [r7, #4]
 800c720:	629a      	str	r2, [r3, #40]	; 0x28
			pxNewSocket->xSelectBits = pxSocket->xSelectBits | eSELECT_READ | eSELECT_EXCEPT;
 800c722:	683b      	ldr	r3, [r7, #0]
 800c724:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800c726:	f043 0205 	orr.w	r2, r3, #5
 800c72a:	687b      	ldr	r3, [r7, #4]
 800c72c:	62da      	str	r2, [r3, #44]	; 0x2c
		}
	}
	#endif /* ipconfigSUPPORT_SELECT_FUNCTION */

	/* And bind it to the same local port as its parent. */
	xAddress.sin_addr = *ipLOCAL_IP_ADDRESS_POINTER;
 800c72e:	4b1b      	ldr	r3, [pc, #108]	; (800c79c <prvTCPSocketCopy+0xe8>)
 800c730:	695b      	ldr	r3, [r3, #20]
 800c732:	60fb      	str	r3, [r7, #12]
	xAddress.sin_port = FreeRTOS_htons( pxSocket->usLocalPort );
 800c734:	683b      	ldr	r3, [r7, #0]
 800c736:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800c738:	021b      	lsls	r3, r3, #8
 800c73a:	b29a      	uxth	r2, r3
 800c73c:	683b      	ldr	r3, [r7, #0]
 800c73e:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800c740:	0a1b      	lsrs	r3, r3, #8
 800c742:	b29b      	uxth	r3, r3
 800c744:	b29b      	uxth	r3, r3
 800c746:	4313      	orrs	r3, r2
 800c748:	b29b      	uxth	r3, r3
 800c74a:	b29b      	uxth	r3, r3
 800c74c:	817b      	strh	r3, [r7, #10]
		orphan temporarily.  Once this socket is really connected, the owner of
		the server socket will be notified. */

		/* When bPassQueued is true, the socket is an orphan until it gets
		connected. */
		pxNewSocket->u.xTCP.bits.bPassQueued = pdTRUE_UNSIGNED;
 800c74e:	687a      	ldr	r2, [r7, #4]
 800c750:	f892 3040 	ldrb.w	r3, [r2, #64]	; 0x40
 800c754:	f043 0304 	orr.w	r3, r3, #4
 800c758:	f882 3040 	strb.w	r3, [r2, #64]	; 0x40
		pxNewSocket->u.xTCP.pxPeerSocket = pxSocket;
 800c75c:	687b      	ldr	r3, [r7, #4]
 800c75e:	683a      	ldr	r2, [r7, #0]
 800c760:	655a      	str	r2, [r3, #84]	; 0x54
			pxSocket->u.xTCP.pxPeerSocket = pxNewSocket;
		}
	}
	#endif

	pxSocket->u.xTCP.usChildCount++;
 800c762:	683b      	ldr	r3, [r7, #0]
 800c764:	f8b3 304e 	ldrh.w	r3, [r3, #78]	; 0x4e
 800c768:	3301      	adds	r3, #1
 800c76a:	b29a      	uxth	r2, r3
 800c76c:	683b      	ldr	r3, [r7, #0]
 800c76e:	f8a3 204e 	strh.w	r2, [r3, #78]	; 0x4e
		pxSocket->u.xTCP.usChildCount,
		pxSocket->u.xTCP.usBacklog,
		pxSocket->u.xTCP.usChildCount == 1u ? "" : "ren" ) );

	/* Now bind the child socket to the same port as the listening socket. */
	if( vSocketBind ( pxNewSocket, &xAddress, sizeof( xAddress ), pdTRUE ) != 0 )
 800c772:	f107 0308 	add.w	r3, r7, #8
 800c776:	6878      	ldr	r0, [r7, #4]
 800c778:	4619      	mov	r1, r3
 800c77a:	2208      	movs	r2, #8
 800c77c:	2301      	movs	r3, #1
 800c77e:	f7fc fcc9 	bl	8009114 <vSocketBind>
 800c782:	4603      	mov	r3, r0
 800c784:	2b00      	cmp	r3, #0
 800c786:	d004      	beq.n	800c792 <prvTCPSocketCopy+0xde>
	{
		FreeRTOS_debug_printf( ( "TCP: Listen: new socket bind error\n" ) );
		vSocketClose( pxNewSocket );
 800c788:	6878      	ldr	r0, [r7, #4]
 800c78a:	f7fc fd79 	bl	8009280 <vSocketClose>
		return pdFALSE;
 800c78e:	2300      	movs	r3, #0
 800c790:	e000      	b.n	800c794 <prvTCPSocketCopy+0xe0>
	}

	return pdTRUE;
 800c792:	2301      	movs	r3, #1
}
 800c794:	4618      	mov	r0, r3
 800c796:	3710      	adds	r7, #16
 800c798:	46bd      	mov	sp, r7
 800c79a:	bd80      	pop	{r7, pc}
 800c79c:	2000bb08 	.word	0x2000bb08

0800c7a0 <FreeRTOS_GetTCPStateName>:
/*-----------------------------------------------------------*/

#if( ( ipconfigHAS_DEBUG_PRINTF != 0 ) || ( ipconfigHAS_PRINTF != 0 ) )

	const char *FreeRTOS_GetTCPStateName( UBaseType_t ulState )
	{
 800c7a0:	b480      	push	{r7}
 800c7a2:	b083      	sub	sp, #12
 800c7a4:	af00      	add	r7, sp, #0
 800c7a6:	6078      	str	r0, [r7, #4]
		if( ulState >= ( UBaseType_t ) ARRAY_SIZE( pcStateNames ) )
 800c7a8:	687b      	ldr	r3, [r7, #4]
 800c7aa:	2b0c      	cmp	r3, #12
 800c7ac:	d901      	bls.n	800c7b2 <FreeRTOS_GetTCPStateName+0x12>
		{
			ulState = ( UBaseType_t ) ARRAY_SIZE( pcStateNames ) - 1u;
 800c7ae:	230c      	movs	r3, #12
 800c7b0:	607b      	str	r3, [r7, #4]
		}
		return pcStateNames[ ulState ];
 800c7b2:	4a05      	ldr	r2, [pc, #20]	; (800c7c8 <FreeRTOS_GetTCPStateName+0x28>)
 800c7b4:	687b      	ldr	r3, [r7, #4]
 800c7b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
	}
 800c7ba:	4618      	mov	r0, r3
 800c7bc:	370c      	adds	r7, #12
 800c7be:	46bd      	mov	sp, r7
 800c7c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c7c4:	4770      	bx	lr
 800c7c6:	bf00      	nop
 800c7c8:	2000bb20 	.word	0x2000bb20

0800c7cc <xTCPCheckNewClient>:
/*
 * In the API accept(), the user asks is there is a new client?  As API's can
 * not walk through the xBoundTCPSocketsList the IP-task will do this.
 */
BaseType_t xTCPCheckNewClient( FreeRTOS_Socket_t *pxSocket )
{
 800c7cc:	b480      	push	{r7}
 800c7ce:	b087      	sub	sp, #28
 800c7d0:	af00      	add	r7, sp, #0
 800c7d2:	6078      	str	r0, [r7, #4]
TickType_t xLocalPort = FreeRTOS_htons( pxSocket->usLocalPort );
 800c7d4:	687b      	ldr	r3, [r7, #4]
 800c7d6:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800c7d8:	021b      	lsls	r3, r3, #8
 800c7da:	b29a      	uxth	r2, r3
 800c7dc:	687b      	ldr	r3, [r7, #4]
 800c7de:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800c7e0:	0a1b      	lsrs	r3, r3, #8
 800c7e2:	b29b      	uxth	r3, r3
 800c7e4:	b29b      	uxth	r3, r3
 800c7e6:	4313      	orrs	r3, r2
 800c7e8:	b29b      	uxth	r3, r3
 800c7ea:	b29b      	uxth	r3, r3
 800c7ec:	60fb      	str	r3, [r7, #12]
ListItem_t *pxIterator;
FreeRTOS_Socket_t *pxFound;
BaseType_t xResult = pdFALSE;
 800c7ee:	2300      	movs	r3, #0
 800c7f0:	613b      	str	r3, [r7, #16]

	/* Here xBoundTCPSocketsList can be accessed safely IP-task is the only one
	who has access. */
	for( pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 800c7f2:	4b16      	ldr	r3, [pc, #88]	; (800c84c <xTCPCheckNewClient+0x80>)
 800c7f4:	68db      	ldr	r3, [r3, #12]
 800c7f6:	617b      	str	r3, [r7, #20]
 800c7f8:	e01d      	b.n	800c836 <xTCPCheckNewClient+0x6a>
		pxIterator != ( ListItem_t * ) listGET_END_MARKER( &xBoundTCPSocketsList );
		pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
	{
		if( listGET_LIST_ITEM_VALUE( pxIterator ) == xLocalPort )
 800c7fa:	697b      	ldr	r3, [r7, #20]
 800c7fc:	681a      	ldr	r2, [r3, #0]
 800c7fe:	68fb      	ldr	r3, [r7, #12]
 800c800:	429a      	cmp	r2, r3
 800c802:	d115      	bne.n	800c830 <xTCPCheckNewClient+0x64>
		{
			pxFound = ( FreeRTOS_Socket_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800c804:	697b      	ldr	r3, [r7, #20]
 800c806:	68db      	ldr	r3, [r3, #12]
 800c808:	60bb      	str	r3, [r7, #8]
			if( ( pxFound->ucProtocol == FREERTOS_IPPROTO_TCP ) && ( pxFound->u.xTCP.bits.bPassAccept != pdFALSE_UNSIGNED ) )
 800c80a:	68bb      	ldr	r3, [r7, #8]
 800c80c:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
 800c810:	2b06      	cmp	r3, #6
 800c812:	d10d      	bne.n	800c830 <xTCPCheckNewClient+0x64>
 800c814:	68bb      	ldr	r3, [r7, #8]
 800c816:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
 800c81a:	f003 0302 	and.w	r3, r3, #2
 800c81e:	b2db      	uxtb	r3, r3
 800c820:	2b00      	cmp	r3, #0
 800c822:	d005      	beq.n	800c830 <xTCPCheckNewClient+0x64>
			{
				pxSocket->u.xTCP.pxPeerSocket = pxFound;
 800c824:	687b      	ldr	r3, [r7, #4]
 800c826:	68ba      	ldr	r2, [r7, #8]
 800c828:	655a      	str	r2, [r3, #84]	; 0x54
				FreeRTOS_debug_printf( ( "xTCPCheckNewClient[0]: client on port %u\n", pxSocket->usLocalPort ) );
				xResult = pdTRUE;
 800c82a:	2301      	movs	r3, #1
 800c82c:	613b      	str	r3, [r7, #16]
				break;
 800c82e:	e006      	b.n	800c83e <xTCPCheckNewClient+0x72>

	/* Here xBoundTCPSocketsList can be accessed safely IP-task is the only one
	who has access. */
	for( pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
		pxIterator != ( ListItem_t * ) listGET_END_MARKER( &xBoundTCPSocketsList );
		pxIterator = ( ListItem_t * ) listGET_NEXT( pxIterator ) )
 800c830:	697b      	ldr	r3, [r7, #20]
 800c832:	685b      	ldr	r3, [r3, #4]
 800c834:	617b      	str	r3, [r7, #20]
FreeRTOS_Socket_t *pxFound;
BaseType_t xResult = pdFALSE;

	/* Here xBoundTCPSocketsList can be accessed safely IP-task is the only one
	who has access. */
	for( pxIterator = ( ListItem_t * ) listGET_HEAD_ENTRY( &xBoundTCPSocketsList );
 800c836:	697b      	ldr	r3, [r7, #20]
 800c838:	4a05      	ldr	r2, [pc, #20]	; (800c850 <xTCPCheckNewClient+0x84>)
 800c83a:	4293      	cmp	r3, r2
 800c83c:	d1dd      	bne.n	800c7fa <xTCPCheckNewClient+0x2e>
				xResult = pdTRUE;
				break;
			}
		}
	}
	return xResult;
 800c83e:	693b      	ldr	r3, [r7, #16]
}
 800c840:	4618      	mov	r0, r3
 800c842:	371c      	adds	r7, #28
 800c844:	46bd      	mov	sp, r7
 800c846:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c84a:	4770      	bx	lr
 800c84c:	2000cf10 	.word	0x2000cf10
 800c850:	2000cf18 	.word	0x2000cf18

0800c854 <FreeRTOS_min_int32>:
	static portINLINE UBaseType_t  	FreeRTOS_min_UBaseType (UBaseType_t  a, UBaseType_t  b);


	static portINLINE int32_t  FreeRTOS_max_int32  (int32_t  a, int32_t  b) { return a >= b ? a : b; }
	static portINLINE uint32_t FreeRTOS_max_uint32 (uint32_t a, uint32_t b) { return a >= b ? a : b; }
	static portINLINE int32_t  FreeRTOS_min_int32  (int32_t  a, int32_t  b) { return a <= b ? a : b; }
 800c854:	b480      	push	{r7}
 800c856:	b083      	sub	sp, #12
 800c858:	af00      	add	r7, sp, #0
 800c85a:	6078      	str	r0, [r7, #4]
 800c85c:	6039      	str	r1, [r7, #0]
 800c85e:	687a      	ldr	r2, [r7, #4]
 800c860:	683b      	ldr	r3, [r7, #0]
 800c862:	4293      	cmp	r3, r2
 800c864:	bfa8      	it	ge
 800c866:	4613      	movge	r3, r2
 800c868:	4618      	mov	r0, r3
 800c86a:	370c      	adds	r7, #12
 800c86c:	46bd      	mov	sp, r7
 800c86e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c872:	4770      	bx	lr

0800c874 <FreeRTOS_min_uint32>:
	static portINLINE uint32_t FreeRTOS_min_uint32 (uint32_t a, uint32_t b) { return a <= b ? a : b; }
 800c874:	b480      	push	{r7}
 800c876:	b083      	sub	sp, #12
 800c878:	af00      	add	r7, sp, #0
 800c87a:	6078      	str	r0, [r7, #4]
 800c87c:	6039      	str	r1, [r7, #0]
 800c87e:	687a      	ldr	r2, [r7, #4]
 800c880:	683b      	ldr	r3, [r7, #0]
 800c882:	4293      	cmp	r3, r2
 800c884:	bf28      	it	cs
 800c886:	4613      	movcs	r3, r2
 800c888:	4618      	mov	r0, r3
 800c88a:	370c      	adds	r7, #12
 800c88c:	46bd      	mov	sp, r7
 800c88e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c892:	4770      	bx	lr

0800c894 <xSequenceLessThanOrEqual>:

#if( ipconfigUSE_TCP_WIN == 1 )
	/* Some 32-bit arithmetic: comparing sequence numbers */
	static portINLINE BaseType_t xSequenceLessThanOrEqual( uint32_t a, uint32_t b );
	static portINLINE BaseType_t xSequenceLessThanOrEqual( uint32_t a, uint32_t b )
	{
 800c894:	b480      	push	{r7}
 800c896:	b083      	sub	sp, #12
 800c898:	af00      	add	r7, sp, #0
 800c89a:	6078      	str	r0, [r7, #4]
 800c89c:	6039      	str	r1, [r7, #0]
		/* Test if a <= b
		Return true if the unsigned subtraction of (b-a) doesn't generate an
		arithmetic overflow. */
		return ( ( b - a ) & 0x80000000UL ) == 0UL;
 800c89e:	683a      	ldr	r2, [r7, #0]
 800c8a0:	687b      	ldr	r3, [r7, #4]
 800c8a2:	1ad3      	subs	r3, r2, r3
 800c8a4:	43db      	mvns	r3, r3
 800c8a6:	0fdb      	lsrs	r3, r3, #31
 800c8a8:	b2db      	uxtb	r3, r3
	}
 800c8aa:	4618      	mov	r0, r3
 800c8ac:	370c      	adds	r7, #12
 800c8ae:	46bd      	mov	sp, r7
 800c8b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c8b4:	4770      	bx	lr
 800c8b6:	bf00      	nop

0800c8b8 <xSequenceLessThan>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE BaseType_t xSequenceLessThan( uint32_t a, uint32_t b );
	static portINLINE BaseType_t xSequenceLessThan( uint32_t a, uint32_t b )
	{
 800c8b8:	b480      	push	{r7}
 800c8ba:	b083      	sub	sp, #12
 800c8bc:	af00      	add	r7, sp, #0
 800c8be:	6078      	str	r0, [r7, #4]
 800c8c0:	6039      	str	r1, [r7, #0]
		/* Test if a < b */
		return ( ( b - a - 1UL ) & 0x80000000UL ) == 0UL;
 800c8c2:	683a      	ldr	r2, [r7, #0]
 800c8c4:	687b      	ldr	r3, [r7, #4]
 800c8c6:	1ad3      	subs	r3, r2, r3
 800c8c8:	3b01      	subs	r3, #1
 800c8ca:	43db      	mvns	r3, r3
 800c8cc:	0fdb      	lsrs	r3, r3, #31
 800c8ce:	b2db      	uxtb	r3, r3
	}
 800c8d0:	4618      	mov	r0, r3
 800c8d2:	370c      	adds	r7, #12
 800c8d4:	46bd      	mov	sp, r7
 800c8d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c8da:	4770      	bx	lr

0800c8dc <xSequenceGreaterThan>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE BaseType_t xSequenceGreaterThan( uint32_t a, uint32_t b );
	static portINLINE BaseType_t xSequenceGreaterThan( uint32_t a, uint32_t b )
	{
 800c8dc:	b480      	push	{r7}
 800c8de:	b083      	sub	sp, #12
 800c8e0:	af00      	add	r7, sp, #0
 800c8e2:	6078      	str	r0, [r7, #4]
 800c8e4:	6039      	str	r1, [r7, #0]
		/* Test if a > b */
		return ( ( a - b - 1UL ) & 0x80000000UL ) == 0UL;
 800c8e6:	687a      	ldr	r2, [r7, #4]
 800c8e8:	683b      	ldr	r3, [r7, #0]
 800c8ea:	1ad3      	subs	r3, r2, r3
 800c8ec:	3b01      	subs	r3, #1
 800c8ee:	43db      	mvns	r3, r3
 800c8f0:	0fdb      	lsrs	r3, r3, #31
 800c8f2:	b2db      	uxtb	r3, r3
	}
 800c8f4:	4618      	mov	r0, r3
 800c8f6:	370c      	adds	r7, #12
 800c8f8:	46bd      	mov	sp, r7
 800c8fa:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c8fe:	4770      	bx	lr

0800c900 <xSequenceGreaterThanOrEqual>:
#endif /* ipconfigUSE_TCP_WIN */

/*-----------------------------------------------------------*/
static portINLINE BaseType_t xSequenceGreaterThanOrEqual( uint32_t a, uint32_t b );
static portINLINE BaseType_t xSequenceGreaterThanOrEqual( uint32_t a, uint32_t b )
{
 800c900:	b480      	push	{r7}
 800c902:	b083      	sub	sp, #12
 800c904:	af00      	add	r7, sp, #0
 800c906:	6078      	str	r0, [r7, #4]
 800c908:	6039      	str	r1, [r7, #0]
	/* Test if a >= b */
	return ( ( a - b ) & 0x80000000UL ) == 0UL;
 800c90a:	687a      	ldr	r2, [r7, #4]
 800c90c:	683b      	ldr	r3, [r7, #0]
 800c90e:	1ad3      	subs	r3, r2, r3
 800c910:	43db      	mvns	r3, r3
 800c912:	0fdb      	lsrs	r3, r3, #31
 800c914:	b2db      	uxtb	r3, r3
}
 800c916:	4618      	mov	r0, r3
 800c918:	370c      	adds	r7, #12
 800c91a:	46bd      	mov	sp, r7
 800c91c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c920:	4770      	bx	lr
 800c922:	bf00      	nop

0800c924 <vListInsertFifo>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem );
	static portINLINE void vListInsertFifo( List_t * const pxList, ListItem_t * const pxNewListItem )
	{
 800c924:	b580      	push	{r7, lr}
 800c926:	b082      	sub	sp, #8
 800c928:	af00      	add	r7, sp, #0
 800c92a:	6078      	str	r0, [r7, #4]
 800c92c:	6039      	str	r1, [r7, #0]
		vListInsertGeneric( pxList, pxNewListItem, &pxList->xListEnd );
 800c92e:	687b      	ldr	r3, [r7, #4]
 800c930:	3308      	adds	r3, #8
 800c932:	6878      	ldr	r0, [r7, #4]
 800c934:	6839      	ldr	r1, [r7, #0]
 800c936:	461a      	mov	r2, r3
 800c938:	f000 f81e 	bl	800c978 <vListInsertGeneric>
	}
 800c93c:	3708      	adds	r7, #8
 800c93e:	46bd      	mov	sp, r7
 800c940:	bd80      	pop	{r7, pc}
 800c942:	bf00      	nop

0800c944 <vTCPTimerSet>:
#endif
/*-----------------------------------------------------------*/

static portINLINE void vTCPTimerSet( TCPTimer_t *pxTimer );
static portINLINE void vTCPTimerSet( TCPTimer_t *pxTimer )
{
 800c944:	b580      	push	{r7, lr}
 800c946:	b082      	sub	sp, #8
 800c948:	af00      	add	r7, sp, #0
 800c94a:	6078      	str	r0, [r7, #4]
	pxTimer->ulBorn = xTaskGetTickCount ( );
 800c94c:	f7f8 fe1a 	bl	8005584 <xTaskGetTickCount>
 800c950:	4602      	mov	r2, r0
 800c952:	687b      	ldr	r3, [r7, #4]
 800c954:	601a      	str	r2, [r3, #0]
}
 800c956:	3708      	adds	r7, #8
 800c958:	46bd      	mov	sp, r7
 800c95a:	bd80      	pop	{r7, pc}

0800c95c <ulTimerGetAge>:
/*-----------------------------------------------------------*/

static portINLINE uint32_t ulTimerGetAge( TCPTimer_t *pxTimer );
static portINLINE uint32_t ulTimerGetAge( TCPTimer_t *pxTimer )
{
 800c95c:	b580      	push	{r7, lr}
 800c95e:	b082      	sub	sp, #8
 800c960:	af00      	add	r7, sp, #0
 800c962:	6078      	str	r0, [r7, #4]
	return ( ( xTaskGetTickCount() - pxTimer->ulBorn ) * portTICK_PERIOD_MS );
 800c964:	f7f8 fe0e 	bl	8005584 <xTaskGetTickCount>
 800c968:	4602      	mov	r2, r0
 800c96a:	687b      	ldr	r3, [r7, #4]
 800c96c:	681b      	ldr	r3, [r3, #0]
 800c96e:	1ad3      	subs	r3, r2, r3
}
 800c970:	4618      	mov	r0, r3
 800c972:	3708      	adds	r7, #8
 800c974:	46bd      	mov	sp, r7
 800c976:	bd80      	pop	{r7, pc}

0800c978 <vListInsertGeneric>:
preceded by a prototype. Later this prototype will be located in list.h? */

extern void vListInsertGeneric( List_t * const pxList, ListItem_t * const pxNewListItem, MiniListItem_t * const pxWhere );

void vListInsertGeneric( List_t * const pxList, ListItem_t * const pxNewListItem, MiniListItem_t * const pxWhere )
{
 800c978:	b480      	push	{r7}
 800c97a:	b085      	sub	sp, #20
 800c97c:	af00      	add	r7, sp, #0
 800c97e:	60f8      	str	r0, [r7, #12]
 800c980:	60b9      	str	r1, [r7, #8]
 800c982:	607a      	str	r2, [r7, #4]
	/* Insert a new list item into pxList, it does not sort the list,
	but it puts the item just before xListEnd, so it will be the last item
	returned by listGET_HEAD_ENTRY() */
	pxNewListItem->pxNext = (struct xLIST_ITEM * configLIST_VOLATILE)pxWhere;
 800c984:	68bb      	ldr	r3, [r7, #8]
 800c986:	687a      	ldr	r2, [r7, #4]
 800c988:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxWhere->pxPrevious;
 800c98a:	687b      	ldr	r3, [r7, #4]
 800c98c:	689a      	ldr	r2, [r3, #8]
 800c98e:	68bb      	ldr	r3, [r7, #8]
 800c990:	609a      	str	r2, [r3, #8]
	pxWhere->pxPrevious->pxNext = pxNewListItem;
 800c992:	687b      	ldr	r3, [r7, #4]
 800c994:	689b      	ldr	r3, [r3, #8]
 800c996:	68ba      	ldr	r2, [r7, #8]
 800c998:	605a      	str	r2, [r3, #4]
	pxWhere->pxPrevious = pxNewListItem;
 800c99a:	687b      	ldr	r3, [r7, #4]
 800c99c:	68ba      	ldr	r2, [r7, #8]
 800c99e:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800c9a0:	68bb      	ldr	r3, [r7, #8]
 800c9a2:	68fa      	ldr	r2, [r7, #12]
 800c9a4:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 800c9a6:	68fb      	ldr	r3, [r7, #12]
 800c9a8:	681b      	ldr	r3, [r3, #0]
 800c9aa:	1c5a      	adds	r2, r3, #1
 800c9ac:	68fb      	ldr	r3, [r7, #12]
 800c9ae:	601a      	str	r2, [r3, #0]
}
 800c9b0:	3714      	adds	r7, #20
 800c9b2:	46bd      	mov	sp, r7
 800c9b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800c9b8:	4770      	bx	lr
 800c9ba:	bf00      	nop

0800c9bc <prvCreateSectors>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static BaseType_t prvCreateSectors( void )
	{
 800c9bc:	b580      	push	{r7, lr}
 800c9be:	b082      	sub	sp, #8
 800c9c0:	af00      	add	r7, sp, #0
	BaseType_t xIndex, xReturn;

		/* Allocate space for 'xTCPSegments' and store them in 'xSegmentList'. */

		vListInitialise( &xSegmentList );
 800c9c2:	4824      	ldr	r0, [pc, #144]	; (800ca54 <prvCreateSectors+0x98>)
 800c9c4:	f7f7 f8b2 	bl	8003b2c <vListInitialise>
		xTCPSegments = ( TCPSegment_t * ) pvPortMallocLarge( ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) );
 800c9c8:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800c9cc:	f7f7 fb70 	bl	80040b0 <pvPortMalloc>
 800c9d0:	4602      	mov	r2, r0
 800c9d2:	4b21      	ldr	r3, [pc, #132]	; (800ca58 <prvCreateSectors+0x9c>)
 800c9d4:	601a      	str	r2, [r3, #0]

		if( xTCPSegments == NULL )
 800c9d6:	4b20      	ldr	r3, [pc, #128]	; (800ca58 <prvCreateSectors+0x9c>)
 800c9d8:	681b      	ldr	r3, [r3, #0]
 800c9da:	2b00      	cmp	r3, #0
 800c9dc:	d102      	bne.n	800c9e4 <prvCreateSectors+0x28>
		{
			FreeRTOS_debug_printf( ( "prvCreateSectors: malloc %lu failed\n",
				ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) ) );

			xReturn = pdFAIL;
 800c9de:	2300      	movs	r3, #0
 800c9e0:	603b      	str	r3, [r7, #0]
 800c9e2:	e032      	b.n	800ca4a <prvCreateSectors+0x8e>
		}
		else
		{
			/* Clear the allocated space. */
			memset( xTCPSegments, '\0', ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) );
 800c9e4:	4b1c      	ldr	r3, [pc, #112]	; (800ca58 <prvCreateSectors+0x9c>)
 800c9e6:	681b      	ldr	r3, [r3, #0]
 800c9e8:	4618      	mov	r0, r3
 800c9ea:	2100      	movs	r1, #0
 800c9ec:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800c9f0:	f003 fc5a 	bl	80102a8 <memset>

			for( xIndex = 0; xIndex < ipconfigTCP_WIN_SEG_COUNT; xIndex++ )
 800c9f4:	2300      	movs	r3, #0
 800c9f6:	607b      	str	r3, [r7, #4]
 800c9f8:	e022      	b.n	800ca40 <prvCreateSectors+0x84>
			{
				/* Could call vListInitialiseItem here but all data has been
				nulled already.  Set the owner to a segment descriptor. */
				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xListItem ), ( void* ) &( xTCPSegments[ xIndex ] ) );
 800c9fa:	4b17      	ldr	r3, [pc, #92]	; (800ca58 <prvCreateSectors+0x9c>)
 800c9fc:	681a      	ldr	r2, [r3, #0]
 800c9fe:	687b      	ldr	r3, [r7, #4]
 800ca00:	019b      	lsls	r3, r3, #6
 800ca02:	4413      	add	r3, r2
 800ca04:	4a14      	ldr	r2, [pc, #80]	; (800ca58 <prvCreateSectors+0x9c>)
 800ca06:	6811      	ldr	r1, [r2, #0]
 800ca08:	687a      	ldr	r2, [r7, #4]
 800ca0a:	0192      	lsls	r2, r2, #6
 800ca0c:	440a      	add	r2, r1
 800ca0e:	639a      	str	r2, [r3, #56]	; 0x38
				listSET_LIST_ITEM_OWNER( &( xTCPSegments[ xIndex ].xQueueItem ), ( void* ) &( xTCPSegments[ xIndex ] ) );
 800ca10:	4b11      	ldr	r3, [pc, #68]	; (800ca58 <prvCreateSectors+0x9c>)
 800ca12:	681a      	ldr	r2, [r3, #0]
 800ca14:	687b      	ldr	r3, [r7, #4]
 800ca16:	019b      	lsls	r3, r3, #6
 800ca18:	4413      	add	r3, r2
 800ca1a:	4a0f      	ldr	r2, [pc, #60]	; (800ca58 <prvCreateSectors+0x9c>)
 800ca1c:	6811      	ldr	r1, [r2, #0]
 800ca1e:	687a      	ldr	r2, [r7, #4]
 800ca20:	0192      	lsls	r2, r2, #6
 800ca22:	440a      	add	r2, r1
 800ca24:	625a      	str	r2, [r3, #36]	; 0x24

				/* And add it to the pool of available segments */
				vListInsertFifo( &xSegmentList, &( xTCPSegments[xIndex].xListItem ) );
 800ca26:	4b0c      	ldr	r3, [pc, #48]	; (800ca58 <prvCreateSectors+0x9c>)
 800ca28:	681a      	ldr	r2, [r3, #0]
 800ca2a:	687b      	ldr	r3, [r7, #4]
 800ca2c:	019b      	lsls	r3, r3, #6
 800ca2e:	4413      	add	r3, r2
 800ca30:	332c      	adds	r3, #44	; 0x2c
 800ca32:	4808      	ldr	r0, [pc, #32]	; (800ca54 <prvCreateSectors+0x98>)
 800ca34:	4619      	mov	r1, r3
 800ca36:	f7ff ff75 	bl	800c924 <vListInsertFifo>
		else
		{
			/* Clear the allocated space. */
			memset( xTCPSegments, '\0', ipconfigTCP_WIN_SEG_COUNT * sizeof( xTCPSegments[ 0 ] ) );

			for( xIndex = 0; xIndex < ipconfigTCP_WIN_SEG_COUNT; xIndex++ )
 800ca3a:	687b      	ldr	r3, [r7, #4]
 800ca3c:	3301      	adds	r3, #1
 800ca3e:	607b      	str	r3, [r7, #4]
 800ca40:	687b      	ldr	r3, [r7, #4]
 800ca42:	2b3f      	cmp	r3, #63	; 0x3f
 800ca44:	ddd9      	ble.n	800c9fa <prvCreateSectors+0x3e>

				/* And add it to the pool of available segments */
				vListInsertFifo( &xSegmentList, &( xTCPSegments[xIndex].xListItem ) );
			}

			xReturn = pdPASS;
 800ca46:	2301      	movs	r3, #1
 800ca48:	603b      	str	r3, [r7, #0]
		}

		return xReturn;
 800ca4a:	683b      	ldr	r3, [r7, #0]
	}
 800ca4c:	4618      	mov	r0, r3
 800ca4e:	3708      	adds	r7, #8
 800ca50:	46bd      	mov	sp, r7
 800ca52:	bd80      	pop	{r7, pc}
 800ca54:	2000c2a0 	.word	0x2000c2a0
 800ca58:	2000c29c 	.word	0x2000c29c

0800ca5c <xTCPWindowRxFind>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowRxFind( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
	{
 800ca5c:	b480      	push	{r7}
 800ca5e:	b087      	sub	sp, #28
 800ca60:	af00      	add	r7, sp, #0
 800ca62:	6078      	str	r0, [r7, #4]
 800ca64:	6039      	str	r1, [r7, #0]
	const ListItem_t *pxIterator;
	const MiniListItem_t* pxEnd;
	TCPSegment_t *pxSegment, *pxReturn = NULL;
 800ca66:	2300      	movs	r3, #0
 800ca68:	613b      	str	r3, [r7, #16]

		/* Find a segment with a given sequence number in the list of received
		segments. */

		pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &pxWindow->xRxSegments );
 800ca6a:	687b      	ldr	r3, [r7, #4]
 800ca6c:	33ac      	adds	r3, #172	; 0xac
 800ca6e:	60fb      	str	r3, [r7, #12]

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 800ca70:	68fb      	ldr	r3, [r7, #12]
 800ca72:	685b      	ldr	r3, [r3, #4]
 800ca74:	617b      	str	r3, [r7, #20]
 800ca76:	e00d      	b.n	800ca94 <xTCPWindowRxFind+0x38>
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800ca78:	697b      	ldr	r3, [r7, #20]
 800ca7a:	68db      	ldr	r3, [r3, #12]
 800ca7c:	60bb      	str	r3, [r7, #8]

			if( pxSegment->ulSequenceNumber == ulSequenceNumber )
 800ca7e:	68bb      	ldr	r3, [r7, #8]
 800ca80:	681a      	ldr	r2, [r3, #0]
 800ca82:	683b      	ldr	r3, [r7, #0]
 800ca84:	429a      	cmp	r2, r3
 800ca86:	d102      	bne.n	800ca8e <xTCPWindowRxFind+0x32>
			{
				pxReturn = pxSegment;
 800ca88:	68bb      	ldr	r3, [r7, #8]
 800ca8a:	613b      	str	r3, [r7, #16]
				break;
 800ca8c:	e006      	b.n	800ca9c <xTCPWindowRxFind+0x40>

		pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &pxWindow->xRxSegments );

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 800ca8e:	697b      	ldr	r3, [r7, #20]
 800ca90:	685b      	ldr	r3, [r3, #4]
 800ca92:	617b      	str	r3, [r7, #20]
		/* Find a segment with a given sequence number in the list of received
		segments. */

		pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &pxWindow->xRxSegments );

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 800ca94:	697a      	ldr	r2, [r7, #20]
 800ca96:	68fb      	ldr	r3, [r7, #12]
 800ca98:	429a      	cmp	r2, r3
 800ca9a:	d1ed      	bne.n	800ca78 <xTCPWindowRxFind+0x1c>
				pxReturn = pxSegment;
				break;
			}
		}

		return pxReturn;
 800ca9c:	693b      	ldr	r3, [r7, #16]
	}
 800ca9e:	4618      	mov	r0, r3
 800caa0:	371c      	adds	r7, #28
 800caa2:	46bd      	mov	sp, r7
 800caa4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800caa8:	4770      	bx	lr
 800caaa:	bf00      	nop

0800caac <xTCPWindowNew>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowNew( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, int32_t lCount, BaseType_t xIsForRx )
	{
 800caac:	b580      	push	{r7, lr}
 800caae:	b088      	sub	sp, #32
 800cab0:	af00      	add	r7, sp, #0
 800cab2:	60f8      	str	r0, [r7, #12]
 800cab4:	60b9      	str	r1, [r7, #8]
 800cab6:	607a      	str	r2, [r7, #4]
 800cab8:	603b      	str	r3, [r7, #0]
	TCPSegment_t *pxSegment;
	ListItem_t * pxItem;

		/* Allocate a new segment.  The socket will borrow all segments from a
		common pool: 'xSegmentList', which is a list of 'TCPSegment_t' */
		if( listLIST_IS_EMPTY( &xSegmentList ) != pdFALSE )
 800caba:	4b2e      	ldr	r3, [pc, #184]	; (800cb74 <xTCPWindowNew+0xc8>)
 800cabc:	681b      	ldr	r3, [r3, #0]
 800cabe:	2b00      	cmp	r3, #0
 800cac0:	d101      	bne.n	800cac6 <xTCPWindowNew+0x1a>
 800cac2:	2301      	movs	r3, #1
 800cac4:	e000      	b.n	800cac8 <xTCPWindowNew+0x1c>
 800cac6:	2300      	movs	r3, #0
 800cac8:	2b00      	cmp	r3, #0
 800caca:	d002      	beq.n	800cad2 <xTCPWindowNew+0x26>
		{
			/* If the TCP-stack runs out of segments, you might consider
			increasing 'ipconfigTCP_WIN_SEG_COUNT'. */
			FreeRTOS_debug_printf( ( "xTCPWindow%cxNew: Error: all segments occupied\n", xIsForRx ? 'R' : 'T' ) );
			pxSegment = NULL;
 800cacc:	2300      	movs	r3, #0
 800cace:	61fb      	str	r3, [r7, #28]
 800cad0:	e04a      	b.n	800cb68 <xTCPWindowNew+0xbc>
		}
		else
		{
			/* Pop the item at the head of the list.  Semaphore protection is
			not required as only the IP task will call these functions.  */
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( &xSegmentList );
 800cad2:	4b28      	ldr	r3, [pc, #160]	; (800cb74 <xTCPWindowNew+0xc8>)
 800cad4:	68db      	ldr	r3, [r3, #12]
 800cad6:	61bb      	str	r3, [r7, #24]
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem );
 800cad8:	69bb      	ldr	r3, [r7, #24]
 800cada:	68db      	ldr	r3, [r3, #12]
 800cadc:	61fb      	str	r3, [r7, #28]

			configASSERT( pxItem != NULL );
 800cade:	69bb      	ldr	r3, [r7, #24]
 800cae0:	2b00      	cmp	r3, #0
 800cae2:	d109      	bne.n	800caf8 <xTCPWindowNew+0x4c>
 800cae4:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cae8:	f383 8811 	msr	BASEPRI, r3
 800caec:	f3bf 8f6f 	isb	sy
 800caf0:	f3bf 8f4f 	dsb	sy
 800caf4:	617b      	str	r3, [r7, #20]
 800caf6:	e7fe      	b.n	800caf6 <xTCPWindowNew+0x4a>
			configASSERT( pxSegment != NULL );
 800caf8:	69fb      	ldr	r3, [r7, #28]
 800cafa:	2b00      	cmp	r3, #0
 800cafc:	d109      	bne.n	800cb12 <xTCPWindowNew+0x66>
 800cafe:	f04f 0350 	mov.w	r3, #80	; 0x50
 800cb02:	f383 8811 	msr	BASEPRI, r3
 800cb06:	f3bf 8f6f 	isb	sy
 800cb0a:	f3bf 8f4f 	dsb	sy
 800cb0e:	613b      	str	r3, [r7, #16]
 800cb10:	e7fe      	b.n	800cb10 <xTCPWindowNew+0x64>

			/* Remove the item from xSegmentList. */
			uxListRemove( pxItem );
 800cb12:	69b8      	ldr	r0, [r7, #24]
 800cb14:	f7f7 f892 	bl	8003c3c <uxListRemove>

			/* Add it to either the connections' Rx or Tx queue. */
			vListInsertFifo( xIsForRx ? &pxWindow->xRxSegments : &pxWindow->xTxSegments, pxItem );
 800cb18:	683b      	ldr	r3, [r7, #0]
 800cb1a:	2b00      	cmp	r3, #0
 800cb1c:	d002      	beq.n	800cb24 <xTCPWindowNew+0x78>
 800cb1e:	68fb      	ldr	r3, [r7, #12]
 800cb20:	33a4      	adds	r3, #164	; 0xa4
 800cb22:	e001      	b.n	800cb28 <xTCPWindowNew+0x7c>
 800cb24:	68fb      	ldr	r3, [r7, #12]
 800cb26:	3390      	adds	r3, #144	; 0x90
 800cb28:	4618      	mov	r0, r3
 800cb2a:	69b9      	ldr	r1, [r7, #24]
 800cb2c:	f7ff fefa 	bl	800c924 <vListInsertFifo>

			/* And set the segment's timer to zero */
			vTCPTimerSet( &pxSegment->xTransmitTimer );
 800cb30:	69fb      	ldr	r3, [r7, #28]
 800cb32:	3310      	adds	r3, #16
 800cb34:	4618      	mov	r0, r3
 800cb36:	f7ff ff05 	bl	800c944 <vTCPTimerSet>

			pxSegment->u.ulFlags = 0;
 800cb3a:	69fb      	ldr	r3, [r7, #28]
 800cb3c:	2200      	movs	r2, #0
 800cb3e:	615a      	str	r2, [r3, #20]
			pxSegment->u.bits.bIsForRx = ( xIsForRx != 0 );
 800cb40:	683b      	ldr	r3, [r7, #0]
 800cb42:	2b00      	cmp	r3, #0
 800cb44:	bf14      	ite	ne
 800cb46:	2301      	movne	r3, #1
 800cb48:	2300      	moveq	r3, #0
 800cb4a:	b2d9      	uxtb	r1, r3
 800cb4c:	69fa      	ldr	r2, [r7, #28]
 800cb4e:	7d93      	ldrb	r3, [r2, #22]
 800cb50:	f361 0382 	bfi	r3, r1, #2, #1
 800cb54:	7593      	strb	r3, [r2, #22]
			pxSegment->lMaxLength = lCount;
 800cb56:	69fb      	ldr	r3, [r7, #28]
 800cb58:	687a      	ldr	r2, [r7, #4]
 800cb5a:	605a      	str	r2, [r3, #4]
			pxSegment->lDataLength = lCount;
 800cb5c:	69fb      	ldr	r3, [r7, #28]
 800cb5e:	687a      	ldr	r2, [r7, #4]
 800cb60:	609a      	str	r2, [r3, #8]
			pxSegment->ulSequenceNumber = ulSequenceNumber;
 800cb62:	69fb      	ldr	r3, [r7, #28]
 800cb64:	68ba      	ldr	r2, [r7, #8]
 800cb66:	601a      	str	r2, [r3, #0]
				}
			}
			#endif /* ipconfigHAS_DEBUG_PRINTF */
		}

		return pxSegment;
 800cb68:	69fb      	ldr	r3, [r7, #28]
	}
 800cb6a:	4618      	mov	r0, r3
 800cb6c:	3720      	adds	r7, #32
 800cb6e:	46bd      	mov	sp, r7
 800cb70:	bd80      	pop	{r7, pc}
 800cb72:	bf00      	nop
 800cb74:	2000c2a0 	.word	0x2000c2a0

0800cb78 <xTCPWindowRxEmpty>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	BaseType_t xTCPWindowRxEmpty( TCPWindow_t *pxWindow )
	{
 800cb78:	b580      	push	{r7, lr}
 800cb7a:	b084      	sub	sp, #16
 800cb7c:	af00      	add	r7, sp, #0
 800cb7e:	6078      	str	r0, [r7, #4]
		/* When the peer has a close request (FIN flag), the driver will check
		if there are missing packets in the Rx-queue.  It will accept the
		closure of the connection if both conditions are true:
		  - the Rx-queue is empty
		  - the highest Rx sequence number has been ACK'ed */
		if( listLIST_IS_EMPTY( ( &pxWindow->xRxSegments ) ) == pdFALSE )
 800cb80:	687b      	ldr	r3, [r7, #4]
 800cb82:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800cb86:	2b00      	cmp	r3, #0
 800cb88:	d002      	beq.n	800cb90 <xTCPWindowRxEmpty+0x18>
		{
			/* Rx data has been stored while earlier packets were missing. */
			xReturn = pdFALSE;
 800cb8a:	2300      	movs	r3, #0
 800cb8c:	60fb      	str	r3, [r7, #12]
 800cb8e:	e00f      	b.n	800cbb0 <xTCPWindowRxEmpty+0x38>
		}
		else if( xSequenceGreaterThanOrEqual( pxWindow->rx.ulCurrentSequenceNumber, pxWindow->rx.ulHighestSequenceNumber ) != pdFALSE )
 800cb90:	687b      	ldr	r3, [r7, #4]
 800cb92:	691a      	ldr	r2, [r3, #16]
 800cb94:	687b      	ldr	r3, [r7, #4]
 800cb96:	699b      	ldr	r3, [r3, #24]
 800cb98:	4610      	mov	r0, r2
 800cb9a:	4619      	mov	r1, r3
 800cb9c:	f7ff feb0 	bl	800c900 <xSequenceGreaterThanOrEqual>
 800cba0:	4603      	mov	r3, r0
 800cba2:	2b00      	cmp	r3, #0
 800cba4:	d002      	beq.n	800cbac <xTCPWindowRxEmpty+0x34>
		{
			/* No Rx packets are being stored and the highest sequence number
			that has been received has been ACKed. */
			xReturn = pdTRUE;
 800cba6:	2301      	movs	r3, #1
 800cba8:	60fb      	str	r3, [r7, #12]
 800cbaa:	e001      	b.n	800cbb0 <xTCPWindowRxEmpty+0x38>
		else
		{
			FreeRTOS_debug_printf( ( "xTCPWindowRxEmpty: cur %lu highest %lu (empty)\n",
				( pxWindow->rx.ulCurrentSequenceNumber - pxWindow->rx.ulFirstSequenceNumber ),
				( pxWindow->rx.ulHighestSequenceNumber - pxWindow->rx.ulFirstSequenceNumber ) ) );
			xReturn = pdFALSE;
 800cbac:	2300      	movs	r3, #0
 800cbae:	60fb      	str	r3, [r7, #12]
		}

		return xReturn;
 800cbb0:	68fb      	ldr	r3, [r7, #12]
	}
 800cbb2:	4618      	mov	r0, r3
 800cbb4:	3710      	adds	r7, #16
 800cbb6:	46bd      	mov	sp, r7
 800cbb8:	bd80      	pop	{r7, pc}
 800cbba:	bf00      	nop

0800cbbc <xTCPWindowGetHead>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowGetHead( List_t *pxList )
	{
 800cbbc:	b580      	push	{r7, lr}
 800cbbe:	b084      	sub	sp, #16
 800cbc0:	af00      	add	r7, sp, #0
 800cbc2:	6078      	str	r0, [r7, #4]
	TCPSegment_t *pxSegment;
	ListItem_t * pxItem;

		/* Detaches and returns the head of a queue. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 800cbc4:	687b      	ldr	r3, [r7, #4]
 800cbc6:	681b      	ldr	r3, [r3, #0]
 800cbc8:	2b00      	cmp	r3, #0
 800cbca:	d101      	bne.n	800cbd0 <xTCPWindowGetHead+0x14>
 800cbcc:	2301      	movs	r3, #1
 800cbce:	e000      	b.n	800cbd2 <xTCPWindowGetHead+0x16>
 800cbd0:	2300      	movs	r3, #0
 800cbd2:	2b00      	cmp	r3, #0
 800cbd4:	d002      	beq.n	800cbdc <xTCPWindowGetHead+0x20>
		{
			pxSegment = NULL;
 800cbd6:	2300      	movs	r3, #0
 800cbd8:	60fb      	str	r3, [r7, #12]
 800cbda:	e008      	b.n	800cbee <xTCPWindowGetHead+0x32>
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
 800cbdc:	687b      	ldr	r3, [r7, #4]
 800cbde:	68db      	ldr	r3, [r3, #12]
 800cbe0:	60bb      	str	r3, [r7, #8]
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem );
 800cbe2:	68bb      	ldr	r3, [r7, #8]
 800cbe4:	68db      	ldr	r3, [r3, #12]
 800cbe6:	60fb      	str	r3, [r7, #12]

			uxListRemove( pxItem );
 800cbe8:	68b8      	ldr	r0, [r7, #8]
 800cbea:	f7f7 f827 	bl	8003c3c <uxListRemove>
		}

		return pxSegment;
 800cbee:	68fb      	ldr	r3, [r7, #12]
	}
 800cbf0:	4618      	mov	r0, r3
 800cbf2:	3710      	adds	r7, #16
 800cbf4:	46bd      	mov	sp, r7
 800cbf6:	bd80      	pop	{r7, pc}

0800cbf8 <xTCPWindowPeekHead>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowPeekHead( List_t *pxList )
	{
 800cbf8:	b480      	push	{r7}
 800cbfa:	b085      	sub	sp, #20
 800cbfc:	af00      	add	r7, sp, #0
 800cbfe:	6078      	str	r0, [r7, #4]
	ListItem_t *pxItem;
	TCPSegment_t *pxReturn;

		/* Returns the head of a queue but it won't be detached. */
		if( listLIST_IS_EMPTY( pxList ) != pdFALSE )
 800cc00:	687b      	ldr	r3, [r7, #4]
 800cc02:	681b      	ldr	r3, [r3, #0]
 800cc04:	2b00      	cmp	r3, #0
 800cc06:	d101      	bne.n	800cc0c <xTCPWindowPeekHead+0x14>
 800cc08:	2301      	movs	r3, #1
 800cc0a:	e000      	b.n	800cc0e <xTCPWindowPeekHead+0x16>
 800cc0c:	2300      	movs	r3, #0
 800cc0e:	2b00      	cmp	r3, #0
 800cc10:	d002      	beq.n	800cc18 <xTCPWindowPeekHead+0x20>
		{
			pxReturn = NULL;
 800cc12:	2300      	movs	r3, #0
 800cc14:	60fb      	str	r3, [r7, #12]
 800cc16:	e005      	b.n	800cc24 <xTCPWindowPeekHead+0x2c>
		}
		else
		{
			pxItem = ( ListItem_t * ) listGET_HEAD_ENTRY( pxList );
 800cc18:	687b      	ldr	r3, [r7, #4]
 800cc1a:	68db      	ldr	r3, [r3, #12]
 800cc1c:	60bb      	str	r3, [r7, #8]
			pxReturn = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxItem );
 800cc1e:	68bb      	ldr	r3, [r7, #8]
 800cc20:	68db      	ldr	r3, [r3, #12]
 800cc22:	60fb      	str	r3, [r7, #12]
		}

		return pxReturn;
 800cc24:	68fb      	ldr	r3, [r7, #12]
	}
 800cc26:	4618      	mov	r0, r3
 800cc28:	3714      	adds	r7, #20
 800cc2a:	46bd      	mov	sp, r7
 800cc2c:	f85d 7b04 	ldr.w	r7, [sp], #4
 800cc30:	4770      	bx	lr
 800cc32:	bf00      	nop

0800cc34 <vTCPWindowFree>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static void vTCPWindowFree( TCPSegment_t *pxSegment )
	{
 800cc34:	b580      	push	{r7, lr}
 800cc36:	b082      	sub	sp, #8
 800cc38:	af00      	add	r7, sp, #0
 800cc3a:	6078      	str	r0, [r7, #4]
		/*  Free entry pxSegment because it's not used any more.  The ownership
		will be passed back to the segment pool.

		Unlink it from one of the queues, if any. */
		if( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL )
 800cc3c:	687b      	ldr	r3, [r7, #4]
 800cc3e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800cc40:	2b00      	cmp	r3, #0
 800cc42:	d004      	beq.n	800cc4e <vTCPWindowFree+0x1a>
		{
			uxListRemove( &( pxSegment->xQueueItem ) );
 800cc44:	687b      	ldr	r3, [r7, #4]
 800cc46:	3318      	adds	r3, #24
 800cc48:	4618      	mov	r0, r3
 800cc4a:	f7f6 fff7 	bl	8003c3c <uxListRemove>
		}

		pxSegment->ulSequenceNumber = 0u;
 800cc4e:	687b      	ldr	r3, [r7, #4]
 800cc50:	2200      	movs	r2, #0
 800cc52:	601a      	str	r2, [r3, #0]
		pxSegment->lDataLength = 0l;
 800cc54:	687b      	ldr	r3, [r7, #4]
 800cc56:	2200      	movs	r2, #0
 800cc58:	609a      	str	r2, [r3, #8]
		pxSegment->u.ulFlags = 0u;
 800cc5a:	687b      	ldr	r3, [r7, #4]
 800cc5c:	2200      	movs	r2, #0
 800cc5e:	615a      	str	r2, [r3, #20]

		/* Take it out of xRxSegments/xTxSegments */
		if( listLIST_ITEM_CONTAINER( &( pxSegment->xListItem ) ) != NULL )
 800cc60:	687b      	ldr	r3, [r7, #4]
 800cc62:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800cc64:	2b00      	cmp	r3, #0
 800cc66:	d004      	beq.n	800cc72 <vTCPWindowFree+0x3e>
		{
			uxListRemove( &( pxSegment->xListItem ) );
 800cc68:	687b      	ldr	r3, [r7, #4]
 800cc6a:	332c      	adds	r3, #44	; 0x2c
 800cc6c:	4618      	mov	r0, r3
 800cc6e:	f7f6 ffe5 	bl	8003c3c <uxListRemove>
		}

		/* Return it to xSegmentList */
		vListInsertFifo( &xSegmentList, &( pxSegment->xListItem ) );
 800cc72:	687b      	ldr	r3, [r7, #4]
 800cc74:	332c      	adds	r3, #44	; 0x2c
 800cc76:	4803      	ldr	r0, [pc, #12]	; (800cc84 <vTCPWindowFree+0x50>)
 800cc78:	4619      	mov	r1, r3
 800cc7a:	f7ff fe53 	bl	800c924 <vListInsertFifo>
	}
 800cc7e:	3708      	adds	r7, #8
 800cc80:	46bd      	mov	sp, r7
 800cc82:	bd80      	pop	{r7, pc}
 800cc84:	2000c2a0 	.word	0x2000c2a0

0800cc88 <vTCPWindowDestroy>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	void vTCPWindowDestroy( TCPWindow_t *pxWindow )
	{
 800cc88:	b580      	push	{r7, lr}
 800cc8a:	b086      	sub	sp, #24
 800cc8c:	af00      	add	r7, sp, #0
 800cc8e:	6078      	str	r0, [r7, #4]

		/*  Destroy a window.  A TCP window doesn't serve any more.  Return all
		owned segments to the pool.  In order to save code, it will make 2 rounds,
		one to remove the segments from xRxSegments, and a second round to clear
		xTxSegments*/
		for( xRound = 0; xRound < 2; xRound++ )
 800cc90:	2300      	movs	r3, #0
 800cc92:	613b      	str	r3, [r7, #16]
 800cc94:	e022      	b.n	800ccdc <vTCPWindowDestroy+0x54>
		{
			if( xRound != 0 )
 800cc96:	693b      	ldr	r3, [r7, #16]
 800cc98:	2b00      	cmp	r3, #0
 800cc9a:	d003      	beq.n	800cca4 <vTCPWindowDestroy+0x1c>
			{
				pxSegments = &( pxWindow->xRxSegments );
 800cc9c:	687b      	ldr	r3, [r7, #4]
 800cc9e:	33a4      	adds	r3, #164	; 0xa4
 800cca0:	617b      	str	r3, [r7, #20]
 800cca2:	e002      	b.n	800ccaa <vTCPWindowDestroy+0x22>
			}
			else
			{
				pxSegments = &( pxWindow->xTxSegments );
 800cca4:	687b      	ldr	r3, [r7, #4]
 800cca6:	3390      	adds	r3, #144	; 0x90
 800cca8:	617b      	str	r3, [r7, #20]
			}

			if( listLIST_IS_INITIALISED( pxSegments ) != pdFALSE )
 800ccaa:	697b      	ldr	r3, [r7, #20]
 800ccac:	689b      	ldr	r3, [r3, #8]
 800ccae:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800ccb2:	d101      	bne.n	800ccb8 <vTCPWindowDestroy+0x30>
 800ccb4:	2301      	movs	r3, #1
 800ccb6:	e000      	b.n	800ccba <vTCPWindowDestroy+0x32>
 800ccb8:	2300      	movs	r3, #0
 800ccba:	2b00      	cmp	r3, #0
 800ccbc:	d00b      	beq.n	800ccd6 <vTCPWindowDestroy+0x4e>
			{
				while( listCURRENT_LIST_LENGTH( pxSegments ) > 0U )
 800ccbe:	e006      	b.n	800ccce <vTCPWindowDestroy+0x46>
				{
					pxSegment = ( TCPSegment_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxSegments );
 800ccc0:	697b      	ldr	r3, [r7, #20]
 800ccc2:	68db      	ldr	r3, [r3, #12]
 800ccc4:	68db      	ldr	r3, [r3, #12]
 800ccc6:	60fb      	str	r3, [r7, #12]
					vTCPWindowFree( pxSegment );
 800ccc8:	68f8      	ldr	r0, [r7, #12]
 800ccca:	f7ff ffb3 	bl	800cc34 <vTCPWindowFree>
				pxSegments = &( pxWindow->xTxSegments );
			}

			if( listLIST_IS_INITIALISED( pxSegments ) != pdFALSE )
			{
				while( listCURRENT_LIST_LENGTH( pxSegments ) > 0U )
 800ccce:	697b      	ldr	r3, [r7, #20]
 800ccd0:	681b      	ldr	r3, [r3, #0]
 800ccd2:	2b00      	cmp	r3, #0
 800ccd4:	d1f4      	bne.n	800ccc0 <vTCPWindowDestroy+0x38>

		/*  Destroy a window.  A TCP window doesn't serve any more.  Return all
		owned segments to the pool.  In order to save code, it will make 2 rounds,
		one to remove the segments from xRxSegments, and a second round to clear
		xTxSegments*/
		for( xRound = 0; xRound < 2; xRound++ )
 800ccd6:	693b      	ldr	r3, [r7, #16]
 800ccd8:	3301      	adds	r3, #1
 800ccda:	613b      	str	r3, [r7, #16]
 800ccdc:	693b      	ldr	r3, [r7, #16]
 800ccde:	2b01      	cmp	r3, #1
 800cce0:	ddd9      	ble.n	800cc96 <vTCPWindowDestroy+0xe>
					pxSegment = ( TCPSegment_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxSegments );
					vTCPWindowFree( pxSegment );
				}
			}
		}
	}
 800cce2:	3718      	adds	r7, #24
 800cce4:	46bd      	mov	sp, r7
 800cce6:	bd80      	pop	{r7, pc}

0800cce8 <vTCPWindowCreate>:
#endif /* ipconfigUSE_TCP_WIN == 1 */
/*-----------------------------------------------------------*/

void vTCPWindowCreate( TCPWindow_t *pxWindow, uint32_t ulRxWindowLength,
	uint32_t ulTxWindowLength, uint32_t ulAckNumber, uint32_t ulSequenceNumber, uint32_t ulMSS )
{
 800cce8:	b580      	push	{r7, lr}
 800ccea:	b084      	sub	sp, #16
 800ccec:	af00      	add	r7, sp, #0
 800ccee:	60f8      	str	r0, [r7, #12]
 800ccf0:	60b9      	str	r1, [r7, #8]
 800ccf2:	607a      	str	r2, [r7, #4]
 800ccf4:	603b      	str	r3, [r7, #0]
	/* Create and initialize a window. */

	#if( ipconfigUSE_TCP_WIN == 1 )
	{
		if( xTCPSegments == NULL )
 800ccf6:	4b17      	ldr	r3, [pc, #92]	; (800cd54 <vTCPWindowCreate+0x6c>)
 800ccf8:	681b      	ldr	r3, [r3, #0]
 800ccfa:	2b00      	cmp	r3, #0
 800ccfc:	d101      	bne.n	800cd02 <vTCPWindowCreate+0x1a>
		{
			prvCreateSectors();
 800ccfe:	f7ff fe5d 	bl	800c9bc <prvCreateSectors>
		}

		vListInitialise( &pxWindow->xTxSegments );
 800cd02:	68fb      	ldr	r3, [r7, #12]
 800cd04:	3390      	adds	r3, #144	; 0x90
 800cd06:	4618      	mov	r0, r3
 800cd08:	f7f6 ff10 	bl	8003b2c <vListInitialise>
		vListInitialise( &pxWindow->xRxSegments );
 800cd0c:	68fb      	ldr	r3, [r7, #12]
 800cd0e:	33a4      	adds	r3, #164	; 0xa4
 800cd10:	4618      	mov	r0, r3
 800cd12:	f7f6 ff0b 	bl	8003b2c <vListInitialise>

		vListInitialise( &pxWindow->xPriorityQueue );			/* Priority queue: segments which must be sent immediately */
 800cd16:	68fb      	ldr	r3, [r7, #12]
 800cd18:	3340      	adds	r3, #64	; 0x40
 800cd1a:	4618      	mov	r0, r3
 800cd1c:	f7f6 ff06 	bl	8003b2c <vListInitialise>
		vListInitialise( &pxWindow->xTxQueue   );			/* Transmit queue: segments queued for transmission */
 800cd20:	68fb      	ldr	r3, [r7, #12]
 800cd22:	3354      	adds	r3, #84	; 0x54
 800cd24:	4618      	mov	r0, r3
 800cd26:	f7f6 ff01 	bl	8003b2c <vListInitialise>
		vListInitialise( &pxWindow->xWaitQueue );			/* Waiting queue:  outstanding segments */
 800cd2a:	68fb      	ldr	r3, [r7, #12]
 800cd2c:	3368      	adds	r3, #104	; 0x68
 800cd2e:	4618      	mov	r0, r3
 800cd30:	f7f6 fefc 	bl	8003b2c <vListInitialise>
	{
		FreeRTOS_debug_printf( ( "vTCPWindowCreate: for WinLen = Rx/Tx: %lu/%lu\n",
			ulRxWindowLength, ulTxWindowLength ) );
	}

	pxWindow->xSize.ulRxWindowLength = ulRxWindowLength;
 800cd34:	68fb      	ldr	r3, [r7, #12]
 800cd36:	68ba      	ldr	r2, [r7, #8]
 800cd38:	605a      	str	r2, [r3, #4]
	pxWindow->xSize.ulTxWindowLength = ulTxWindowLength;
 800cd3a:	68fb      	ldr	r3, [r7, #12]
 800cd3c:	687a      	ldr	r2, [r7, #4]
 800cd3e:	609a      	str	r2, [r3, #8]

	vTCPWindowInit( pxWindow, ulAckNumber, ulSequenceNumber, ulMSS );
 800cd40:	68f8      	ldr	r0, [r7, #12]
 800cd42:	6839      	ldr	r1, [r7, #0]
 800cd44:	69ba      	ldr	r2, [r7, #24]
 800cd46:	69fb      	ldr	r3, [r7, #28]
 800cd48:	f000 f806 	bl	800cd58 <vTCPWindowInit>
}
 800cd4c:	3710      	adds	r7, #16
 800cd4e:	46bd      	mov	sp, r7
 800cd50:	bd80      	pop	{r7, pc}
 800cd52:	bf00      	nop
 800cd54:	2000c29c 	.word	0x2000c29c

0800cd58 <vTCPWindowInit>:
/*-----------------------------------------------------------*/

void vTCPWindowInit( TCPWindow_t *pxWindow, uint32_t ulAckNumber, uint32_t ulSequenceNumber, uint32_t ulMSS )
{
 800cd58:	b480      	push	{r7}
 800cd5a:	b087      	sub	sp, #28
 800cd5c:	af00      	add	r7, sp, #0
 800cd5e:	60f8      	str	r0, [r7, #12]
 800cd60:	60b9      	str	r1, [r7, #8]
 800cd62:	607a      	str	r2, [r7, #4]
 800cd64:	603b      	str	r3, [r7, #0]
const int32_t l500ms = 500;
 800cd66:	f44f 73fa 	mov.w	r3, #500	; 0x1f4
 800cd6a:	617b      	str	r3, [r7, #20]

	pxWindow->u.ulFlags = 0ul;
 800cd6c:	68fb      	ldr	r3, [r7, #12]
 800cd6e:	2200      	movs	r2, #0
 800cd70:	601a      	str	r2, [r3, #0]
	pxWindow->u.bits.bHasInit = pdTRUE_UNSIGNED;
 800cd72:	68fa      	ldr	r2, [r7, #12]
 800cd74:	7813      	ldrb	r3, [r2, #0]
 800cd76:	f043 0301 	orr.w	r3, r3, #1
 800cd7a:	7013      	strb	r3, [r2, #0]

	if( ulMSS != 0ul )
 800cd7c:	683b      	ldr	r3, [r7, #0]
 800cd7e:	2b00      	cmp	r3, #0
 800cd80:	d024      	beq.n	800cdcc <vTCPWindowInit+0x74>
	{
		if( pxWindow->usMSSInit != 0u )
 800cd82:	68fb      	ldr	r3, [r7, #12]
 800cd84:	f8b3 30be 	ldrh.w	r3, [r3, #190]	; 0xbe
 800cd88:	2b00      	cmp	r3, #0
 800cd8a:	d004      	beq.n	800cd96 <vTCPWindowInit+0x3e>
		{
			pxWindow->usMSSInit = ( uint16_t ) ulMSS;
 800cd8c:	683b      	ldr	r3, [r7, #0]
 800cd8e:	b29a      	uxth	r2, r3
 800cd90:	68fb      	ldr	r3, [r7, #12]
 800cd92:	f8a3 20be 	strh.w	r2, [r3, #190]	; 0xbe
		}

		if( ( ulMSS < ( uint32_t ) pxWindow->usMSS ) || ( pxWindow->usMSS == 0u ) )
 800cd96:	68fb      	ldr	r3, [r7, #12]
 800cd98:	f8b3 30bc 	ldrh.w	r3, [r3, #188]	; 0xbc
 800cd9c:	461a      	mov	r2, r3
 800cd9e:	683b      	ldr	r3, [r7, #0]
 800cda0:	429a      	cmp	r2, r3
 800cda2:	d804      	bhi.n	800cdae <vTCPWindowInit+0x56>
 800cda4:	68fb      	ldr	r3, [r7, #12]
 800cda6:	f8b3 30bc 	ldrh.w	r3, [r3, #188]	; 0xbc
 800cdaa:	2b00      	cmp	r3, #0
 800cdac:	d10e      	bne.n	800cdcc <vTCPWindowInit+0x74>
		{
			pxWindow->xSize.ulRxWindowLength = ( pxWindow->xSize.ulRxWindowLength / ulMSS ) * ulMSS;
 800cdae:	68fb      	ldr	r3, [r7, #12]
 800cdb0:	685a      	ldr	r2, [r3, #4]
 800cdb2:	683b      	ldr	r3, [r7, #0]
 800cdb4:	fbb2 f3f3 	udiv	r3, r2, r3
 800cdb8:	683a      	ldr	r2, [r7, #0]
 800cdba:	fb02 f203 	mul.w	r2, r2, r3
 800cdbe:	68fb      	ldr	r3, [r7, #12]
 800cdc0:	605a      	str	r2, [r3, #4]
			pxWindow->usMSS = ( uint16_t ) ulMSS;
 800cdc2:	683b      	ldr	r3, [r7, #0]
 800cdc4:	b29a      	uxth	r2, r3
 800cdc6:	68fb      	ldr	r3, [r7, #12]
 800cdc8:	f8a3 20bc 	strh.w	r2, [r3, #188]	; 0xbc
		pxWindow->xTxSegment.lMaxLength = ( int32_t ) pxWindow->usMSS;
	}
	#endif /* ipconfigUSE_TCP_WIN == 1 */

	/*Start with a timeout of 2 * 500 ms (1 sec). */
	pxWindow->lSRTT = l500ms;
 800cdcc:	68fb      	ldr	r3, [r7, #12]
 800cdce:	697a      	ldr	r2, [r7, #20]
 800cdd0:	639a      	str	r2, [r3, #56]	; 0x38

	/* Just for logging, to print relative sequence numbers. */
	pxWindow->rx.ulFirstSequenceNumber = ulAckNumber;
 800cdd2:	68fb      	ldr	r3, [r7, #12]
 800cdd4:	68ba      	ldr	r2, [r7, #8]
 800cdd6:	60da      	str	r2, [r3, #12]

	/* The segment asked for in the next transmission. */
	pxWindow->rx.ulCurrentSequenceNumber = ulAckNumber;
 800cdd8:	68fb      	ldr	r3, [r7, #12]
 800cdda:	68ba      	ldr	r2, [r7, #8]
 800cddc:	611a      	str	r2, [r3, #16]

	/* The right-hand side of the receive window. */
	pxWindow->rx.ulHighestSequenceNumber = ulAckNumber;
 800cdde:	68fb      	ldr	r3, [r7, #12]
 800cde0:	68ba      	ldr	r2, [r7, #8]
 800cde2:	619a      	str	r2, [r3, #24]

	pxWindow->tx.ulFirstSequenceNumber = ulSequenceNumber;
 800cde4:	68fb      	ldr	r3, [r7, #12]
 800cde6:	687a      	ldr	r2, [r7, #4]
 800cde8:	61da      	str	r2, [r3, #28]

	/* The segment asked for in next transmission. */
	pxWindow->tx.ulCurrentSequenceNumber = ulSequenceNumber;
 800cdea:	68fb      	ldr	r3, [r7, #12]
 800cdec:	687a      	ldr	r2, [r7, #4]
 800cdee:	621a      	str	r2, [r3, #32]

	/* The sequence number given to the next outgoing byte to be added is
	maintained by lTCPWindowTxAdd(). */
	pxWindow->ulNextTxSequenceNumber = ulSequenceNumber;
 800cdf0:	68fb      	ldr	r3, [r7, #12]
 800cdf2:	687a      	ldr	r2, [r7, #4]
 800cdf4:	635a      	str	r2, [r3, #52]	; 0x34

	/* The right-hand side of the transmit window. */
	pxWindow->tx.ulHighestSequenceNumber = ulSequenceNumber;
 800cdf6:	68fb      	ldr	r3, [r7, #12]
 800cdf8:	687a      	ldr	r2, [r7, #4]
 800cdfa:	629a      	str	r2, [r3, #40]	; 0x28
	pxWindow->ulOurSequenceNumber = ulSequenceNumber;
 800cdfc:	68fb      	ldr	r3, [r7, #12]
 800cdfe:	687a      	ldr	r2, [r7, #4]
 800ce00:	62da      	str	r2, [r3, #44]	; 0x2c
}
 800ce02:	371c      	adds	r7, #28
 800ce04:	46bd      	mov	sp, r7
 800ce06:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ce0a:	4770      	bx	lr

0800ce0c <xTCPWindowRxConfirm>:
 *=============================================================================*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static TCPSegment_t *xTCPWindowRxConfirm( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, uint32_t ulLength )
	{
 800ce0c:	b580      	push	{r7, lr}
 800ce0e:	b08a      	sub	sp, #40	; 0x28
 800ce10:	af00      	add	r7, sp, #0
 800ce12:	60f8      	str	r0, [r7, #12]
 800ce14:	60b9      	str	r1, [r7, #8]
 800ce16:	607a      	str	r2, [r7, #4]
	TCPSegment_t *pxBest = NULL;
 800ce18:	2300      	movs	r3, #0
 800ce1a:	627b      	str	r3, [r7, #36]	; 0x24
	const ListItem_t *pxIterator;
	uint32_t ulNextSequenceNumber = ulSequenceNumber + ulLength;
 800ce1c:	68ba      	ldr	r2, [r7, #8]
 800ce1e:	687b      	ldr	r3, [r7, #4]
 800ce20:	4413      	add	r3, r2
 800ce22:	61fb      	str	r3, [r7, #28]
	const MiniListItem_t* pxEnd = ( const MiniListItem_t* ) listGET_END_MARKER( &pxWindow->xRxSegments );
 800ce24:	68fb      	ldr	r3, [r7, #12]
 800ce26:	33ac      	adds	r3, #172	; 0xac
 800ce28:	61bb      	str	r3, [r7, #24]
		and (ulSequenceNumber+ulLength).  Normally none will be found, because
		the next RX segment should have a sequence number equal to
		'(ulSequenceNumber+ulLength)'. */

		/* Iterate through all RX segments that are stored: */
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 800ce2a:	69bb      	ldr	r3, [r7, #24]
 800ce2c:	685b      	ldr	r3, [r3, #4]
 800ce2e:	623b      	str	r3, [r7, #32]
 800ce30:	e027      	b.n	800ce82 <xTCPWindowRxConfirm+0x76>
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
		{
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800ce32:	6a3b      	ldr	r3, [r7, #32]
 800ce34:	68db      	ldr	r3, [r3, #12]
 800ce36:	617b      	str	r3, [r7, #20]
			/* And see if there is a segment for which:
			'ulSequenceNumber' <= 'pxSegment->ulSequenceNumber' < 'ulNextSequenceNumber'
			If there are more matching segments, the one with the lowest sequence number
			shall be taken */
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 800ce38:	697b      	ldr	r3, [r7, #20]
 800ce3a:	681b      	ldr	r3, [r3, #0]
 800ce3c:	4618      	mov	r0, r3
 800ce3e:	68b9      	ldr	r1, [r7, #8]
 800ce40:	f7ff fd5e 	bl	800c900 <xSequenceGreaterThanOrEqual>
 800ce44:	4603      	mov	r3, r0
 800ce46:	2b00      	cmp	r3, #0
 800ce48:	d018      	beq.n	800ce7c <xTCPWindowRxConfirm+0x70>
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulNextSequenceNumber ) != 0 ) )
 800ce4a:	697b      	ldr	r3, [r7, #20]
 800ce4c:	681b      	ldr	r3, [r3, #0]
 800ce4e:	4618      	mov	r0, r3
 800ce50:	69f9      	ldr	r1, [r7, #28]
 800ce52:	f7ff fd31 	bl	800c8b8 <xSequenceLessThan>
 800ce56:	4603      	mov	r3, r0
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
			/* And see if there is a segment for which:
			'ulSequenceNumber' <= 'pxSegment->ulSequenceNumber' < 'ulNextSequenceNumber'
			If there are more matching segments, the one with the lowest sequence number
			shall be taken */
			if( ( xSequenceGreaterThanOrEqual( pxSegment->ulSequenceNumber, ulSequenceNumber ) != 0 ) &&
 800ce58:	2b00      	cmp	r3, #0
 800ce5a:	d00f      	beq.n	800ce7c <xTCPWindowRxConfirm+0x70>
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulNextSequenceNumber ) != 0 ) )
			{
				if( ( pxBest == NULL ) || ( xSequenceLessThan( pxSegment->ulSequenceNumber, pxBest->ulSequenceNumber ) != 0 ) )
 800ce5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ce5e:	2b00      	cmp	r3, #0
 800ce60:	d00a      	beq.n	800ce78 <xTCPWindowRxConfirm+0x6c>
 800ce62:	697b      	ldr	r3, [r7, #20]
 800ce64:	681a      	ldr	r2, [r3, #0]
 800ce66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ce68:	681b      	ldr	r3, [r3, #0]
 800ce6a:	4610      	mov	r0, r2
 800ce6c:	4619      	mov	r1, r3
 800ce6e:	f7ff fd23 	bl	800c8b8 <xSequenceLessThan>
 800ce72:	4603      	mov	r3, r0
 800ce74:	2b00      	cmp	r3, #0
 800ce76:	d001      	beq.n	800ce7c <xTCPWindowRxConfirm+0x70>
				{
					pxBest = pxSegment;
 800ce78:	697b      	ldr	r3, [r7, #20]
 800ce7a:	627b      	str	r3, [r7, #36]	; 0x24
		'(ulSequenceNumber+ulLength)'. */

		/* Iterate through all RX segments that are stored: */
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
			 pxIterator != ( const ListItem_t * ) pxEnd;
			 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 800ce7c:	6a3b      	ldr	r3, [r7, #32]
 800ce7e:	685b      	ldr	r3, [r3, #4]
 800ce80:	623b      	str	r3, [r7, #32]
		and (ulSequenceNumber+ulLength).  Normally none will be found, because
		the next RX segment should have a sequence number equal to
		'(ulSequenceNumber+ulLength)'. */

		/* Iterate through all RX segments that are stored: */
		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 800ce82:	6a3a      	ldr	r2, [r7, #32]
 800ce84:	69bb      	ldr	r3, [r7, #24]
 800ce86:	429a      	cmp	r2, r3
 800ce88:	d1d3      	bne.n	800ce32 <xTCPWindowRxConfirm+0x26>
					pxBest = pxSegment;
				}
			}
		}

		if( ( pxBest != NULL ) &&
 800ce8a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ce8c:	2b00      	cmp	r3, #0
 800ce8e:	d003      	beq.n	800ce98 <xTCPWindowRxConfirm+0x8c>
			( ( pxBest->ulSequenceNumber != ulSequenceNumber ) || ( pxBest->lDataLength != ( int32_t ) ulLength ) ) )
 800ce90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800ce92:	681a      	ldr	r2, [r3, #0]
					pxBest = pxSegment;
				}
			}
		}

		if( ( pxBest != NULL ) &&
 800ce94:	68bb      	ldr	r3, [r7, #8]
 800ce96:	429a      	cmp	r2, r3
				pxBest->ulSequenceNumber - pxWindow->rx.ulFirstSequenceNumber,
				pxBest->lDataLength,
				pxBest->ulSequenceNumber + ( ( uint32_t ) pxBest->lDataLength ) - pxWindow->rx.ulFirstSequenceNumber ) );
		}

		return pxBest;
 800ce98:	6a7b      	ldr	r3, [r7, #36]	; 0x24
	}
 800ce9a:	4618      	mov	r0, r3
 800ce9c:	3728      	adds	r7, #40	; 0x28
 800ce9e:	46bd      	mov	sp, r7
 800cea0:	bd80      	pop	{r7, pc}
 800cea2:	bf00      	nop

0800cea4 <lTCPWindowRxCheck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	int32_t lTCPWindowRxCheck( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber, uint32_t ulLength, uint32_t ulSpace )
	{
 800cea4:	b580      	push	{r7, lr}
 800cea6:	b08a      	sub	sp, #40	; 0x28
 800cea8:	af00      	add	r7, sp, #0
 800ceaa:	60f8      	str	r0, [r7, #12]
 800ceac:	60b9      	str	r1, [r7, #8]
 800ceae:	607a      	str	r2, [r7, #4]
 800ceb0:	603b      	str	r3, [r7, #0]
		or there is not enough space.

		As a side-effect, pxWindow->ulUserDataLength will get set to non-zero,
		if more Rx data may be passed to the user after this packet. */

		ulCurrentSequenceNumber = pxWindow->rx.ulCurrentSequenceNumber;
 800ceb2:	68fb      	ldr	r3, [r7, #12]
 800ceb4:	691b      	ldr	r3, [r3, #16]
 800ceb6:	627b      	str	r3, [r7, #36]	; 0x24

		/* For Selective Ack (SACK), used when out-of-sequence data come in. */
		pxWindow->ucOptionLength = 0u;
 800ceb8:	68fb      	ldr	r3, [r7, #12]
 800ceba:	2200      	movs	r2, #0
 800cebc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

		/* Non-zero if TCP-windows contains data which must be popped. */
		pxWindow->ulUserDataLength = 0ul;
 800cec0:	68fb      	ldr	r3, [r7, #12]
 800cec2:	2200      	movs	r2, #0
 800cec4:	631a      	str	r2, [r3, #48]	; 0x30

		if( ulCurrentSequenceNumber == ulSequenceNumber )
 800cec6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cec8:	68bb      	ldr	r3, [r7, #8]
 800ceca:	429a      	cmp	r2, r3
 800cecc:	d145      	bne.n	800cf5a <lTCPWindowRxCheck+0xb6>
		{
			/* This is the packet with the lowest sequence number we're waiting
			for.  It can be passed directly to the rx stream. */
			if( ulLength > ulSpace )
 800cece:	687a      	ldr	r2, [r7, #4]
 800ced0:	683b      	ldr	r3, [r7, #0]
 800ced2:	429a      	cmp	r2, r3
 800ced4:	d903      	bls.n	800cede <lTCPWindowRxCheck+0x3a>
			{
				FreeRTOS_debug_printf( ( "lTCPWindowRxCheck: Refuse %lu bytes, due to lack of space (%lu)\n", ulLength, ulSpace ) );
				lReturn = -1;
 800ced6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800ceda:	61fb      	str	r3, [r7, #28]
 800cedc:	e0bb      	b.n	800d056 <lTCPWindowRxCheck+0x1b2>
			}
			else
			{
				ulCurrentSequenceNumber += ulLength;
 800cede:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cee0:	687b      	ldr	r3, [r7, #4]
 800cee2:	4413      	add	r3, r2
 800cee4:	627b      	str	r3, [r7, #36]	; 0x24

				if( listCURRENT_LIST_LENGTH( &( pxWindow->xRxSegments ) ) != 0 )
 800cee6:	68fb      	ldr	r3, [r7, #12]
 800cee8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 800ceec:	2b00      	cmp	r3, #0
 800ceee:	d02e      	beq.n	800cf4e <lTCPWindowRxCheck+0xaa>
				{
					ulSavedSequenceNumber = ulCurrentSequenceNumber;
 800cef0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cef2:	61bb      	str	r3, [r7, #24]

					/* See if (part of) this segment has been stored already,
					but this rarely happens. */
					pxFound = xTCPWindowRxConfirm( pxWindow, ulSequenceNumber, ulLength );
 800cef4:	68f8      	ldr	r0, [r7, #12]
 800cef6:	68b9      	ldr	r1, [r7, #8]
 800cef8:	687a      	ldr	r2, [r7, #4]
 800cefa:	f7ff ff87 	bl	800ce0c <xTCPWindowRxConfirm>
 800cefe:	6178      	str	r0, [r7, #20]
					if( pxFound != NULL )
 800cf00:	697b      	ldr	r3, [r7, #20]
 800cf02:	2b00      	cmp	r3, #0
 800cf04:	d008      	beq.n	800cf18 <lTCPWindowRxCheck+0x74>
					{
						ulCurrentSequenceNumber = pxFound->ulSequenceNumber + ( ( uint32_t ) pxFound->lDataLength );
 800cf06:	697b      	ldr	r3, [r7, #20]
 800cf08:	681b      	ldr	r3, [r3, #0]
 800cf0a:	697a      	ldr	r2, [r7, #20]
 800cf0c:	6892      	ldr	r2, [r2, #8]
 800cf0e:	4413      	add	r3, r2
 800cf10:	627b      	str	r3, [r7, #36]	; 0x24

						/* Remove it because it will be passed to user directly. */
						vTCPWindowFree( pxFound );
 800cf12:	6978      	ldr	r0, [r7, #20]
 800cf14:	f7ff fe8e 	bl	800cc34 <vTCPWindowFree>
					}

					/*  Check for following segments that are already in the
					queue and increment ulCurrentSequenceNumber. */
					while( ( pxFound = xTCPWindowRxFind( pxWindow, ulCurrentSequenceNumber ) ) != NULL )
 800cf18:	e008      	b.n	800cf2c <lTCPWindowRxCheck+0x88>
					{
						ulCurrentSequenceNumber += ( uint32_t ) pxFound->lDataLength;
 800cf1a:	697b      	ldr	r3, [r7, #20]
 800cf1c:	689b      	ldr	r3, [r3, #8]
 800cf1e:	461a      	mov	r2, r3
 800cf20:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cf22:	4413      	add	r3, r2
 800cf24:	627b      	str	r3, [r7, #36]	; 0x24

						/* As all packet below this one have been passed to the
						user it can be discarded. */
						vTCPWindowFree( pxFound );
 800cf26:	6978      	ldr	r0, [r7, #20]
 800cf28:	f7ff fe84 	bl	800cc34 <vTCPWindowFree>
						vTCPWindowFree( pxFound );
					}

					/*  Check for following segments that are already in the
					queue and increment ulCurrentSequenceNumber. */
					while( ( pxFound = xTCPWindowRxFind( pxWindow, ulCurrentSequenceNumber ) ) != NULL )
 800cf2c:	68f8      	ldr	r0, [r7, #12]
 800cf2e:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800cf30:	f7ff fd94 	bl	800ca5c <xTCPWindowRxFind>
 800cf34:	6178      	str	r0, [r7, #20]
 800cf36:	697b      	ldr	r3, [r7, #20]
 800cf38:	2b00      	cmp	r3, #0
 800cf3a:	d1ee      	bne.n	800cf1a <lTCPWindowRxCheck+0x76>
						/* As all packet below this one have been passed to the
						user it can be discarded. */
						vTCPWindowFree( pxFound );
					}

					if( ulSavedSequenceNumber != ulCurrentSequenceNumber )
 800cf3c:	69ba      	ldr	r2, [r7, #24]
 800cf3e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cf40:	429a      	cmp	r2, r3
 800cf42:	d004      	beq.n	800cf4e <lTCPWindowRxCheck+0xaa>
					{
						/*  After the current data-package, there is more data
						to be popped. */
						pxWindow->ulUserDataLength = ulCurrentSequenceNumber - ulSavedSequenceNumber;
 800cf44:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cf46:	69bb      	ldr	r3, [r7, #24]
 800cf48:	1ad2      	subs	r2, r2, r3
 800cf4a:	68fb      	ldr	r3, [r7, #12]
 800cf4c:	631a      	str	r2, [r3, #48]	; 0x30
								listCURRENT_LIST_LENGTH( &pxWindow->xRxSegments ) ) );
						}
					}
				}

				pxWindow->rx.ulCurrentSequenceNumber = ulCurrentSequenceNumber;
 800cf4e:	68fb      	ldr	r3, [r7, #12]
 800cf50:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800cf52:	611a      	str	r2, [r3, #16]

				/* Packet was expected, may be passed directly to the socket
				buffer or application.  Store the packet at offset 0. */
				lReturn = 0;
 800cf54:	2300      	movs	r3, #0
 800cf56:	61fb      	str	r3, [r7, #28]
 800cf58:	e07d      	b.n	800d056 <lTCPWindowRxCheck+0x1b2>
			}
		}
		else if( ulCurrentSequenceNumber == ( ulSequenceNumber + 1UL ) )
 800cf5a:	68bb      	ldr	r3, [r7, #8]
 800cf5c:	1c5a      	adds	r2, r3, #1
 800cf5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cf60:	429a      	cmp	r2, r3
 800cf62:	d103      	bne.n	800cf6c <lTCPWindowRxCheck+0xc8>
		{
			/* Looks like a TCP keep-alive message.  Do not accept/store Rx data
			ulUserDataLength = 0. Not packet out-of-sync.  Just reply to it. */
			lReturn = -1;
 800cf64:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800cf68:	61fb      	str	r3, [r7, #28]
 800cf6a:	e074      	b.n	800d056 <lTCPWindowRxCheck+0x1b2>
			/* The packet is not the one expected.  See if it falls within the Rx
			window so it can be stored. */

			/*  An "out-of-sequence" segment was received, must have missed one.
			Prepare a SACK (Selective ACK). */
			ulLast = ulSequenceNumber + ulLength;
 800cf6c:	68ba      	ldr	r2, [r7, #8]
 800cf6e:	687b      	ldr	r3, [r7, #4]
 800cf70:	4413      	add	r3, r2
 800cf72:	623b      	str	r3, [r7, #32]
			lDistance = ( int32_t ) ( ulLast - ulCurrentSequenceNumber );
 800cf74:	6a3a      	ldr	r2, [r7, #32]
 800cf76:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800cf78:	1ad3      	subs	r3, r2, r3
 800cf7a:	613b      	str	r3, [r7, #16]

			if( lDistance <= 0 )
 800cf7c:	693b      	ldr	r3, [r7, #16]
 800cf7e:	2b00      	cmp	r3, #0
 800cf80:	dc03      	bgt.n	800cf8a <lTCPWindowRxCheck+0xe6>
			{
				/* An earlier has been received, must be a retransmission of a
				packet that has been accepted already.  No need to send out a
				Selective ACK (SACK). */
				lReturn = -1;
 800cf82:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800cf86:	61fb      	str	r3, [r7, #28]
 800cf88:	e065      	b.n	800d056 <lTCPWindowRxCheck+0x1b2>
			}
			else if( lDistance > ( int32_t ) ulSpace )
 800cf8a:	683a      	ldr	r2, [r7, #0]
 800cf8c:	693b      	ldr	r3, [r7, #16]
 800cf8e:	429a      	cmp	r2, r3
 800cf90:	da03      	bge.n	800cf9a <lTCPWindowRxCheck+0xf6>
			{
				/* The new segment is ahead of rx.ulCurrentSequenceNumber.  The
				sequence number of this packet is too far ahead, ignore it. */
				FreeRTOS_debug_printf( ( "lTCPWindowRxCheck: Refuse %lu+%lu bytes, due to lack of space (%lu)\n", lDistance, ulLength, ulSpace ) );
				lReturn = -1;
 800cf92:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800cf96:	61fb      	str	r3, [r7, #28]
 800cf98:	e05d      	b.n	800d056 <lTCPWindowRxCheck+0x1b2>

				/* TODO: SACK's may also be delayed for a short period
				 * This is useful because subsequent packets will be SACK'd with
				 * single one message
				 */
				while( ( pxFound = xTCPWindowRxFind( pxWindow, ulLast ) ) != NULL )
 800cf9a:	e005      	b.n	800cfa8 <lTCPWindowRxCheck+0x104>
				{
					ulLast += ( uint32_t ) pxFound->lDataLength;
 800cf9c:	697b      	ldr	r3, [r7, #20]
 800cf9e:	689b      	ldr	r3, [r3, #8]
 800cfa0:	461a      	mov	r2, r3
 800cfa2:	6a3b      	ldr	r3, [r7, #32]
 800cfa4:	4413      	add	r3, r2
 800cfa6:	623b      	str	r3, [r7, #32]

				/* TODO: SACK's may also be delayed for a short period
				 * This is useful because subsequent packets will be SACK'd with
				 * single one message
				 */
				while( ( pxFound = xTCPWindowRxFind( pxWindow, ulLast ) ) != NULL )
 800cfa8:	68f8      	ldr	r0, [r7, #12]
 800cfaa:	6a39      	ldr	r1, [r7, #32]
 800cfac:	f7ff fd56 	bl	800ca5c <xTCPWindowRxFind>
 800cfb0:	6178      	str	r0, [r7, #20]
 800cfb2:	697b      	ldr	r3, [r7, #20]
 800cfb4:	2b00      	cmp	r3, #0
 800cfb6:	d1f1      	bne.n	800cf9c <lTCPWindowRxCheck+0xf8>
						ulLast - pxWindow->rx.ulFirstSequenceNumber ) );
				}

				/* Now prepare the SACK message.
				Code OPTION_CODE_SINGLE_SACK already in network byte order. */
				pxWindow->ulOptionsData[0] = OPTION_CODE_SINGLE_SACK;
 800cfb8:	68fb      	ldr	r3, [r7, #12]
 800cfba:	4a29      	ldr	r2, [pc, #164]	; (800d060 <lTCPWindowRxCheck+0x1bc>)
 800cfbc:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80

				/* First sequence number that we received. */
				pxWindow->ulOptionsData[1] = FreeRTOS_htonl( ulSequenceNumber );
 800cfc0:	68bb      	ldr	r3, [r7, #8]
 800cfc2:	061a      	lsls	r2, r3, #24
 800cfc4:	68bb      	ldr	r3, [r7, #8]
 800cfc6:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800cfca:	021b      	lsls	r3, r3, #8
 800cfcc:	431a      	orrs	r2, r3
 800cfce:	68bb      	ldr	r3, [r7, #8]
 800cfd0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800cfd4:	0a1b      	lsrs	r3, r3, #8
 800cfd6:	431a      	orrs	r2, r3
 800cfd8:	68bb      	ldr	r3, [r7, #8]
 800cfda:	0e1b      	lsrs	r3, r3, #24
 800cfdc:	431a      	orrs	r2, r3
 800cfde:	68fb      	ldr	r3, [r7, #12]
 800cfe0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84

				/* Last + 1 */
				pxWindow->ulOptionsData[2] = FreeRTOS_htonl( ulLast );
 800cfe4:	6a3b      	ldr	r3, [r7, #32]
 800cfe6:	061a      	lsls	r2, r3, #24
 800cfe8:	6a3b      	ldr	r3, [r7, #32]
 800cfea:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 800cfee:	021b      	lsls	r3, r3, #8
 800cff0:	431a      	orrs	r2, r3
 800cff2:	6a3b      	ldr	r3, [r7, #32]
 800cff4:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
 800cff8:	0a1b      	lsrs	r3, r3, #8
 800cffa:	431a      	orrs	r2, r3
 800cffc:	6a3b      	ldr	r3, [r7, #32]
 800cffe:	0e1b      	lsrs	r3, r3, #24
 800d000:	431a      	orrs	r2, r3
 800d002:	68fb      	ldr	r3, [r7, #12]
 800d004:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

				/* Which make 12 (3*4) option bytes. */
				pxWindow->ucOptionLength = 3 * sizeof( pxWindow->ulOptionsData[ 0 ] );
 800d008:	68fb      	ldr	r3, [r7, #12]
 800d00a:	220c      	movs	r2, #12
 800d00c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

				pxFound = xTCPWindowRxFind( pxWindow, ulSequenceNumber );
 800d010:	68f8      	ldr	r0, [r7, #12]
 800d012:	68b9      	ldr	r1, [r7, #8]
 800d014:	f7ff fd22 	bl	800ca5c <xTCPWindowRxFind>
 800d018:	6178      	str	r0, [r7, #20]

				if( pxFound != NULL )
 800d01a:	697b      	ldr	r3, [r7, #20]
 800d01c:	2b00      	cmp	r3, #0
 800d01e:	d003      	beq.n	800d028 <lTCPWindowRxCheck+0x184>
				{
					/* This out-of-sequence packet has been received for a
					second time.  It is already stored but do send a SACK
					again. */
					lReturn = -1;
 800d020:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800d024:	61fb      	str	r3, [r7, #28]
 800d026:	e016      	b.n	800d056 <lTCPWindowRxCheck+0x1b2>
				}
				else
				{
					pxFound = xTCPWindowRxNew( pxWindow, ulSequenceNumber, ( int32_t ) ulLength );
 800d028:	687b      	ldr	r3, [r7, #4]
 800d02a:	68f8      	ldr	r0, [r7, #12]
 800d02c:	68b9      	ldr	r1, [r7, #8]
 800d02e:	461a      	mov	r2, r3
 800d030:	2301      	movs	r3, #1
 800d032:	f7ff fd3b 	bl	800caac <xTCPWindowNew>
 800d036:	6178      	str	r0, [r7, #20]

					if( pxFound == NULL )
 800d038:	697b      	ldr	r3, [r7, #20]
 800d03a:	2b00      	cmp	r3, #0
 800d03c:	d107      	bne.n	800d04e <lTCPWindowRxCheck+0x1aa>
					{
						/* Can not send a SACK, because the segment cannot be
						stored. */
						pxWindow->ucOptionLength = 0u;
 800d03e:	68fb      	ldr	r3, [r7, #12]
 800d040:	2200      	movs	r2, #0
 800d042:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c

						/* Needs to be stored but there is no segment
						available. */
						lReturn = -1;
 800d046:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800d04a:	61fb      	str	r3, [r7, #28]
 800d04c:	e003      	b.n	800d056 <lTCPWindowRxCheck+0x1b2>
							FreeRTOS_flush_logging( );
						}

						/* Return a positive value.  The packet may be accepted
						and stored but an earlier packet is still missing. */
						lReturn = ( int32_t ) ( ulSequenceNumber - ulCurrentSequenceNumber );
 800d04e:	68ba      	ldr	r2, [r7, #8]
 800d050:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d052:	1ad3      	subs	r3, r2, r3
 800d054:	61fb      	str	r3, [r7, #28]
					}
				}
			}
		}

		return lReturn;
 800d056:	69fb      	ldr	r3, [r7, #28]
	}
 800d058:	4618      	mov	r0, r3
 800d05a:	3728      	adds	r7, #40	; 0x28
 800d05c:	46bd      	mov	sp, r7
 800d05e:	bd80      	pop	{r7, pc}
 800d060:	0a050101 	.word	0x0a050101

0800d064 <lTCPIncrementTxPosition>:
 *=============================================================================*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static int32_t lTCPIncrementTxPosition( int32_t lPosition, int32_t lMax, int32_t lCount )
	{
 800d064:	b480      	push	{r7}
 800d066:	b085      	sub	sp, #20
 800d068:	af00      	add	r7, sp, #0
 800d06a:	60f8      	str	r0, [r7, #12]
 800d06c:	60b9      	str	r1, [r7, #8]
 800d06e:	607a      	str	r2, [r7, #4]
		/* +TCP stores data in circular buffers.  Calculate the next position to
		store. */
		lPosition += lCount;
 800d070:	68fa      	ldr	r2, [r7, #12]
 800d072:	687b      	ldr	r3, [r7, #4]
 800d074:	4413      	add	r3, r2
 800d076:	60fb      	str	r3, [r7, #12]
		if( lPosition >= lMax )
 800d078:	68fa      	ldr	r2, [r7, #12]
 800d07a:	68bb      	ldr	r3, [r7, #8]
 800d07c:	429a      	cmp	r2, r3
 800d07e:	db03      	blt.n	800d088 <lTCPIncrementTxPosition+0x24>
		{
			lPosition -= lMax;
 800d080:	68fa      	ldr	r2, [r7, #12]
 800d082:	68bb      	ldr	r3, [r7, #8]
 800d084:	1ad3      	subs	r3, r2, r3
 800d086:	60fb      	str	r3, [r7, #12]
		}

		return lPosition;
 800d088:	68fb      	ldr	r3, [r7, #12]
	}
 800d08a:	4618      	mov	r0, r3
 800d08c:	3714      	adds	r7, #20
 800d08e:	46bd      	mov	sp, r7
 800d090:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d094:	4770      	bx	lr
 800d096:	bf00      	nop

0800d098 <lTCPWindowTxAdd>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	int32_t lTCPWindowTxAdd( TCPWindow_t *pxWindow, uint32_t ulLength, int32_t lPosition, int32_t lMax )
	{
 800d098:	b580      	push	{r7, lr}
 800d09a:	b088      	sub	sp, #32
 800d09c:	af00      	add	r7, sp, #0
 800d09e:	60f8      	str	r0, [r7, #12]
 800d0a0:	60b9      	str	r1, [r7, #8]
 800d0a2:	607a      	str	r2, [r7, #4]
 800d0a4:	603b      	str	r3, [r7, #0]
	int32_t lBytesLeft = ( int32_t ) ulLength, lToWrite;
 800d0a6:	68bb      	ldr	r3, [r7, #8]
 800d0a8:	61fb      	str	r3, [r7, #28]
	int32_t lDone = 0;
 800d0aa:	2300      	movs	r3, #0
 800d0ac:	61bb      	str	r3, [r7, #24]
	TCPSegment_t *pxSegment = pxWindow->pxHeadSegment;
 800d0ae:	68fb      	ldr	r3, [r7, #12]
 800d0b0:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800d0b2:	617b      	str	r3, [r7, #20]

		/* Puts a message in the Tx-window (after buffer size has been
		verified). */
		if( pxSegment != NULL )
 800d0b4:	697b      	ldr	r3, [r7, #20]
 800d0b6:	2b00      	cmp	r3, #0
 800d0b8:	d040      	beq.n	800d13c <lTCPWindowTxAdd+0xa4>
		{
			if( pxSegment->lDataLength < pxSegment->lMaxLength )
 800d0ba:	697b      	ldr	r3, [r7, #20]
 800d0bc:	689a      	ldr	r2, [r3, #8]
 800d0be:	697b      	ldr	r3, [r7, #20]
 800d0c0:	685b      	ldr	r3, [r3, #4]
 800d0c2:	429a      	cmp	r2, r3
 800d0c4:	da3a      	bge.n	800d13c <lTCPWindowTxAdd+0xa4>
			{
				if( ( pxSegment->u.bits.bOutstanding == pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength != 0 ) )
 800d0c6:	697b      	ldr	r3, [r7, #20]
 800d0c8:	7d9b      	ldrb	r3, [r3, #22]
 800d0ca:	f003 0301 	and.w	r3, r3, #1
 800d0ce:	b2db      	uxtb	r3, r3
 800d0d0:	2b00      	cmp	r3, #0
 800d0d2:	d133      	bne.n	800d13c <lTCPWindowTxAdd+0xa4>
 800d0d4:	697b      	ldr	r3, [r7, #20]
 800d0d6:	689b      	ldr	r3, [r3, #8]
 800d0d8:	2b00      	cmp	r3, #0
 800d0da:	d02f      	beq.n	800d13c <lTCPWindowTxAdd+0xa4>
				{
					/* Adding data to a segment that was already in the TX queue.  It
					will be filled-up to a maximum of MSS (maximum segment size). */
					lToWrite = FreeRTOS_min_int32( lBytesLeft, pxSegment->lMaxLength - pxSegment->lDataLength );
 800d0dc:	697b      	ldr	r3, [r7, #20]
 800d0de:	685a      	ldr	r2, [r3, #4]
 800d0e0:	697b      	ldr	r3, [r7, #20]
 800d0e2:	689b      	ldr	r3, [r3, #8]
 800d0e4:	1ad3      	subs	r3, r2, r3
 800d0e6:	69f8      	ldr	r0, [r7, #28]
 800d0e8:	4619      	mov	r1, r3
 800d0ea:	f7ff fbb3 	bl	800c854 <FreeRTOS_min_int32>
 800d0ee:	6138      	str	r0, [r7, #16]

					pxSegment->lDataLength += lToWrite;
 800d0f0:	697b      	ldr	r3, [r7, #20]
 800d0f2:	689a      	ldr	r2, [r3, #8]
 800d0f4:	693b      	ldr	r3, [r7, #16]
 800d0f6:	441a      	add	r2, r3
 800d0f8:	697b      	ldr	r3, [r7, #20]
 800d0fa:	609a      	str	r2, [r3, #8]

					if( pxSegment->lDataLength >= pxSegment->lMaxLength )
 800d0fc:	697b      	ldr	r3, [r7, #20]
 800d0fe:	689a      	ldr	r2, [r3, #8]
 800d100:	697b      	ldr	r3, [r7, #20]
 800d102:	685b      	ldr	r3, [r3, #4]
 800d104:	429a      	cmp	r2, r3
 800d106:	db02      	blt.n	800d10e <lTCPWindowTxAdd+0x76>
					{
						/* This segment is full, don't add more bytes. */
						pxWindow->pxHeadSegment = NULL;
 800d108:	68fb      	ldr	r3, [r7, #12]
 800d10a:	2200      	movs	r2, #0
 800d10c:	67da      	str	r2, [r3, #124]	; 0x7c
					}

					lBytesLeft -= lToWrite;
 800d10e:	69fa      	ldr	r2, [r7, #28]
 800d110:	693b      	ldr	r3, [r7, #16]
 800d112:	1ad3      	subs	r3, r2, r3
 800d114:	61fb      	str	r3, [r7, #28]

					/* ulNextTxSequenceNumber is the sequence number of the next byte to
					be stored for transmission. */
					pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
 800d116:	68fb      	ldr	r3, [r7, #12]
 800d118:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d11a:	693b      	ldr	r3, [r7, #16]
 800d11c:	441a      	add	r2, r3
 800d11e:	68fb      	ldr	r3, [r7, #12]
 800d120:	635a      	str	r2, [r3, #52]	; 0x34

					/* Increased the return value. */
					lDone += lToWrite;
 800d122:	69ba      	ldr	r2, [r7, #24]
 800d124:	693b      	ldr	r3, [r7, #16]
 800d126:	4413      	add	r3, r2
 800d128:	61bb      	str	r3, [r7, #24]

					/* Some detailed logging, for those who're interested. */
					if( ( xTCPWindowLoggingLevel >= 2 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != 0 ) )
 800d12a:	4b33      	ldr	r3, [pc, #204]	; (800d1f8 <lTCPWindowTxAdd+0x160>)
 800d12c:	681b      	ldr	r3, [r3, #0]
 800d12e:	2b01      	cmp	r3, #1
						FreeRTOS_flush_logging( );
					}

					/* Calculate the next position in the circular data buffer, knowing
					its maximum length 'lMax'. */
					lPosition = lTCPIncrementTxPosition( lPosition, lMax, lToWrite );
 800d130:	6878      	ldr	r0, [r7, #4]
 800d132:	6839      	ldr	r1, [r7, #0]
 800d134:	693a      	ldr	r2, [r7, #16]
 800d136:	f7ff ff95 	bl	800d064 <lTCPIncrementTxPosition>
 800d13a:	6078      	str	r0, [r7, #4]
				}
			}
		}

		while( lBytesLeft > 0 )
 800d13c:	e053      	b.n	800d1e6 <lTCPWindowTxAdd+0x14e>
		{
			/* The current transmission segment is full, create new segments as
			needed. */
			pxSegment = xTCPWindowTxNew( pxWindow, pxWindow->ulNextTxSequenceNumber, pxWindow->usMSS );
 800d13e:	68fb      	ldr	r3, [r7, #12]
 800d140:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d142:	68fb      	ldr	r3, [r7, #12]
 800d144:	f8b3 30bc 	ldrh.w	r3, [r3, #188]	; 0xbc
 800d148:	68f8      	ldr	r0, [r7, #12]
 800d14a:	4611      	mov	r1, r2
 800d14c:	461a      	mov	r2, r3
 800d14e:	2300      	movs	r3, #0
 800d150:	f7ff fcac 	bl	800caac <xTCPWindowNew>
 800d154:	6178      	str	r0, [r7, #20]

			if( pxSegment != NULL )
 800d156:	697b      	ldr	r3, [r7, #20]
 800d158:	2b00      	cmp	r3, #0
 800d15a:	d043      	beq.n	800d1e4 <lTCPWindowTxAdd+0x14c>
			{
				/* Store as many as needed, but no more than the maximum
				(MSS). */
				lToWrite = FreeRTOS_min_int32( lBytesLeft, pxSegment->lMaxLength );
 800d15c:	697b      	ldr	r3, [r7, #20]
 800d15e:	685b      	ldr	r3, [r3, #4]
 800d160:	69f8      	ldr	r0, [r7, #28]
 800d162:	4619      	mov	r1, r3
 800d164:	f7ff fb76 	bl	800c854 <FreeRTOS_min_int32>
 800d168:	6138      	str	r0, [r7, #16]

				pxSegment->lDataLength = lToWrite;
 800d16a:	697b      	ldr	r3, [r7, #20]
 800d16c:	693a      	ldr	r2, [r7, #16]
 800d16e:	609a      	str	r2, [r3, #8]
				pxSegment->lStreamPos = lPosition;
 800d170:	697b      	ldr	r3, [r7, #20]
 800d172:	687a      	ldr	r2, [r7, #4]
 800d174:	60da      	str	r2, [r3, #12]
				lBytesLeft -= lToWrite;
 800d176:	69fa      	ldr	r2, [r7, #28]
 800d178:	693b      	ldr	r3, [r7, #16]
 800d17a:	1ad3      	subs	r3, r2, r3
 800d17c:	61fb      	str	r3, [r7, #28]
				lPosition = lTCPIncrementTxPosition( lPosition, lMax, lToWrite );
 800d17e:	6878      	ldr	r0, [r7, #4]
 800d180:	6839      	ldr	r1, [r7, #0]
 800d182:	693a      	ldr	r2, [r7, #16]
 800d184:	f7ff ff6e 	bl	800d064 <lTCPIncrementTxPosition>
 800d188:	6078      	str	r0, [r7, #4]
				pxWindow->ulNextTxSequenceNumber += ( uint32_t ) lToWrite;
 800d18a:	68fb      	ldr	r3, [r7, #12]
 800d18c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800d18e:	693b      	ldr	r3, [r7, #16]
 800d190:	441a      	add	r2, r3
 800d192:	68fb      	ldr	r3, [r7, #12]
 800d194:	635a      	str	r2, [r3, #52]	; 0x34
				lDone += lToWrite;
 800d196:	69ba      	ldr	r2, [r7, #24]
 800d198:	693b      	ldr	r3, [r7, #16]
 800d19a:	4413      	add	r3, r2
 800d19c:	61bb      	str	r3, [r7, #24]

				/* Link this segment in the Tx-Queue. */
				vListInsertFifo( &( pxWindow->xTxQueue ), &( pxSegment->xQueueItem ) );
 800d19e:	68fb      	ldr	r3, [r7, #12]
 800d1a0:	f103 0254 	add.w	r2, r3, #84	; 0x54
 800d1a4:	697b      	ldr	r3, [r7, #20]
 800d1a6:	3318      	adds	r3, #24
 800d1a8:	4610      	mov	r0, r2
 800d1aa:	4619      	mov	r1, r3
 800d1ac:	f7ff fbba 	bl	800c924 <vListInsertFifo>

				/* Let 'pxHeadSegment' point to this segment if there is still
				space. */
				if( pxSegment->lDataLength < pxSegment->lMaxLength )
 800d1b0:	697b      	ldr	r3, [r7, #20]
 800d1b2:	689a      	ldr	r2, [r3, #8]
 800d1b4:	697b      	ldr	r3, [r7, #20]
 800d1b6:	685b      	ldr	r3, [r3, #4]
 800d1b8:	429a      	cmp	r2, r3
 800d1ba:	da03      	bge.n	800d1c4 <lTCPWindowTxAdd+0x12c>
				{
					pxWindow->pxHeadSegment = pxSegment;
 800d1bc:	68fb      	ldr	r3, [r7, #12]
 800d1be:	697a      	ldr	r2, [r7, #20]
 800d1c0:	67da      	str	r2, [r3, #124]	; 0x7c
 800d1c2:	e002      	b.n	800d1ca <lTCPWindowTxAdd+0x132>
				}
				else
				{
					pxWindow->pxHeadSegment = NULL;
 800d1c4:	68fb      	ldr	r3, [r7, #12]
 800d1c6:	2200      	movs	r2, #0
 800d1c8:	67da      	str	r2, [r3, #124]	; 0x7c
				}

				if( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != 0 )
 800d1ca:	68fb      	ldr	r3, [r7, #12]
 800d1cc:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
 800d1d0:	2b17      	cmp	r3, #23
 800d1d2:	d008      	beq.n	800d1e6 <lTCPWindowTxAdd+0x14e>
				{
					if( ( xTCPWindowLoggingLevel >= 3 ) ||
 800d1d4:	4b08      	ldr	r3, [pc, #32]	; (800d1f8 <lTCPWindowTxAdd+0x160>)
 800d1d6:	681b      	ldr	r3, [r3, #0]
 800d1d8:	2b02      	cmp	r3, #2
 800d1da:	dc04      	bgt.n	800d1e6 <lTCPWindowTxAdd+0x14e>
						( ( xTCPWindowLoggingLevel >= 2 ) && ( pxWindow->pxHeadSegment != NULL ) ) )
 800d1dc:	4b06      	ldr	r3, [pc, #24]	; (800d1f8 <lTCPWindowTxAdd+0x160>)
 800d1de:	681b      	ldr	r3, [r3, #0]
					pxWindow->pxHeadSegment = NULL;
				}

				if( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != 0 )
				{
					if( ( xTCPWindowLoggingLevel >= 3 ) ||
 800d1e0:	2b01      	cmp	r3, #1
 800d1e2:	e000      	b.n	800d1e6 <lTCPWindowTxAdd+0x14e>
				No more data can be sent at the moment. */
				if( lDone != 0 )
				{
					FreeRTOS_debug_printf( ( "lTCPWindowTxAdd: Sorry all buffers full (cancel %ld bytes)\n", lBytesLeft ) );
				}
				break;
 800d1e4:	e002      	b.n	800d1ec <lTCPWindowTxAdd+0x154>
					lPosition = lTCPIncrementTxPosition( lPosition, lMax, lToWrite );
				}
			}
		}

		while( lBytesLeft > 0 )
 800d1e6:	69fb      	ldr	r3, [r7, #28]
 800d1e8:	2b00      	cmp	r3, #0
 800d1ea:	dca8      	bgt.n	800d13e <lTCPWindowTxAdd+0xa6>
				}
				break;
			}
		}

		return lDone;
 800d1ec:	69bb      	ldr	r3, [r7, #24]
	}
 800d1ee:	4618      	mov	r0, r3
 800d1f0:	3720      	adds	r7, #32
 800d1f2:	46bd      	mov	sp, r7
 800d1f4:	bd80      	pop	{r7, pc}
 800d1f6:	bf00      	nop
 800d1f8:	2000c2b4 	.word	0x2000c2b4

0800d1fc <xTCPWindowTxDone>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	BaseType_t xTCPWindowTxDone( TCPWindow_t *pxWindow )
	{
 800d1fc:	b480      	push	{r7}
 800d1fe:	b083      	sub	sp, #12
 800d200:	af00      	add	r7, sp, #0
 800d202:	6078      	str	r0, [r7, #4]
		return listLIST_IS_EMPTY( ( &pxWindow->xTxSegments) );
 800d204:	687b      	ldr	r3, [r7, #4]
 800d206:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800d20a:	2b00      	cmp	r3, #0
 800d20c:	bf0c      	ite	eq
 800d20e:	2301      	moveq	r3, #1
 800d210:	2300      	movne	r3, #0
 800d212:	b2db      	uxtb	r3, r3
	}
 800d214:	4618      	mov	r0, r3
 800d216:	370c      	adds	r7, #12
 800d218:	46bd      	mov	sp, r7
 800d21a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d21e:	4770      	bx	lr

0800d220 <prvTCPWindowTxHasSpace>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static BaseType_t prvTCPWindowTxHasSpace( TCPWindow_t *pxWindow, uint32_t ulWindowSize )
	{
 800d220:	b580      	push	{r7, lr}
 800d222:	b086      	sub	sp, #24
 800d224:	af00      	add	r7, sp, #0
 800d226:	6078      	str	r0, [r7, #4]
 800d228:	6039      	str	r1, [r7, #0]
	TCPSegment_t *pxSegment;

		/* This function will look if there is new transmission data.  It will
		return true if there is data to be sent. */

		pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );
 800d22a:	687b      	ldr	r3, [r7, #4]
 800d22c:	3354      	adds	r3, #84	; 0x54
 800d22e:	4618      	mov	r0, r3
 800d230:	f7ff fce2 	bl	800cbf8 <xTCPWindowPeekHead>
 800d234:	60f8      	str	r0, [r7, #12]

		if( pxSegment == NULL )
 800d236:	68fb      	ldr	r3, [r7, #12]
 800d238:	2b00      	cmp	r3, #0
 800d23a:	d102      	bne.n	800d242 <prvTCPWindowTxHasSpace+0x22>
		{
			xHasSpace = pdFALSE;
 800d23c:	2300      	movs	r3, #0
 800d23e:	613b      	str	r3, [r7, #16]
 800d240:	e02f      	b.n	800d2a2 <prvTCPWindowTxHasSpace+0x82>
		}
		else
		{
			/* How much data is outstanding, i.e. how much data has been sent
			but not yet acknowledged ? */
			if( pxWindow->tx.ulHighestSequenceNumber >= pxWindow->tx.ulCurrentSequenceNumber )
 800d242:	687b      	ldr	r3, [r7, #4]
 800d244:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d246:	687b      	ldr	r3, [r7, #4]
 800d248:	6a1b      	ldr	r3, [r3, #32]
 800d24a:	429a      	cmp	r2, r3
 800d24c:	d306      	bcc.n	800d25c <prvTCPWindowTxHasSpace+0x3c>
			{
				ulTxOutstanding = pxWindow->tx.ulHighestSequenceNumber - pxWindow->tx.ulCurrentSequenceNumber;
 800d24e:	687b      	ldr	r3, [r7, #4]
 800d250:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d252:	687b      	ldr	r3, [r7, #4]
 800d254:	6a1b      	ldr	r3, [r3, #32]
 800d256:	1ad3      	subs	r3, r2, r3
 800d258:	617b      	str	r3, [r7, #20]
 800d25a:	e001      	b.n	800d260 <prvTCPWindowTxHasSpace+0x40>
			}
			else
			{
				ulTxOutstanding = 0UL;
 800d25c:	2300      	movs	r3, #0
 800d25e:	617b      	str	r3, [r7, #20]
			}

			/* Subtract this from the peer's space. */
			ulWindowSize -= FreeRTOS_min_uint32( ulWindowSize, ulTxOutstanding );
 800d260:	6838      	ldr	r0, [r7, #0]
 800d262:	6979      	ldr	r1, [r7, #20]
 800d264:	f7ff fb06 	bl	800c874 <FreeRTOS_min_uint32>
 800d268:	4602      	mov	r2, r0
 800d26a:	683b      	ldr	r3, [r7, #0]
 800d26c:	1a9b      	subs	r3, r3, r2
 800d26e:	603b      	str	r3, [r7, #0]

			/* See if the next segment may be sent. */
			if( ulWindowSize >= ( uint32_t ) pxSegment->lDataLength )
 800d270:	68fb      	ldr	r3, [r7, #12]
 800d272:	689b      	ldr	r3, [r3, #8]
 800d274:	461a      	mov	r2, r3
 800d276:	683b      	ldr	r3, [r7, #0]
 800d278:	429a      	cmp	r2, r3
 800d27a:	d802      	bhi.n	800d282 <prvTCPWindowTxHasSpace+0x62>
			{
				xHasSpace = pdTRUE;
 800d27c:	2301      	movs	r3, #1
 800d27e:	613b      	str	r3, [r7, #16]
 800d280:	e001      	b.n	800d286 <prvTCPWindowTxHasSpace+0x66>
			}
			else
			{
				xHasSpace = pdFALSE;
 800d282:	2300      	movs	r3, #0
 800d284:	613b      	str	r3, [r7, #16]

			/* If 'xHasSpace', it looks like the peer has at least space for 1
			more new segment of size MSS.  xSize.ulTxWindowLength is the self-imposed
			limitation of the transmission window (in case of many resends it
			may be decreased). */
			if( ( ulTxOutstanding != 0UL ) && ( pxWindow->xSize.ulTxWindowLength < ulTxOutstanding + ( ( uint32_t ) pxSegment->lDataLength ) ) )
 800d286:	697b      	ldr	r3, [r7, #20]
 800d288:	2b00      	cmp	r3, #0
 800d28a:	d00a      	beq.n	800d2a2 <prvTCPWindowTxHasSpace+0x82>
 800d28c:	687b      	ldr	r3, [r7, #4]
 800d28e:	689a      	ldr	r2, [r3, #8]
 800d290:	68fb      	ldr	r3, [r7, #12]
 800d292:	689b      	ldr	r3, [r3, #8]
 800d294:	4619      	mov	r1, r3
 800d296:	697b      	ldr	r3, [r7, #20]
 800d298:	440b      	add	r3, r1
 800d29a:	429a      	cmp	r2, r3
 800d29c:	d201      	bcs.n	800d2a2 <prvTCPWindowTxHasSpace+0x82>
			{
				xHasSpace = pdFALSE;
 800d29e:	2300      	movs	r3, #0
 800d2a0:	613b      	str	r3, [r7, #16]
			}
		}

		return xHasSpace;
 800d2a2:	693b      	ldr	r3, [r7, #16]
	}
 800d2a4:	4618      	mov	r0, r3
 800d2a6:	3718      	adds	r7, #24
 800d2a8:	46bd      	mov	sp, r7
 800d2aa:	bd80      	pop	{r7, pc}

0800d2ac <xTCPWindowTxHasData>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	BaseType_t xTCPWindowTxHasData( TCPWindow_t *pxWindow, uint32_t ulWindowSize, TickType_t *pulDelay )
	{
 800d2ac:	b580      	push	{r7, lr}
 800d2ae:	b088      	sub	sp, #32
 800d2b0:	af00      	add	r7, sp, #0
 800d2b2:	60f8      	str	r0, [r7, #12]
 800d2b4:	60b9      	str	r1, [r7, #8]
 800d2b6:	607a      	str	r2, [r7, #4]
	TCPSegment_t *pxSegment;
	BaseType_t xReturn;
	TickType_t ulAge, ulMaxAge;

		*pulDelay = 0u;
 800d2b8:	687b      	ldr	r3, [r7, #4]
 800d2ba:	2200      	movs	r2, #0
 800d2bc:	601a      	str	r2, [r3, #0]

		if( listLIST_IS_EMPTY( &pxWindow->xPriorityQueue ) == pdFALSE )
 800d2be:	68fb      	ldr	r3, [r7, #12]
 800d2c0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800d2c2:	2b00      	cmp	r3, #0
 800d2c4:	d002      	beq.n	800d2cc <xTCPWindowTxHasData+0x20>
		{
			/* No need to look at retransmissions or new transmission as long as
			there are priority segments.  *pulDelay equals zero, meaning it must
			be sent out immediately. */
			xReturn = pdTRUE;
 800d2c6:	2301      	movs	r3, #1
 800d2c8:	61fb      	str	r3, [r7, #28]
 800d2ca:	e04a      	b.n	800d362 <xTCPWindowTxHasData+0xb6>
		}
		else
		{
			pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );
 800d2cc:	68fb      	ldr	r3, [r7, #12]
 800d2ce:	3368      	adds	r3, #104	; 0x68
 800d2d0:	4618      	mov	r0, r3
 800d2d2:	f7ff fc91 	bl	800cbf8 <xTCPWindowPeekHead>
 800d2d6:	61b8      	str	r0, [r7, #24]

			if( pxSegment != NULL )
 800d2d8:	69bb      	ldr	r3, [r7, #24]
 800d2da:	2b00      	cmp	r3, #0
 800d2dc:	d019      	beq.n	800d312 <xTCPWindowTxHasData+0x66>
			{
				/* There is an outstanding segment, see if it is time to resend
				it. */
				ulAge = ulTimerGetAge( &pxSegment->xTransmitTimer );
 800d2de:	69bb      	ldr	r3, [r7, #24]
 800d2e0:	3310      	adds	r3, #16
 800d2e2:	4618      	mov	r0, r3
 800d2e4:	f7ff fb3a 	bl	800c95c <ulTimerGetAge>
 800d2e8:	6178      	str	r0, [r7, #20]

				/* After a packet has been sent for the first time, it will wait
				'1 * lSRTT' ms for an ACK. A second time it will wait '2 * lSRTT' ms,
				each time doubling the time-out */
				ulMaxAge = ( 1u << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );
 800d2ea:	68fb      	ldr	r3, [r7, #12]
 800d2ec:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d2ee:	461a      	mov	r2, r3
 800d2f0:	69bb      	ldr	r3, [r7, #24]
 800d2f2:	7d1b      	ldrb	r3, [r3, #20]
 800d2f4:	fa02 f303 	lsl.w	r3, r2, r3
 800d2f8:	613b      	str	r3, [r7, #16]

				if( ulMaxAge > ulAge )
 800d2fa:	693a      	ldr	r2, [r7, #16]
 800d2fc:	697b      	ldr	r3, [r7, #20]
 800d2fe:	429a      	cmp	r2, r3
 800d300:	d904      	bls.n	800d30c <xTCPWindowTxHasData+0x60>
				{
					/* A segment must be sent after this amount of msecs */
					*pulDelay = ulMaxAge - ulAge;
 800d302:	693a      	ldr	r2, [r7, #16]
 800d304:	697b      	ldr	r3, [r7, #20]
 800d306:	1ad2      	subs	r2, r2, r3
 800d308:	687b      	ldr	r3, [r7, #4]
 800d30a:	601a      	str	r2, [r3, #0]
				}

				xReturn = pdTRUE;
 800d30c:	2301      	movs	r3, #1
 800d30e:	61fb      	str	r3, [r7, #28]
 800d310:	e027      	b.n	800d362 <xTCPWindowTxHasData+0xb6>
			}
			else
			{
				/* No priority segment, no outstanding data, see if there is new
				transmission data. */
				pxSegment = xTCPWindowPeekHead( &pxWindow->xTxQueue );
 800d312:	68fb      	ldr	r3, [r7, #12]
 800d314:	3354      	adds	r3, #84	; 0x54
 800d316:	4618      	mov	r0, r3
 800d318:	f7ff fc6e 	bl	800cbf8 <xTCPWindowPeekHead>
 800d31c:	61b8      	str	r0, [r7, #24]

				/* See if it fits in the peer's reception window. */
				if( pxSegment == NULL )
 800d31e:	69bb      	ldr	r3, [r7, #24]
 800d320:	2b00      	cmp	r3, #0
 800d322:	d102      	bne.n	800d32a <xTCPWindowTxHasData+0x7e>
				{
					xReturn = pdFALSE;
 800d324:	2300      	movs	r3, #0
 800d326:	61fb      	str	r3, [r7, #28]
 800d328:	e01b      	b.n	800d362 <xTCPWindowTxHasData+0xb6>
				}
				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
 800d32a:	68f8      	ldr	r0, [r7, #12]
 800d32c:	68b9      	ldr	r1, [r7, #8]
 800d32e:	f7ff ff77 	bl	800d220 <prvTCPWindowTxHasSpace>
 800d332:	4603      	mov	r3, r0
 800d334:	2b00      	cmp	r3, #0
 800d336:	d102      	bne.n	800d33e <xTCPWindowTxHasData+0x92>
				{
					/* Too many outstanding messages. */
					xReturn = pdFALSE;
 800d338:	2300      	movs	r3, #0
 800d33a:	61fb      	str	r3, [r7, #28]
 800d33c:	e011      	b.n	800d362 <xTCPWindowTxHasData+0xb6>
				}
				else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength < pxSegment->lMaxLength ) )
 800d33e:	68fb      	ldr	r3, [r7, #12]
 800d340:	781b      	ldrb	r3, [r3, #0]
 800d342:	f003 0302 	and.w	r3, r3, #2
 800d346:	b2db      	uxtb	r3, r3
 800d348:	2b00      	cmp	r3, #0
 800d34a:	d008      	beq.n	800d35e <xTCPWindowTxHasData+0xb2>
 800d34c:	69bb      	ldr	r3, [r7, #24]
 800d34e:	689a      	ldr	r2, [r3, #8]
 800d350:	69bb      	ldr	r3, [r7, #24]
 800d352:	685b      	ldr	r3, [r3, #4]
 800d354:	429a      	cmp	r2, r3
 800d356:	da02      	bge.n	800d35e <xTCPWindowTxHasData+0xb2>
				{
					/* 'bSendFullSize' is a special optimisation.  If true, the
					driver will only sent completely filled packets (of MSS
					bytes). */
					xReturn = pdFALSE;
 800d358:	2300      	movs	r3, #0
 800d35a:	61fb      	str	r3, [r7, #28]
 800d35c:	e001      	b.n	800d362 <xTCPWindowTxHasData+0xb6>
				}
				else
				{
					xReturn = pdTRUE;
 800d35e:	2301      	movs	r3, #1
 800d360:	61fb      	str	r3, [r7, #28]
				}
			}
		}

		return xReturn;
 800d362:	69fb      	ldr	r3, [r7, #28]
	}
 800d364:	4618      	mov	r0, r3
 800d366:	3720      	adds	r7, #32
 800d368:	46bd      	mov	sp, r7
 800d36a:	bd80      	pop	{r7, pc}

0800d36c <ulTCPWindowTxGet>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxGet( TCPWindow_t *pxWindow, uint32_t ulWindowSize, int32_t *plPosition )
	{
 800d36c:	b580      	push	{r7, lr}
 800d36e:	b088      	sub	sp, #32
 800d370:	af00      	add	r7, sp, #0
 800d372:	60f8      	str	r0, [r7, #12]
 800d374:	60b9      	str	r1, [r7, #8]
 800d376:	607a      	str	r2, [r7, #4]
	TCPSegment_t *pxSegment;
	uint32_t ulMaxTime;
	uint32_t ulReturn  = ~0UL;
 800d378:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 800d37c:	61bb      	str	r3, [r7, #24]

		/* Fetches data to be sent-out now.

		Priority messages: segments with a resend need no check current sliding
		window size. */
		pxSegment = xTCPWindowGetHead( &( pxWindow->xPriorityQueue ) );
 800d37e:	68fb      	ldr	r3, [r7, #12]
 800d380:	3340      	adds	r3, #64	; 0x40
 800d382:	4618      	mov	r0, r3
 800d384:	f7ff fc1a 	bl	800cbbc <xTCPWindowGetHead>
 800d388:	61f8      	str	r0, [r7, #28]
		pxWindow->ulOurSequenceNumber = pxWindow->tx.ulHighestSequenceNumber;
 800d38a:	68fb      	ldr	r3, [r7, #12]
 800d38c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 800d38e:	68fb      	ldr	r3, [r7, #12]
 800d390:	62da      	str	r2, [r3, #44]	; 0x2c

		if( pxSegment == NULL )
 800d392:	69fb      	ldr	r3, [r7, #28]
 800d394:	2b00      	cmp	r3, #0
 800d396:	d16e      	bne.n	800d476 <ulTCPWindowTxGet+0x10a>
		{
			/* Waiting messages: outstanding messages with a running timer
			neither check peer's reception window size because these packets
			have been sent earlier. */
			pxSegment = xTCPWindowPeekHead( &( pxWindow->xWaitQueue ) );
 800d398:	68fb      	ldr	r3, [r7, #12]
 800d39a:	3368      	adds	r3, #104	; 0x68
 800d39c:	4618      	mov	r0, r3
 800d39e:	f7ff fc2b 	bl	800cbf8 <xTCPWindowPeekHead>
 800d3a2:	61f8      	str	r0, [r7, #28]

			if( pxSegment != NULL )
 800d3a4:	69fb      	ldr	r3, [r7, #28]
 800d3a6:	2b00      	cmp	r3, #0
 800d3a8:	d01f      	beq.n	800d3ea <ulTCPWindowTxGet+0x7e>
			{
				/* Do check the timing. */
				ulMaxTime = ( 1u << pxSegment->u.bits.ucTransmitCount ) * ( ( uint32_t ) pxWindow->lSRTT );
 800d3aa:	68fb      	ldr	r3, [r7, #12]
 800d3ac:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d3ae:	461a      	mov	r2, r3
 800d3b0:	69fb      	ldr	r3, [r7, #28]
 800d3b2:	7d1b      	ldrb	r3, [r3, #20]
 800d3b4:	fa02 f303 	lsl.w	r3, r2, r3
 800d3b8:	617b      	str	r3, [r7, #20]

				if( ulTimerGetAge( &pxSegment->xTransmitTimer ) > ulMaxTime )
 800d3ba:	69fb      	ldr	r3, [r7, #28]
 800d3bc:	3310      	adds	r3, #16
 800d3be:	4618      	mov	r0, r3
 800d3c0:	f7ff facc 	bl	800c95c <ulTimerGetAge>
 800d3c4:	4602      	mov	r2, r0
 800d3c6:	697b      	ldr	r3, [r7, #20]
 800d3c8:	429a      	cmp	r2, r3
 800d3ca:	d90c      	bls.n	800d3e6 <ulTCPWindowTxGet+0x7a>
				{
					/* A normal (non-fast) retransmission.  Move it from the
					head of the waiting queue. */
					pxSegment = xTCPWindowGetHead( &( pxWindow->xWaitQueue ) );
 800d3cc:	68fb      	ldr	r3, [r7, #12]
 800d3ce:	3368      	adds	r3, #104	; 0x68
 800d3d0:	4618      	mov	r0, r3
 800d3d2:	f7ff fbf3 	bl	800cbbc <xTCPWindowGetHead>
 800d3d6:	61f8      	str	r0, [r7, #28]
					pxSegment->u.bits.ucDupAckCount = pdFALSE_UNSIGNED;
 800d3d8:	69fb      	ldr	r3, [r7, #28]
 800d3da:	2200      	movs	r2, #0
 800d3dc:	755a      	strb	r2, [r3, #21]

					/* Some detailed logging. */
					if( ( xTCPWindowLoggingLevel != 0 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != 0 ) )
 800d3de:	4b4c      	ldr	r3, [pc, #304]	; (800d510 <ulTCPWindowTxGet+0x1a4>)
 800d3e0:	681b      	ldr	r3, [r3, #0]
 800d3e2:	2b00      	cmp	r3, #0
 800d3e4:	e001      	b.n	800d3ea <ulTCPWindowTxGet+0x7e>
						FreeRTOS_flush_logging( );
					}
				}
				else
				{
					pxSegment = NULL;
 800d3e6:	2300      	movs	r3, #0
 800d3e8:	61fb      	str	r3, [r7, #28]
				}
			}

			if( pxSegment == NULL )
 800d3ea:	69fb      	ldr	r3, [r7, #28]
 800d3ec:	2b00      	cmp	r3, #0
 800d3ee:	d142      	bne.n	800d476 <ulTCPWindowTxGet+0x10a>
			{
				/* New messages: sent-out for the first time.  Check current
				sliding window size of peer. */
				pxSegment = xTCPWindowPeekHead( &( pxWindow->xTxQueue ) );
 800d3f0:	68fb      	ldr	r3, [r7, #12]
 800d3f2:	3354      	adds	r3, #84	; 0x54
 800d3f4:	4618      	mov	r0, r3
 800d3f6:	f7ff fbff 	bl	800cbf8 <xTCPWindowPeekHead>
 800d3fa:	61f8      	str	r0, [r7, #28]

				if( pxSegment == NULL )
 800d3fc:	69fb      	ldr	r3, [r7, #28]
 800d3fe:	2b00      	cmp	r3, #0
 800d400:	d102      	bne.n	800d408 <ulTCPWindowTxGet+0x9c>
				{
					/* No segments queued. */
					ulReturn = 0UL;
 800d402:	2300      	movs	r3, #0
 800d404:	61bb      	str	r3, [r7, #24]
 800d406:	e036      	b.n	800d476 <ulTCPWindowTxGet+0x10a>
				}
				else if( ( pxWindow->u.bits.bSendFullSize != pdFALSE_UNSIGNED ) && ( pxSegment->lDataLength < pxSegment->lMaxLength ) )
 800d408:	68fb      	ldr	r3, [r7, #12]
 800d40a:	781b      	ldrb	r3, [r3, #0]
 800d40c:	f003 0302 	and.w	r3, r3, #2
 800d410:	b2db      	uxtb	r3, r3
 800d412:	2b00      	cmp	r3, #0
 800d414:	d008      	beq.n	800d428 <ulTCPWindowTxGet+0xbc>
 800d416:	69fb      	ldr	r3, [r7, #28]
 800d418:	689a      	ldr	r2, [r3, #8]
 800d41a:	69fb      	ldr	r3, [r7, #28]
 800d41c:	685b      	ldr	r3, [r3, #4]
 800d41e:	429a      	cmp	r2, r3
 800d420:	da02      	bge.n	800d428 <ulTCPWindowTxGet+0xbc>
				{
					/* A segment has been queued but the driver waits until it
					has a full size of MSS. */
					ulReturn = 0;
 800d422:	2300      	movs	r3, #0
 800d424:	61bb      	str	r3, [r7, #24]
 800d426:	e026      	b.n	800d476 <ulTCPWindowTxGet+0x10a>
				}
				else if( prvTCPWindowTxHasSpace( pxWindow, ulWindowSize ) == pdFALSE )
 800d428:	68f8      	ldr	r0, [r7, #12]
 800d42a:	68b9      	ldr	r1, [r7, #8]
 800d42c:	f7ff fef8 	bl	800d220 <prvTCPWindowTxHasSpace>
 800d430:	4603      	mov	r3, r0
 800d432:	2b00      	cmp	r3, #0
 800d434:	d102      	bne.n	800d43c <ulTCPWindowTxGet+0xd0>
				{
					/* Peer has no more space at this moment. */
					ulReturn = 0;
 800d436:	2300      	movs	r3, #0
 800d438:	61bb      	str	r3, [r7, #24]
 800d43a:	e01c      	b.n	800d476 <ulTCPWindowTxGet+0x10a>
				}
				else
				{
					/* Move it out of the Tx queue. */
					pxSegment = xTCPWindowGetHead( &( pxWindow->xTxQueue ) );
 800d43c:	68fb      	ldr	r3, [r7, #12]
 800d43e:	3354      	adds	r3, #84	; 0x54
 800d440:	4618      	mov	r0, r3
 800d442:	f7ff fbbb 	bl	800cbbc <xTCPWindowGetHead>
 800d446:	61f8      	str	r0, [r7, #28]

					/* Don't let pxHeadSegment point to this segment any more,
					so no more data will be added. */
					if( pxWindow->pxHeadSegment == pxSegment )
 800d448:	68fb      	ldr	r3, [r7, #12]
 800d44a:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 800d44c:	69fb      	ldr	r3, [r7, #28]
 800d44e:	429a      	cmp	r2, r3
 800d450:	d102      	bne.n	800d458 <ulTCPWindowTxGet+0xec>
					{
						pxWindow->pxHeadSegment = NULL;
 800d452:	68fb      	ldr	r3, [r7, #12]
 800d454:	2200      	movs	r2, #0
 800d456:	67da      	str	r2, [r3, #124]	; 0x7c
					}

					/* pxWindow->tx.highest registers the highest sequence
					number in our transmission window. */
					pxWindow->tx.ulHighestSequenceNumber = pxSegment->ulSequenceNumber + ( ( uint32_t ) pxSegment->lDataLength );
 800d458:	69fb      	ldr	r3, [r7, #28]
 800d45a:	681b      	ldr	r3, [r3, #0]
 800d45c:	69fa      	ldr	r2, [r7, #28]
 800d45e:	6892      	ldr	r2, [r2, #8]
 800d460:	441a      	add	r2, r3
 800d462:	68fb      	ldr	r3, [r7, #12]
 800d464:	629a      	str	r2, [r3, #40]	; 0x28

					/* ...and more detailed logging */
					if( ( xTCPWindowLoggingLevel >= 2 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != pdFALSE ) )
 800d466:	4b2a      	ldr	r3, [pc, #168]	; (800d510 <ulTCPWindowTxGet+0x1a4>)
 800d468:	681b      	ldr	r3, [r3, #0]
 800d46a:	2b01      	cmp	r3, #1
 800d46c:	dd03      	ble.n	800d476 <ulTCPWindowTxGet+0x10a>
 800d46e:	68fb      	ldr	r3, [r7, #12]
 800d470:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
 800d474:	2b17      	cmp	r3, #23
				FreeRTOS_flush_logging( );
			}
		}

		/* See if it has already been determined to return 0. */
		if( ulReturn != 0UL )
 800d476:	69bb      	ldr	r3, [r7, #24]
 800d478:	2b00      	cmp	r3, #0
 800d47a:	d043      	beq.n	800d504 <ulTCPWindowTxGet+0x198>
		{
			configASSERT( listLIST_ITEM_CONTAINER( &(pxSegment->xQueueItem ) ) == NULL );
 800d47c:	69fb      	ldr	r3, [r7, #28]
 800d47e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d480:	2b00      	cmp	r3, #0
 800d482:	d009      	beq.n	800d498 <ulTCPWindowTxGet+0x12c>
 800d484:	f04f 0350 	mov.w	r3, #80	; 0x50
 800d488:	f383 8811 	msr	BASEPRI, r3
 800d48c:	f3bf 8f6f 	isb	sy
 800d490:	f3bf 8f4f 	dsb	sy
 800d494:	613b      	str	r3, [r7, #16]
 800d496:	e7fe      	b.n	800d496 <ulTCPWindowTxGet+0x12a>

			/* Now that the segment will be transmitted, add it to the tail of
			the waiting queue. */
			vListInsertFifo( &pxWindow->xWaitQueue, &pxSegment->xQueueItem );
 800d498:	68fb      	ldr	r3, [r7, #12]
 800d49a:	f103 0268 	add.w	r2, r3, #104	; 0x68
 800d49e:	69fb      	ldr	r3, [r7, #28]
 800d4a0:	3318      	adds	r3, #24
 800d4a2:	4610      	mov	r0, r2
 800d4a4:	4619      	mov	r1, r3
 800d4a6:	f7ff fa3d 	bl	800c924 <vListInsertFifo>

			/* And mark it as outstanding. */
			pxSegment->u.bits.bOutstanding = pdTRUE_UNSIGNED;
 800d4aa:	69fa      	ldr	r2, [r7, #28]
 800d4ac:	7d93      	ldrb	r3, [r2, #22]
 800d4ae:	f043 0301 	orr.w	r3, r3, #1
 800d4b2:	7593      	strb	r3, [r2, #22]

			/* Administer the transmit count, needed for fast
			retransmissions. */
			( pxSegment->u.bits.ucTransmitCount )++;
 800d4b4:	69fb      	ldr	r3, [r7, #28]
 800d4b6:	7d1b      	ldrb	r3, [r3, #20]
 800d4b8:	3301      	adds	r3, #1
 800d4ba:	b2da      	uxtb	r2, r3
 800d4bc:	69fb      	ldr	r3, [r7, #28]
 800d4be:	751a      	strb	r2, [r3, #20]

			/* If there have been several retransmissions (4), decrease the
			size of the transmission window to at most 2 times MSS. */
			if( pxSegment->u.bits.ucTransmitCount == MAX_TRANSMIT_COUNT_USING_LARGE_WINDOW )
 800d4c0:	69fb      	ldr	r3, [r7, #28]
 800d4c2:	7d1b      	ldrb	r3, [r3, #20]
 800d4c4:	2b04      	cmp	r3, #4
 800d4c6:	d10d      	bne.n	800d4e4 <ulTCPWindowTxGet+0x178>
			{
				if( pxWindow->xSize.ulTxWindowLength > ( 2U * pxWindow->usMSS ) )
 800d4c8:	68fb      	ldr	r3, [r7, #12]
 800d4ca:	689a      	ldr	r2, [r3, #8]
 800d4cc:	68fb      	ldr	r3, [r7, #12]
 800d4ce:	f8b3 30bc 	ldrh.w	r3, [r3, #188]	; 0xbc
 800d4d2:	005b      	lsls	r3, r3, #1
 800d4d4:	429a      	cmp	r2, r3
 800d4d6:	d905      	bls.n	800d4e4 <ulTCPWindowTxGet+0x178>
				{
					FreeRTOS_debug_printf( ( "ulTCPWindowTxGet[%u - %d]: Change Tx window: %lu -> %u\n",
						pxWindow->usPeerPortNumber, pxWindow->usOurPortNumber,
						pxWindow->xSize.ulTxWindowLength, 2 * pxWindow->usMSS ) );
					pxWindow->xSize.ulTxWindowLength = ( 2UL * pxWindow->usMSS );
 800d4d8:	68fb      	ldr	r3, [r7, #12]
 800d4da:	f8b3 30bc 	ldrh.w	r3, [r3, #188]	; 0xbc
 800d4de:	005a      	lsls	r2, r3, #1
 800d4e0:	68fb      	ldr	r3, [r7, #12]
 800d4e2:	609a      	str	r2, [r3, #8]
				}
			}

			/* Clear the transmit timer. */
			vTCPTimerSet( &( pxSegment->xTransmitTimer ) );
 800d4e4:	69fb      	ldr	r3, [r7, #28]
 800d4e6:	3310      	adds	r3, #16
 800d4e8:	4618      	mov	r0, r3
 800d4ea:	f7ff fa2b 	bl	800c944 <vTCPTimerSet>

			pxWindow->ulOurSequenceNumber = pxSegment->ulSequenceNumber;
 800d4ee:	69fb      	ldr	r3, [r7, #28]
 800d4f0:	681a      	ldr	r2, [r3, #0]
 800d4f2:	68fb      	ldr	r3, [r7, #12]
 800d4f4:	62da      	str	r2, [r3, #44]	; 0x2c

			/* Inform the caller where to find the data within the queue. */
			*plPosition = pxSegment->lStreamPos;
 800d4f6:	69fb      	ldr	r3, [r7, #28]
 800d4f8:	68da      	ldr	r2, [r3, #12]
 800d4fa:	687b      	ldr	r3, [r7, #4]
 800d4fc:	601a      	str	r2, [r3, #0]

			/* And return the length of the data segment */
			ulReturn = ( uint32_t ) pxSegment->lDataLength;
 800d4fe:	69fb      	ldr	r3, [r7, #28]
 800d500:	689b      	ldr	r3, [r3, #8]
 800d502:	61bb      	str	r3, [r7, #24]
		}

		return ulReturn;
 800d504:	69bb      	ldr	r3, [r7, #24]
	}
 800d506:	4618      	mov	r0, r3
 800d508:	3720      	adds	r7, #32
 800d50a:	46bd      	mov	sp, r7
 800d50c:	bd80      	pop	{r7, pc}
 800d50e:	bf00      	nop
 800d510:	2000c2b4 	.word	0x2000c2b4

0800d514 <prvTCPWindowTxCheckAck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static uint32_t prvTCPWindowTxCheckAck( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
	{
 800d514:	b580      	push	{r7, lr}
 800d516:	b08c      	sub	sp, #48	; 0x30
 800d518:	af00      	add	r7, sp, #0
 800d51a:	60f8      	str	r0, [r7, #12]
 800d51c:	60b9      	str	r1, [r7, #8]
 800d51e:	607a      	str	r2, [r7, #4]
	uint32_t ulBytesConfirmed = 0u;
 800d520:	2300      	movs	r3, #0
 800d522:	62fb      	str	r3, [r7, #44]	; 0x2c
	uint32_t ulSequenceNumber = ulFirst, ulDataLength;
 800d524:	68bb      	ldr	r3, [r7, #8]
 800d526:	62bb      	str	r3, [r7, #40]	; 0x28
	const ListItem_t *pxIterator;
	const MiniListItem_t *pxEnd = ( const MiniListItem_t* )listGET_END_MARKER( &pxWindow->xTxSegments );
 800d528:	68fb      	ldr	r3, [r7, #12]
 800d52a:	3398      	adds	r3, #152	; 0x98
 800d52c:	61fb      	str	r3, [r7, #28]

		 A Smoothed RTT will increase quickly, but it is conservative when
		 becoming smaller. */

		for(
				pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 800d52e:	69fb      	ldr	r3, [r7, #28]
 800d530:	685b      	ldr	r3, [r3, #4]
 800d532:	627b      	str	r3, [r7, #36]	; 0x24
		  RTO is Retransmit timeout

		 A Smoothed RTT will increase quickly, but it is conservative when
		 becoming smaller. */

		for(
 800d534:	e09c      	b.n	800d670 <prvTCPWindowTxCheckAck+0x15c>
				pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
				( pxIterator != ( const ListItem_t * ) pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 );
			)
		{
			xDoUnlink = pdFALSE;
 800d536:	2300      	movs	r3, #0
 800d538:	623b      	str	r3, [r7, #32]
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800d53a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d53c:	68db      	ldr	r3, [r3, #12]
 800d53e:	61bb      	str	r3, [r7, #24]

			/* Move to the next item because the current item might get
			removed. */
			pxIterator = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 800d540:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800d542:	685b      	ldr	r3, [r3, #4]
 800d544:	627b      	str	r3, [r7, #36]	; 0x24

			/* Continue if this segment does not fall within the ACK'd range. */
			if( xSequenceGreaterThan( ulSequenceNumber, pxSegment->ulSequenceNumber ) != pdFALSE )
 800d546:	69bb      	ldr	r3, [r7, #24]
 800d548:	681b      	ldr	r3, [r3, #0]
 800d54a:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d54c:	4619      	mov	r1, r3
 800d54e:	f7ff f9c5 	bl	800c8dc <xSequenceGreaterThan>
 800d552:	4603      	mov	r3, r0
 800d554:	2b00      	cmp	r3, #0
 800d556:	d000      	beq.n	800d55a <prvTCPWindowTxCheckAck+0x46>
			{
				continue;
 800d558:	e08a      	b.n	800d670 <prvTCPWindowTxCheckAck+0x15c>
			}

			/* Is it ready? */
			if( ulSequenceNumber != pxSegment->ulSequenceNumber )
 800d55a:	69bb      	ldr	r3, [r7, #24]
 800d55c:	681a      	ldr	r2, [r3, #0]
 800d55e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d560:	429a      	cmp	r2, r3
 800d562:	d000      	beq.n	800d566 <prvTCPWindowTxCheckAck+0x52>
			{
				break;
 800d564:	e090      	b.n	800d688 <prvTCPWindowTxCheckAck+0x174>
			}

			ulDataLength = ( uint32_t ) pxSegment->lDataLength;
 800d566:	69bb      	ldr	r3, [r7, #24]
 800d568:	689b      	ldr	r3, [r3, #8]
 800d56a:	617b      	str	r3, [r7, #20]

			if( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED )
 800d56c:	69bb      	ldr	r3, [r7, #24]
 800d56e:	7d9b      	ldrb	r3, [r3, #22]
 800d570:	f003 0302 	and.w	r3, r3, #2
 800d574:	b2db      	uxtb	r3, r3
 800d576:	2b00      	cmp	r3, #0
 800d578:	d14e      	bne.n	800d618 <prvTCPWindowTxCheckAck+0x104>
			{
				if( xSequenceGreaterThan( pxSegment->ulSequenceNumber + ( uint32_t )ulDataLength, ulLast ) != pdFALSE )
 800d57a:	69bb      	ldr	r3, [r7, #24]
 800d57c:	681a      	ldr	r2, [r3, #0]
 800d57e:	697b      	ldr	r3, [r7, #20]
 800d580:	4413      	add	r3, r2
 800d582:	4618      	mov	r0, r3
 800d584:	6879      	ldr	r1, [r7, #4]
 800d586:	f7ff f9a9 	bl	800c8dc <xSequenceGreaterThan>
 800d58a:	4603      	mov	r3, r0
 800d58c:	2b00      	cmp	r3, #0
 800d58e:	d000      	beq.n	800d592 <prvTCPWindowTxCheckAck+0x7e>
							ulFirstSeq - pxWindow->tx.ulFirstSequenceNumber,
							ulLast - pxWindow->tx.ulFirstSequenceNumber,
							ulFirstSeq, ulFirstSeq + ulDataLength ) );
					}
					#endif /* ipconfigHAS_DEBUG_PRINTF */
					break;
 800d590:	e07a      	b.n	800d688 <prvTCPWindowTxCheckAck+0x174>
				}

				/* This segment is fully ACK'd, set the flag. */
				pxSegment->u.bits.bAcked = pdTRUE_UNSIGNED;
 800d592:	69ba      	ldr	r2, [r7, #24]
 800d594:	7d93      	ldrb	r3, [r2, #22]
 800d596:	f043 0302 	orr.w	r3, r3, #2
 800d59a:	7593      	strb	r3, [r2, #22]

				/* Calculate the RTT only if the segment was sent-out for the
				first time and if this is the last ACK'd segment in a range. */
				if( ( pxSegment->u.bits.ucTransmitCount == 1 ) && ( ( pxSegment->ulSequenceNumber + ulDataLength ) == ulLast ) )
 800d59c:	69bb      	ldr	r3, [r7, #24]
 800d59e:	7d1b      	ldrb	r3, [r3, #20]
 800d5a0:	2b01      	cmp	r3, #1
 800d5a2:	d137      	bne.n	800d614 <prvTCPWindowTxCheckAck+0x100>
 800d5a4:	69bb      	ldr	r3, [r7, #24]
 800d5a6:	681a      	ldr	r2, [r3, #0]
 800d5a8:	697b      	ldr	r3, [r7, #20]
 800d5aa:	441a      	add	r2, r3
 800d5ac:	687b      	ldr	r3, [r7, #4]
 800d5ae:	429a      	cmp	r2, r3
 800d5b0:	d130      	bne.n	800d614 <prvTCPWindowTxCheckAck+0x100>
				{
					int32_t mS = ( int32_t ) ulTimerGetAge( &( pxSegment->xTransmitTimer ) );
 800d5b2:	69bb      	ldr	r3, [r7, #24]
 800d5b4:	3310      	adds	r3, #16
 800d5b6:	4618      	mov	r0, r3
 800d5b8:	f7ff f9d0 	bl	800c95c <ulTimerGetAge>
 800d5bc:	4603      	mov	r3, r0
 800d5be:	613b      	str	r3, [r7, #16]

					if( pxWindow->lSRTT >= mS )
 800d5c0:	68fb      	ldr	r3, [r7, #12]
 800d5c2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800d5c4:	693b      	ldr	r3, [r7, #16]
 800d5c6:	429a      	cmp	r2, r3
 800d5c8:	db0e      	blt.n	800d5e8 <prvTCPWindowTxCheckAck+0xd4>
					{
						/* RTT becomes smaller: adapt slowly. */
						pxWindow->lSRTT = ( ( winSRTT_DECREMENT_NEW * mS ) + ( winSRTT_DECREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_DECREMENT_NEW + winSRTT_DECREMENT_CURRENT );
 800d5ca:	68fb      	ldr	r3, [r7, #12]
 800d5cc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800d5ce:	4613      	mov	r3, r2
 800d5d0:	00db      	lsls	r3, r3, #3
 800d5d2:	1a9a      	subs	r2, r3, r2
 800d5d4:	693b      	ldr	r3, [r7, #16]
 800d5d6:	4413      	add	r3, r2
 800d5d8:	2b00      	cmp	r3, #0
 800d5da:	da00      	bge.n	800d5de <prvTCPWindowTxCheckAck+0xca>
 800d5dc:	3307      	adds	r3, #7
 800d5de:	10db      	asrs	r3, r3, #3
 800d5e0:	461a      	mov	r2, r3
 800d5e2:	68fb      	ldr	r3, [r7, #12]
 800d5e4:	639a      	str	r2, [r3, #56]	; 0x38
 800d5e6:	e00e      	b.n	800d606 <prvTCPWindowTxCheckAck+0xf2>
					}
					else
					{
						/* RTT becomes larger: adapt quicker */
						pxWindow->lSRTT = ( ( winSRTT_INCREMENT_NEW * mS ) + ( winSRTT_INCREMENT_CURRENT * pxWindow->lSRTT ) ) / ( winSRTT_INCREMENT_NEW + winSRTT_INCREMENT_CURRENT );
 800d5e8:	68fb      	ldr	r3, [r7, #12]
 800d5ea:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800d5ec:	4613      	mov	r3, r2
 800d5ee:	005b      	lsls	r3, r3, #1
 800d5f0:	441a      	add	r2, r3
 800d5f2:	693b      	ldr	r3, [r7, #16]
 800d5f4:	4413      	add	r3, r2
 800d5f6:	005b      	lsls	r3, r3, #1
 800d5f8:	2b00      	cmp	r3, #0
 800d5fa:	da00      	bge.n	800d5fe <prvTCPWindowTxCheckAck+0xea>
 800d5fc:	3307      	adds	r3, #7
 800d5fe:	10db      	asrs	r3, r3, #3
 800d600:	461a      	mov	r2, r3
 800d602:	68fb      	ldr	r3, [r7, #12]
 800d604:	639a      	str	r2, [r3, #56]	; 0x38
					}

					/* Cap to the minimum of 50ms. */
					if( pxWindow->lSRTT < winSRTT_CAP_mS )
 800d606:	68fb      	ldr	r3, [r7, #12]
 800d608:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800d60a:	2b31      	cmp	r3, #49	; 0x31
 800d60c:	dc02      	bgt.n	800d614 <prvTCPWindowTxCheckAck+0x100>
					{
						pxWindow->lSRTT = winSRTT_CAP_mS;
 800d60e:	68fb      	ldr	r3, [r7, #12]
 800d610:	2232      	movs	r2, #50	; 0x32
 800d612:	639a      	str	r2, [r3, #56]	; 0x38
					}
				}

				/* Unlink it from the 3 queues, but do not destroy it (yet). */
				xDoUnlink = pdTRUE;
 800d614:	2301      	movs	r3, #1
 800d616:	623b      	str	r3, [r7, #32]
			}

			/* pxSegment->u.bits.bAcked is now true.  Is it located at the left
			side of the transmission queue?  If so, it may be freed. */
			if( ulSequenceNumber == pxWindow->tx.ulCurrentSequenceNumber )
 800d618:	68fb      	ldr	r3, [r7, #12]
 800d61a:	6a1a      	ldr	r2, [r3, #32]
 800d61c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800d61e:	429a      	cmp	r2, r3
 800d620:	d116      	bne.n	800d650 <prvTCPWindowTxCheckAck+0x13c>
			{
				if( ( xTCPWindowLoggingLevel >= 2 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != pdFALSE ) )
 800d622:	4b1c      	ldr	r3, [pc, #112]	; (800d694 <prvTCPWindowTxCheckAck+0x180>)
 800d624:	681b      	ldr	r3, [r3, #0]
 800d626:	2b01      	cmp	r3, #1
 800d628:	dd03      	ble.n	800d632 <prvTCPWindowTxCheckAck+0x11e>
 800d62a:	68fb      	ldr	r3, [r7, #12]
 800d62c:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
 800d630:	2b17      	cmp	r3, #23
						ulLast - pxWindow->tx.ulFirstSequenceNumber,
						pxSegment->ulSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) );
				}

				/* Increase the left-hand value of the transmission window. */
				pxWindow->tx.ulCurrentSequenceNumber += ulDataLength;
 800d632:	68fb      	ldr	r3, [r7, #12]
 800d634:	6a1a      	ldr	r2, [r3, #32]
 800d636:	697b      	ldr	r3, [r7, #20]
 800d638:	441a      	add	r2, r3
 800d63a:	68fb      	ldr	r3, [r7, #12]
 800d63c:	621a      	str	r2, [r3, #32]

				/* This function will return the number of bytes that the tail
				of txStream may be advanced. */
				ulBytesConfirmed += ulDataLength;
 800d63e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800d640:	697b      	ldr	r3, [r7, #20]
 800d642:	4413      	add	r3, r2
 800d644:	62fb      	str	r3, [r7, #44]	; 0x2c

				/* All segments below tx.ulCurrentSequenceNumber may be freed. */
				vTCPWindowFree( pxSegment );
 800d646:	69b8      	ldr	r0, [r7, #24]
 800d648:	f7ff faf4 	bl	800cc34 <vTCPWindowFree>

				/* No need to unlink it any more. */
				xDoUnlink = pdFALSE;
 800d64c:	2300      	movs	r3, #0
 800d64e:	623b      	str	r3, [r7, #32]
			}

			if( ( xDoUnlink != pdFALSE ) && ( listLIST_ITEM_CONTAINER( &( pxSegment->xQueueItem ) ) != NULL ) )
 800d650:	6a3b      	ldr	r3, [r7, #32]
 800d652:	2b00      	cmp	r3, #0
 800d654:	d008      	beq.n	800d668 <prvTCPWindowTxCheckAck+0x154>
 800d656:	69bb      	ldr	r3, [r7, #24]
 800d658:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800d65a:	2b00      	cmp	r3, #0
 800d65c:	d004      	beq.n	800d668 <prvTCPWindowTxCheckAck+0x154>
			{
				/* Remove item from its queues. */
				uxListRemove( &pxSegment->xQueueItem );
 800d65e:	69bb      	ldr	r3, [r7, #24]
 800d660:	3318      	adds	r3, #24
 800d662:	4618      	mov	r0, r3
 800d664:	f7f6 faea 	bl	8003c3c <uxListRemove>
			}

			ulSequenceNumber += ulDataLength;
 800d668:	6aba      	ldr	r2, [r7, #40]	; 0x28
 800d66a:	697b      	ldr	r3, [r7, #20]
 800d66c:	4413      	add	r3, r2
 800d66e:	62bb      	str	r3, [r7, #40]	; 0x28
		  RTO is Retransmit timeout

		 A Smoothed RTT will increase quickly, but it is conservative when
		 becoming smaller. */

		for(
 800d670:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 800d672:	69fb      	ldr	r3, [r7, #28]
 800d674:	429a      	cmp	r2, r3
 800d676:	d007      	beq.n	800d688 <prvTCPWindowTxCheckAck+0x174>
				pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
				( pxIterator != ( const ListItem_t * ) pxEnd ) && ( xSequenceLessThan( ulSequenceNumber, ulLast ) != 0 );
 800d678:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 800d67a:	6879      	ldr	r1, [r7, #4]
 800d67c:	f7ff f91c 	bl	800c8b8 <xSequenceLessThan>
 800d680:	4603      	mov	r3, r0
 800d682:	2b00      	cmp	r3, #0
 800d684:	f47f af57 	bne.w	800d536 <prvTCPWindowTxCheckAck+0x22>
			}

			ulSequenceNumber += ulDataLength;
		}

		return ulBytesConfirmed;
 800d688:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	}
 800d68a:	4618      	mov	r0, r3
 800d68c:	3730      	adds	r7, #48	; 0x30
 800d68e:	46bd      	mov	sp, r7
 800d690:	bd80      	pop	{r7, pc}
 800d692:	bf00      	nop
 800d694:	2000c2b4 	.word	0x2000c2b4

0800d698 <prvTCPWindowFastRetransmit>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	static uint32_t prvTCPWindowFastRetransmit( TCPWindow_t *pxWindow, uint32_t ulFirst )
	{
 800d698:	b580      	push	{r7, lr}
 800d69a:	b086      	sub	sp, #24
 800d69c:	af00      	add	r7, sp, #0
 800d69e:	6078      	str	r0, [r7, #4]
 800d6a0:	6039      	str	r1, [r7, #0]
	const ListItem_t *pxIterator;
	const MiniListItem_t* pxEnd;
	TCPSegment_t *pxSegment;
	uint32_t ulCount = 0UL;
 800d6a2:	2300      	movs	r3, #0
 800d6a4:	613b      	str	r3, [r7, #16]

		/* A higher Tx block has been acknowledged.  Now iterate through the
		 xWaitQueue to find a possible condition for a FAST retransmission. */

		pxEnd = ( const MiniListItem_t* ) listGET_END_MARKER( &( pxWindow->xWaitQueue ) );
 800d6a6:	687b      	ldr	r3, [r7, #4]
 800d6a8:	3370      	adds	r3, #112	; 0x70
 800d6aa:	60fb      	str	r3, [r7, #12]

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 800d6ac:	68fb      	ldr	r3, [r7, #12]
 800d6ae:	685b      	ldr	r3, [r3, #4]
 800d6b0:	617b      	str	r3, [r7, #20]
 800d6b2:	e03b      	b.n	800d72c <prvTCPWindowFastRetransmit+0x94>
			 pxIterator != ( const ListItem_t * ) pxEnd; )
		{
			/* Get the owner, which is a TCP segment. */
			pxSegment = ( TCPSegment_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800d6b4:	697b      	ldr	r3, [r7, #20]
 800d6b6:	68db      	ldr	r3, [r3, #12]
 800d6b8:	60bb      	str	r3, [r7, #8]

			/* Hop to the next item before the current gets unlinked. */
			pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 800d6ba:	697b      	ldr	r3, [r7, #20]
 800d6bc:	685b      	ldr	r3, [r3, #4]
 800d6be:	617b      	str	r3, [r7, #20]

			/* Fast retransmission:
			When 3 packets with a higher sequence number have been acknowledged
			by the peer, it is very unlikely a current packet will ever arrive.
			It will be retransmitted far before the RTO. */
			if( ( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED ) &&
 800d6c0:	68bb      	ldr	r3, [r7, #8]
 800d6c2:	7d9b      	ldrb	r3, [r3, #22]
 800d6c4:	f003 0302 	and.w	r3, r3, #2
 800d6c8:	b2db      	uxtb	r3, r3
 800d6ca:	2b00      	cmp	r3, #0
 800d6cc:	d12e      	bne.n	800d72c <prvTCPWindowFastRetransmit+0x94>
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE ) &&
 800d6ce:	68bb      	ldr	r3, [r7, #8]
 800d6d0:	681b      	ldr	r3, [r3, #0]
 800d6d2:	4618      	mov	r0, r3
 800d6d4:	6839      	ldr	r1, [r7, #0]
 800d6d6:	f7ff f8ef 	bl	800c8b8 <xSequenceLessThan>
 800d6da:	4603      	mov	r3, r0

			/* Fast retransmission:
			When 3 packets with a higher sequence number have been acknowledged
			by the peer, it is very unlikely a current packet will ever arrive.
			It will be retransmitted far before the RTO. */
			if( ( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED ) &&
 800d6dc:	2b00      	cmp	r3, #0
 800d6de:	d025      	beq.n	800d72c <prvTCPWindowFastRetransmit+0x94>
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE ) &&
				( ++( pxSegment->u.bits.ucDupAckCount ) == DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT ) )
 800d6e0:	68bb      	ldr	r3, [r7, #8]
 800d6e2:	7d5b      	ldrb	r3, [r3, #21]
 800d6e4:	3301      	adds	r3, #1
 800d6e6:	b2da      	uxtb	r2, r3
			/* Fast retransmission:
			When 3 packets with a higher sequence number have been acknowledged
			by the peer, it is very unlikely a current packet will ever arrive.
			It will be retransmitted far before the RTO. */
			if( ( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED ) &&
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE ) &&
 800d6e8:	68bb      	ldr	r3, [r7, #8]
 800d6ea:	755a      	strb	r2, [r3, #21]
				( ++( pxSegment->u.bits.ucDupAckCount ) == DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT ) )
 800d6ec:	68bb      	ldr	r3, [r7, #8]
 800d6ee:	7d5b      	ldrb	r3, [r3, #21]
			/* Fast retransmission:
			When 3 packets with a higher sequence number have been acknowledged
			by the peer, it is very unlikely a current packet will ever arrive.
			It will be retransmitted far before the RTO. */
			if( ( pxSegment->u.bits.bAcked == pdFALSE_UNSIGNED ) &&
				( xSequenceLessThan( pxSegment->ulSequenceNumber, ulFirst ) != pdFALSE ) &&
 800d6f0:	2b03      	cmp	r3, #3
 800d6f2:	d11b      	bne.n	800d72c <prvTCPWindowFastRetransmit+0x94>
				( ++( pxSegment->u.bits.ucDupAckCount ) == DUPLICATE_ACKS_BEFORE_FAST_RETRANSMIT ) )
			{
				pxSegment->u.bits.ucTransmitCount = pdFALSE_UNSIGNED;
 800d6f4:	68bb      	ldr	r3, [r7, #8]
 800d6f6:	2200      	movs	r2, #0
 800d6f8:	751a      	strb	r2, [r3, #20]

				/* Not clearing 'ucDupAckCount' yet as more SACK's might come in
				which might lead to a second fast rexmit. */
				if( ( xTCPWindowLoggingLevel >= 0 ) && ( ipconfigTCP_MAY_LOG_PORT( pxWindow->usOurPortNumber ) != pdFALSE ) )
 800d6fa:	4b11      	ldr	r3, [pc, #68]	; (800d740 <prvTCPWindowFastRetransmit+0xa8>)
 800d6fc:	681b      	ldr	r3, [r3, #0]
 800d6fe:	2b00      	cmp	r3, #0
 800d700:	db03      	blt.n	800d70a <prvTCPWindowFastRetransmit+0x72>
 800d702:	687b      	ldr	r3, [r7, #4]
 800d704:	f8b3 30b8 	ldrh.w	r3, [r3, #184]	; 0xb8
 800d708:	2b17      	cmp	r3, #23
						ulFirst - pxWindow->tx.ulFirstSequenceNumber ) );
					FreeRTOS_flush_logging( );
				}

				/* Remove it from xWaitQueue. */
				uxListRemove( &pxSegment->xQueueItem );
 800d70a:	68bb      	ldr	r3, [r7, #8]
 800d70c:	3318      	adds	r3, #24
 800d70e:	4618      	mov	r0, r3
 800d710:	f7f6 fa94 	bl	8003c3c <uxListRemove>

				/* Add this segment to the priority queue so it gets
				retransmitted immediately. */
				vListInsertFifo( &( pxWindow->xPriorityQueue ), &( pxSegment->xQueueItem ) );
 800d714:	687b      	ldr	r3, [r7, #4]
 800d716:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800d71a:	68bb      	ldr	r3, [r7, #8]
 800d71c:	3318      	adds	r3, #24
 800d71e:	4610      	mov	r0, r2
 800d720:	4619      	mov	r1, r3
 800d722:	f7ff f8ff 	bl	800c924 <vListInsertFifo>
				ulCount++;
 800d726:	693b      	ldr	r3, [r7, #16]
 800d728:	3301      	adds	r3, #1
 800d72a:	613b      	str	r3, [r7, #16]
		/* A higher Tx block has been acknowledged.  Now iterate through the
		 xWaitQueue to find a possible condition for a FAST retransmission. */

		pxEnd = ( const MiniListItem_t* ) listGET_END_MARKER( &( pxWindow->xWaitQueue ) );

		for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxEnd );
 800d72c:	697a      	ldr	r2, [r7, #20]
 800d72e:	68fb      	ldr	r3, [r7, #12]
 800d730:	429a      	cmp	r2, r3
 800d732:	d1bf      	bne.n	800d6b4 <prvTCPWindowFastRetransmit+0x1c>
				vListInsertFifo( &( pxWindow->xPriorityQueue ), &( pxSegment->xQueueItem ) );
				ulCount++;
			}
		}

		return ulCount;
 800d734:	693b      	ldr	r3, [r7, #16]
	}
 800d736:	4618      	mov	r0, r3
 800d738:	3718      	adds	r7, #24
 800d73a:	46bd      	mov	sp, r7
 800d73c:	bd80      	pop	{r7, pc}
 800d73e:	bf00      	nop
 800d740:	2000c2b4 	.word	0x2000c2b4

0800d744 <ulTCPWindowTxAck>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxAck( TCPWindow_t *pxWindow, uint32_t ulSequenceNumber )
	{
 800d744:	b580      	push	{r7, lr}
 800d746:	b084      	sub	sp, #16
 800d748:	af00      	add	r7, sp, #0
 800d74a:	6078      	str	r0, [r7, #4]
 800d74c:	6039      	str	r1, [r7, #0]
	uint32_t ulFirstSequence, ulReturn;

		/* Receive a normal ACK. */

		ulFirstSequence = pxWindow->tx.ulCurrentSequenceNumber;
 800d74e:	687b      	ldr	r3, [r7, #4]
 800d750:	6a1b      	ldr	r3, [r3, #32]
 800d752:	60bb      	str	r3, [r7, #8]

		if( xSequenceLessThanOrEqual( ulSequenceNumber, ulFirstSequence ) != pdFALSE )
 800d754:	6838      	ldr	r0, [r7, #0]
 800d756:	68b9      	ldr	r1, [r7, #8]
 800d758:	f7ff f89c 	bl	800c894 <xSequenceLessThanOrEqual>
 800d75c:	4603      	mov	r3, r0
 800d75e:	2b00      	cmp	r3, #0
 800d760:	d002      	beq.n	800d768 <ulTCPWindowTxAck+0x24>
		{
			ulReturn = 0UL;
 800d762:	2300      	movs	r3, #0
 800d764:	60fb      	str	r3, [r7, #12]
 800d766:	e005      	b.n	800d774 <ulTCPWindowTxAck+0x30>
		}
		else
		{
			ulReturn = prvTCPWindowTxCheckAck( pxWindow, ulFirstSequence, ulSequenceNumber );
 800d768:	6878      	ldr	r0, [r7, #4]
 800d76a:	68b9      	ldr	r1, [r7, #8]
 800d76c:	683a      	ldr	r2, [r7, #0]
 800d76e:	f7ff fed1 	bl	800d514 <prvTCPWindowTxCheckAck>
 800d772:	60f8      	str	r0, [r7, #12]
		}

		return ulReturn;
 800d774:	68fb      	ldr	r3, [r7, #12]
	}
 800d776:	4618      	mov	r0, r3
 800d778:	3710      	adds	r7, #16
 800d77a:	46bd      	mov	sp, r7
 800d77c:	bd80      	pop	{r7, pc}
 800d77e:	bf00      	nop

0800d780 <ulTCPWindowTxSack>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_TCP_WIN == 1 )

	uint32_t ulTCPWindowTxSack( TCPWindow_t *pxWindow, uint32_t ulFirst, uint32_t ulLast )
	{
 800d780:	b580      	push	{r7, lr}
 800d782:	b086      	sub	sp, #24
 800d784:	af00      	add	r7, sp, #0
 800d786:	60f8      	str	r0, [r7, #12]
 800d788:	60b9      	str	r1, [r7, #8]
 800d78a:	607a      	str	r2, [r7, #4]
	uint32_t ulAckCount = 0UL;
 800d78c:	2300      	movs	r3, #0
 800d78e:	617b      	str	r3, [r7, #20]
	uint32_t ulCurrentSequenceNumber = pxWindow->tx.ulCurrentSequenceNumber;
 800d790:	68fb      	ldr	r3, [r7, #12]
 800d792:	6a1b      	ldr	r3, [r3, #32]
 800d794:	613b      	str	r3, [r7, #16]

		/* Receive a SACK option. */
		ulAckCount = prvTCPWindowTxCheckAck( pxWindow, ulFirst, ulLast );
 800d796:	68f8      	ldr	r0, [r7, #12]
 800d798:	68b9      	ldr	r1, [r7, #8]
 800d79a:	687a      	ldr	r2, [r7, #4]
 800d79c:	f7ff feba 	bl	800d514 <prvTCPWindowTxCheckAck>
 800d7a0:	6178      	str	r0, [r7, #20]
		prvTCPWindowFastRetransmit( pxWindow, ulFirst );
 800d7a2:	68f8      	ldr	r0, [r7, #12]
 800d7a4:	68b9      	ldr	r1, [r7, #8]
 800d7a6:	f7ff ff77 	bl	800d698 <prvTCPWindowFastRetransmit>

		if( ( xTCPWindowLoggingLevel >= 1 ) && ( xSequenceGreaterThan( ulFirst, ulCurrentSequenceNumber ) != pdFALSE ) )
 800d7aa:	4b06      	ldr	r3, [pc, #24]	; (800d7c4 <ulTCPWindowTxSack+0x44>)
 800d7ac:	681b      	ldr	r3, [r3, #0]
 800d7ae:	2b00      	cmp	r3, #0
 800d7b0:	dd03      	ble.n	800d7ba <ulTCPWindowTxSack+0x3a>
 800d7b2:	68b8      	ldr	r0, [r7, #8]
 800d7b4:	6939      	ldr	r1, [r7, #16]
 800d7b6:	f7ff f891 	bl	800c8dc <xSequenceGreaterThan>
				ulLast - pxWindow->tx.ulFirstSequenceNumber,
				pxWindow->tx.ulCurrentSequenceNumber - pxWindow->tx.ulFirstSequenceNumber ) );
			FreeRTOS_flush_logging( );
		}

		return ulAckCount;
 800d7ba:	697b      	ldr	r3, [r7, #20]
	}
 800d7bc:	4618      	mov	r0, r3
 800d7be:	3718      	adds	r7, #24
 800d7c0:	46bd      	mov	sp, r7
 800d7c2:	bd80      	pop	{r7, pc}
 800d7c4:	2000c2b4 	.word	0x2000c2b4

0800d7c8 <FreeRTOS_min_uint32>:
 800d7c8:	b480      	push	{r7}
 800d7ca:	b083      	sub	sp, #12
 800d7cc:	af00      	add	r7, sp, #0
 800d7ce:	6078      	str	r0, [r7, #4]
 800d7d0:	6039      	str	r1, [r7, #0]
 800d7d2:	687a      	ldr	r2, [r7, #4]
 800d7d4:	683b      	ldr	r3, [r7, #0]
 800d7d6:	4293      	cmp	r3, r2
 800d7d8:	bf28      	it	cs
 800d7da:	4613      	movcs	r3, r2
 800d7dc:	4618      	mov	r0, r3
 800d7de:	370c      	adds	r7, #12
 800d7e0:	46bd      	mov	sp, r7
 800d7e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d7e6:	4770      	bx	lr

0800d7e8 <uxStreamBufferSpace>:
}
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper );
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
 800d7e8:	b480      	push	{r7}
 800d7ea:	b087      	sub	sp, #28
 800d7ec:	af00      	add	r7, sp, #0
 800d7ee:	60f8      	str	r0, [r7, #12]
 800d7f0:	60b9      	str	r1, [r7, #8]
 800d7f2:	607a      	str	r2, [r7, #4]
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 800d7f4:	68fb      	ldr	r3, [r7, #12]
 800d7f6:	691a      	ldr	r2, [r3, #16]
 800d7f8:	687b      	ldr	r3, [r7, #4]
 800d7fa:	441a      	add	r2, r3
 800d7fc:	68bb      	ldr	r3, [r7, #8]
 800d7fe:	1ad3      	subs	r3, r2, r3
 800d800:	3b01      	subs	r3, #1
 800d802:	617b      	str	r3, [r7, #20]
	if( uxCount >= pxBuffer->LENGTH )
 800d804:	68fb      	ldr	r3, [r7, #12]
 800d806:	691a      	ldr	r2, [r3, #16]
 800d808:	697b      	ldr	r3, [r7, #20]
 800d80a:	429a      	cmp	r2, r3
 800d80c:	d804      	bhi.n	800d818 <uxStreamBufferSpace+0x30>
	{
		uxCount -= pxBuffer->LENGTH;
 800d80e:	68fb      	ldr	r3, [r7, #12]
 800d810:	691b      	ldr	r3, [r3, #16]
 800d812:	697a      	ldr	r2, [r7, #20]
 800d814:	1ad3      	subs	r3, r2, r3
 800d816:	617b      	str	r3, [r7, #20]
	}

	return uxCount;
 800d818:	697b      	ldr	r3, [r7, #20]
}
 800d81a:	4618      	mov	r0, r3
 800d81c:	371c      	adds	r7, #28
 800d81e:	46bd      	mov	sp, r7
 800d820:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d824:	4770      	bx	lr
 800d826:	bf00      	nop

0800d828 <uxStreamBufferDistance>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper );
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
 800d828:	b480      	push	{r7}
 800d82a:	b087      	sub	sp, #28
 800d82c:	af00      	add	r7, sp, #0
 800d82e:	60f8      	str	r0, [r7, #12]
 800d830:	60b9      	str	r1, [r7, #8]
 800d832:	607a      	str	r2, [r7, #4]
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 800d834:	68fb      	ldr	r3, [r7, #12]
 800d836:	691a      	ldr	r2, [r3, #16]
 800d838:	687b      	ldr	r3, [r7, #4]
 800d83a:	441a      	add	r2, r3
 800d83c:	68bb      	ldr	r3, [r7, #8]
 800d83e:	1ad3      	subs	r3, r2, r3
 800d840:	617b      	str	r3, [r7, #20]
	if ( uxCount >= pxBuffer->LENGTH )
 800d842:	68fb      	ldr	r3, [r7, #12]
 800d844:	691a      	ldr	r2, [r3, #16]
 800d846:	697b      	ldr	r3, [r7, #20]
 800d848:	429a      	cmp	r2, r3
 800d84a:	d804      	bhi.n	800d856 <uxStreamBufferDistance+0x2e>
	{
		uxCount -= pxBuffer->LENGTH;
 800d84c:	68fb      	ldr	r3, [r7, #12]
 800d84e:	691b      	ldr	r3, [r3, #16]
 800d850:	697a      	ldr	r2, [r7, #20]
 800d852:	1ad3      	subs	r3, r2, r3
 800d854:	617b      	str	r3, [r7, #20]
	}

	return uxCount;
 800d856:	697b      	ldr	r3, [r7, #20]
}
 800d858:	4618      	mov	r0, r3
 800d85a:	371c      	adds	r7, #28
 800d85c:	46bd      	mov	sp, r7
 800d85e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d862:	4770      	bx	lr

0800d864 <uxStreamBufferGetSpace>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer )
{
 800d864:	b580      	push	{r7, lr}
 800d866:	b084      	sub	sp, #16
 800d868:	af00      	add	r7, sp, #0
 800d86a:	6078      	str	r0, [r7, #4]
/* Returns the number of items which can still be added to uxHead
before hitting on uxTail */
size_t uxHead = pxBuffer->uxHead;
 800d86c:	687b      	ldr	r3, [r7, #4]
 800d86e:	689b      	ldr	r3, [r3, #8]
 800d870:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
 800d872:	687b      	ldr	r3, [r7, #4]
 800d874:	681b      	ldr	r3, [r3, #0]
 800d876:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferSpace( pxBuffer, uxHead, uxTail );
 800d878:	6878      	ldr	r0, [r7, #4]
 800d87a:	68f9      	ldr	r1, [r7, #12]
 800d87c:	68ba      	ldr	r2, [r7, #8]
 800d87e:	f7ff ffb3 	bl	800d7e8 <uxStreamBufferSpace>
 800d882:	4603      	mov	r3, r0
}
 800d884:	4618      	mov	r0, r3
 800d886:	3710      	adds	r7, #16
 800d888:	46bd      	mov	sp, r7
 800d88a:	bd80      	pop	{r7, pc}

0800d88c <uxStreamBufferGetSize>:
}
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
{
 800d88c:	b580      	push	{r7, lr}
 800d88e:	b084      	sub	sp, #16
 800d890:	af00      	add	r7, sp, #0
 800d892:	6078      	str	r0, [r7, #4]
/* Returns the number of items which can be read from uxTail
before reaching uxHead */
size_t uxHead = pxBuffer->uxHead;
 800d894:	687b      	ldr	r3, [r7, #4]
 800d896:	689b      	ldr	r3, [r3, #8]
 800d898:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
 800d89a:	687b      	ldr	r3, [r7, #4]
 800d89c:	681b      	ldr	r3, [r3, #0]
 800d89e:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferDistance( pxBuffer, uxTail, uxHead );
 800d8a0:	6878      	ldr	r0, [r7, #4]
 800d8a2:	68b9      	ldr	r1, [r7, #8]
 800d8a4:	68fa      	ldr	r2, [r7, #12]
 800d8a6:	f7ff ffbf 	bl	800d828 <uxStreamBufferDistance>
 800d8aa:	4603      	mov	r3, r0
}
 800d8ac:	4618      	mov	r0, r3
 800d8ae:	3710      	adds	r7, #16
 800d8b0:	46bd      	mov	sp, r7
 800d8b2:	bd80      	pop	{r7, pc}

0800d8b4 <xStreamBufferLessThenEqual>:
}
/*-----------------------------------------------------------*/

static portINLINE BaseType_t xStreamBufferLessThenEqual( const StreamBuffer_t *pxBuffer, const size_t uxLeft, const size_t uxRight );
static portINLINE BaseType_t xStreamBufferLessThenEqual( const StreamBuffer_t *pxBuffer, const size_t uxLeft, const size_t uxRight )
{
 800d8b4:	b480      	push	{r7}
 800d8b6:	b087      	sub	sp, #28
 800d8b8:	af00      	add	r7, sp, #0
 800d8ba:	60f8      	str	r0, [r7, #12]
 800d8bc:	60b9      	str	r1, [r7, #8]
 800d8be:	607a      	str	r2, [r7, #4]
BaseType_t xReturn;
size_t uxTail = pxBuffer->uxTail;
 800d8c0:	68fb      	ldr	r3, [r7, #12]
 800d8c2:	681b      	ldr	r3, [r3, #0]
 800d8c4:	613b      	str	r3, [r7, #16]

	/* Returns true if ( uxLeft < uxRight ) */
	if( ( uxLeft < uxTail ) ^ ( uxRight < uxTail ) )
 800d8c6:	68ba      	ldr	r2, [r7, #8]
 800d8c8:	693b      	ldr	r3, [r7, #16]
 800d8ca:	429a      	cmp	r2, r3
 800d8cc:	bf34      	ite	cc
 800d8ce:	2301      	movcc	r3, #1
 800d8d0:	2300      	movcs	r3, #0
 800d8d2:	b2da      	uxtb	r2, r3
 800d8d4:	6879      	ldr	r1, [r7, #4]
 800d8d6:	693b      	ldr	r3, [r7, #16]
 800d8d8:	4299      	cmp	r1, r3
 800d8da:	bf34      	ite	cc
 800d8dc:	2301      	movcc	r3, #1
 800d8de:	2300      	movcs	r3, #0
 800d8e0:	b2db      	uxtb	r3, r3
 800d8e2:	4053      	eors	r3, r2
 800d8e4:	b2db      	uxtb	r3, r3
 800d8e6:	2b00      	cmp	r3, #0
 800d8e8:	d009      	beq.n	800d8fe <xStreamBufferLessThenEqual+0x4a>
	{
		if( uxRight < uxTail )
 800d8ea:	687a      	ldr	r2, [r7, #4]
 800d8ec:	693b      	ldr	r3, [r7, #16]
 800d8ee:	429a      	cmp	r2, r3
 800d8f0:	d202      	bcs.n	800d8f8 <xStreamBufferLessThenEqual+0x44>
		{
			xReturn = pdTRUE;
 800d8f2:	2301      	movs	r3, #1
 800d8f4:	617b      	str	r3, [r7, #20]
 800d8f6:	e00b      	b.n	800d910 <xStreamBufferLessThenEqual+0x5c>
		}
		else
		{
			xReturn = pdFALSE;
 800d8f8:	2300      	movs	r3, #0
 800d8fa:	617b      	str	r3, [r7, #20]
 800d8fc:	e008      	b.n	800d910 <xStreamBufferLessThenEqual+0x5c>
		}
	}
	else
	{
		if( uxLeft <= uxRight )
 800d8fe:	68ba      	ldr	r2, [r7, #8]
 800d900:	687b      	ldr	r3, [r7, #4]
 800d902:	429a      	cmp	r2, r3
 800d904:	d802      	bhi.n	800d90c <xStreamBufferLessThenEqual+0x58>
		{
			xReturn = pdTRUE;
 800d906:	2301      	movs	r3, #1
 800d908:	617b      	str	r3, [r7, #20]
 800d90a:	e001      	b.n	800d910 <xStreamBufferLessThenEqual+0x5c>
		}
		else
		{
			xReturn = pdFALSE;
 800d90c:	2300      	movs	r3, #0
 800d90e:	617b      	str	r3, [r7, #20]
		}
	}
	return xReturn;
 800d910:	697b      	ldr	r3, [r7, #20]
}
 800d912:	4618      	mov	r0, r3
 800d914:	371c      	adds	r7, #28
 800d916:	46bd      	mov	sp, r7
 800d918:	f85d 7b04 	ldr.w	r7, [sp], #4
 800d91c:	4770      	bx	lr
 800d91e:	bf00      	nop

0800d920 <uxStreamBufferAdd>:
 * an offset from uxHead while uxHead will not be moved yet.  This possibility
 * will be used when TCP data is received while earlier data is still missing.
 * If 'pucData' equals NULL, the function is called to advance 'uxHead' only.
 */
size_t uxStreamBufferAdd( StreamBuffer_t *pxBuffer, size_t uxOffset, const uint8_t *pucData, size_t uxCount )
{
 800d920:	b580      	push	{r7, lr}
 800d922:	b088      	sub	sp, #32
 800d924:	af00      	add	r7, sp, #0
 800d926:	60f8      	str	r0, [r7, #12]
 800d928:	60b9      	str	r1, [r7, #8]
 800d92a:	607a      	str	r2, [r7, #4]
 800d92c:	603b      	str	r3, [r7, #0]
size_t uxSpace, uxNextHead, uxFirst;

	uxSpace = uxStreamBufferGetSpace( pxBuffer );
 800d92e:	68f8      	ldr	r0, [r7, #12]
 800d930:	f7ff ff98 	bl	800d864 <uxStreamBufferGetSpace>
 800d934:	61f8      	str	r0, [r7, #28]

	/* If uxOffset > 0, items can be placed in front of uxHead */
	if( uxSpace > uxOffset )
 800d936:	69fa      	ldr	r2, [r7, #28]
 800d938:	68bb      	ldr	r3, [r7, #8]
 800d93a:	429a      	cmp	r2, r3
 800d93c:	d904      	bls.n	800d948 <uxStreamBufferAdd+0x28>
	{
		uxSpace -= uxOffset;
 800d93e:	69fa      	ldr	r2, [r7, #28]
 800d940:	68bb      	ldr	r3, [r7, #8]
 800d942:	1ad3      	subs	r3, r2, r3
 800d944:	61fb      	str	r3, [r7, #28]
 800d946:	e001      	b.n	800d94c <uxStreamBufferAdd+0x2c>
	}
	else
	{
		uxSpace = 0u;
 800d948:	2300      	movs	r3, #0
 800d94a:	61fb      	str	r3, [r7, #28]
	}

	/* The number of bytes that can be written is the minimum of the number of
	bytes requested and the number available. */
	uxCount = FreeRTOS_min_uint32( uxSpace, uxCount );
 800d94c:	69f8      	ldr	r0, [r7, #28]
 800d94e:	6839      	ldr	r1, [r7, #0]
 800d950:	f7ff ff3a 	bl	800d7c8 <FreeRTOS_min_uint32>
 800d954:	6038      	str	r0, [r7, #0]

	if( uxCount != 0u )
 800d956:	683b      	ldr	r3, [r7, #0]
 800d958:	2b00      	cmp	r3, #0
 800d95a:	d05a      	beq.n	800da12 <uxStreamBufferAdd+0xf2>
	{
		uxNextHead = pxBuffer->uxHead;
 800d95c:	68fb      	ldr	r3, [r7, #12]
 800d95e:	689b      	ldr	r3, [r3, #8]
 800d960:	61bb      	str	r3, [r7, #24]

		if( uxOffset != 0u )
 800d962:	68bb      	ldr	r3, [r7, #8]
 800d964:	2b00      	cmp	r3, #0
 800d966:	d00d      	beq.n	800d984 <uxStreamBufferAdd+0x64>
		{
			/* ( uxOffset > 0 ) means: write in front if the uxHead marker */
			uxNextHead += uxOffset;
 800d968:	69ba      	ldr	r2, [r7, #24]
 800d96a:	68bb      	ldr	r3, [r7, #8]
 800d96c:	4413      	add	r3, r2
 800d96e:	61bb      	str	r3, [r7, #24]
			if( uxNextHead >= pxBuffer->LENGTH )
 800d970:	68fb      	ldr	r3, [r7, #12]
 800d972:	691a      	ldr	r2, [r3, #16]
 800d974:	69bb      	ldr	r3, [r7, #24]
 800d976:	429a      	cmp	r2, r3
 800d978:	d804      	bhi.n	800d984 <uxStreamBufferAdd+0x64>
			{
				uxNextHead -= pxBuffer->LENGTH;
 800d97a:	68fb      	ldr	r3, [r7, #12]
 800d97c:	691b      	ldr	r3, [r3, #16]
 800d97e:	69ba      	ldr	r2, [r7, #24]
 800d980:	1ad3      	subs	r3, r2, r3
 800d982:	61bb      	str	r3, [r7, #24]
			}
		}

		if( pucData != NULL )
 800d984:	687b      	ldr	r3, [r7, #4]
 800d986:	2b00      	cmp	r3, #0
 800d988:	d022      	beq.n	800d9d0 <uxStreamBufferAdd+0xb0>
		{
			/* Calculate the number of bytes that can be added in the first
			write - which may be less than the total number of bytes that need
			to be added if the buffer will wrap back to the beginning. */
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextHead, uxCount );
 800d98a:	68fb      	ldr	r3, [r7, #12]
 800d98c:	691a      	ldr	r2, [r3, #16]
 800d98e:	69bb      	ldr	r3, [r7, #24]
 800d990:	1ad3      	subs	r3, r2, r3
 800d992:	4618      	mov	r0, r3
 800d994:	6839      	ldr	r1, [r7, #0]
 800d996:	f7ff ff17 	bl	800d7c8 <FreeRTOS_min_uint32>
 800d99a:	6178      	str	r0, [r7, #20]

			/* Write as many bytes as can be written in the first write. */
			memcpy( ( void* ) ( pxBuffer->ucArray + uxNextHead ), pucData, uxFirst );
 800d99c:	69bb      	ldr	r3, [r7, #24]
 800d99e:	3310      	adds	r3, #16
 800d9a0:	68fa      	ldr	r2, [r7, #12]
 800d9a2:	4413      	add	r3, r2
 800d9a4:	3304      	adds	r3, #4
 800d9a6:	4618      	mov	r0, r3
 800d9a8:	6879      	ldr	r1, [r7, #4]
 800d9aa:	697a      	ldr	r2, [r7, #20]
 800d9ac:	f002 fb7c 	bl	80100a8 <memcpy>

			/* If the number of bytes written was less than the number that
			could be written in the first write... */
			if( uxCount > uxFirst )
 800d9b0:	683a      	ldr	r2, [r7, #0]
 800d9b2:	697b      	ldr	r3, [r7, #20]
 800d9b4:	429a      	cmp	r2, r3
 800d9b6:	d90b      	bls.n	800d9d0 <uxStreamBufferAdd+0xb0>
			{
				/* ...then write the remaining bytes to the start of the
				buffer. */
				memcpy( ( void * )pxBuffer->ucArray, pucData + uxFirst, uxCount - uxFirst );
 800d9b8:	68fb      	ldr	r3, [r7, #12]
 800d9ba:	f103 0014 	add.w	r0, r3, #20
 800d9be:	687a      	ldr	r2, [r7, #4]
 800d9c0:	697b      	ldr	r3, [r7, #20]
 800d9c2:	18d1      	adds	r1, r2, r3
 800d9c4:	683a      	ldr	r2, [r7, #0]
 800d9c6:	697b      	ldr	r3, [r7, #20]
 800d9c8:	1ad3      	subs	r3, r2, r3
 800d9ca:	461a      	mov	r2, r3
 800d9cc:	f002 fb6c 	bl	80100a8 <memcpy>
			}
		}

		if( uxOffset == 0u )
 800d9d0:	68bb      	ldr	r3, [r7, #8]
 800d9d2:	2b00      	cmp	r3, #0
 800d9d4:	d110      	bne.n	800d9f8 <uxStreamBufferAdd+0xd8>
		{
			/* ( uxOffset == 0 ) means: write at uxHead position */
			uxNextHead += uxCount;
 800d9d6:	69ba      	ldr	r2, [r7, #24]
 800d9d8:	683b      	ldr	r3, [r7, #0]
 800d9da:	4413      	add	r3, r2
 800d9dc:	61bb      	str	r3, [r7, #24]
			if( uxNextHead >= pxBuffer->LENGTH )
 800d9de:	68fb      	ldr	r3, [r7, #12]
 800d9e0:	691a      	ldr	r2, [r3, #16]
 800d9e2:	69bb      	ldr	r3, [r7, #24]
 800d9e4:	429a      	cmp	r2, r3
 800d9e6:	d804      	bhi.n	800d9f2 <uxStreamBufferAdd+0xd2>
			{
				uxNextHead -= pxBuffer->LENGTH;
 800d9e8:	68fb      	ldr	r3, [r7, #12]
 800d9ea:	691b      	ldr	r3, [r3, #16]
 800d9ec:	69ba      	ldr	r2, [r7, #24]
 800d9ee:	1ad3      	subs	r3, r2, r3
 800d9f0:	61bb      	str	r3, [r7, #24]
			}
			pxBuffer->uxHead = uxNextHead;
 800d9f2:	68fb      	ldr	r3, [r7, #12]
 800d9f4:	69ba      	ldr	r2, [r7, #24]
 800d9f6:	609a      	str	r2, [r3, #8]
		}

		if( xStreamBufferLessThenEqual( pxBuffer, pxBuffer->uxFront, uxNextHead ) != pdFALSE )
 800d9f8:	68fb      	ldr	r3, [r7, #12]
 800d9fa:	68db      	ldr	r3, [r3, #12]
 800d9fc:	68f8      	ldr	r0, [r7, #12]
 800d9fe:	4619      	mov	r1, r3
 800da00:	69ba      	ldr	r2, [r7, #24]
 800da02:	f7ff ff57 	bl	800d8b4 <xStreamBufferLessThenEqual>
 800da06:	4603      	mov	r3, r0
 800da08:	2b00      	cmp	r3, #0
 800da0a:	d002      	beq.n	800da12 <uxStreamBufferAdd+0xf2>
		{
			/* Advance the front pointer */
			pxBuffer->uxFront = uxNextHead;
 800da0c:	68fb      	ldr	r3, [r7, #12]
 800da0e:	69ba      	ldr	r2, [r7, #24]
 800da10:	60da      	str	r2, [r3, #12]
		}
	}

	return uxCount;
 800da12:	683b      	ldr	r3, [r7, #0]
}
 800da14:	4618      	mov	r0, r3
 800da16:	3720      	adds	r7, #32
 800da18:	46bd      	mov	sp, r7
 800da1a:	bd80      	pop	{r7, pc}

0800da1c <uxStreamBufferGet>:
 * If 'pucData' equals NULL, the function is called to advance 'lTail' only.
 * if 'xPeek' is pdTRUE, or if 'uxOffset' is non-zero, the 'lTail' pointer will
 * not be advanced.
 */
size_t uxStreamBufferGet( StreamBuffer_t *pxBuffer, size_t uxOffset, uint8_t *pucData, size_t uxMaxCount, BaseType_t xPeek )
{
 800da1c:	b580      	push	{r7, lr}
 800da1e:	b088      	sub	sp, #32
 800da20:	af00      	add	r7, sp, #0
 800da22:	60f8      	str	r0, [r7, #12]
 800da24:	60b9      	str	r1, [r7, #8]
 800da26:	607a      	str	r2, [r7, #4]
 800da28:	603b      	str	r3, [r7, #0]
size_t uxSize, uxCount, uxFirst, uxNextTail;

	/* How much data is available? */
	uxSize = uxStreamBufferGetSize( pxBuffer );
 800da2a:	68f8      	ldr	r0, [r7, #12]
 800da2c:	f7ff ff2e 	bl	800d88c <uxStreamBufferGetSize>
 800da30:	61f8      	str	r0, [r7, #28]

	if( uxSize > uxOffset )
 800da32:	69fa      	ldr	r2, [r7, #28]
 800da34:	68bb      	ldr	r3, [r7, #8]
 800da36:	429a      	cmp	r2, r3
 800da38:	d904      	bls.n	800da44 <uxStreamBufferGet+0x28>
	{
		uxSize -= uxOffset;
 800da3a:	69fa      	ldr	r2, [r7, #28]
 800da3c:	68bb      	ldr	r3, [r7, #8]
 800da3e:	1ad3      	subs	r3, r2, r3
 800da40:	61fb      	str	r3, [r7, #28]
 800da42:	e001      	b.n	800da48 <uxStreamBufferGet+0x2c>
	}
	else
	{
		uxSize = 0u;
 800da44:	2300      	movs	r3, #0
 800da46:	61fb      	str	r3, [r7, #28]
	}

	/* Use the minimum of the wanted bytes and the available bytes. */
	uxCount = FreeRTOS_min_uint32( uxSize, uxMaxCount );
 800da48:	69f8      	ldr	r0, [r7, #28]
 800da4a:	6839      	ldr	r1, [r7, #0]
 800da4c:	f7ff febc 	bl	800d7c8 <FreeRTOS_min_uint32>
 800da50:	6178      	str	r0, [r7, #20]

	if( uxCount > 0u )
 800da52:	697b      	ldr	r3, [r7, #20]
 800da54:	2b00      	cmp	r3, #0
 800da56:	d050      	beq.n	800dafa <uxStreamBufferGet+0xde>
	{
		uxNextTail = pxBuffer->uxTail;
 800da58:	68fb      	ldr	r3, [r7, #12]
 800da5a:	681b      	ldr	r3, [r3, #0]
 800da5c:	61bb      	str	r3, [r7, #24]

		if( uxOffset != 0u )
 800da5e:	68bb      	ldr	r3, [r7, #8]
 800da60:	2b00      	cmp	r3, #0
 800da62:	d00d      	beq.n	800da80 <uxStreamBufferGet+0x64>
		{
			uxNextTail += uxOffset;
 800da64:	69ba      	ldr	r2, [r7, #24]
 800da66:	68bb      	ldr	r3, [r7, #8]
 800da68:	4413      	add	r3, r2
 800da6a:	61bb      	str	r3, [r7, #24]
			if( uxNextTail >= pxBuffer->LENGTH )
 800da6c:	68fb      	ldr	r3, [r7, #12]
 800da6e:	691a      	ldr	r2, [r3, #16]
 800da70:	69bb      	ldr	r3, [r7, #24]
 800da72:	429a      	cmp	r2, r3
 800da74:	d804      	bhi.n	800da80 <uxStreamBufferGet+0x64>
			{
				uxNextTail -= pxBuffer->LENGTH;
 800da76:	68fb      	ldr	r3, [r7, #12]
 800da78:	691b      	ldr	r3, [r3, #16]
 800da7a:	69ba      	ldr	r2, [r7, #24]
 800da7c:	1ad3      	subs	r3, r2, r3
 800da7e:	61bb      	str	r3, [r7, #24]
			}
		}

		if( pucData != NULL )
 800da80:	687b      	ldr	r3, [r7, #4]
 800da82:	2b00      	cmp	r3, #0
 800da84:	d022      	beq.n	800dacc <uxStreamBufferGet+0xb0>
		{
			/* Calculate the number of bytes that can be read - which may be
			less than the number wanted if the data wraps around to the start of
			the buffer. */
			uxFirst = FreeRTOS_min_uint32( pxBuffer->LENGTH - uxNextTail, uxCount );
 800da86:	68fb      	ldr	r3, [r7, #12]
 800da88:	691a      	ldr	r2, [r3, #16]
 800da8a:	69bb      	ldr	r3, [r7, #24]
 800da8c:	1ad3      	subs	r3, r2, r3
 800da8e:	4618      	mov	r0, r3
 800da90:	6979      	ldr	r1, [r7, #20]
 800da92:	f7ff fe99 	bl	800d7c8 <FreeRTOS_min_uint32>
 800da96:	6138      	str	r0, [r7, #16]

			/* Obtain the number of bytes it is possible to obtain in the first
			read. */
			memcpy( pucData, pxBuffer->ucArray + uxNextTail, uxFirst );
 800da98:	69bb      	ldr	r3, [r7, #24]
 800da9a:	3310      	adds	r3, #16
 800da9c:	68fa      	ldr	r2, [r7, #12]
 800da9e:	4413      	add	r3, r2
 800daa0:	3304      	adds	r3, #4
 800daa2:	6878      	ldr	r0, [r7, #4]
 800daa4:	4619      	mov	r1, r3
 800daa6:	693a      	ldr	r2, [r7, #16]
 800daa8:	f002 fafe 	bl	80100a8 <memcpy>

			/* If the total number of wanted bytes is greater than the number
			that could be read in the first read... */
			if( uxCount > uxFirst )
 800daac:	697a      	ldr	r2, [r7, #20]
 800daae:	693b      	ldr	r3, [r7, #16]
 800dab0:	429a      	cmp	r2, r3
 800dab2:	d90b      	bls.n	800dacc <uxStreamBufferGet+0xb0>
			{
				/*...then read the remaining bytes from the start of the buffer. */
				memcpy( pucData + uxFirst, pxBuffer->ucArray, uxCount - uxFirst );
 800dab4:	687a      	ldr	r2, [r7, #4]
 800dab6:	693b      	ldr	r3, [r7, #16]
 800dab8:	18d0      	adds	r0, r2, r3
 800daba:	68fb      	ldr	r3, [r7, #12]
 800dabc:	f103 0114 	add.w	r1, r3, #20
 800dac0:	697a      	ldr	r2, [r7, #20]
 800dac2:	693b      	ldr	r3, [r7, #16]
 800dac4:	1ad3      	subs	r3, r2, r3
 800dac6:	461a      	mov	r2, r3
 800dac8:	f002 faee 	bl	80100a8 <memcpy>
			}
		}

		if( ( xPeek == pdFALSE ) && ( uxOffset == 0UL ) )
 800dacc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800dace:	2b00      	cmp	r3, #0
 800dad0:	d113      	bne.n	800dafa <uxStreamBufferGet+0xde>
 800dad2:	68bb      	ldr	r3, [r7, #8]
 800dad4:	2b00      	cmp	r3, #0
 800dad6:	d110      	bne.n	800dafa <uxStreamBufferGet+0xde>
		{
			/* Move the tail pointer to effecively remove the data read from
			the buffer. */
			uxNextTail += uxCount;
 800dad8:	69ba      	ldr	r2, [r7, #24]
 800dada:	697b      	ldr	r3, [r7, #20]
 800dadc:	4413      	add	r3, r2
 800dade:	61bb      	str	r3, [r7, #24]

			if( uxNextTail >= pxBuffer->LENGTH )
 800dae0:	68fb      	ldr	r3, [r7, #12]
 800dae2:	691a      	ldr	r2, [r3, #16]
 800dae4:	69bb      	ldr	r3, [r7, #24]
 800dae6:	429a      	cmp	r2, r3
 800dae8:	d804      	bhi.n	800daf4 <uxStreamBufferGet+0xd8>
			{
				uxNextTail -= pxBuffer->LENGTH;
 800daea:	68fb      	ldr	r3, [r7, #12]
 800daec:	691b      	ldr	r3, [r3, #16]
 800daee:	69ba      	ldr	r2, [r7, #24]
 800daf0:	1ad3      	subs	r3, r2, r3
 800daf2:	61bb      	str	r3, [r7, #24]
			}

			pxBuffer->uxTail = uxNextTail;
 800daf4:	68fb      	ldr	r3, [r7, #12]
 800daf6:	69ba      	ldr	r2, [r7, #24]
 800daf8:	601a      	str	r2, [r3, #0]
		}
	}

	return uxCount;
 800dafa:	697b      	ldr	r3, [r7, #20]
}
 800dafc:	4618      	mov	r0, r3
 800dafe:	3720      	adds	r7, #32
 800db00:	46bd      	mov	sp, r7
 800db02:	bd80      	pop	{r7, pc}

0800db04 <usChar2u16>:
			( ( ( uint32_t )apChr[3] ) );
}

static portINLINE uint16_t usChar2u16 (const uint8_t *apChr);
static portINLINE uint16_t usChar2u16 (const uint8_t *apChr)
{
 800db04:	b480      	push	{r7}
 800db06:	b083      	sub	sp, #12
 800db08:	af00      	add	r7, sp, #0
 800db0a:	6078      	str	r0, [r7, #4]
	return ( uint16_t )
			( ( ( ( uint32_t )apChr[0] ) << 8) |
 800db0c:	687b      	ldr	r3, [r7, #4]
 800db0e:	781b      	ldrb	r3, [r3, #0]
}

static portINLINE uint16_t usChar2u16 (const uint8_t *apChr);
static portINLINE uint16_t usChar2u16 (const uint8_t *apChr)
{
	return ( uint16_t )
 800db10:	b29b      	uxth	r3, r3
 800db12:	021b      	lsls	r3, r3, #8
 800db14:	b29a      	uxth	r2, r3
			( ( ( ( uint32_t )apChr[0] ) << 8) |
			  ( ( ( uint32_t )apChr[1] ) ) );
 800db16:	687b      	ldr	r3, [r7, #4]
 800db18:	3301      	adds	r3, #1
 800db1a:	781b      	ldrb	r3, [r3, #0]
}

static portINLINE uint16_t usChar2u16 (const uint8_t *apChr);
static portINLINE uint16_t usChar2u16 (const uint8_t *apChr)
{
	return ( uint16_t )
 800db1c:	b29b      	uxth	r3, r3
 800db1e:	4313      	orrs	r3, r2
 800db20:	b29b      	uxth	r3, r3
			( ( ( ( uint32_t )apChr[0] ) << 8) |
			  ( ( ( uint32_t )apChr[1] ) ) );
}
 800db22:	4618      	mov	r0, r3
 800db24:	370c      	adds	r7, #12
 800db26:	46bd      	mov	sp, r7
 800db28:	f85d 7b04 	ldr.w	r7, [sp], #4
 800db2c:	4770      	bx	lr
 800db2e:	bf00      	nop

0800db30 <vDNSInitialise>:
	/*-----------------------------------------------------------*/

	/* Initialise the list of call-back structures. */
	void vDNSInitialise( void );
	void vDNSInitialise( void )
	{
 800db30:	b580      	push	{r7, lr}
 800db32:	af00      	add	r7, sp, #0
		vListInitialise( &xCallbackList );
 800db34:	4801      	ldr	r0, [pc, #4]	; (800db3c <vDNSInitialise+0xc>)
 800db36:	f7f5 fff9 	bl	8003b2c <vListInitialise>
	}
 800db3a:	bd80      	pop	{r7, pc}
 800db3c:	2000c318 	.word	0x2000c318

0800db40 <vDNSCheckCallBack>:
	As soon as the list hase become empty, the DNS timer will be stopped
	In case pvSearchID is supplied, the user wants to cancel a DNS request
	*/
	void vDNSCheckCallBack( void *pvSearchID );
	void vDNSCheckCallBack( void *pvSearchID )
	{
 800db40:	b580      	push	{r7, lr}
 800db42:	b086      	sub	sp, #24
 800db44:	af00      	add	r7, sp, #0
 800db46:	6078      	str	r0, [r7, #4]
	const ListItem_t *pxIterator;
	const MiniListItem_t* xEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xCallbackList );
 800db48:	4b26      	ldr	r3, [pc, #152]	; (800dbe4 <vDNSCheckCallBack+0xa4>)
 800db4a:	613b      	str	r3, [r7, #16]

		vTaskSuspendAll();
 800db4c:	f7f7 fc6a 	bl	8005424 <vTaskSuspendAll>
		{
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 800db50:	693b      	ldr	r3, [r7, #16]
 800db52:	685b      	ldr	r3, [r3, #4]
 800db54:	617b      	str	r3, [r7, #20]
 800db56:	e034      	b.n	800dbc2 <vDNSCheckCallBack+0x82>
				 pxIterator != ( const ListItem_t * ) xEnd;
				  )
			{
				DNSCallback_t *pxCallback = ( DNSCallback_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800db58:	697b      	ldr	r3, [r7, #20]
 800db5a:	68db      	ldr	r3, [r3, #12]
 800db5c:	60fb      	str	r3, [r7, #12]
				/* Move to the next item because we might remove this item */
				pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator );
 800db5e:	697b      	ldr	r3, [r7, #20]
 800db60:	685b      	ldr	r3, [r3, #4]
 800db62:	617b      	str	r3, [r7, #20]
				if( ( pvSearchID != NULL ) && ( pvSearchID == pxCallback->pvSearchID ) )
 800db64:	687b      	ldr	r3, [r7, #4]
 800db66:	2b00      	cmp	r3, #0
 800db68:	d00d      	beq.n	800db86 <vDNSCheckCallBack+0x46>
 800db6a:	68fb      	ldr	r3, [r7, #12]
 800db6c:	691a      	ldr	r2, [r3, #16]
 800db6e:	687b      	ldr	r3, [r7, #4]
 800db70:	429a      	cmp	r2, r3
 800db72:	d108      	bne.n	800db86 <vDNSCheckCallBack+0x46>
				{
					uxListRemove( &pxCallback->xListItem );
 800db74:	68fb      	ldr	r3, [r7, #12]
 800db76:	3314      	adds	r3, #20
 800db78:	4618      	mov	r0, r3
 800db7a:	f7f6 f85f 	bl	8003c3c <uxListRemove>
					vPortFree( pxCallback );
 800db7e:	68f8      	ldr	r0, [r7, #12]
 800db80:	f7f6 fb36 	bl	80041f0 <vPortFree>
 800db84:	e01d      	b.n	800dbc2 <vDNSCheckCallBack+0x82>
				}
				else if( xTaskCheckForTimeOut( &pxCallback->xTimeoutState, &pxCallback->xRemaningTime ) != pdFALSE )
 800db86:	68fb      	ldr	r3, [r7, #12]
 800db88:	f103 0208 	add.w	r2, r3, #8
 800db8c:	68fb      	ldr	r3, [r7, #12]
 800db8e:	4610      	mov	r0, r2
 800db90:	4619      	mov	r1, r3
 800db92:	f7f8 f809 	bl	8005ba8 <xTaskCheckForTimeOut>
 800db96:	4603      	mov	r3, r0
 800db98:	2b00      	cmp	r3, #0
 800db9a:	d012      	beq.n	800dbc2 <vDNSCheckCallBack+0x82>
				{
					pxCallback->pCallbackFunction( pxCallback->pcName, pxCallback->pvSearchID, 0 );
 800db9c:	68fb      	ldr	r3, [r7, #12]
 800db9e:	685b      	ldr	r3, [r3, #4]
 800dba0:	68fa      	ldr	r2, [r7, #12]
 800dba2:	f102 0128 	add.w	r1, r2, #40	; 0x28
 800dba6:	68fa      	ldr	r2, [r7, #12]
 800dba8:	6912      	ldr	r2, [r2, #16]
 800dbaa:	4608      	mov	r0, r1
 800dbac:	4611      	mov	r1, r2
 800dbae:	2200      	movs	r2, #0
 800dbb0:	4798      	blx	r3
					uxListRemove( &pxCallback->xListItem );
 800dbb2:	68fb      	ldr	r3, [r7, #12]
 800dbb4:	3314      	adds	r3, #20
 800dbb6:	4618      	mov	r0, r3
 800dbb8:	f7f6 f840 	bl	8003c3c <uxListRemove>
					vPortFree( ( void * ) pxCallback );
 800dbbc:	68f8      	ldr	r0, [r7, #12]
 800dbbe:	f7f6 fb17 	bl	80041f0 <vPortFree>
	const ListItem_t *pxIterator;
	const MiniListItem_t* xEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xCallbackList );

		vTaskSuspendAll();
		{
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 800dbc2:	697a      	ldr	r2, [r7, #20]
 800dbc4:	693b      	ldr	r3, [r7, #16]
 800dbc6:	429a      	cmp	r2, r3
 800dbc8:	d1c6      	bne.n	800db58 <vDNSCheckCallBack+0x18>
					uxListRemove( &pxCallback->xListItem );
					vPortFree( ( void * ) pxCallback );
				}
			}
		}
		xTaskResumeAll();
 800dbca:	f7f7 fc39 	bl	8005440 <xTaskResumeAll>

		if( listLIST_IS_EMPTY( &xCallbackList ) )
 800dbce:	4b06      	ldr	r3, [pc, #24]	; (800dbe8 <vDNSCheckCallBack+0xa8>)
 800dbd0:	681b      	ldr	r3, [r3, #0]
 800dbd2:	2b00      	cmp	r3, #0
 800dbd4:	d102      	bne.n	800dbdc <vDNSCheckCallBack+0x9c>
		{
			vIPSetDnsTimerEnableState( pdFALSE );
 800dbd6:	2000      	movs	r0, #0
 800dbd8:	f7fa fca0 	bl	800851c <vIPSetDnsTimerEnableState>
		}
	}
 800dbdc:	3718      	adds	r7, #24
 800dbde:	46bd      	mov	sp, r7
 800dbe0:	bd80      	pop	{r7, pc}
 800dbe2:	bf00      	nop
 800dbe4:	2000c320 	.word	0x2000c320
 800dbe8:	2000c318 	.word	0x2000c318

0800dbec <vDNSDoCallback>:

	/* A DNS reply was received, see if there is any matching entry and
	call the handler. */
	static void vDNSDoCallback( TickType_t xIdentifier, const char *pcName, uint32_t ulIPAddress );
	static void vDNSDoCallback( TickType_t xIdentifier, const char *pcName, uint32_t ulIPAddress )
	{
 800dbec:	b580      	push	{r7, lr}
 800dbee:	b088      	sub	sp, #32
 800dbf0:	af00      	add	r7, sp, #0
 800dbf2:	60f8      	str	r0, [r7, #12]
 800dbf4:	60b9      	str	r1, [r7, #8]
 800dbf6:	607a      	str	r2, [r7, #4]
		const ListItem_t *pxIterator;
		const MiniListItem_t* xEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xCallbackList );
 800dbf8:	4b1a      	ldr	r3, [pc, #104]	; (800dc64 <vDNSDoCallback+0x78>)
 800dbfa:	61bb      	str	r3, [r7, #24]

		vTaskSuspendAll();
 800dbfc:	f7f7 fc12 	bl	8005424 <vTaskSuspendAll>
		{
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 800dc00:	69bb      	ldr	r3, [r7, #24]
 800dc02:	685b      	ldr	r3, [r3, #4]
 800dc04:	61fb      	str	r3, [r7, #28]
 800dc06:	e023      	b.n	800dc50 <vDNSDoCallback+0x64>
				 pxIterator != ( const ListItem_t * ) xEnd;
				 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
			{
				if( listGET_LIST_ITEM_VALUE( pxIterator ) == xIdentifier )
 800dc08:	69fb      	ldr	r3, [r7, #28]
 800dc0a:	681a      	ldr	r2, [r3, #0]
 800dc0c:	68fb      	ldr	r3, [r7, #12]
 800dc0e:	429a      	cmp	r2, r3
 800dc10:	d11b      	bne.n	800dc4a <vDNSDoCallback+0x5e>
				{
					DNSCallback_t *pxCallback = ( DNSCallback_t * ) listGET_LIST_ITEM_OWNER( pxIterator );
 800dc12:	69fb      	ldr	r3, [r7, #28]
 800dc14:	68db      	ldr	r3, [r3, #12]
 800dc16:	617b      	str	r3, [r7, #20]
					pxCallback->pCallbackFunction( pcName, pxCallback->pvSearchID, ulIPAddress );
 800dc18:	697b      	ldr	r3, [r7, #20]
 800dc1a:	685b      	ldr	r3, [r3, #4]
 800dc1c:	697a      	ldr	r2, [r7, #20]
 800dc1e:	6912      	ldr	r2, [r2, #16]
 800dc20:	68b8      	ldr	r0, [r7, #8]
 800dc22:	4611      	mov	r1, r2
 800dc24:	687a      	ldr	r2, [r7, #4]
 800dc26:	4798      	blx	r3
					uxListRemove( &pxCallback->xListItem );
 800dc28:	697b      	ldr	r3, [r7, #20]
 800dc2a:	3314      	adds	r3, #20
 800dc2c:	4618      	mov	r0, r3
 800dc2e:	f7f6 f805 	bl	8003c3c <uxListRemove>
					vPortFree( pxCallback );
 800dc32:	6978      	ldr	r0, [r7, #20]
 800dc34:	f7f6 fadc 	bl	80041f0 <vPortFree>
					if( listLIST_IS_EMPTY( &xCallbackList ) )
 800dc38:	4b0b      	ldr	r3, [pc, #44]	; (800dc68 <vDNSDoCallback+0x7c>)
 800dc3a:	681b      	ldr	r3, [r3, #0]
 800dc3c:	2b00      	cmp	r3, #0
 800dc3e:	d103      	bne.n	800dc48 <vDNSDoCallback+0x5c>
					{
						vIPSetDnsTimerEnableState( pdFALSE );
 800dc40:	2000      	movs	r0, #0
 800dc42:	f7fa fc6b 	bl	800851c <vIPSetDnsTimerEnableState>
					}
					break;
 800dc46:	e007      	b.n	800dc58 <vDNSDoCallback+0x6c>
 800dc48:	e006      	b.n	800dc58 <vDNSDoCallback+0x6c>

		vTaskSuspendAll();
		{
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
				 pxIterator != ( const ListItem_t * ) xEnd;
				 pxIterator  = ( const ListItem_t * ) listGET_NEXT( pxIterator ) )
 800dc4a:	69fb      	ldr	r3, [r7, #28]
 800dc4c:	685b      	ldr	r3, [r3, #4]
 800dc4e:	61fb      	str	r3, [r7, #28]
		const ListItem_t *pxIterator;
		const MiniListItem_t* xEnd = ( const MiniListItem_t* )listGET_END_MARKER( &xCallbackList );

		vTaskSuspendAll();
		{
			for( pxIterator  = ( const ListItem_t * ) listGET_NEXT( xEnd );
 800dc50:	69fa      	ldr	r2, [r7, #28]
 800dc52:	69bb      	ldr	r3, [r7, #24]
 800dc54:	429a      	cmp	r2, r3
 800dc56:	d1d7      	bne.n	800dc08 <vDNSDoCallback+0x1c>
					}
					break;
				}
			}
		}
		xTaskResumeAll();
 800dc58:	f7f7 fbf2 	bl	8005440 <xTaskResumeAll>
	}
 800dc5c:	3720      	adds	r7, #32
 800dc5e:	46bd      	mov	sp, r7
 800dc60:	bd80      	pop	{r7, pc}
 800dc62:	bf00      	nop
 800dc64:	2000c320 	.word	0x2000c320
 800dc68:	2000c318 	.word	0x2000c318

0800dc6c <prvReadNameField>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_DNS_CACHE == 1 )

	static uint8_t *prvReadNameField( uint8_t *pucByte, char *pcName, BaseType_t xLen )
	{
 800dc6c:	b480      	push	{r7}
 800dc6e:	b087      	sub	sp, #28
 800dc70:	af00      	add	r7, sp, #0
 800dc72:	60f8      	str	r0, [r7, #12]
 800dc74:	60b9      	str	r1, [r7, #8]
 800dc76:	607a      	str	r2, [r7, #4]
	BaseType_t xNameLen = 0;
 800dc78:	2300      	movs	r3, #0
 800dc7a:	617b      	str	r3, [r7, #20]
		/* Determine if the name is the fully coded name, or an offset to the name
		elsewhere in the message. */
		if( ( *pucByte & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
 800dc7c:	68fb      	ldr	r3, [r7, #12]
 800dc7e:	781b      	ldrb	r3, [r3, #0]
 800dc80:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800dc84:	2bc0      	cmp	r3, #192	; 0xc0
 800dc86:	d103      	bne.n	800dc90 <prvReadNameField+0x24>
		{
			/* Jump over the two byte offset. */
			pucByte += sizeof( uint16_t );
 800dc88:	68fb      	ldr	r3, [r7, #12]
 800dc8a:	3302      	adds	r3, #2
 800dc8c:	60fb      	str	r3, [r7, #12]
 800dc8e:	e033      	b.n	800dcf8 <prvReadNameField+0x8c>

		}
		else
		{
			/* pucByte points to the full name.  Walk over the string. */
			while( *pucByte != 0x00 )
 800dc90:	e02b      	b.n	800dcea <prvReadNameField+0x7e>
			{
				BaseType_t xCount;
				if( xNameLen && xNameLen < xLen - 1 )
 800dc92:	697b      	ldr	r3, [r7, #20]
 800dc94:	2b00      	cmp	r3, #0
 800dc96:	d00c      	beq.n	800dcb2 <prvReadNameField+0x46>
 800dc98:	687b      	ldr	r3, [r7, #4]
 800dc9a:	1e5a      	subs	r2, r3, #1
 800dc9c:	697b      	ldr	r3, [r7, #20]
 800dc9e:	429a      	cmp	r2, r3
 800dca0:	dd07      	ble.n	800dcb2 <prvReadNameField+0x46>
					pcName[xNameLen++] = '.';
 800dca2:	697b      	ldr	r3, [r7, #20]
 800dca4:	1c5a      	adds	r2, r3, #1
 800dca6:	617a      	str	r2, [r7, #20]
 800dca8:	461a      	mov	r2, r3
 800dcaa:	68bb      	ldr	r3, [r7, #8]
 800dcac:	4413      	add	r3, r2
 800dcae:	222e      	movs	r2, #46	; 0x2e
 800dcb0:	701a      	strb	r2, [r3, #0]
				for( xCount = *(pucByte++); xCount--; pucByte++ )
 800dcb2:	68fb      	ldr	r3, [r7, #12]
 800dcb4:	1c5a      	adds	r2, r3, #1
 800dcb6:	60fa      	str	r2, [r7, #12]
 800dcb8:	781b      	ldrb	r3, [r3, #0]
 800dcba:	613b      	str	r3, [r7, #16]
 800dcbc:	e010      	b.n	800dce0 <prvReadNameField+0x74>
				{
					if( xNameLen < xLen - 1 )
 800dcbe:	687b      	ldr	r3, [r7, #4]
 800dcc0:	1e5a      	subs	r2, r3, #1
 800dcc2:	697b      	ldr	r3, [r7, #20]
 800dcc4:	429a      	cmp	r2, r3
 800dcc6:	dd08      	ble.n	800dcda <prvReadNameField+0x6e>
						pcName[xNameLen++] = *( ( char * ) pucByte );
 800dcc8:	697b      	ldr	r3, [r7, #20]
 800dcca:	1c5a      	adds	r2, r3, #1
 800dccc:	617a      	str	r2, [r7, #20]
 800dcce:	461a      	mov	r2, r3
 800dcd0:	68bb      	ldr	r3, [r7, #8]
 800dcd2:	4413      	add	r3, r2
 800dcd4:	68fa      	ldr	r2, [r7, #12]
 800dcd6:	7812      	ldrb	r2, [r2, #0]
 800dcd8:	701a      	strb	r2, [r3, #0]
			while( *pucByte != 0x00 )
			{
				BaseType_t xCount;
				if( xNameLen && xNameLen < xLen - 1 )
					pcName[xNameLen++] = '.';
				for( xCount = *(pucByte++); xCount--; pucByte++ )
 800dcda:	68fb      	ldr	r3, [r7, #12]
 800dcdc:	3301      	adds	r3, #1
 800dcde:	60fb      	str	r3, [r7, #12]
 800dce0:	693b      	ldr	r3, [r7, #16]
 800dce2:	1e5a      	subs	r2, r3, #1
 800dce4:	613a      	str	r2, [r7, #16]
 800dce6:	2b00      	cmp	r3, #0
 800dce8:	d1e9      	bne.n	800dcbe <prvReadNameField+0x52>

		}
		else
		{
			/* pucByte points to the full name.  Walk over the string. */
			while( *pucByte != 0x00 )
 800dcea:	68fb      	ldr	r3, [r7, #12]
 800dcec:	781b      	ldrb	r3, [r3, #0]
 800dcee:	2b00      	cmp	r3, #0
 800dcf0:	d1cf      	bne.n	800dc92 <prvReadNameField+0x26>
					if( xNameLen < xLen - 1 )
						pcName[xNameLen++] = *( ( char * ) pucByte );
				}
			}

			pucByte++;
 800dcf2:	68fb      	ldr	r3, [r7, #12]
 800dcf4:	3301      	adds	r3, #1
 800dcf6:	60fb      	str	r3, [r7, #12]
		}

		return pucByte;
 800dcf8:	68fb      	ldr	r3, [r7, #12]
	}
 800dcfa:	4618      	mov	r0, r3
 800dcfc:	371c      	adds	r7, #28
 800dcfe:	46bd      	mov	sp, r7
 800dd00:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd04:	4770      	bx	lr
 800dd06:	bf00      	nop

0800dd08 <prvSkipNameField>:
#endif	/* ipconfigUSE_DNS_CACHE == 1 */
/*-----------------------------------------------------------*/

static uint8_t *prvSkipNameField( uint8_t *pucByte )
{
 800dd08:	b480      	push	{r7}
 800dd0a:	b083      	sub	sp, #12
 800dd0c:	af00      	add	r7, sp, #0
 800dd0e:	6078      	str	r0, [r7, #4]
	/* Determine if the name is the fully coded name, or an offset to the name
	elsewhere in the message. */
	if( ( *pucByte & dnsNAME_IS_OFFSET ) == dnsNAME_IS_OFFSET )
 800dd10:	687b      	ldr	r3, [r7, #4]
 800dd12:	781b      	ldrb	r3, [r3, #0]
 800dd14:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 800dd18:	2bc0      	cmp	r3, #192	; 0xc0
 800dd1a:	d103      	bne.n	800dd24 <prvSkipNameField+0x1c>
	{
		/* Jump over the two byte offset. */
		pucByte += sizeof( uint16_t );
 800dd1c:	687b      	ldr	r3, [r7, #4]
 800dd1e:	3302      	adds	r3, #2
 800dd20:	607b      	str	r3, [r7, #4]
 800dd22:	e00d      	b.n	800dd40 <prvSkipNameField+0x38>

	}
	else
	{
		/* pucByte points to the full name.  Walk over the string. */
		while( *pucByte != 0x00 )
 800dd24:	e005      	b.n	800dd32 <prvSkipNameField+0x2a>
		{
			/* The number of bytes to jump for each name section is stored in the byte
			before the name section. */
			pucByte += ( *pucByte + 1 );
 800dd26:	687b      	ldr	r3, [r7, #4]
 800dd28:	781b      	ldrb	r3, [r3, #0]
 800dd2a:	3301      	adds	r3, #1
 800dd2c:	687a      	ldr	r2, [r7, #4]
 800dd2e:	4413      	add	r3, r2
 800dd30:	607b      	str	r3, [r7, #4]

	}
	else
	{
		/* pucByte points to the full name.  Walk over the string. */
		while( *pucByte != 0x00 )
 800dd32:	687b      	ldr	r3, [r7, #4]
 800dd34:	781b      	ldrb	r3, [r3, #0]
 800dd36:	2b00      	cmp	r3, #0
 800dd38:	d1f5      	bne.n	800dd26 <prvSkipNameField+0x1e>
			/* The number of bytes to jump for each name section is stored in the byte
			before the name section. */
			pucByte += ( *pucByte + 1 );
		}

		pucByte++;
 800dd3a:	687b      	ldr	r3, [r7, #4]
 800dd3c:	3301      	adds	r3, #1
 800dd3e:	607b      	str	r3, [r7, #4]
	}

	return pucByte;
 800dd40:	687b      	ldr	r3, [r7, #4]
}
 800dd42:	4618      	mov	r0, r3
 800dd44:	370c      	adds	r7, #12
 800dd46:	46bd      	mov	sp, r7
 800dd48:	f85d 7b04 	ldr.w	r7, [sp], #4
 800dd4c:	4770      	bx	lr
 800dd4e:	bf00      	nop

0800dd50 <ulDNSHandlePacket>:
/*-----------------------------------------------------------*/

uint32_t ulDNSHandlePacket( NetworkBufferDescriptor_t *pxNetworkBuffer )
{
 800dd50:	b580      	push	{r7, lr}
 800dd52:	b084      	sub	sp, #16
 800dd54:	af00      	add	r7, sp, #0
 800dd56:	6078      	str	r0, [r7, #4]
uint8_t *pucUDPPayloadBuffer = pxNetworkBuffer->pucEthernetBuffer + sizeof( UDPPacket_t );
 800dd58:	687b      	ldr	r3, [r7, #4]
 800dd5a:	699b      	ldr	r3, [r3, #24]
 800dd5c:	332a      	adds	r3, #42	; 0x2a
 800dd5e:	60fb      	str	r3, [r7, #12]
DNSMessage_t *pxDNSMessageHeader = ( DNSMessage_t * ) pucUDPPayloadBuffer;
 800dd60:	68fb      	ldr	r3, [r7, #12]
 800dd62:	60bb      	str	r3, [r7, #8]

	prvParseDNSReply( pucUDPPayloadBuffer, ( uint32_t ) pxDNSMessageHeader->usIdentifier );
 800dd64:	68bb      	ldr	r3, [r7, #8]
 800dd66:	881b      	ldrh	r3, [r3, #0]
 800dd68:	b29b      	uxth	r3, r3
 800dd6a:	68f8      	ldr	r0, [r7, #12]
 800dd6c:	4619      	mov	r1, r3
 800dd6e:	f000 f805 	bl	800dd7c <prvParseDNSReply>

	/* The packet was not consumed. */
	return pdFAIL;
 800dd72:	2300      	movs	r3, #0
}
 800dd74:	4618      	mov	r0, r3
 800dd76:	3710      	adds	r7, #16
 800dd78:	46bd      	mov	sp, r7
 800dd7a:	bd80      	pop	{r7, pc}

0800dd7c <prvParseDNSReply>:

#endif /* ipconfigUSE_NBNS */
/*-----------------------------------------------------------*/

static uint32_t prvParseDNSReply( uint8_t *pucUDPPayloadBuffer, TickType_t xIdentifier )
{
 800dd7c:	b580      	push	{r7, lr}
 800dd7e:	b0b2      	sub	sp, #200	; 0xc8
 800dd80:	af00      	add	r7, sp, #0
 800dd82:	6078      	str	r0, [r7, #4]
 800dd84:	6039      	str	r1, [r7, #0]
DNSMessage_t *pxDNSMessageHeader;
uint32_t ulIPAddress = 0UL;
 800dd86:	2300      	movs	r3, #0
 800dd88:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
#if( ipconfigUSE_LLMNR == 1 )
	char *pcRequestedName = NULL;
 800dd8c:	2300      	movs	r3, #0
 800dd8e:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
#endif
uint8_t *pucByte;
uint16_t x, usDataLength, usQuestions;
#if( ipconfigUSE_LLMNR == 1 )
	uint16_t usType = 0, usClass = 0;
 800dd92:	2300      	movs	r3, #0
 800dd94:	f8a7 30b8 	strh.w	r3, [r7, #184]	; 0xb8
 800dd98:	2300      	movs	r3, #0
 800dd9a:	f8a7 30b6 	strh.w	r3, [r7, #182]	; 0xb6
#endif
#if( ipconfigUSE_DNS_CACHE == 1 )
	char pcName[128] = ""; /*_RB_ What is the significance of 128?  Probably too big to go on the stack for a small MCU but don't know how else it could be made re-entrant.  Might be necessary. */
 800dd9e:	2300      	movs	r3, #0
 800dda0:	60fb      	str	r3, [r7, #12]
 800dda2:	f107 0310 	add.w	r3, r7, #16
 800dda6:	227c      	movs	r2, #124	; 0x7c
 800dda8:	4618      	mov	r0, r3
 800ddaa:	2100      	movs	r1, #0
 800ddac:	f002 fa7c 	bl	80102a8 <memset>
#endif

	pxDNSMessageHeader = ( DNSMessage_t * ) pucUDPPayloadBuffer;
 800ddb0:	687b      	ldr	r3, [r7, #4]
 800ddb2:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4

	if( pxDNSMessageHeader->usIdentifier == ( uint16_t ) xIdentifier )
 800ddb6:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800ddba:	881b      	ldrh	r3, [r3, #0]
 800ddbc:	b29a      	uxth	r2, r3
 800ddbe:	683b      	ldr	r3, [r7, #0]
 800ddc0:	b29b      	uxth	r3, r3
 800ddc2:	429a      	cmp	r2, r3
 800ddc4:	f040 8230 	bne.w	800e228 <prvParseDNSReply+0x4ac>
	{
		/* Start at the first byte after the header. */
		pucByte = pucUDPPayloadBuffer + sizeof( DNSMessage_t );
 800ddc8:	687b      	ldr	r3, [r7, #4]
 800ddca:	330c      	adds	r3, #12
 800ddcc:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

		/* Skip any question records. */
		usQuestions = FreeRTOS_ntohs( pxDNSMessageHeader->usQuestions );
 800ddd0:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800ddd4:	889b      	ldrh	r3, [r3, #4]
 800ddd6:	b29b      	uxth	r3, r3
 800ddd8:	021b      	lsls	r3, r3, #8
 800ddda:	b29a      	uxth	r2, r3
 800dddc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800dde0:	889b      	ldrh	r3, [r3, #4]
 800dde2:	b29b      	uxth	r3, r3
 800dde4:	0a1b      	lsrs	r3, r3, #8
 800dde6:	b29b      	uxth	r3, r3
 800dde8:	b29b      	uxth	r3, r3
 800ddea:	4313      	orrs	r3, r2
 800ddec:	b29b      	uxth	r3, r3
 800ddee:	f8a7 30aa 	strh.w	r3, [r7, #170]	; 0xaa
		for( x = 0; x < usQuestions; x++ )
 800ddf2:	2300      	movs	r3, #0
 800ddf4:	f8a7 30ba 	strh.w	r3, [r7, #186]	; 0xba
 800ddf8:	e036      	b.n	800de68 <prvParseDNSReply+0xec>
		{
			#if( ipconfigUSE_LLMNR == 1 )
			{
				if( x == 0 )
 800ddfa:	f8b7 30ba 	ldrh.w	r3, [r7, #186]	; 0xba
 800ddfe:	2b00      	cmp	r3, #0
 800de00:	d103      	bne.n	800de0a <prvParseDNSReply+0x8e>
				{
					pcRequestedName = ( char * ) pucByte;
 800de02:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800de06:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
				}
			}
			#endif

#if( ipconfigUSE_DNS_CACHE == 1 )
			if( x == 0 )
 800de0a:	f8b7 30ba 	ldrh.w	r3, [r7, #186]	; 0xba
 800de0e:	2b00      	cmp	r3, #0
 800de10:	d10a      	bne.n	800de28 <prvParseDNSReply+0xac>
			{
				pucByte = prvReadNameField( pucByte, pcName, sizeof( pcName ) );
 800de12:	f107 030c 	add.w	r3, r7, #12
 800de16:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
 800de1a:	4619      	mov	r1, r3
 800de1c:	2280      	movs	r2, #128	; 0x80
 800de1e:	f7ff ff25 	bl	800dc6c <prvReadNameField>
 800de22:	f8c7 00bc 	str.w	r0, [r7, #188]	; 0xbc
 800de26:	e005      	b.n	800de34 <prvParseDNSReply+0xb8>
			}
			else
#endif /* ipconfigUSE_DNS_CACHE */
			{
				/* Skip the variable length pcName field. */
				pucByte = prvSkipNameField( pucByte );
 800de28:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
 800de2c:	f7ff ff6c 	bl	800dd08 <prvSkipNameField>
 800de30:	f8c7 00bc 	str.w	r0, [r7, #188]	; 0xbc
			}

			#if( ipconfigUSE_LLMNR == 1 )
			{
				/* usChar2u16 returns value in host endianness */
				usType = usChar2u16( pucByte );
 800de34:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
 800de38:	f7ff fe64 	bl	800db04 <usChar2u16>
 800de3c:	4603      	mov	r3, r0
 800de3e:	f8a7 30b8 	strh.w	r3, [r7, #184]	; 0xb8
				usClass = usChar2u16( pucByte + 2 );
 800de42:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800de46:	3302      	adds	r3, #2
 800de48:	4618      	mov	r0, r3
 800de4a:	f7ff fe5b 	bl	800db04 <usChar2u16>
 800de4e:	4603      	mov	r3, r0
 800de50:	f8a7 30b6 	strh.w	r3, [r7, #182]	; 0xb6
			}
			#endif /* ipconfigUSE_LLMNR */

			/* Skip the type and class fields. */
			pucByte += sizeof( uint32_t );
 800de54:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800de58:	3304      	adds	r3, #4
 800de5a:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
		/* Start at the first byte after the header. */
		pucByte = pucUDPPayloadBuffer + sizeof( DNSMessage_t );

		/* Skip any question records. */
		usQuestions = FreeRTOS_ntohs( pxDNSMessageHeader->usQuestions );
		for( x = 0; x < usQuestions; x++ )
 800de5e:	f8b7 30ba 	ldrh.w	r3, [r7, #186]	; 0xba
 800de62:	3301      	adds	r3, #1
 800de64:	f8a7 30ba 	strh.w	r3, [r7, #186]	; 0xba
 800de68:	f8b7 20ba 	ldrh.w	r2, [r7, #186]	; 0xba
 800de6c:	f8b7 30aa 	ldrh.w	r3, [r7, #170]	; 0xaa
 800de70:	429a      	cmp	r2, r3
 800de72:	d3c2      	bcc.n	800ddfa <prvParseDNSReply+0x7e>
			/* Skip the type and class fields. */
			pucByte += sizeof( uint32_t );
		}

		/* Search through the answers records. */
		pxDNSMessageHeader->usAnswers = FreeRTOS_ntohs( pxDNSMessageHeader->usAnswers );
 800de74:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800de78:	88db      	ldrh	r3, [r3, #6]
 800de7a:	b29b      	uxth	r3, r3
 800de7c:	021b      	lsls	r3, r3, #8
 800de7e:	b29a      	uxth	r2, r3
 800de80:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800de84:	88db      	ldrh	r3, [r3, #6]
 800de86:	b29b      	uxth	r3, r3
 800de88:	0a1b      	lsrs	r3, r3, #8
 800de8a:	b29b      	uxth	r3, r3
 800de8c:	b29b      	uxth	r3, r3
 800de8e:	4313      	orrs	r3, r2
 800de90:	b29b      	uxth	r3, r3
 800de92:	b29a      	uxth	r2, r3
 800de94:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800de98:	80da      	strh	r2, [r3, #6]

		if( ( pxDNSMessageHeader->usFlags & dnsRX_FLAGS_MASK ) == dnsEXPECTED_RX_FLAGS )
 800de9a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800de9e:	885b      	ldrh	r3, [r3, #2]
 800dea0:	b29b      	uxth	r3, r3
 800dea2:	f403 6378 	and.w	r3, r3, #3968	; 0xf80
 800dea6:	2b80      	cmp	r3, #128	; 0x80
 800dea8:	d172      	bne.n	800df90 <prvParseDNSReply+0x214>
		{
			for( x = 0; x < pxDNSMessageHeader->usAnswers; x++ )
 800deaa:	2300      	movs	r3, #0
 800deac:	f8a7 30ba 	strh.w	r3, [r7, #186]	; 0xba
 800deb0:	e064      	b.n	800df7c <prvParseDNSReply+0x200>
			{
				pucByte = prvSkipNameField( pucByte );
 800deb2:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
 800deb6:	f7ff ff27 	bl	800dd08 <prvSkipNameField>
 800deba:	f8c7 00bc 	str.w	r0, [r7, #188]	; 0xbc

				/* Is the type field that of an A record? */
				if( usChar2u16( pucByte ) == dnsTYPE_A_HOST )
 800debe:	f8d7 00bc 	ldr.w	r0, [r7, #188]	; 0xbc
 800dec2:	f7ff fe1f 	bl	800db04 <usChar2u16>
 800dec6:	4603      	mov	r3, r0
 800dec8:	2b01      	cmp	r3, #1
 800deca:	d12f      	bne.n	800df2c <prvParseDNSReply+0x1b0>
				{
					/* This is the required record.  Skip the type, class, and
					time to live fields, plus the first byte of the data
					length. */
					pucByte += ( sizeof( uint32_t ) + sizeof( uint32_t ) + sizeof( uint8_t ) );
 800decc:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800ded0:	3309      	adds	r3, #9
 800ded2:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

					/* Sanity check the data length. */
					if( ( size_t ) *pucByte == sizeof( uint32_t ) )
 800ded6:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800deda:	781b      	ldrb	r3, [r3, #0]
 800dedc:	2b04      	cmp	r3, #4
 800dede:	d124      	bne.n	800df2a <prvParseDNSReply+0x1ae>
					{
						/* Skip the second byte of the length. */
						pucByte++;
 800dee0:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800dee4:	3301      	adds	r3, #1
 800dee6:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

						/* Copy the IP address out of the record. */
						memcpy( ( void * ) &ulIPAddress, ( void * ) pucByte, sizeof( uint32_t ) );
 800deea:	f107 0390 	add.w	r3, r7, #144	; 0x90
 800deee:	4618      	mov	r0, r3
 800def0:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
 800def4:	2204      	movs	r2, #4
 800def6:	f002 f8d7 	bl	80100a8 <memcpy>

						#if( ipconfigUSE_DNS_CACHE == 1 )
						{
							prvProcessDNSCache( pcName, &ulIPAddress, pdFALSE );
 800defa:	f107 020c 	add.w	r2, r7, #12
 800defe:	f107 0390 	add.w	r3, r7, #144	; 0x90
 800df02:	4610      	mov	r0, r2
 800df04:	4619      	mov	r1, r3
 800df06:	2200      	movs	r2, #0
 800df08:	f000 fa02 	bl	800e310 <prvProcessDNSCache>
						}
						#endif /* ipconfigUSE_DNS_CACHE */
						#if( ipconfigDNS_USE_CALLBACKS != 0 )
						{
							/* See if any asynchronous call was made to FreeRTOS_gethostbyname_a() */
							vDNSDoCallback( ( TickType_t ) pxDNSMessageHeader->usIdentifier, pcName, ulIPAddress );
 800df0c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800df10:	881b      	ldrh	r3, [r3, #0]
 800df12:	b29b      	uxth	r3, r3
 800df14:	4619      	mov	r1, r3
 800df16:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 800df1a:	f107 020c 	add.w	r2, r7, #12
 800df1e:	4608      	mov	r0, r1
 800df20:	4611      	mov	r1, r2
 800df22:	461a      	mov	r2, r3
 800df24:	f7ff fe62 	bl	800dbec <vDNSDoCallback>
						}
						#endif	/* ipconfigDNS_USE_CALLBACKS != 0 */
					}

					break;
 800df28:	e031      	b.n	800df8e <prvParseDNSReply+0x212>
 800df2a:	e030      	b.n	800df8e <prvParseDNSReply+0x212>
				}
				else
				{
					/* Skip the type, class and time to live fields. */
					pucByte += ( sizeof( uint32_t ) + sizeof( uint32_t ) );
 800df2c:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800df30:	3308      	adds	r3, #8
 800df32:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc

					/* Determine the length of the data in the field. */
					memcpy( ( void * ) &usDataLength, ( void * ) pucByte, sizeof( uint16_t ) );
 800df36:	f107 038e 	add.w	r3, r7, #142	; 0x8e
 800df3a:	4618      	mov	r0, r3
 800df3c:	f8d7 10bc 	ldr.w	r1, [r7, #188]	; 0xbc
 800df40:	2202      	movs	r2, #2
 800df42:	f002 f8b1 	bl	80100a8 <memcpy>
					usDataLength = FreeRTOS_ntohs( usDataLength );
 800df46:	f8b7 308e 	ldrh.w	r3, [r7, #142]	; 0x8e
 800df4a:	021b      	lsls	r3, r3, #8
 800df4c:	b29a      	uxth	r2, r3
 800df4e:	f8b7 308e 	ldrh.w	r3, [r7, #142]	; 0x8e
 800df52:	0a1b      	lsrs	r3, r3, #8
 800df54:	b29b      	uxth	r3, r3
 800df56:	b29b      	uxth	r3, r3
 800df58:	4313      	orrs	r3, r2
 800df5a:	b29b      	uxth	r3, r3
 800df5c:	b29b      	uxth	r3, r3
 800df5e:	f8a7 308e 	strh.w	r3, [r7, #142]	; 0x8e

					/* Jump over the data length bytes, and the data itself. */
					pucByte += usDataLength + sizeof( uint16_t );
 800df62:	f8b7 308e 	ldrh.w	r3, [r7, #142]	; 0x8e
 800df66:	3302      	adds	r3, #2
 800df68:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 800df6c:	4413      	add	r3, r2
 800df6e:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
		/* Search through the answers records. */
		pxDNSMessageHeader->usAnswers = FreeRTOS_ntohs( pxDNSMessageHeader->usAnswers );

		if( ( pxDNSMessageHeader->usFlags & dnsRX_FLAGS_MASK ) == dnsEXPECTED_RX_FLAGS )
		{
			for( x = 0; x < pxDNSMessageHeader->usAnswers; x++ )
 800df72:	f8b7 30ba 	ldrh.w	r3, [r7, #186]	; 0xba
 800df76:	3301      	adds	r3, #1
 800df78:	f8a7 30ba 	strh.w	r3, [r7, #186]	; 0xba
 800df7c:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800df80:	88db      	ldrh	r3, [r3, #6]
 800df82:	b29b      	uxth	r3, r3
 800df84:	f8b7 20ba 	ldrh.w	r2, [r7, #186]	; 0xba
 800df88:	429a      	cmp	r2, r3
 800df8a:	d392      	bcc.n	800deb2 <prvParseDNSReply+0x136>
 800df8c:	e14c      	b.n	800e228 <prvParseDNSReply+0x4ac>
 800df8e:	e14b      	b.n	800e228 <prvParseDNSReply+0x4ac>
					pucByte += usDataLength + sizeof( uint16_t );
				}
			}
		}
#if( ipconfigUSE_LLMNR == 1 )
		else if( usQuestions && ( usType == dnsTYPE_A_HOST ) && ( usClass == dnsCLASS_IN ) )
 800df90:	f8b7 30aa 	ldrh.w	r3, [r7, #170]	; 0xaa
 800df94:	2b00      	cmp	r3, #0
 800df96:	f000 8147 	beq.w	800e228 <prvParseDNSReply+0x4ac>
 800df9a:	f8b7 30b8 	ldrh.w	r3, [r7, #184]	; 0xb8
 800df9e:	2b01      	cmp	r3, #1
 800dfa0:	f040 8142 	bne.w	800e228 <prvParseDNSReply+0x4ac>
 800dfa4:	f8b7 30b6 	ldrh.w	r3, [r7, #182]	; 0xb6
 800dfa8:	2b01      	cmp	r3, #1
 800dfaa:	f040 813d 	bne.w	800e228 <prvParseDNSReply+0x4ac>
		{
			/* If this is not a reply to our DNS request, it might an LLMNR
			request. */
			if( xApplicationDNSQueryHook ( ( pcRequestedName + 1 ) ) )
 800dfae:	f8d7 30c0 	ldr.w	r3, [r7, #192]	; 0xc0
 800dfb2:	3301      	adds	r3, #1
 800dfb4:	4618      	mov	r0, r3
 800dfb6:	f001 fab5 	bl	800f524 <xApplicationDNSQueryHook>
 800dfba:	4603      	mov	r3, r0
 800dfbc:	2b00      	cmp	r3, #0
 800dfbe:	f000 8133 	beq.w	800e228 <prvParseDNSReply+0x4ac>
			{
			int16_t usLength;
			NetworkBufferDescriptor_t *pxNewBuffer = NULL;
 800dfc2:	2300      	movs	r3, #0
 800dfc4:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
			NetworkBufferDescriptor_t *pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( pucUDPPayloadBuffer );
 800dfc8:	6878      	ldr	r0, [r7, #4]
 800dfca:	f7f9 fe8d 	bl	8007ce8 <pxUDPPayloadBuffer_to_NetworkBuffer>
 800dfce:	f8c7 00ac 	str.w	r0, [r7, #172]	; 0xac
			LLMNRAnswer_t *pxAnswer;

				if( ( xBufferAllocFixedSize == pdFALSE ) && ( pxNetworkBuffer != NULL ) )
 800dfd2:	4b98      	ldr	r3, [pc, #608]	; (800e234 <prvParseDNSReply+0x4b8>)
 800dfd4:	681b      	ldr	r3, [r3, #0]
 800dfd6:	2b00      	cmp	r3, #0
 800dfd8:	d144      	bne.n	800e064 <prvParseDNSReply+0x2e8>
 800dfda:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800dfde:	2b00      	cmp	r3, #0
 800dfe0:	d040      	beq.n	800e064 <prvParseDNSReply+0x2e8>
				{
				BaseType_t xDataLength = pxNetworkBuffer->xDataLength + sizeof( UDPHeader_t ) +
 800dfe2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800dfe6:	69db      	ldr	r3, [r3, #28]
					sizeof( EthernetHeader_t ) + sizeof( IPHeader_t );
 800dfe8:	332a      	adds	r3, #42	; 0x2a
			NetworkBufferDescriptor_t *pxNetworkBuffer = pxUDPPayloadBuffer_to_NetworkBuffer( pucUDPPayloadBuffer );
			LLMNRAnswer_t *pxAnswer;

				if( ( xBufferAllocFixedSize == pdFALSE ) && ( pxNetworkBuffer != NULL ) )
				{
				BaseType_t xDataLength = pxNetworkBuffer->xDataLength + sizeof( UDPHeader_t ) +
 800dfea:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
					sizeof( EthernetHeader_t ) + sizeof( IPHeader_t );

					/* The field xDataLength was set to the length of the UDP payload.
					The answer (reply) will be longer than the request, so the packet
					must be duplicaed into a bigger buffer */
					pxNetworkBuffer->xDataLength = xDataLength;
 800dfee:	f8d7 20a4 	ldr.w	r2, [r7, #164]	; 0xa4
 800dff2:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800dff6:	61da      	str	r2, [r3, #28]
					pxNewBuffer = pxDuplicateNetworkBufferWithDescriptor( pxNetworkBuffer, xDataLength + 16 );
 800dff8:	f8d7 30a4 	ldr.w	r3, [r7, #164]	; 0xa4
 800dffc:	3310      	adds	r3, #16
 800dffe:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 800e002:	4619      	mov	r1, r3
 800e004:	f7f9 fe24 	bl	8007c50 <pxDuplicateNetworkBufferWithDescriptor>
 800e008:	f8c7 00b0 	str.w	r0, [r7, #176]	; 0xb0
					if( pxNewBuffer != NULL )
 800e00c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800e010:	2b00      	cmp	r3, #0
 800e012:	d024      	beq.n	800e05e <prvParseDNSReply+0x2e2>
					{
					BaseType_t xOffset1, xOffset2;

						xOffset1 = ( BaseType_t ) ( pucByte - pucUDPPayloadBuffer );
 800e014:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 800e018:	687b      	ldr	r3, [r7, #4]
 800e01a:	1ad3      	subs	r3, r2, r3
 800e01c:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
						xOffset2 = ( BaseType_t ) ( ( ( uint8_t * ) pcRequestedName ) - pucUDPPayloadBuffer );
 800e020:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 800e024:	687b      	ldr	r3, [r7, #4]
 800e026:	1ad3      	subs	r3, r2, r3
 800e028:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c

						pxNetworkBuffer = pxNewBuffer;
 800e02c:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800e030:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
						pucUDPPayloadBuffer = pxNetworkBuffer->pucEthernetBuffer + ipUDP_PAYLOAD_OFFSET_IPv4;
 800e034:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e038:	699b      	ldr	r3, [r3, #24]
 800e03a:	332a      	adds	r3, #42	; 0x2a
 800e03c:	607b      	str	r3, [r7, #4]

						pucByte = pucUDPPayloadBuffer + xOffset1;
 800e03e:	f8d7 30a0 	ldr.w	r3, [r7, #160]	; 0xa0
 800e042:	687a      	ldr	r2, [r7, #4]
 800e044:	4413      	add	r3, r2
 800e046:	f8c7 30bc 	str.w	r3, [r7, #188]	; 0xbc
						pcRequestedName = ( char * ) ( pucUDPPayloadBuffer + xOffset2 );
 800e04a:	f8d7 309c 	ldr.w	r3, [r7, #156]	; 0x9c
 800e04e:	687a      	ldr	r2, [r7, #4]
 800e050:	4413      	add	r3, r2
 800e052:	f8c7 30c0 	str.w	r3, [r7, #192]	; 0xc0
						pxDNSMessageHeader = ( DNSMessage_t * ) pucUDPPayloadBuffer;
 800e056:	687b      	ldr	r3, [r7, #4]
 800e058:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
 800e05c:	e002      	b.n	800e064 <prvParseDNSReply+0x2e8>

					}
					else
					{
						/* Just to indicate that the message may not be answered. */
						pxNetworkBuffer = NULL;
 800e05e:	2300      	movs	r3, #0
 800e060:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
					}
				}
				if( pxNetworkBuffer != NULL )
 800e064:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
 800e068:	2b00      	cmp	r3, #0
 800e06a:	f000 80dd 	beq.w	800e228 <prvParseDNSReply+0x4ac>
				{
					pxAnswer = (LLMNRAnswer_t *)pucByte;
 800e06e:	f8d7 30bc 	ldr.w	r3, [r7, #188]	; 0xbc
 800e072:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98

					/* We leave 'usIdentifier' and 'usQuestions' untouched */
					vSetField16( pxDNSMessageHeader, DNSMessage_t, usFlags, dnsLLMNR_FLAGS_IS_REPONSE );	/* Set the response flag */
 800e076:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e07a:	3302      	adds	r3, #2
 800e07c:	2280      	movs	r2, #128	; 0x80
 800e07e:	701a      	strb	r2, [r3, #0]
 800e080:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e084:	3303      	adds	r3, #3
 800e086:	2200      	movs	r2, #0
 800e088:	701a      	strb	r2, [r3, #0]
					vSetField16( pxDNSMessageHeader, DNSMessage_t, usAnswers, 1 );	/* Provide a single answer */
 800e08a:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e08e:	3306      	adds	r3, #6
 800e090:	2200      	movs	r2, #0
 800e092:	701a      	strb	r2, [r3, #0]
 800e094:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e098:	3307      	adds	r3, #7
 800e09a:	2201      	movs	r2, #1
 800e09c:	701a      	strb	r2, [r3, #0]
					vSetField16( pxDNSMessageHeader, DNSMessage_t, usAuthorityRRs, 0 );	/* No authority */
 800e09e:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e0a2:	3308      	adds	r3, #8
 800e0a4:	2200      	movs	r2, #0
 800e0a6:	701a      	strb	r2, [r3, #0]
 800e0a8:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e0ac:	3309      	adds	r3, #9
 800e0ae:	2200      	movs	r2, #0
 800e0b0:	701a      	strb	r2, [r3, #0]
					vSetField16( pxDNSMessageHeader, DNSMessage_t, usAdditionalRRs, 0 );	/* No additional info */
 800e0b2:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e0b6:	330a      	adds	r3, #10
 800e0b8:	2200      	movs	r2, #0
 800e0ba:	701a      	strb	r2, [r3, #0]
 800e0bc:	f8d7 30c4 	ldr.w	r3, [r7, #196]	; 0xc4
 800e0c0:	330b      	adds	r3, #11
 800e0c2:	2200      	movs	r2, #0
 800e0c4:	701a      	strb	r2, [r3, #0]

					pxAnswer->ucNameCode = dnsNAME_IS_OFFSET;
 800e0c6:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e0ca:	22c0      	movs	r2, #192	; 0xc0
 800e0cc:	701a      	strb	r2, [r3, #0]
					pxAnswer->ucNameOffset = ( uint8_t )( pcRequestedName - ( char * ) pucUDPPayloadBuffer );
 800e0ce:	f8d7 20c0 	ldr.w	r2, [r7, #192]	; 0xc0
 800e0d2:	687b      	ldr	r3, [r7, #4]
 800e0d4:	1ad3      	subs	r3, r2, r3
 800e0d6:	b2da      	uxtb	r2, r3
 800e0d8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e0dc:	705a      	strb	r2, [r3, #1]

					vSetField16( pxAnswer, LLMNRAnswer_t, usType, dnsTYPE_A_HOST );	/* Type A: host */
 800e0de:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e0e2:	3302      	adds	r3, #2
 800e0e4:	2200      	movs	r2, #0
 800e0e6:	701a      	strb	r2, [r3, #0]
 800e0e8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e0ec:	3303      	adds	r3, #3
 800e0ee:	2201      	movs	r2, #1
 800e0f0:	701a      	strb	r2, [r3, #0]
					vSetField16( pxAnswer, LLMNRAnswer_t, usClass, dnsCLASS_IN );	/* 1: Class IN */
 800e0f2:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e0f6:	3304      	adds	r3, #4
 800e0f8:	2200      	movs	r2, #0
 800e0fa:	701a      	strb	r2, [r3, #0]
 800e0fc:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e100:	3305      	adds	r3, #5
 800e102:	2201      	movs	r2, #1
 800e104:	701a      	strb	r2, [r3, #0]
					vSetField32( pxAnswer, LLMNRAnswer_t, ulTTL, dnsLLMNR_TTL_VALUE );
 800e106:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e10a:	3306      	adds	r3, #6
 800e10c:	2200      	movs	r2, #0
 800e10e:	701a      	strb	r2, [r3, #0]
 800e110:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e114:	3307      	adds	r3, #7
 800e116:	2204      	movs	r2, #4
 800e118:	701a      	strb	r2, [r3, #0]
 800e11a:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e11e:	3308      	adds	r3, #8
 800e120:	2293      	movs	r2, #147	; 0x93
 800e122:	701a      	strb	r2, [r3, #0]
 800e124:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e128:	3309      	adds	r3, #9
 800e12a:	22e0      	movs	r2, #224	; 0xe0
 800e12c:	701a      	strb	r2, [r3, #0]
					vSetField16( pxAnswer, LLMNRAnswer_t, usDataLength, 4 );
 800e12e:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e132:	330a      	adds	r3, #10
 800e134:	2200      	movs	r2, #0
 800e136:	701a      	strb	r2, [r3, #0]
 800e138:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e13c:	330b      	adds	r3, #11
 800e13e:	2204      	movs	r2, #4
 800e140:	701a      	strb	r2, [r3, #0]
					vSetField32( pxAnswer, LLMNRAnswer_t, ulIPAddress, FreeRTOS_ntohl( *ipLOCAL_IP_ADDRESS_POINTER ) );
 800e142:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e146:	330c      	adds	r3, #12
 800e148:	4a3b      	ldr	r2, [pc, #236]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e14a:	6952      	ldr	r2, [r2, #20]
 800e14c:	0611      	lsls	r1, r2, #24
 800e14e:	4a3a      	ldr	r2, [pc, #232]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e150:	6952      	ldr	r2, [r2, #20]
 800e152:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 800e156:	0212      	lsls	r2, r2, #8
 800e158:	4311      	orrs	r1, r2
 800e15a:	4a37      	ldr	r2, [pc, #220]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e15c:	6952      	ldr	r2, [r2, #20]
 800e15e:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 800e162:	0a12      	lsrs	r2, r2, #8
 800e164:	4311      	orrs	r1, r2
 800e166:	4a34      	ldr	r2, [pc, #208]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e168:	6952      	ldr	r2, [r2, #20]
 800e16a:	0e12      	lsrs	r2, r2, #24
 800e16c:	430a      	orrs	r2, r1
 800e16e:	0e12      	lsrs	r2, r2, #24
 800e170:	b2d2      	uxtb	r2, r2
 800e172:	701a      	strb	r2, [r3, #0]
 800e174:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e178:	330d      	adds	r3, #13
 800e17a:	4a2f      	ldr	r2, [pc, #188]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e17c:	6952      	ldr	r2, [r2, #20]
 800e17e:	0611      	lsls	r1, r2, #24
 800e180:	4a2d      	ldr	r2, [pc, #180]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e182:	6952      	ldr	r2, [r2, #20]
 800e184:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 800e188:	0212      	lsls	r2, r2, #8
 800e18a:	4311      	orrs	r1, r2
 800e18c:	4a2a      	ldr	r2, [pc, #168]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e18e:	6952      	ldr	r2, [r2, #20]
 800e190:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 800e194:	0a12      	lsrs	r2, r2, #8
 800e196:	4311      	orrs	r1, r2
 800e198:	4a27      	ldr	r2, [pc, #156]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e19a:	6952      	ldr	r2, [r2, #20]
 800e19c:	0e12      	lsrs	r2, r2, #24
 800e19e:	430a      	orrs	r2, r1
 800e1a0:	0c12      	lsrs	r2, r2, #16
 800e1a2:	b2d2      	uxtb	r2, r2
 800e1a4:	701a      	strb	r2, [r3, #0]
 800e1a6:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e1aa:	330e      	adds	r3, #14
 800e1ac:	4a22      	ldr	r2, [pc, #136]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e1ae:	6952      	ldr	r2, [r2, #20]
 800e1b0:	0611      	lsls	r1, r2, #24
 800e1b2:	4a21      	ldr	r2, [pc, #132]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e1b4:	6952      	ldr	r2, [r2, #20]
 800e1b6:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
 800e1ba:	0212      	lsls	r2, r2, #8
 800e1bc:	4311      	orrs	r1, r2
 800e1be:	4a1e      	ldr	r2, [pc, #120]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e1c0:	6952      	ldr	r2, [r2, #20]
 800e1c2:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 800e1c6:	0a12      	lsrs	r2, r2, #8
 800e1c8:	4311      	orrs	r1, r2
 800e1ca:	4a1b      	ldr	r2, [pc, #108]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e1cc:	6952      	ldr	r2, [r2, #20]
 800e1ce:	0e12      	lsrs	r2, r2, #24
 800e1d0:	430a      	orrs	r2, r1
 800e1d2:	0a12      	lsrs	r2, r2, #8
 800e1d4:	b2d2      	uxtb	r2, r2
 800e1d6:	701a      	strb	r2, [r3, #0]
 800e1d8:	f8d7 3098 	ldr.w	r3, [r7, #152]	; 0x98
 800e1dc:	330f      	adds	r3, #15
 800e1de:	4a16      	ldr	r2, [pc, #88]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e1e0:	6952      	ldr	r2, [r2, #20]
 800e1e2:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
 800e1e6:	0a12      	lsrs	r2, r2, #8
 800e1e8:	b2d1      	uxtb	r1, r2
 800e1ea:	4a13      	ldr	r2, [pc, #76]	; (800e238 <prvParseDNSReply+0x4bc>)
 800e1ec:	6952      	ldr	r2, [r2, #20]
 800e1ee:	0e12      	lsrs	r2, r2, #24
 800e1f0:	b2d2      	uxtb	r2, r2
 800e1f2:	430a      	orrs	r2, r1
 800e1f4:	b2d2      	uxtb	r2, r2
 800e1f6:	701a      	strb	r2, [r3, #0]

					usLength = ( int16_t ) ( sizeof( *pxAnswer ) + ( size_t ) ( pucByte - pucUDPPayloadBuffer ) );
 800e1f8:	f8d7 20bc 	ldr.w	r2, [r7, #188]	; 0xbc
 800e1fc:	687b      	ldr	r3, [r7, #4]
 800e1fe:	1ad3      	subs	r3, r2, r3
 800e200:	b29b      	uxth	r3, r3
 800e202:	3310      	adds	r3, #16
 800e204:	b29b      	uxth	r3, r3
 800e206:	f8a7 3096 	strh.w	r3, [r7, #150]	; 0x96

					prvReplyDNSMessage( pxNetworkBuffer, usLength );
 800e20a:	f9b7 3096 	ldrsh.w	r3, [r7, #150]	; 0x96
 800e20e:	f8d7 00ac 	ldr.w	r0, [r7, #172]	; 0xac
 800e212:	4619      	mov	r1, r3
 800e214:	f000 f812 	bl	800e23c <prvReplyDNSMessage>

					if( pxNewBuffer != NULL )
 800e218:	f8d7 30b0 	ldr.w	r3, [r7, #176]	; 0xb0
 800e21c:	2b00      	cmp	r3, #0
 800e21e:	d003      	beq.n	800e228 <prvParseDNSReply+0x4ac>
					{
						vReleaseNetworkBufferAndDescriptor( pxNewBuffer );
 800e220:	f8d7 00b0 	ldr.w	r0, [r7, #176]	; 0xb0
 800e224:	f7f9 fada 	bl	80077dc <vReleaseNetworkBufferAndDescriptor>
			}
		}
#endif /* ipconfigUSE_LLMNR == 1 */
	}

	return ulIPAddress;
 800e228:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
}
 800e22c:	4618      	mov	r0, r3
 800e22e:	37c8      	adds	r7, #200	; 0xc8
 800e230:	46bd      	mov	sp, r7
 800e232:	bd80      	pop	{r7, pc}
 800e234:	08012a08 	.word	0x08012a08
 800e238:	2000bb08 	.word	0x2000bb08

0800e23c <prvReplyDNSMessage>:
/*-----------------------------------------------------------*/

#if( ( ipconfigUSE_NBNS == 1 ) || ( ipconfigUSE_LLMNR == 1 ) )

	static void prvReplyDNSMessage( NetworkBufferDescriptor_t *pxNetworkBuffer, BaseType_t lNetLength )
	{
 800e23c:	b580      	push	{r7, lr}
 800e23e:	b086      	sub	sp, #24
 800e240:	af00      	add	r7, sp, #0
 800e242:	6078      	str	r0, [r7, #4]
 800e244:	6039      	str	r1, [r7, #0]
	UDPPacket_t *pxUDPPacket;
	IPHeader_t *pxIPHeader;
	UDPHeader_t *pxUDPHeader;

		pxUDPPacket = (UDPPacket_t *) pxNetworkBuffer->pucEthernetBuffer;
 800e246:	687b      	ldr	r3, [r7, #4]
 800e248:	699b      	ldr	r3, [r3, #24]
 800e24a:	617b      	str	r3, [r7, #20]
		pxIPHeader = &pxUDPPacket->xIPHeader;
 800e24c:	697b      	ldr	r3, [r7, #20]
 800e24e:	330e      	adds	r3, #14
 800e250:	613b      	str	r3, [r7, #16]
		pxUDPHeader = &pxUDPPacket->xUDPHeader;
 800e252:	697b      	ldr	r3, [r7, #20]
 800e254:	3322      	adds	r3, #34	; 0x22
 800e256:	60fb      	str	r3, [r7, #12]
		/* HT: started using defines like 'ipSIZE_OF_xxx' */
		pxIPHeader->usLength               = FreeRTOS_htons( lNetLength + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_UDP_HEADER );
 800e258:	683b      	ldr	r3, [r7, #0]
 800e25a:	b29b      	uxth	r3, r3
 800e25c:	331c      	adds	r3, #28
 800e25e:	b29b      	uxth	r3, r3
 800e260:	021b      	lsls	r3, r3, #8
 800e262:	b29a      	uxth	r2, r3
 800e264:	683b      	ldr	r3, [r7, #0]
 800e266:	331c      	adds	r3, #28
 800e268:	0a1b      	lsrs	r3, r3, #8
 800e26a:	b29b      	uxth	r3, r3
 800e26c:	4313      	orrs	r3, r2
 800e26e:	b29a      	uxth	r2, r3
 800e270:	693b      	ldr	r3, [r7, #16]
 800e272:	805a      	strh	r2, [r3, #2]
		/* HT:endian: should not be translated, copying from packet to packet */
		pxIPHeader->ulDestinationIPAddress = pxIPHeader->ulSourceIPAddress;
 800e274:	693b      	ldr	r3, [r7, #16]
 800e276:	68da      	ldr	r2, [r3, #12]
 800e278:	693b      	ldr	r3, [r7, #16]
 800e27a:	611a      	str	r2, [r3, #16]
		pxIPHeader->ulSourceIPAddress      = *ipLOCAL_IP_ADDRESS_POINTER;
 800e27c:	4b22      	ldr	r3, [pc, #136]	; (800e308 <prvReplyDNSMessage+0xcc>)
 800e27e:	695a      	ldr	r2, [r3, #20]
 800e280:	693b      	ldr	r3, [r7, #16]
 800e282:	60da      	str	r2, [r3, #12]
		pxIPHeader->ucTimeToLive           = ipconfigUDP_TIME_TO_LIVE;
 800e284:	693b      	ldr	r3, [r7, #16]
 800e286:	2280      	movs	r2, #128	; 0x80
 800e288:	721a      	strb	r2, [r3, #8]
		pxIPHeader->usIdentification       = FreeRTOS_htons( usPacketIdentifier );
 800e28a:	4b20      	ldr	r3, [pc, #128]	; (800e30c <prvReplyDNSMessage+0xd0>)
 800e28c:	881b      	ldrh	r3, [r3, #0]
 800e28e:	021b      	lsls	r3, r3, #8
 800e290:	b29a      	uxth	r2, r3
 800e292:	4b1e      	ldr	r3, [pc, #120]	; (800e30c <prvReplyDNSMessage+0xd0>)
 800e294:	881b      	ldrh	r3, [r3, #0]
 800e296:	0a1b      	lsrs	r3, r3, #8
 800e298:	b29b      	uxth	r3, r3
 800e29a:	b29b      	uxth	r3, r3
 800e29c:	4313      	orrs	r3, r2
 800e29e:	b29b      	uxth	r3, r3
 800e2a0:	b29a      	uxth	r2, r3
 800e2a2:	693b      	ldr	r3, [r7, #16]
 800e2a4:	809a      	strh	r2, [r3, #4]
		usPacketIdentifier++;
 800e2a6:	4b19      	ldr	r3, [pc, #100]	; (800e30c <prvReplyDNSMessage+0xd0>)
 800e2a8:	881b      	ldrh	r3, [r3, #0]
 800e2aa:	3301      	adds	r3, #1
 800e2ac:	b29a      	uxth	r2, r3
 800e2ae:	4b17      	ldr	r3, [pc, #92]	; (800e30c <prvReplyDNSMessage+0xd0>)
 800e2b0:	801a      	strh	r2, [r3, #0]
		pxUDPHeader->usLength              = FreeRTOS_htons( lNetLength + ipSIZE_OF_UDP_HEADER );
 800e2b2:	683b      	ldr	r3, [r7, #0]
 800e2b4:	b29b      	uxth	r3, r3
 800e2b6:	3308      	adds	r3, #8
 800e2b8:	b29b      	uxth	r3, r3
 800e2ba:	021b      	lsls	r3, r3, #8
 800e2bc:	b29a      	uxth	r2, r3
 800e2be:	683b      	ldr	r3, [r7, #0]
 800e2c0:	3308      	adds	r3, #8
 800e2c2:	0a1b      	lsrs	r3, r3, #8
 800e2c4:	b29b      	uxth	r3, r3
 800e2c6:	4313      	orrs	r3, r2
 800e2c8:	b29a      	uxth	r2, r3
 800e2ca:	68fb      	ldr	r3, [r7, #12]
 800e2cc:	809a      	strh	r2, [r3, #4]
		vFlip_16( pxUDPPacket->xUDPHeader.usSourcePort, pxUDPPacket->xUDPHeader.usDestinationPort );
 800e2ce:	697b      	ldr	r3, [r7, #20]
 800e2d0:	f893 2022 	ldrb.w	r2, [r3, #34]	; 0x22
 800e2d4:	f893 3023 	ldrb.w	r3, [r3, #35]	; 0x23
 800e2d8:	021b      	lsls	r3, r3, #8
 800e2da:	4313      	orrs	r3, r2
 800e2dc:	817b      	strh	r3, [r7, #10]
 800e2de:	697b      	ldr	r3, [r7, #20]
 800e2e0:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800e2e2:	b29a      	uxth	r2, r3
 800e2e4:	697b      	ldr	r3, [r7, #20]
 800e2e6:	845a      	strh	r2, [r3, #34]	; 0x22
 800e2e8:	697b      	ldr	r3, [r7, #20]
 800e2ea:	897a      	ldrh	r2, [r7, #10]
 800e2ec:	849a      	strh	r2, [r3, #36]	; 0x24
			usGenerateProtocolChecksum( ( uint8_t* ) pxUDPPacket, pdTRUE );
		}
		#endif

		/* Important: tell NIC driver how many bytes must be sent */
		pxNetworkBuffer->xDataLength = ( size_t ) ( lNetLength + ipSIZE_OF_IPv4_HEADER + ipSIZE_OF_UDP_HEADER + ipSIZE_OF_ETH_HEADER );
 800e2ee:	683b      	ldr	r3, [r7, #0]
 800e2f0:	f103 022a 	add.w	r2, r3, #42	; 0x2a
 800e2f4:	687b      	ldr	r3, [r7, #4]
 800e2f6:	61da      	str	r2, [r3, #28]

		/* This function will fill in the eth addresses and send the packet */
		vReturnEthernetFrame( pxNetworkBuffer, pdFALSE );
 800e2f8:	6878      	ldr	r0, [r7, #4]
 800e2fa:	2100      	movs	r1, #0
 800e2fc:	f7fa f8d0 	bl	80084a0 <vReturnEthernetFrame>
	}
 800e300:	3718      	adds	r7, #24
 800e302:	46bd      	mov	sp, r7
 800e304:	bd80      	pop	{r7, pc}
 800e306:	bf00      	nop
 800e308:	2000bb08 	.word	0x2000bb08
 800e30c:	2000c1c0 	.word	0x2000c1c0

0800e310 <prvProcessDNSCache>:
/*-----------------------------------------------------------*/

#if( ipconfigUSE_DNS_CACHE == 1 )

	static void prvProcessDNSCache( const char *pcName, uint32_t *pulIP, BaseType_t xLookUp )
	{
 800e310:	b580      	push	{r7, lr}
 800e312:	b086      	sub	sp, #24
 800e314:	af00      	add	r7, sp, #0
 800e316:	60f8      	str	r0, [r7, #12]
 800e318:	60b9      	str	r1, [r7, #8]
 800e31a:	607a      	str	r2, [r7, #4]
	BaseType_t x;
	BaseType_t xFound = pdFALSE;
 800e31c:	2300      	movs	r3, #0
 800e31e:	613b      	str	r3, [r7, #16]
	static BaseType_t xFreeEntry = 0;

		/* For each entry in the DNS cache table. */
		for( x = 0; x < ipconfigDNS_CACHE_ENTRIES; x++ )
 800e320:	2300      	movs	r3, #0
 800e322:	617b      	str	r3, [r7, #20]
 800e324:	e038      	b.n	800e398 <prvProcessDNSCache+0x88>
		{
			if( xDNSCache[ x ].pcName[ 0 ] == 0 )
 800e326:	4938      	ldr	r1, [pc, #224]	; (800e408 <prvProcessDNSCache+0xf8>)
 800e328:	697a      	ldr	r2, [r7, #20]
 800e32a:	4613      	mov	r3, r2
 800e32c:	005b      	lsls	r3, r3, #1
 800e32e:	4413      	add	r3, r2
 800e330:	00db      	lsls	r3, r3, #3
 800e332:	440b      	add	r3, r1
 800e334:	791b      	ldrb	r3, [r3, #4]
 800e336:	2b00      	cmp	r3, #0
 800e338:	d100      	bne.n	800e33c <prvProcessDNSCache+0x2c>
			{
				break;
 800e33a:	e030      	b.n	800e39e <prvProcessDNSCache+0x8e>
			}

			if( strncmp( xDNSCache[ x ].pcName, pcName, sizeof( xDNSCache[ x ].pcName ) ) == 0 )
 800e33c:	697a      	ldr	r2, [r7, #20]
 800e33e:	4613      	mov	r3, r2
 800e340:	005b      	lsls	r3, r3, #1
 800e342:	4413      	add	r3, r2
 800e344:	00db      	lsls	r3, r3, #3
 800e346:	4a30      	ldr	r2, [pc, #192]	; (800e408 <prvProcessDNSCache+0xf8>)
 800e348:	4413      	add	r3, r2
 800e34a:	3304      	adds	r3, #4
 800e34c:	4618      	mov	r0, r3
 800e34e:	68f9      	ldr	r1, [r7, #12]
 800e350:	2210      	movs	r2, #16
 800e352:	f004 f841 	bl	80123d8 <strncmp>
 800e356:	4603      	mov	r3, r0
 800e358:	2b00      	cmp	r3, #0
 800e35a:	d11a      	bne.n	800e392 <prvProcessDNSCache+0x82>
			{
				/* Is this function called for a lookup or to add/update an IP address? */
				if( xLookUp != pdFALSE )
 800e35c:	687b      	ldr	r3, [r7, #4]
 800e35e:	2b00      	cmp	r3, #0
 800e360:	d00a      	beq.n	800e378 <prvProcessDNSCache+0x68>
				{
					*pulIP = xDNSCache[ x ].ulIPAddress;
 800e362:	4929      	ldr	r1, [pc, #164]	; (800e408 <prvProcessDNSCache+0xf8>)
 800e364:	697a      	ldr	r2, [r7, #20]
 800e366:	4613      	mov	r3, r2
 800e368:	005b      	lsls	r3, r3, #1
 800e36a:	4413      	add	r3, r2
 800e36c:	00db      	lsls	r3, r3, #3
 800e36e:	440b      	add	r3, r1
 800e370:	681a      	ldr	r2, [r3, #0]
 800e372:	68bb      	ldr	r3, [r7, #8]
 800e374:	601a      	str	r2, [r3, #0]
 800e376:	e009      	b.n	800e38c <prvProcessDNSCache+0x7c>
				}
				else
				{
					xDNSCache[ x ].ulIPAddress = *pulIP;
 800e378:	68bb      	ldr	r3, [r7, #8]
 800e37a:	6819      	ldr	r1, [r3, #0]
 800e37c:	4822      	ldr	r0, [pc, #136]	; (800e408 <prvProcessDNSCache+0xf8>)
 800e37e:	697a      	ldr	r2, [r7, #20]
 800e380:	4613      	mov	r3, r2
 800e382:	005b      	lsls	r3, r3, #1
 800e384:	4413      	add	r3, r2
 800e386:	00db      	lsls	r3, r3, #3
 800e388:	4403      	add	r3, r0
 800e38a:	6019      	str	r1, [r3, #0]
				}

				xFound = pdTRUE;
 800e38c:	2301      	movs	r3, #1
 800e38e:	613b      	str	r3, [r7, #16]
				break;
 800e390:	e005      	b.n	800e39e <prvProcessDNSCache+0x8e>
	BaseType_t x;
	BaseType_t xFound = pdFALSE;
	static BaseType_t xFreeEntry = 0;

		/* For each entry in the DNS cache table. */
		for( x = 0; x < ipconfigDNS_CACHE_ENTRIES; x++ )
 800e392:	697b      	ldr	r3, [r7, #20]
 800e394:	3301      	adds	r3, #1
 800e396:	617b      	str	r3, [r7, #20]
 800e398:	697b      	ldr	r3, [r7, #20]
 800e39a:	2b03      	cmp	r3, #3
 800e39c:	ddc3      	ble.n	800e326 <prvProcessDNSCache+0x16>
				xFound = pdTRUE;
				break;
			}
		}

		if( xFound == pdFALSE )
 800e39e:	693b      	ldr	r3, [r7, #16]
 800e3a0:	2b00      	cmp	r3, #0
 800e3a2:	d12b      	bne.n	800e3fc <prvProcessDNSCache+0xec>
		{
			if( xLookUp != pdFALSE )
 800e3a4:	687b      	ldr	r3, [r7, #4]
 800e3a6:	2b00      	cmp	r3, #0
 800e3a8:	d003      	beq.n	800e3b2 <prvProcessDNSCache+0xa2>
			{
				*pulIP = 0;
 800e3aa:	68bb      	ldr	r3, [r7, #8]
 800e3ac:	2200      	movs	r2, #0
 800e3ae:	601a      	str	r2, [r3, #0]
 800e3b0:	e024      	b.n	800e3fc <prvProcessDNSCache+0xec>
			}
			else
			{
				/* Called to add or update an item */
				strncpy( xDNSCache[ xFreeEntry ].pcName, pcName, sizeof( xDNSCache[ xFreeEntry ].pcName ) );
 800e3b2:	4b16      	ldr	r3, [pc, #88]	; (800e40c <prvProcessDNSCache+0xfc>)
 800e3b4:	681a      	ldr	r2, [r3, #0]
 800e3b6:	4613      	mov	r3, r2
 800e3b8:	005b      	lsls	r3, r3, #1
 800e3ba:	4413      	add	r3, r2
 800e3bc:	00db      	lsls	r3, r3, #3
 800e3be:	4a12      	ldr	r2, [pc, #72]	; (800e408 <prvProcessDNSCache+0xf8>)
 800e3c0:	4413      	add	r3, r2
 800e3c2:	3304      	adds	r3, #4
 800e3c4:	4618      	mov	r0, r3
 800e3c6:	68f9      	ldr	r1, [r7, #12]
 800e3c8:	2210      	movs	r2, #16
 800e3ca:	f004 f81e 	bl	801240a <strncpy>
				xDNSCache[ xFreeEntry ].ulIPAddress = *pulIP;
 800e3ce:	4b0f      	ldr	r3, [pc, #60]	; (800e40c <prvProcessDNSCache+0xfc>)
 800e3d0:	681a      	ldr	r2, [r3, #0]
 800e3d2:	68bb      	ldr	r3, [r7, #8]
 800e3d4:	6819      	ldr	r1, [r3, #0]
 800e3d6:	480c      	ldr	r0, [pc, #48]	; (800e408 <prvProcessDNSCache+0xf8>)
 800e3d8:	4613      	mov	r3, r2
 800e3da:	005b      	lsls	r3, r3, #1
 800e3dc:	4413      	add	r3, r2
 800e3de:	00db      	lsls	r3, r3, #3
 800e3e0:	4403      	add	r3, r0
 800e3e2:	6019      	str	r1, [r3, #0]

				xFreeEntry++;
 800e3e4:	4b09      	ldr	r3, [pc, #36]	; (800e40c <prvProcessDNSCache+0xfc>)
 800e3e6:	681b      	ldr	r3, [r3, #0]
 800e3e8:	3301      	adds	r3, #1
 800e3ea:	4a08      	ldr	r2, [pc, #32]	; (800e40c <prvProcessDNSCache+0xfc>)
 800e3ec:	6013      	str	r3, [r2, #0]
				if( xFreeEntry == ipconfigDNS_CACHE_ENTRIES )
 800e3ee:	4b07      	ldr	r3, [pc, #28]	; (800e40c <prvProcessDNSCache+0xfc>)
 800e3f0:	681b      	ldr	r3, [r3, #0]
 800e3f2:	2b04      	cmp	r3, #4
 800e3f4:	d102      	bne.n	800e3fc <prvProcessDNSCache+0xec>
				{
					xFreeEntry = 0;
 800e3f6:	4b05      	ldr	r3, [pc, #20]	; (800e40c <prvProcessDNSCache+0xfc>)
 800e3f8:	2200      	movs	r2, #0
 800e3fa:	601a      	str	r2, [r3, #0]
				}
			}
		}

		if( ( xLookUp == 0 ) || ( *pulIP != 0 ) )
 800e3fc:	687b      	ldr	r3, [r7, #4]
 800e3fe:	2b00      	cmp	r3, #0
		{
			FreeRTOS_debug_printf( ( "prvProcessDNSCache: %s: '%s' @ %lxip\n", xLookUp ? "look-up" : "add", pcName, FreeRTOS_ntohl( *pulIP ) ) );
		}
	}
 800e400:	3718      	adds	r7, #24
 800e402:	46bd      	mov	sp, r7
 800e404:	bd80      	pop	{r7, pc}
 800e406:	bf00      	nop
 800e408:	2000c2b8 	.word	0x2000c2b8
 800e40c:	2000c32c 	.word	0x2000c32c

0800e410 <strbuf_init>:
	int curLen;
	struct xPrintFlags flags;
};

static void strbuf_init( struct SStringBuf *apStr, char *apBuf, const char *apMaxStr )
{
 800e410:	b580      	push	{r7, lr}
 800e412:	b084      	sub	sp, #16
 800e414:	af00      	add	r7, sp, #0
 800e416:	60f8      	str	r0, [r7, #12]
 800e418:	60b9      	str	r1, [r7, #8]
 800e41a:	607a      	str	r2, [r7, #4]
	apStr->str = apBuf;
 800e41c:	68fb      	ldr	r3, [r7, #12]
 800e41e:	68ba      	ldr	r2, [r7, #8]
 800e420:	601a      	str	r2, [r3, #0]
	apStr->orgStr = apBuf;
 800e422:	68fb      	ldr	r3, [r7, #12]
 800e424:	68ba      	ldr	r2, [r7, #8]
 800e426:	605a      	str	r2, [r3, #4]
	apStr->nulPos = apMaxStr-1;
 800e428:	687b      	ldr	r3, [r7, #4]
 800e42a:	1e5a      	subs	r2, r3, #1
 800e42c:	68fb      	ldr	r3, [r7, #12]
 800e42e:	609a      	str	r2, [r3, #8]
	apStr->curLen = 0;
 800e430:	68fb      	ldr	r3, [r7, #12]
 800e432:	2200      	movs	r2, #0
 800e434:	60da      	str	r2, [r3, #12]

	memset( &apStr->flags, '\0', sizeof( apStr->flags ) );
 800e436:	68fb      	ldr	r3, [r7, #12]
 800e438:	3310      	adds	r3, #16
 800e43a:	4618      	mov	r0, r3
 800e43c:	2100      	movs	r1, #0
 800e43e:	2210      	movs	r2, #16
 800e440:	f001 ff32 	bl	80102a8 <memset>
}
 800e444:	3710      	adds	r7, #16
 800e446:	46bd      	mov	sp, r7
 800e448:	bd80      	pop	{r7, pc}
 800e44a:	bf00      	nop

0800e44c <strbuf_printchar>:
/*-----------------------------------------------------------*/

static BaseType_t strbuf_printchar( struct SStringBuf *apStr, int c )
{
 800e44c:	b580      	push	{r7, lr}
 800e44e:	b082      	sub	sp, #8
 800e450:	af00      	add	r7, sp, #0
 800e452:	6078      	str	r0, [r7, #4]
 800e454:	6039      	str	r1, [r7, #0]
	if( apStr->str == NULL )
 800e456:	687b      	ldr	r3, [r7, #4]
 800e458:	681b      	ldr	r3, [r3, #0]
 800e45a:	2b00      	cmp	r3, #0
 800e45c:	d10d      	bne.n	800e47a <strbuf_printchar+0x2e>
	{
		vOutputChar( ( char ) c, xTicksToWait );
 800e45e:	683b      	ldr	r3, [r7, #0]
 800e460:	b2db      	uxtb	r3, r3
 800e462:	2214      	movs	r2, #20
 800e464:	4618      	mov	r0, r3
 800e466:	4611      	mov	r1, r2
 800e468:	f001 f846 	bl	800f4f8 <vOutputChar>
		apStr->curLen++;
 800e46c:	687b      	ldr	r3, [r7, #4]
 800e46e:	68db      	ldr	r3, [r3, #12]
 800e470:	1c5a      	adds	r2, r3, #1
 800e472:	687b      	ldr	r3, [r7, #4]
 800e474:	60da      	str	r2, [r3, #12]
		return pdTRUE;
 800e476:	2301      	movs	r3, #1
 800e478:	e022      	b.n	800e4c0 <strbuf_printchar+0x74>
	}
	if( apStr->str < apStr->nulPos )
 800e47a:	687b      	ldr	r3, [r7, #4]
 800e47c:	681a      	ldr	r2, [r3, #0]
 800e47e:	687b      	ldr	r3, [r7, #4]
 800e480:	689b      	ldr	r3, [r3, #8]
 800e482:	429a      	cmp	r2, r3
 800e484:	d20e      	bcs.n	800e4a4 <strbuf_printchar+0x58>
	{
		*( apStr->str++ ) = c;
 800e486:	687b      	ldr	r3, [r7, #4]
 800e488:	681b      	ldr	r3, [r3, #0]
 800e48a:	1c59      	adds	r1, r3, #1
 800e48c:	687a      	ldr	r2, [r7, #4]
 800e48e:	6011      	str	r1, [r2, #0]
 800e490:	683a      	ldr	r2, [r7, #0]
 800e492:	b2d2      	uxtb	r2, r2
 800e494:	701a      	strb	r2, [r3, #0]
		apStr->curLen++;
 800e496:	687b      	ldr	r3, [r7, #4]
 800e498:	68db      	ldr	r3, [r3, #12]
 800e49a:	1c5a      	adds	r2, r3, #1
 800e49c:	687b      	ldr	r3, [r7, #4]
 800e49e:	60da      	str	r2, [r3, #12]
		return pdTRUE;
 800e4a0:	2301      	movs	r3, #1
 800e4a2:	e00d      	b.n	800e4c0 <strbuf_printchar+0x74>
	}
	if( apStr->str == apStr->nulPos )
 800e4a4:	687b      	ldr	r3, [r7, #4]
 800e4a6:	681a      	ldr	r2, [r3, #0]
 800e4a8:	687b      	ldr	r3, [r7, #4]
 800e4aa:	689b      	ldr	r3, [r3, #8]
 800e4ac:	429a      	cmp	r2, r3
 800e4ae:	d106      	bne.n	800e4be <strbuf_printchar+0x72>
	{
		*( apStr->str++ ) = '\0';
 800e4b0:	687b      	ldr	r3, [r7, #4]
 800e4b2:	681b      	ldr	r3, [r3, #0]
 800e4b4:	1c59      	adds	r1, r3, #1
 800e4b6:	687a      	ldr	r2, [r7, #4]
 800e4b8:	6011      	str	r1, [r2, #0]
 800e4ba:	2200      	movs	r2, #0
 800e4bc:	701a      	strb	r2, [r3, #0]
	}
	return pdFALSE;
 800e4be:	2300      	movs	r3, #0
}
 800e4c0:	4618      	mov	r0, r3
 800e4c2:	3708      	adds	r7, #8
 800e4c4:	46bd      	mov	sp, r7
 800e4c6:	bd80      	pop	{r7, pc}

0800e4c8 <strbuf_printchar_inline>:
/*-----------------------------------------------------------*/

static portINLINE BaseType_t strbuf_printchar_inline( struct SStringBuf *apStr, int c )
{
 800e4c8:	b580      	push	{r7, lr}
 800e4ca:	b082      	sub	sp, #8
 800e4cc:	af00      	add	r7, sp, #0
 800e4ce:	6078      	str	r0, [r7, #4]
 800e4d0:	6039      	str	r1, [r7, #0]
	if( apStr->str == NULL )
 800e4d2:	687b      	ldr	r3, [r7, #4]
 800e4d4:	681b      	ldr	r3, [r3, #0]
 800e4d6:	2b00      	cmp	r3, #0
 800e4d8:	d112      	bne.n	800e500 <strbuf_printchar_inline+0x38>
	{
		vOutputChar( ( char ) c, xTicksToWait );
 800e4da:	683b      	ldr	r3, [r7, #0]
 800e4dc:	b2db      	uxtb	r3, r3
 800e4de:	2214      	movs	r2, #20
 800e4e0:	4618      	mov	r0, r3
 800e4e2:	4611      	mov	r1, r2
 800e4e4:	f001 f808 	bl	800f4f8 <vOutputChar>
		if( c == 0 )
 800e4e8:	683b      	ldr	r3, [r7, #0]
 800e4ea:	2b00      	cmp	r3, #0
 800e4ec:	d101      	bne.n	800e4f2 <strbuf_printchar_inline+0x2a>
		{
			return pdFALSE;
 800e4ee:	2300      	movs	r3, #0
 800e4f0:	e02e      	b.n	800e550 <strbuf_printchar_inline+0x88>
		}
		apStr->curLen++;
 800e4f2:	687b      	ldr	r3, [r7, #4]
 800e4f4:	68db      	ldr	r3, [r3, #12]
 800e4f6:	1c5a      	adds	r2, r3, #1
 800e4f8:	687b      	ldr	r3, [r7, #4]
 800e4fa:	60da      	str	r2, [r3, #12]
		return pdTRUE;
 800e4fc:	2301      	movs	r3, #1
 800e4fe:	e027      	b.n	800e550 <strbuf_printchar_inline+0x88>
	}
	if( apStr->str < apStr->nulPos )
 800e500:	687b      	ldr	r3, [r7, #4]
 800e502:	681a      	ldr	r2, [r3, #0]
 800e504:	687b      	ldr	r3, [r7, #4]
 800e506:	689b      	ldr	r3, [r3, #8]
 800e508:	429a      	cmp	r2, r3
 800e50a:	d213      	bcs.n	800e534 <strbuf_printchar_inline+0x6c>
	{
		*(apStr->str++) = c;
 800e50c:	687b      	ldr	r3, [r7, #4]
 800e50e:	681b      	ldr	r3, [r3, #0]
 800e510:	1c59      	adds	r1, r3, #1
 800e512:	687a      	ldr	r2, [r7, #4]
 800e514:	6011      	str	r1, [r2, #0]
 800e516:	683a      	ldr	r2, [r7, #0]
 800e518:	b2d2      	uxtb	r2, r2
 800e51a:	701a      	strb	r2, [r3, #0]
		if( c == 0 )
 800e51c:	683b      	ldr	r3, [r7, #0]
 800e51e:	2b00      	cmp	r3, #0
 800e520:	d101      	bne.n	800e526 <strbuf_printchar_inline+0x5e>
		{
			return pdFALSE;
 800e522:	2300      	movs	r3, #0
 800e524:	e014      	b.n	800e550 <strbuf_printchar_inline+0x88>
		}
		apStr->curLen++;
 800e526:	687b      	ldr	r3, [r7, #4]
 800e528:	68db      	ldr	r3, [r3, #12]
 800e52a:	1c5a      	adds	r2, r3, #1
 800e52c:	687b      	ldr	r3, [r7, #4]
 800e52e:	60da      	str	r2, [r3, #12]
		return pdTRUE;
 800e530:	2301      	movs	r3, #1
 800e532:	e00d      	b.n	800e550 <strbuf_printchar_inline+0x88>
	}
	if( apStr->str == apStr->nulPos )
 800e534:	687b      	ldr	r3, [r7, #4]
 800e536:	681a      	ldr	r2, [r3, #0]
 800e538:	687b      	ldr	r3, [r7, #4]
 800e53a:	689b      	ldr	r3, [r3, #8]
 800e53c:	429a      	cmp	r2, r3
 800e53e:	d106      	bne.n	800e54e <strbuf_printchar_inline+0x86>
	{
		*( apStr->str++ ) = '\0';
 800e540:	687b      	ldr	r3, [r7, #4]
 800e542:	681b      	ldr	r3, [r3, #0]
 800e544:	1c59      	adds	r1, r3, #1
 800e546:	687a      	ldr	r2, [r7, #4]
 800e548:	6011      	str	r1, [r2, #0]
 800e54a:	2200      	movs	r2, #0
 800e54c:	701a      	strb	r2, [r3, #0]
	}
	return pdFALSE;
 800e54e:	2300      	movs	r3, #0
}
 800e550:	4618      	mov	r0, r3
 800e552:	3708      	adds	r7, #8
 800e554:	46bd      	mov	sp, r7
 800e556:	bd80      	pop	{r7, pc}

0800e558 <prints>:
	return iResult;
}
/*-----------------------------------------------------------*/

static BaseType_t prints(struct SStringBuf *apBuf, const char *apString )
{
 800e558:	b5f0      	push	{r4, r5, r6, r7, lr}
 800e55a:	b085      	sub	sp, #20
 800e55c:	af00      	add	r7, sp, #0
 800e55e:	6078      	str	r0, [r7, #4]
 800e560:	6039      	str	r1, [r7, #0]
	register int padchar = ' ';
 800e562:	2620      	movs	r6, #32
	int i,len;

	if( apBuf->flags.width > 0 )
 800e564:	687b      	ldr	r3, [r7, #4]
 800e566:	695b      	ldr	r3, [r3, #20]
 800e568:	2b00      	cmp	r3, #0
 800e56a:	dd1b      	ble.n	800e5a4 <prints+0x4c>
	{
		register int len = 0;
 800e56c:	2400      	movs	r4, #0
		register const char *ptr;
		for( ptr = apString; *ptr; ++ptr )
 800e56e:	683d      	ldr	r5, [r7, #0]
 800e570:	e001      	b.n	800e576 <prints+0x1e>
		{
			++len;
 800e572:	3401      	adds	r4, #1

	if( apBuf->flags.width > 0 )
	{
		register int len = 0;
		register const char *ptr;
		for( ptr = apString; *ptr; ++ptr )
 800e574:	3501      	adds	r5, #1
 800e576:	782b      	ldrb	r3, [r5, #0]
 800e578:	2b00      	cmp	r3, #0
 800e57a:	d1fa      	bne.n	800e572 <prints+0x1a>
		{
			++len;
		}

		if( len >= apBuf->flags.width )
 800e57c:	687b      	ldr	r3, [r7, #4]
 800e57e:	695b      	ldr	r3, [r3, #20]
 800e580:	42a3      	cmp	r3, r4
 800e582:	dc03      	bgt.n	800e58c <prints+0x34>
		{
			apBuf->flags.width = 0;
 800e584:	687b      	ldr	r3, [r7, #4]
 800e586:	2200      	movs	r2, #0
 800e588:	615a      	str	r2, [r3, #20]
 800e58a:	e004      	b.n	800e596 <prints+0x3e>
		}
		else
		{
			apBuf->flags.width -= len;
 800e58c:	687b      	ldr	r3, [r7, #4]
 800e58e:	695b      	ldr	r3, [r3, #20]
 800e590:	1b1a      	subs	r2, r3, r4
 800e592:	687b      	ldr	r3, [r7, #4]
 800e594:	615a      	str	r2, [r3, #20]
		}

		if( apBuf->flags.pad & PAD_ZERO )
 800e596:	687b      	ldr	r3, [r7, #4]
 800e598:	7f1b      	ldrb	r3, [r3, #28]
 800e59a:	f003 0302 	and.w	r3, r3, #2
 800e59e:	2b00      	cmp	r3, #0
 800e5a0:	d000      	beq.n	800e5a4 <prints+0x4c>
		{
			padchar = '0';
 800e5a2:	2630      	movs	r6, #48	; 0x30
		}
	}
	if( ( apBuf->flags.pad & PAD_RIGHT ) == 0 )
 800e5a4:	687b      	ldr	r3, [r7, #4]
 800e5a6:	7f1b      	ldrb	r3, [r3, #28]
 800e5a8:	f003 0301 	and.w	r3, r3, #1
 800e5ac:	2b00      	cmp	r3, #0
 800e5ae:	d112      	bne.n	800e5d6 <prints+0x7e>
	{
		for( ; apBuf->flags.width > 0; --apBuf->flags.width )
 800e5b0:	e00d      	b.n	800e5ce <prints+0x76>
		{
			if( strbuf_printchar( apBuf, padchar ) == 0 )
 800e5b2:	6878      	ldr	r0, [r7, #4]
 800e5b4:	4631      	mov	r1, r6
 800e5b6:	f7ff ff49 	bl	800e44c <strbuf_printchar>
 800e5ba:	4603      	mov	r3, r0
 800e5bc:	2b00      	cmp	r3, #0
 800e5be:	d101      	bne.n	800e5c4 <prints+0x6c>
			{
				return pdFALSE;
 800e5c0:	2300      	movs	r3, #0
 800e5c2:	e062      	b.n	800e68a <prints+0x132>
			padchar = '0';
		}
	}
	if( ( apBuf->flags.pad & PAD_RIGHT ) == 0 )
	{
		for( ; apBuf->flags.width > 0; --apBuf->flags.width )
 800e5c4:	687b      	ldr	r3, [r7, #4]
 800e5c6:	695b      	ldr	r3, [r3, #20]
 800e5c8:	1e5a      	subs	r2, r3, #1
 800e5ca:	687b      	ldr	r3, [r7, #4]
 800e5cc:	615a      	str	r2, [r3, #20]
 800e5ce:	687b      	ldr	r3, [r7, #4]
 800e5d0:	695b      	ldr	r3, [r3, #20]
 800e5d2:	2b00      	cmp	r3, #0
 800e5d4:	dced      	bgt.n	800e5b2 <prints+0x5a>
			{
				return pdFALSE;
			}
		}
	}
	if( ( apBuf->flags.isNumber == pdTRUE ) && ( apBuf->flags.pad == pdTRUE ) )
 800e5d6:	687b      	ldr	r3, [r7, #4]
 800e5d8:	7f9b      	ldrb	r3, [r3, #30]
 800e5da:	f003 0302 	and.w	r3, r3, #2
 800e5de:	b2db      	uxtb	r3, r3
 800e5e0:	2b00      	cmp	r3, #0
 800e5e2:	d022      	beq.n	800e62a <prints+0xd2>
 800e5e4:	687b      	ldr	r3, [r7, #4]
 800e5e6:	7f1b      	ldrb	r3, [r3, #28]
 800e5e8:	2b01      	cmp	r3, #1
 800e5ea:	d11e      	bne.n	800e62a <prints+0xd2>
		/* The string to print represents an integer number.
		 * In this case, printLimit is the min number of digits to print
		 * If the length of the number to print is less than the min nb of i
		 * digits to display, we add 0 before printing the number
		 */
		len = strlen( apString );
 800e5ec:	6838      	ldr	r0, [r7, #0]
 800e5ee:	f003 feeb 	bl	80123c8 <strlen>
 800e5f2:	4603      	mov	r3, r0
 800e5f4:	60bb      	str	r3, [r7, #8]

		if( len < apBuf->flags.printLimit )
 800e5f6:	687b      	ldr	r3, [r7, #4]
 800e5f8:	699a      	ldr	r2, [r3, #24]
 800e5fa:	68bb      	ldr	r3, [r7, #8]
 800e5fc:	429a      	cmp	r2, r3
 800e5fe:	dd14      	ble.n	800e62a <prints+0xd2>
		{
			i = apBuf->flags.printLimit - len;
 800e600:	687b      	ldr	r3, [r7, #4]
 800e602:	699a      	ldr	r2, [r3, #24]
 800e604:	68bb      	ldr	r3, [r7, #8]
 800e606:	1ad3      	subs	r3, r2, r3
 800e608:	60fb      	str	r3, [r7, #12]
			for( ; i; i-- )
 800e60a:	e00b      	b.n	800e624 <prints+0xcc>
			{
				if( strbuf_printchar( apBuf, '0' )  == 0 )
 800e60c:	6878      	ldr	r0, [r7, #4]
 800e60e:	2130      	movs	r1, #48	; 0x30
 800e610:	f7ff ff1c 	bl	800e44c <strbuf_printchar>
 800e614:	4603      	mov	r3, r0
 800e616:	2b00      	cmp	r3, #0
 800e618:	d101      	bne.n	800e61e <prints+0xc6>
				{
					return pdFALSE;
 800e61a:	2300      	movs	r3, #0
 800e61c:	e035      	b.n	800e68a <prints+0x132>
		len = strlen( apString );

		if( len < apBuf->flags.printLimit )
		{
			i = apBuf->flags.printLimit - len;
			for( ; i; i-- )
 800e61e:	68fb      	ldr	r3, [r7, #12]
 800e620:	3b01      	subs	r3, #1
 800e622:	60fb      	str	r3, [r7, #12]
 800e624:	68fb      	ldr	r3, [r7, #12]
 800e626:	2b00      	cmp	r3, #0
 800e628:	d1f0      	bne.n	800e60c <prints+0xb4>
		}
	}
	/* The string to print is not the result of a number conversion to ascii.
	 * For a string, printLimit is the max number of characters to display
	 */
	for( ; apBuf->flags.printLimit && *apString ; ++apString, --apBuf->flags.printLimit )
 800e62a:	e012      	b.n	800e652 <prints+0xfa>
	{
		if( !strbuf_printchar( apBuf, *apString ) )
 800e62c:	683b      	ldr	r3, [r7, #0]
 800e62e:	781b      	ldrb	r3, [r3, #0]
 800e630:	6878      	ldr	r0, [r7, #4]
 800e632:	4619      	mov	r1, r3
 800e634:	f7ff ff0a 	bl	800e44c <strbuf_printchar>
 800e638:	4603      	mov	r3, r0
 800e63a:	2b00      	cmp	r3, #0
 800e63c:	d101      	bne.n	800e642 <prints+0xea>
		{
			return pdFALSE;
 800e63e:	2300      	movs	r3, #0
 800e640:	e023      	b.n	800e68a <prints+0x132>
		}
	}
	/* The string to print is not the result of a number conversion to ascii.
	 * For a string, printLimit is the max number of characters to display
	 */
	for( ; apBuf->flags.printLimit && *apString ; ++apString, --apBuf->flags.printLimit )
 800e642:	683b      	ldr	r3, [r7, #0]
 800e644:	3301      	adds	r3, #1
 800e646:	603b      	str	r3, [r7, #0]
 800e648:	687b      	ldr	r3, [r7, #4]
 800e64a:	699b      	ldr	r3, [r3, #24]
 800e64c:	1e5a      	subs	r2, r3, #1
 800e64e:	687b      	ldr	r3, [r7, #4]
 800e650:	619a      	str	r2, [r3, #24]
 800e652:	687b      	ldr	r3, [r7, #4]
 800e654:	699b      	ldr	r3, [r3, #24]
 800e656:	2b00      	cmp	r3, #0
 800e658:	d003      	beq.n	800e662 <prints+0x10a>
 800e65a:	683b      	ldr	r3, [r7, #0]
 800e65c:	781b      	ldrb	r3, [r3, #0]
 800e65e:	2b00      	cmp	r3, #0
 800e660:	d1e4      	bne.n	800e62c <prints+0xd4>
		{
			return pdFALSE;
		}
	}

	for( ; apBuf->flags.width > 0; --apBuf->flags.width )
 800e662:	e00d      	b.n	800e680 <prints+0x128>
	{
		if( !strbuf_printchar( apBuf, padchar ) )
 800e664:	6878      	ldr	r0, [r7, #4]
 800e666:	4631      	mov	r1, r6
 800e668:	f7ff fef0 	bl	800e44c <strbuf_printchar>
 800e66c:	4603      	mov	r3, r0
 800e66e:	2b00      	cmp	r3, #0
 800e670:	d101      	bne.n	800e676 <prints+0x11e>
		{
			return pdFALSE;
 800e672:	2300      	movs	r3, #0
 800e674:	e009      	b.n	800e68a <prints+0x132>
		{
			return pdFALSE;
		}
	}

	for( ; apBuf->flags.width > 0; --apBuf->flags.width )
 800e676:	687b      	ldr	r3, [r7, #4]
 800e678:	695b      	ldr	r3, [r3, #20]
 800e67a:	1e5a      	subs	r2, r3, #1
 800e67c:	687b      	ldr	r3, [r7, #4]
 800e67e:	615a      	str	r2, [r3, #20]
 800e680:	687b      	ldr	r3, [r7, #4]
 800e682:	695b      	ldr	r3, [r3, #20]
 800e684:	2b00      	cmp	r3, #0
 800e686:	dced      	bgt.n	800e664 <prints+0x10c>
		{
			return pdFALSE;
		}
	}

	return pdTRUE;
 800e688:	2301      	movs	r3, #1
}
 800e68a:	4618      	mov	r0, r3
 800e68c:	3714      	adds	r7, #20
 800e68e:	46bd      	mov	sp, r7
 800e690:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800e692:	bf00      	nop

0800e694 <printi>:
}
#endif	/* SPRINTF_LONG_LONG */
/*-----------------------------------------------------------*/

static BaseType_t printi( struct SStringBuf *apBuf, int i )
{
 800e694:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800e698:	b087      	sub	sp, #28
 800e69a:	af00      	add	r7, sp, #0
 800e69c:	6078      	str	r0, [r7, #4]
 800e69e:	6039      	str	r1, [r7, #0]
	char print_buf[ PRINT_BUF_LEN ];
	register char *s;
	register int t, neg = 0;
 800e6a0:	f04f 0900 	mov.w	r9, #0
	register unsigned int u = i;
 800e6a4:	683d      	ldr	r5, [r7, #0]
	register unsigned base = apBuf->flags.base;
 800e6a6:	687b      	ldr	r3, [r7, #4]
 800e6a8:	691b      	ldr	r3, [r3, #16]
 800e6aa:	461e      	mov	r6, r3

	apBuf->flags.isNumber = pdTRUE;	/* Parameter for prints */
 800e6ac:	687a      	ldr	r2, [r7, #4]
 800e6ae:	7f93      	ldrb	r3, [r2, #30]
 800e6b0:	f043 0302 	orr.w	r3, r3, #2
 800e6b4:	7793      	strb	r3, [r2, #30]

	if( i == 0 )
 800e6b6:	683b      	ldr	r3, [r7, #0]
 800e6b8:	2b00      	cmp	r3, #0
 800e6ba:	d10b      	bne.n	800e6d4 <printi+0x40>
	{
		print_buf[ 0 ] = '0';
 800e6bc:	2330      	movs	r3, #48	; 0x30
 800e6be:	733b      	strb	r3, [r7, #12]
		print_buf[ 1 ] = '\0';
 800e6c0:	2300      	movs	r3, #0
 800e6c2:	737b      	strb	r3, [r7, #13]
		return prints( apBuf, print_buf );
 800e6c4:	f107 030c 	add.w	r3, r7, #12
 800e6c8:	6878      	ldr	r0, [r7, #4]
 800e6ca:	4619      	mov	r1, r3
 800e6cc:	f7ff ff44 	bl	800e558 <prints>
 800e6d0:	4603      	mov	r3, r0
 800e6d2:	e065      	b.n	800e7a0 <printi+0x10c>
	}

	if( ( apBuf->flags.isSigned == pdTRUE ) && ( base == 10 ) && ( i < 0 ) )
 800e6d4:	687b      	ldr	r3, [r7, #4]
 800e6d6:	7f9b      	ldrb	r3, [r3, #30]
 800e6d8:	f003 0301 	and.w	r3, r3, #1
 800e6dc:	b2db      	uxtb	r3, r3
 800e6de:	2b00      	cmp	r3, #0
 800e6e0:	d009      	beq.n	800e6f6 <printi+0x62>
 800e6e2:	2e0a      	cmp	r6, #10
 800e6e4:	d107      	bne.n	800e6f6 <printi+0x62>
 800e6e6:	683b      	ldr	r3, [r7, #0]
 800e6e8:	2b00      	cmp	r3, #0
 800e6ea:	da04      	bge.n	800e6f6 <printi+0x62>
	{
		neg = 1;
 800e6ec:	f04f 0901 	mov.w	r9, #1
		u = -i;
 800e6f0:	683b      	ldr	r3, [r7, #0]
 800e6f2:	425b      	negs	r3, r3
 800e6f4:	461d      	mov	r5, r3
	}

	s = print_buf + sizeof( print_buf ) - 1;
 800e6f6:	f107 040c 	add.w	r4, r7, #12
 800e6fa:	340b      	adds	r4, #11

	*s = '\0';
 800e6fc:	2300      	movs	r3, #0
 800e6fe:	7023      	strb	r3, [r4, #0]
	switch( base )
 800e700:	2e0a      	cmp	r6, #10
 800e702:	d026      	beq.n	800e752 <printi+0xbe>
 800e704:	2e10      	cmp	r6, #16
 800e706:	d013      	beq.n	800e730 <printi+0x9c>
 800e708:	2e08      	cmp	r6, #8
 800e70a:	d022      	beq.n	800e752 <printi+0xbe>
 800e70c:	e024      	b.n	800e758 <printi+0xc4>
	{
	case 16:
		while( u != 0 )
		{
			t = u & 0xF;
 800e70e:	462b      	mov	r3, r5
 800e710:	f003 080f 	and.w	r8, r3, #15
			if( t >= 10 )
 800e714:	f1b8 0f09 	cmp.w	r8, #9
 800e718:	dd03      	ble.n	800e722 <printi+0x8e>
			{
				t += apBuf->flags.letBase - '0' - 10;
 800e71a:	687b      	ldr	r3, [r7, #4]
 800e71c:	7f5b      	ldrb	r3, [r3, #29]
 800e71e:	3b3a      	subs	r3, #58	; 0x3a
 800e720:	4498      	add	r8, r3
			}
			*( --s ) = t + '0';
 800e722:	3c01      	subs	r4, #1
 800e724:	fa5f f388 	uxtb.w	r3, r8
 800e728:	3330      	adds	r3, #48	; 0x30
 800e72a:	b2db      	uxtb	r3, r3
 800e72c:	7023      	strb	r3, [r4, #0]
			u >>= 4;
 800e72e:	092d      	lsrs	r5, r5, #4

	*s = '\0';
	switch( base )
	{
	case 16:
		while( u != 0 )
 800e730:	2d00      	cmp	r5, #0
 800e732:	d1ec      	bne.n	800e70e <printi+0x7a>
				t += apBuf->flags.letBase - '0' - 10;
			}
			*( --s ) = t + '0';
			u >>= 4;
		}
		break;
 800e734:	e010      	b.n	800e758 <printi+0xc4>
	case 8:
	case 10:
		/* GCC compiles very efficient */
		while( u )
		{
			t = u % base;
 800e736:	fbb5 f3f6 	udiv	r3, r5, r6
 800e73a:	fb06 f303 	mul.w	r3, r6, r3
 800e73e:	1aeb      	subs	r3, r5, r3
 800e740:	4698      	mov	r8, r3
			*( --s ) = t + '0';
 800e742:	3c01      	subs	r4, #1
 800e744:	fa5f f388 	uxtb.w	r3, r8
 800e748:	3330      	adds	r3, #48	; 0x30
 800e74a:	b2db      	uxtb	r3, r3
 800e74c:	7023      	strb	r3, [r4, #0]
			u /= base;
 800e74e:	fbb5 f5f6 	udiv	r5, r5, r6
		break;

	case 8:
	case 10:
		/* GCC compiles very efficient */
		while( u )
 800e752:	2d00      	cmp	r5, #0
 800e754:	d1ef      	bne.n	800e736 <printi+0xa2>
		{
			t = u % base;
			*( --s ) = t + '0';
			u /= base;
		}
		break;
 800e756:	bf00      	nop
		}
		break;
*/
	}

	if( neg != 0 )
 800e758:	f1b9 0f00 	cmp.w	r9, #0
 800e75c:	d01b      	beq.n	800e796 <printi+0x102>
	{
		if( apBuf->flags.width && (apBuf->flags.pad & PAD_ZERO ) )
 800e75e:	687b      	ldr	r3, [r7, #4]
 800e760:	695b      	ldr	r3, [r3, #20]
 800e762:	2b00      	cmp	r3, #0
 800e764:	d014      	beq.n	800e790 <printi+0xfc>
 800e766:	687b      	ldr	r3, [r7, #4]
 800e768:	7f1b      	ldrb	r3, [r3, #28]
 800e76a:	f003 0302 	and.w	r3, r3, #2
 800e76e:	2b00      	cmp	r3, #0
 800e770:	d00e      	beq.n	800e790 <printi+0xfc>
		{
			if( strbuf_printchar( apBuf, '-' ) == 0 )
 800e772:	6878      	ldr	r0, [r7, #4]
 800e774:	212d      	movs	r1, #45	; 0x2d
 800e776:	f7ff fe69 	bl	800e44c <strbuf_printchar>
 800e77a:	4603      	mov	r3, r0
 800e77c:	2b00      	cmp	r3, #0
 800e77e:	d101      	bne.n	800e784 <printi+0xf0>
			{
				return pdFALSE;
 800e780:	2300      	movs	r3, #0
 800e782:	e00d      	b.n	800e7a0 <printi+0x10c>
			}
			--apBuf->flags.width;
 800e784:	687b      	ldr	r3, [r7, #4]
 800e786:	695b      	ldr	r3, [r3, #20]
 800e788:	1e5a      	subs	r2, r3, #1
 800e78a:	687b      	ldr	r3, [r7, #4]
 800e78c:	615a      	str	r2, [r3, #20]
 800e78e:	e002      	b.n	800e796 <printi+0x102>
		}
		else
		{
			*( --s ) = '-';
 800e790:	3c01      	subs	r4, #1
 800e792:	232d      	movs	r3, #45	; 0x2d
 800e794:	7023      	strb	r3, [r4, #0]
		}
	}

	return prints( apBuf, s );
 800e796:	6878      	ldr	r0, [r7, #4]
 800e798:	4621      	mov	r1, r4
 800e79a:	f7ff fedd 	bl	800e558 <prints>
 800e79e:	4603      	mov	r3, r0
}
 800e7a0:	4618      	mov	r0, r3
 800e7a2:	371c      	adds	r7, #28
 800e7a4:	46bd      	mov	sp, r7
 800e7a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800e7aa:	bf00      	nop

0800e7ac <printIp>:
/*-----------------------------------------------------------*/

static BaseType_t printIp(struct SStringBuf *apBuf, unsigned i )
{
 800e7ac:	b5b0      	push	{r4, r5, r7, lr}
 800e7ae:	b088      	sub	sp, #32
 800e7b0:	af02      	add	r7, sp, #8
 800e7b2:	6078      	str	r0, [r7, #4]
 800e7b4:	6039      	str	r1, [r7, #0]
	char print_buf[16];

	sprintf( print_buf, "%u.%u.%u.%u",
 800e7b6:	683b      	ldr	r3, [r7, #0]
 800e7b8:	0e1d      	lsrs	r5, r3, #24
		i >> 24,
		( i >> 16 ) & 0xff,
 800e7ba:	683b      	ldr	r3, [r7, #0]
 800e7bc:	0c1b      	lsrs	r3, r3, #16

static BaseType_t printIp(struct SStringBuf *apBuf, unsigned i )
{
	char print_buf[16];

	sprintf( print_buf, "%u.%u.%u.%u",
 800e7be:	b2dc      	uxtb	r4, r3
		i >> 24,
		( i >> 16 ) & 0xff,
		( i >> 8 ) & 0xff,
 800e7c0:	683b      	ldr	r3, [r7, #0]
 800e7c2:	0a1b      	lsrs	r3, r3, #8

static BaseType_t printIp(struct SStringBuf *apBuf, unsigned i )
{
	char print_buf[16];

	sprintf( print_buf, "%u.%u.%u.%u",
 800e7c4:	b2da      	uxtb	r2, r3
 800e7c6:	683b      	ldr	r3, [r7, #0]
 800e7c8:	b2db      	uxtb	r3, r3
 800e7ca:	f107 0108 	add.w	r1, r7, #8
 800e7ce:	9200      	str	r2, [sp, #0]
 800e7d0:	9301      	str	r3, [sp, #4]
 800e7d2:	4608      	mov	r0, r1
 800e7d4:	490a      	ldr	r1, [pc, #40]	; (800e800 <printIp+0x54>)
 800e7d6:	462a      	mov	r2, r5
 800e7d8:	4623      	mov	r3, r4
 800e7da:	f000 f9c5 	bl	800eb68 <sprintf>
		i >> 24,
		( i >> 16 ) & 0xff,
		( i >> 8 ) & 0xff,
		i & 0xff );
	apBuf->flags.isNumber = pdTRUE;	/* Parameter for prints */
 800e7de:	687a      	ldr	r2, [r7, #4]
 800e7e0:	7f93      	ldrb	r3, [r2, #30]
 800e7e2:	f043 0302 	orr.w	r3, r3, #2
 800e7e6:	7793      	strb	r3, [r2, #30]
	prints( apBuf, print_buf );
 800e7e8:	f107 0308 	add.w	r3, r7, #8
 800e7ec:	6878      	ldr	r0, [r7, #4]
 800e7ee:	4619      	mov	r1, r3
 800e7f0:	f7ff feb2 	bl	800e558 <prints>

	return pdTRUE;
 800e7f4:	2301      	movs	r3, #1
}
 800e7f6:	4618      	mov	r0, r3
 800e7f8:	3718      	adds	r7, #24
 800e7fa:	46bd      	mov	sp, r7
 800e7fc:	bdb0      	pop	{r4, r5, r7, pc}
 800e7fe:	bf00      	nop
 800e800:	08012800 	.word	0x08012800

0800e804 <tiny_print>:
/*-----------------------------------------------------------*/

static void tiny_print( struct SStringBuf *apBuf, const char *format, va_list args )
{
 800e804:	b590      	push	{r4, r7, lr}
 800e806:	b087      	sub	sp, #28
 800e808:	af00      	add	r7, sp, #0
 800e80a:	60f8      	str	r0, [r7, #12]
 800e80c:	60b9      	str	r1, [r7, #8]
 800e80e:	607a      	str	r2, [r7, #4]
	char scr[2];

	for( ; ; )
	{
		int ch = *( format++ );
 800e810:	68bb      	ldr	r3, [r7, #8]
 800e812:	1c5a      	adds	r2, r3, #1
 800e814:	60ba      	str	r2, [r7, #8]
 800e816:	781b      	ldrb	r3, [r3, #0]
 800e818:	617b      	str	r3, [r7, #20]

		if( ch != '%' )
 800e81a:	697b      	ldr	r3, [r7, #20]
 800e81c:	2b25      	cmp	r3, #37	; 0x25
 800e81e:	d00f      	beq.n	800e840 <tiny_print+0x3c>
		{
			do
			{
				/* Put the most like flow in a small loop */
				if( strbuf_printchar_inline( apBuf, ch ) == 0 )
 800e820:	68f8      	ldr	r0, [r7, #12]
 800e822:	6979      	ldr	r1, [r7, #20]
 800e824:	f7ff fe50 	bl	800e4c8 <strbuf_printchar_inline>
 800e828:	4603      	mov	r3, r0
 800e82a:	2b00      	cmp	r3, #0
 800e82c:	d100      	bne.n	800e830 <tiny_print+0x2c>
				{
					return;
 800e82e:	e156      	b.n	800eade <tiny_print+0x2da>
				}
				ch = *( format++ );
 800e830:	68bb      	ldr	r3, [r7, #8]
 800e832:	1c5a      	adds	r2, r3, #1
 800e834:	60ba      	str	r2, [r7, #8]
 800e836:	781b      	ldrb	r3, [r3, #0]
 800e838:	617b      	str	r3, [r7, #20]
			} while( ch != '%' );
 800e83a:	697b      	ldr	r3, [r7, #20]
 800e83c:	2b25      	cmp	r3, #37	; 0x25
 800e83e:	d1ef      	bne.n	800e820 <tiny_print+0x1c>
		}
		ch = *( format++ );
 800e840:	68bb      	ldr	r3, [r7, #8]
 800e842:	1c5a      	adds	r2, r3, #1
 800e844:	60ba      	str	r2, [r7, #8]
 800e846:	781b      	ldrb	r3, [r3, #0]
 800e848:	617b      	str	r3, [r7, #20]
		/* Now ch has character after '%', format pointing to next */

		if( ch == '\0' )
 800e84a:	697b      	ldr	r3, [r7, #20]
 800e84c:	2b00      	cmp	r3, #0
 800e84e:	d100      	bne.n	800e852 <tiny_print+0x4e>
		{
			break;
 800e850:	e141      	b.n	800ead6 <tiny_print+0x2d2>
		}
		if( ch == '%' )
 800e852:	697b      	ldr	r3, [r7, #20]
 800e854:	2b25      	cmp	r3, #37	; 0x25
 800e856:	d108      	bne.n	800e86a <tiny_print+0x66>
		{
			if( strbuf_printchar( apBuf, ch ) == 0 )
 800e858:	68f8      	ldr	r0, [r7, #12]
 800e85a:	6979      	ldr	r1, [r7, #20]
 800e85c:	f7ff fdf6 	bl	800e44c <strbuf_printchar>
 800e860:	4603      	mov	r3, r0
 800e862:	2b00      	cmp	r3, #0
 800e864:	d100      	bne.n	800e868 <tiny_print+0x64>
			{
				return;
 800e866:	e13a      	b.n	800eade <tiny_print+0x2da>
			}
			continue;
 800e868:	e134      	b.n	800ead4 <tiny_print+0x2d0>
		}
		memset( &apBuf->flags, '\0', sizeof( apBuf->flags ) );
 800e86a:	68fb      	ldr	r3, [r7, #12]
 800e86c:	3310      	adds	r3, #16
 800e86e:	4618      	mov	r0, r3
 800e870:	2100      	movs	r1, #0
 800e872:	2210      	movs	r2, #16
 800e874:	f001 fd18 	bl	80102a8 <memset>

		if( ch == '-' )
 800e878:	697b      	ldr	r3, [r7, #20]
 800e87a:	2b2d      	cmp	r3, #45	; 0x2d
 800e87c:	d107      	bne.n	800e88e <tiny_print+0x8a>
		{
			ch = *( format++ );
 800e87e:	68bb      	ldr	r3, [r7, #8]
 800e880:	1c5a      	adds	r2, r3, #1
 800e882:	60ba      	str	r2, [r7, #8]
 800e884:	781b      	ldrb	r3, [r3, #0]
 800e886:	617b      	str	r3, [r7, #20]
			apBuf->flags.pad = PAD_RIGHT;
 800e888:	68fb      	ldr	r3, [r7, #12]
 800e88a:	2201      	movs	r2, #1
 800e88c:	771a      	strb	r2, [r3, #28]
		}
		while( ch == '0' )
 800e88e:	e00b      	b.n	800e8a8 <tiny_print+0xa4>
		{
			ch = *( format++ );
 800e890:	68bb      	ldr	r3, [r7, #8]
 800e892:	1c5a      	adds	r2, r3, #1
 800e894:	60ba      	str	r2, [r7, #8]
 800e896:	781b      	ldrb	r3, [r3, #0]
 800e898:	617b      	str	r3, [r7, #20]
			apBuf->flags.pad |= PAD_ZERO;
 800e89a:	68fb      	ldr	r3, [r7, #12]
 800e89c:	7f1b      	ldrb	r3, [r3, #28]
 800e89e:	f043 0302 	orr.w	r3, r3, #2
 800e8a2:	b2da      	uxtb	r2, r3
 800e8a4:	68fb      	ldr	r3, [r7, #12]
 800e8a6:	771a      	strb	r2, [r3, #28]
		if( ch == '-' )
		{
			ch = *( format++ );
			apBuf->flags.pad = PAD_RIGHT;
		}
		while( ch == '0' )
 800e8a8:	697b      	ldr	r3, [r7, #20]
 800e8aa:	2b30      	cmp	r3, #48	; 0x30
 800e8ac:	d0f0      	beq.n	800e890 <tiny_print+0x8c>
		{
			ch = *( format++ );
			apBuf->flags.pad |= PAD_ZERO;
		}
		if( ch == '*' )
 800e8ae:	697b      	ldr	r3, [r7, #20]
 800e8b0:	2b2a      	cmp	r3, #42	; 0x2a
 800e8b2:	d10b      	bne.n	800e8cc <tiny_print+0xc8>
		{
			ch = *( format++ );
 800e8b4:	68bb      	ldr	r3, [r7, #8]
 800e8b6:	1c5a      	adds	r2, r3, #1
 800e8b8:	60ba      	str	r2, [r7, #8]
 800e8ba:	781b      	ldrb	r3, [r3, #0]
 800e8bc:	617b      	str	r3, [r7, #20]
			apBuf->flags.width = va_arg( args, int );
 800e8be:	687b      	ldr	r3, [r7, #4]
 800e8c0:	1d1a      	adds	r2, r3, #4
 800e8c2:	607a      	str	r2, [r7, #4]
 800e8c4:	681a      	ldr	r2, [r3, #0]
 800e8c6:	68fb      	ldr	r3, [r7, #12]
 800e8c8:	615a      	str	r2, [r3, #20]
 800e8ca:	e01b      	b.n	800e904 <tiny_print+0x100>
		}
		else
		{
			while( ch >= '0' && ch <= '9' )
 800e8cc:	e014      	b.n	800e8f8 <tiny_print+0xf4>
			{
				apBuf->flags.width *= 10;
 800e8ce:	68fb      	ldr	r3, [r7, #12]
 800e8d0:	695a      	ldr	r2, [r3, #20]
 800e8d2:	4613      	mov	r3, r2
 800e8d4:	009b      	lsls	r3, r3, #2
 800e8d6:	4413      	add	r3, r2
 800e8d8:	005b      	lsls	r3, r3, #1
 800e8da:	461a      	mov	r2, r3
 800e8dc:	68fb      	ldr	r3, [r7, #12]
 800e8de:	615a      	str	r2, [r3, #20]
				apBuf->flags.width += ch - '0';
 800e8e0:	68fb      	ldr	r3, [r7, #12]
 800e8e2:	695a      	ldr	r2, [r3, #20]
 800e8e4:	697b      	ldr	r3, [r7, #20]
 800e8e6:	3b30      	subs	r3, #48	; 0x30
 800e8e8:	441a      	add	r2, r3
 800e8ea:	68fb      	ldr	r3, [r7, #12]
 800e8ec:	615a      	str	r2, [r3, #20]
				ch = *( format++ );
 800e8ee:	68bb      	ldr	r3, [r7, #8]
 800e8f0:	1c5a      	adds	r2, r3, #1
 800e8f2:	60ba      	str	r2, [r7, #8]
 800e8f4:	781b      	ldrb	r3, [r3, #0]
 800e8f6:	617b      	str	r3, [r7, #20]
			ch = *( format++ );
			apBuf->flags.width = va_arg( args, int );
		}
		else
		{
			while( ch >= '0' && ch <= '9' )
 800e8f8:	697b      	ldr	r3, [r7, #20]
 800e8fa:	2b2f      	cmp	r3, #47	; 0x2f
 800e8fc:	dd02      	ble.n	800e904 <tiny_print+0x100>
 800e8fe:	697b      	ldr	r3, [r7, #20]
 800e900:	2b39      	cmp	r3, #57	; 0x39
 800e902:	dde4      	ble.n	800e8ce <tiny_print+0xca>
				apBuf->flags.width *= 10;
				apBuf->flags.width += ch - '0';
				ch = *( format++ );
			}
		}
		if( ch == '.' )
 800e904:	697b      	ldr	r3, [r7, #20]
 800e906:	2b2e      	cmp	r3, #46	; 0x2e
 800e908:	d12f      	bne.n	800e96a <tiny_print+0x166>
		{
			ch = *( format++ );
 800e90a:	68bb      	ldr	r3, [r7, #8]
 800e90c:	1c5a      	adds	r2, r3, #1
 800e90e:	60ba      	str	r2, [r7, #8]
 800e910:	781b      	ldrb	r3, [r3, #0]
 800e912:	617b      	str	r3, [r7, #20]
			if( ch == '*' )
 800e914:	697b      	ldr	r3, [r7, #20]
 800e916:	2b2a      	cmp	r3, #42	; 0x2a
 800e918:	d10b      	bne.n	800e932 <tiny_print+0x12e>
			{
				apBuf->flags.printLimit = va_arg( args, int );
 800e91a:	687b      	ldr	r3, [r7, #4]
 800e91c:	1d1a      	adds	r2, r3, #4
 800e91e:	607a      	str	r2, [r7, #4]
 800e920:	681a      	ldr	r2, [r3, #0]
 800e922:	68fb      	ldr	r3, [r7, #12]
 800e924:	619a      	str	r2, [r3, #24]
				ch = *( format++ );
 800e926:	68bb      	ldr	r3, [r7, #8]
 800e928:	1c5a      	adds	r2, r3, #1
 800e92a:	60ba      	str	r2, [r7, #8]
 800e92c:	781b      	ldrb	r3, [r3, #0]
 800e92e:	617b      	str	r3, [r7, #20]
 800e930:	e01b      	b.n	800e96a <tiny_print+0x166>
			}
			else
			{
				while( ch >= '0' && ch <= '9' )
 800e932:	e014      	b.n	800e95e <tiny_print+0x15a>
				{
					apBuf->flags.printLimit *= 10;
 800e934:	68fb      	ldr	r3, [r7, #12]
 800e936:	699a      	ldr	r2, [r3, #24]
 800e938:	4613      	mov	r3, r2
 800e93a:	009b      	lsls	r3, r3, #2
 800e93c:	4413      	add	r3, r2
 800e93e:	005b      	lsls	r3, r3, #1
 800e940:	461a      	mov	r2, r3
 800e942:	68fb      	ldr	r3, [r7, #12]
 800e944:	619a      	str	r2, [r3, #24]
					apBuf->flags.printLimit += ch - '0';
 800e946:	68fb      	ldr	r3, [r7, #12]
 800e948:	699a      	ldr	r2, [r3, #24]
 800e94a:	697b      	ldr	r3, [r7, #20]
 800e94c:	3b30      	subs	r3, #48	; 0x30
 800e94e:	441a      	add	r2, r3
 800e950:	68fb      	ldr	r3, [r7, #12]
 800e952:	619a      	str	r2, [r3, #24]
					ch = *( format++ );
 800e954:	68bb      	ldr	r3, [r7, #8]
 800e956:	1c5a      	adds	r2, r3, #1
 800e958:	60ba      	str	r2, [r7, #8]
 800e95a:	781b      	ldrb	r3, [r3, #0]
 800e95c:	617b      	str	r3, [r7, #20]
				apBuf->flags.printLimit = va_arg( args, int );
				ch = *( format++ );
			}
			else
			{
				while( ch >= '0' && ch <= '9' )
 800e95e:	697b      	ldr	r3, [r7, #20]
 800e960:	2b2f      	cmp	r3, #47	; 0x2f
 800e962:	dd02      	ble.n	800e96a <tiny_print+0x166>
 800e964:	697b      	ldr	r3, [r7, #20]
 800e966:	2b39      	cmp	r3, #57	; 0x39
 800e968:	dde4      	ble.n	800e934 <tiny_print+0x130>
					apBuf->flags.printLimit += ch - '0';
					ch = *( format++ );
				}
			}
		}
		if( apBuf->flags.printLimit == 0 )
 800e96a:	68fb      	ldr	r3, [r7, #12]
 800e96c:	699b      	ldr	r3, [r3, #24]
 800e96e:	2b00      	cmp	r3, #0
 800e970:	d104      	bne.n	800e97c <tiny_print+0x178>
		{
			apBuf->flags.printLimit--;  /* -1: make it unlimited */
 800e972:	68fb      	ldr	r3, [r7, #12]
 800e974:	699b      	ldr	r3, [r3, #24]
 800e976:	1e5a      	subs	r2, r3, #1
 800e978:	68fb      	ldr	r3, [r7, #12]
 800e97a:	619a      	str	r2, [r3, #24]
		}
		if( ch == 's' )
 800e97c:	697b      	ldr	r3, [r7, #20]
 800e97e:	2b73      	cmp	r3, #115	; 0x73
 800e980:	d112      	bne.n	800e9a8 <tiny_print+0x1a4>
		{
			register char *s = ( char * )va_arg( args, int );
 800e982:	687b      	ldr	r3, [r7, #4]
 800e984:	1d1a      	adds	r2, r3, #4
 800e986:	607a      	str	r2, [r7, #4]
 800e988:	681b      	ldr	r3, [r3, #0]
 800e98a:	461c      	mov	r4, r3
			if( prints( apBuf, s ? s : "(null)" ) == 0 )
 800e98c:	2c00      	cmp	r4, #0
 800e98e:	d001      	beq.n	800e994 <tiny_print+0x190>
 800e990:	4623      	mov	r3, r4
 800e992:	e000      	b.n	800e996 <tiny_print+0x192>
 800e994:	4b53      	ldr	r3, [pc, #332]	; (800eae4 <tiny_print+0x2e0>)
 800e996:	68f8      	ldr	r0, [r7, #12]
 800e998:	4619      	mov	r1, r3
 800e99a:	f7ff fddd 	bl	800e558 <prints>
 800e99e:	4603      	mov	r3, r0
 800e9a0:	2b00      	cmp	r3, #0
 800e9a2:	d100      	bne.n	800e9a6 <tiny_print+0x1a2>
			{
				break;
 800e9a4:	e097      	b.n	800ead6 <tiny_print+0x2d2>
			}
			continue;
 800e9a6:	e095      	b.n	800ead4 <tiny_print+0x2d0>
		}
		if( ch == 'c' )
 800e9a8:	697b      	ldr	r3, [r7, #20]
 800e9aa:	2b63      	cmp	r3, #99	; 0x63
 800e9ac:	d10f      	bne.n	800e9ce <tiny_print+0x1ca>
		{
			/* char are converted to int then pushed on the stack */
			scr[0] = ( char ) va_arg( args, int );
 800e9ae:	687b      	ldr	r3, [r7, #4]
 800e9b0:	1d1a      	adds	r2, r3, #4
 800e9b2:	607a      	str	r2, [r7, #4]
 800e9b4:	681b      	ldr	r3, [r3, #0]
 800e9b6:	b2db      	uxtb	r3, r3
 800e9b8:	743b      	strb	r3, [r7, #16]

			if( strbuf_printchar( apBuf, scr[0] )  == 0 )
 800e9ba:	7c3b      	ldrb	r3, [r7, #16]
 800e9bc:	68f8      	ldr	r0, [r7, #12]
 800e9be:	4619      	mov	r1, r3
 800e9c0:	f7ff fd44 	bl	800e44c <strbuf_printchar>
 800e9c4:	4603      	mov	r3, r0
 800e9c6:	2b00      	cmp	r3, #0
 800e9c8:	d100      	bne.n	800e9cc <tiny_print+0x1c8>
			{
				return;
 800e9ca:	e088      	b.n	800eade <tiny_print+0x2da>
			}

			continue;
 800e9cc:	e082      	b.n	800ead4 <tiny_print+0x2d0>
		}
		if( ch == 'l' )
 800e9ce:	697b      	ldr	r3, [r7, #20]
 800e9d0:	2b6c      	cmp	r3, #108	; 0x6c
 800e9d2:	d109      	bne.n	800e9e8 <tiny_print+0x1e4>
		{
			ch = *( format++ );
 800e9d4:	68bb      	ldr	r3, [r7, #8]
 800e9d6:	1c5a      	adds	r2, r3, #1
 800e9d8:	60ba      	str	r2, [r7, #8]
 800e9da:	781b      	ldrb	r3, [r3, #0]
 800e9dc:	617b      	str	r3, [r7, #20]
			apBuf->flags.long32 = 1;
 800e9de:	68fa      	ldr	r2, [r7, #12]
 800e9e0:	7f93      	ldrb	r3, [r2, #30]
 800e9e2:	f043 0304 	orr.w	r3, r3, #4
 800e9e6:	7793      	strb	r3, [r2, #30]
			/* Makes not difference as u32 == long */
		}
		if( ch == 'L' )
 800e9e8:	697b      	ldr	r3, [r7, #20]
 800e9ea:	2b4c      	cmp	r3, #76	; 0x4c
 800e9ec:	d109      	bne.n	800ea02 <tiny_print+0x1fe>
		{
			ch = *( format++ );
 800e9ee:	68bb      	ldr	r3, [r7, #8]
 800e9f0:	1c5a      	adds	r2, r3, #1
 800e9f2:	60ba      	str	r2, [r7, #8]
 800e9f4:	781b      	ldrb	r3, [r3, #0]
 800e9f6:	617b      	str	r3, [r7, #20]
			apBuf->flags.long64 = 1;
 800e9f8:	68fa      	ldr	r2, [r7, #12]
 800e9fa:	7f93      	ldrb	r3, [r2, #30]
 800e9fc:	f043 0308 	orr.w	r3, r3, #8
 800ea00:	7793      	strb	r3, [r2, #30]
			/* Does make a difference */
		}
		apBuf->flags.base = 10;
 800ea02:	68fb      	ldr	r3, [r7, #12]
 800ea04:	220a      	movs	r2, #10
 800ea06:	611a      	str	r2, [r3, #16]
		apBuf->flags.letBase = 'a';
 800ea08:	68fb      	ldr	r3, [r7, #12]
 800ea0a:	2261      	movs	r2, #97	; 0x61
 800ea0c:	775a      	strb	r2, [r3, #29]

		if( ch == 'd' || ch == 'u' )
 800ea0e:	697b      	ldr	r3, [r7, #20]
 800ea10:	2b64      	cmp	r3, #100	; 0x64
 800ea12:	d002      	beq.n	800ea1a <tiny_print+0x216>
 800ea14:	697b      	ldr	r3, [r7, #20]
 800ea16:	2b75      	cmp	r3, #117	; 0x75
 800ea18:	d117      	bne.n	800ea4a <tiny_print+0x246>
		{
			apBuf->flags.isSigned = ( ch == 'd' );
 800ea1a:	697b      	ldr	r3, [r7, #20]
 800ea1c:	2b64      	cmp	r3, #100	; 0x64
 800ea1e:	bf0c      	ite	eq
 800ea20:	2301      	moveq	r3, #1
 800ea22:	2300      	movne	r3, #0
 800ea24:	b2d9      	uxtb	r1, r3
 800ea26:	68fa      	ldr	r2, [r7, #12]
 800ea28:	7f93      	ldrb	r3, [r2, #30]
 800ea2a:	f361 0300 	bfi	r3, r1, #0, #1
 800ea2e:	7793      	strb	r3, [r2, #30]
				{
					break;
				}
			} else
#endif	/* SPRINTF_LONG_LONG */
			if( printi( apBuf, va_arg( args, int ) ) == 0 )
 800ea30:	687b      	ldr	r3, [r7, #4]
 800ea32:	1d1a      	adds	r2, r3, #4
 800ea34:	607a      	str	r2, [r7, #4]
 800ea36:	681b      	ldr	r3, [r3, #0]
 800ea38:	68f8      	ldr	r0, [r7, #12]
 800ea3a:	4619      	mov	r1, r3
 800ea3c:	f7ff fe2a 	bl	800e694 <printi>
 800ea40:	4603      	mov	r3, r0
 800ea42:	2b00      	cmp	r3, #0
 800ea44:	d100      	bne.n	800ea48 <tiny_print+0x244>
			{
				break;
 800ea46:	e046      	b.n	800ead6 <tiny_print+0x2d2>
			}
			continue;
 800ea48:	e044      	b.n	800ead4 <tiny_print+0x2d0>
		}

		apBuf->flags.base = 16;		/* From here all hexadecimal */
 800ea4a:	68fb      	ldr	r3, [r7, #12]
 800ea4c:	2210      	movs	r2, #16
 800ea4e:	611a      	str	r2, [r3, #16]

		if( ch == 'x' && format[0] == 'i' && format[1] == 'p' )
 800ea50:	697b      	ldr	r3, [r7, #20]
 800ea52:	2b78      	cmp	r3, #120	; 0x78
 800ea54:	d118      	bne.n	800ea88 <tiny_print+0x284>
 800ea56:	68bb      	ldr	r3, [r7, #8]
 800ea58:	781b      	ldrb	r3, [r3, #0]
 800ea5a:	2b69      	cmp	r3, #105	; 0x69
 800ea5c:	d114      	bne.n	800ea88 <tiny_print+0x284>
 800ea5e:	68bb      	ldr	r3, [r7, #8]
 800ea60:	3301      	adds	r3, #1
 800ea62:	781b      	ldrb	r3, [r3, #0]
 800ea64:	2b70      	cmp	r3, #112	; 0x70
 800ea66:	d10f      	bne.n	800ea88 <tiny_print+0x284>
		{
			format += 2;	/* eat the "xi" of "xip" */
 800ea68:	68bb      	ldr	r3, [r7, #8]
 800ea6a:	3302      	adds	r3, #2
 800ea6c:	60bb      	str	r3, [r7, #8]
			/* Will use base 10 again */
			if( printIp( apBuf, va_arg( args, int ) ) == 0 )
 800ea6e:	687b      	ldr	r3, [r7, #4]
 800ea70:	1d1a      	adds	r2, r3, #4
 800ea72:	607a      	str	r2, [r7, #4]
 800ea74:	681b      	ldr	r3, [r3, #0]
 800ea76:	68f8      	ldr	r0, [r7, #12]
 800ea78:	4619      	mov	r1, r3
 800ea7a:	f7ff fe97 	bl	800e7ac <printIp>
 800ea7e:	4603      	mov	r3, r0
 800ea80:	2b00      	cmp	r3, #0
 800ea82:	d100      	bne.n	800ea86 <tiny_print+0x282>
			{
				break;
 800ea84:	e027      	b.n	800ead6 <tiny_print+0x2d2>
			}
			continue;
 800ea86:	e025      	b.n	800ead4 <tiny_print+0x2d0>
		}
		if( ch == 'x' || ch == 'X' || ch == 'p' || ch == 'o' )
 800ea88:	697b      	ldr	r3, [r7, #20]
 800ea8a:	2b78      	cmp	r3, #120	; 0x78
 800ea8c:	d008      	beq.n	800eaa0 <tiny_print+0x29c>
 800ea8e:	697b      	ldr	r3, [r7, #20]
 800ea90:	2b58      	cmp	r3, #88	; 0x58
 800ea92:	d005      	beq.n	800eaa0 <tiny_print+0x29c>
 800ea94:	697b      	ldr	r3, [r7, #20]
 800ea96:	2b70      	cmp	r3, #112	; 0x70
 800ea98:	d002      	beq.n	800eaa0 <tiny_print+0x29c>
 800ea9a:	697b      	ldr	r3, [r7, #20]
 800ea9c:	2b6f      	cmp	r3, #111	; 0x6f
 800ea9e:	d119      	bne.n	800ead4 <tiny_print+0x2d0>
		{
			if( ch == 'X' )
 800eaa0:	697b      	ldr	r3, [r7, #20]
 800eaa2:	2b58      	cmp	r3, #88	; 0x58
 800eaa4:	d103      	bne.n	800eaae <tiny_print+0x2aa>
			{
				apBuf->flags.letBase = 'A';
 800eaa6:	68fb      	ldr	r3, [r7, #12]
 800eaa8:	2241      	movs	r2, #65	; 0x41
 800eaaa:	775a      	strb	r2, [r3, #29]
 800eaac:	e005      	b.n	800eaba <tiny_print+0x2b6>
			}
			else if( ch == 'o' )
 800eaae:	697b      	ldr	r3, [r7, #20]
 800eab0:	2b6f      	cmp	r3, #111	; 0x6f
 800eab2:	d102      	bne.n	800eaba <tiny_print+0x2b6>
			{
				apBuf->flags.base = 8;
 800eab4:	68fb      	ldr	r3, [r7, #12]
 800eab6:	2208      	movs	r2, #8
 800eab8:	611a      	str	r2, [r3, #16]
				{
					break;
				}
			} else
#endif	/* SPRINTF_LONG_LONG */
			if( printi( apBuf, va_arg( args, int ) ) == 0 )
 800eaba:	687b      	ldr	r3, [r7, #4]
 800eabc:	1d1a      	adds	r2, r3, #4
 800eabe:	607a      	str	r2, [r7, #4]
 800eac0:	681b      	ldr	r3, [r3, #0]
 800eac2:	68f8      	ldr	r0, [r7, #12]
 800eac4:	4619      	mov	r1, r3
 800eac6:	f7ff fde5 	bl	800e694 <printi>
 800eaca:	4603      	mov	r3, r0
 800eacc:	2b00      	cmp	r3, #0
 800eace:	d100      	bne.n	800ead2 <tiny_print+0x2ce>
			{
				break;
 800ead0:	e001      	b.n	800ead6 <tiny_print+0x2d2>
			}
			continue;
 800ead2:	bf00      	nop
		}
	}
 800ead4:	e69c      	b.n	800e810 <tiny_print+0xc>
	strbuf_printchar( apBuf, '\0' );
 800ead6:	68f8      	ldr	r0, [r7, #12]
 800ead8:	2100      	movs	r1, #0
 800eada:	f7ff fcb7 	bl	800e44c <strbuf_printchar>
}
 800eade:	371c      	adds	r7, #28
 800eae0:	46bd      	mov	sp, r7
 800eae2:	bd90      	pop	{r4, r7, pc}
 800eae4:	0801280c 	.word	0x0801280c

0800eae8 <vsnprintf>:
	return strBuf.curLen;
}
/*-----------------------------------------------------------*/

int vsnprintf( char *apBuf, size_t aMaxLen, const char *apFmt, va_list args )
{
 800eae8:	b580      	push	{r7, lr}
 800eaea:	b08c      	sub	sp, #48	; 0x30
 800eaec:	af00      	add	r7, sp, #0
 800eaee:	60f8      	str	r0, [r7, #12]
 800eaf0:	60b9      	str	r1, [r7, #8]
 800eaf2:	607a      	str	r2, [r7, #4]
 800eaf4:	603b      	str	r3, [r7, #0]
	struct SStringBuf strBuf;
	strbuf_init( &strBuf, apBuf, ( const char* )apBuf + aMaxLen );
 800eaf6:	68fa      	ldr	r2, [r7, #12]
 800eaf8:	68bb      	ldr	r3, [r7, #8]
 800eafa:	4413      	add	r3, r2
 800eafc:	f107 0210 	add.w	r2, r7, #16
 800eb00:	4610      	mov	r0, r2
 800eb02:	68f9      	ldr	r1, [r7, #12]
 800eb04:	461a      	mov	r2, r3
 800eb06:	f7ff fc83 	bl	800e410 <strbuf_init>
	tiny_print( &strBuf, apFmt, args );
 800eb0a:	f107 0310 	add.w	r3, r7, #16
 800eb0e:	4618      	mov	r0, r3
 800eb10:	6879      	ldr	r1, [r7, #4]
 800eb12:	683a      	ldr	r2, [r7, #0]
 800eb14:	f7ff fe76 	bl	800e804 <tiny_print>

	return strBuf.curLen;
 800eb18:	69fb      	ldr	r3, [r7, #28]
}
 800eb1a:	4618      	mov	r0, r3
 800eb1c:	3730      	adds	r7, #48	; 0x30
 800eb1e:	46bd      	mov	sp, r7
 800eb20:	bd80      	pop	{r7, pc}
 800eb22:	bf00      	nop

0800eb24 <snprintf>:
/*-----------------------------------------------------------*/

int snprintf( char *apBuf, size_t aMaxLen, const char *apFmt, ... )
{
 800eb24:	b40c      	push	{r2, r3}
 800eb26:	b580      	push	{r7, lr}
 800eb28:	b08c      	sub	sp, #48	; 0x30
 800eb2a:	af00      	add	r7, sp, #0
 800eb2c:	6078      	str	r0, [r7, #4]
 800eb2e:	6039      	str	r1, [r7, #0]
	va_list args;

	va_start( args,  apFmt );
 800eb30:	f107 033c 	add.w	r3, r7, #60	; 0x3c
 800eb34:	62fb      	str	r3, [r7, #44]	; 0x2c
	struct SStringBuf strBuf;
	strbuf_init( &strBuf, apBuf, ( const char* )apBuf + aMaxLen );
 800eb36:	687a      	ldr	r2, [r7, #4]
 800eb38:	683b      	ldr	r3, [r7, #0]
 800eb3a:	4413      	add	r3, r2
 800eb3c:	f107 020c 	add.w	r2, r7, #12
 800eb40:	4610      	mov	r0, r2
 800eb42:	6879      	ldr	r1, [r7, #4]
 800eb44:	461a      	mov	r2, r3
 800eb46:	f7ff fc63 	bl	800e410 <strbuf_init>
	tiny_print( &strBuf, apFmt, args );
 800eb4a:	f107 030c 	add.w	r3, r7, #12
 800eb4e:	4618      	mov	r0, r3
 800eb50:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 800eb52:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800eb54:	f7ff fe56 	bl	800e804 <tiny_print>
	va_end( args );

	return strBuf.curLen;
 800eb58:	69bb      	ldr	r3, [r7, #24]
}
 800eb5a:	4618      	mov	r0, r3
 800eb5c:	3730      	adds	r7, #48	; 0x30
 800eb5e:	46bd      	mov	sp, r7
 800eb60:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800eb64:	b002      	add	sp, #8
 800eb66:	4770      	bx	lr

0800eb68 <sprintf>:
/*-----------------------------------------------------------*/

int sprintf( char *apBuf, const char *apFmt, ... )
{
 800eb68:	b40e      	push	{r1, r2, r3}
 800eb6a:	b580      	push	{r7, lr}
 800eb6c:	b08d      	sub	sp, #52	; 0x34
 800eb6e:	af00      	add	r7, sp, #0
 800eb70:	6078      	str	r0, [r7, #4]
	va_list args;

	va_start( args,  apFmt );
 800eb72:	f107 0340 	add.w	r3, r7, #64	; 0x40
 800eb76:	62fb      	str	r3, [r7, #44]	; 0x2c
	struct SStringBuf strBuf;
	strbuf_init( &strBuf, apBuf, ( const char * )apBuf + 1024 );
 800eb78:	687b      	ldr	r3, [r7, #4]
 800eb7a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800eb7e:	f107 020c 	add.w	r2, r7, #12
 800eb82:	4610      	mov	r0, r2
 800eb84:	6879      	ldr	r1, [r7, #4]
 800eb86:	461a      	mov	r2, r3
 800eb88:	f7ff fc42 	bl	800e410 <strbuf_init>
	tiny_print( &strBuf, apFmt, args );
 800eb8c:	f107 030c 	add.w	r3, r7, #12
 800eb90:	4618      	mov	r0, r3
 800eb92:	6bf9      	ldr	r1, [r7, #60]	; 0x3c
 800eb94:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800eb96:	f7ff fe35 	bl	800e804 <tiny_print>
	va_end( args );

	return strBuf.curLen;
 800eb9a:	69bb      	ldr	r3, [r7, #24]
}
 800eb9c:	4618      	mov	r0, r3
 800eb9e:	3734      	adds	r7, #52	; 0x34
 800eba0:	46bd      	mov	sp, r7
 800eba2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800eba6:	b003      	add	sp, #12
 800eba8:	4770      	bx	lr
 800ebaa:	bf00      	nop

0800ebac <uxStreamBufferSpace>:
}
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper );
static portINLINE size_t uxStreamBufferSpace( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
 800ebac:	b480      	push	{r7}
 800ebae:	b087      	sub	sp, #28
 800ebb0:	af00      	add	r7, sp, #0
 800ebb2:	60f8      	str	r0, [r7, #12]
 800ebb4:	60b9      	str	r1, [r7, #8]
 800ebb6:	607a      	str	r2, [r7, #4]
/* Returns the space between uxLower and uxUpper, which equals to the distance minus 1 */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower - 1u;
 800ebb8:	68fb      	ldr	r3, [r7, #12]
 800ebba:	691a      	ldr	r2, [r3, #16]
 800ebbc:	687b      	ldr	r3, [r7, #4]
 800ebbe:	441a      	add	r2, r3
 800ebc0:	68bb      	ldr	r3, [r7, #8]
 800ebc2:	1ad3      	subs	r3, r2, r3
 800ebc4:	3b01      	subs	r3, #1
 800ebc6:	617b      	str	r3, [r7, #20]
	if( uxCount >= pxBuffer->LENGTH )
 800ebc8:	68fb      	ldr	r3, [r7, #12]
 800ebca:	691a      	ldr	r2, [r3, #16]
 800ebcc:	697b      	ldr	r3, [r7, #20]
 800ebce:	429a      	cmp	r2, r3
 800ebd0:	d804      	bhi.n	800ebdc <uxStreamBufferSpace+0x30>
	{
		uxCount -= pxBuffer->LENGTH;
 800ebd2:	68fb      	ldr	r3, [r7, #12]
 800ebd4:	691b      	ldr	r3, [r3, #16]
 800ebd6:	697a      	ldr	r2, [r7, #20]
 800ebd8:	1ad3      	subs	r3, r2, r3
 800ebda:	617b      	str	r3, [r7, #20]
	}

	return uxCount;
 800ebdc:	697b      	ldr	r3, [r7, #20]
}
 800ebde:	4618      	mov	r0, r3
 800ebe0:	371c      	adds	r7, #28
 800ebe2:	46bd      	mov	sp, r7
 800ebe4:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ebe8:	4770      	bx	lr
 800ebea:	bf00      	nop

0800ebec <uxStreamBufferDistance>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper );
static portINLINE size_t uxStreamBufferDistance( const StreamBuffer_t *pxBuffer, const size_t uxLower, const size_t uxUpper )
{
 800ebec:	b480      	push	{r7}
 800ebee:	b087      	sub	sp, #28
 800ebf0:	af00      	add	r7, sp, #0
 800ebf2:	60f8      	str	r0, [r7, #12]
 800ebf4:	60b9      	str	r1, [r7, #8]
 800ebf6:	607a      	str	r2, [r7, #4]
/* Returns the distance between uxLower and uxUpper */
size_t uxCount;

	uxCount = pxBuffer->LENGTH + uxUpper - uxLower;
 800ebf8:	68fb      	ldr	r3, [r7, #12]
 800ebfa:	691a      	ldr	r2, [r3, #16]
 800ebfc:	687b      	ldr	r3, [r7, #4]
 800ebfe:	441a      	add	r2, r3
 800ec00:	68bb      	ldr	r3, [r7, #8]
 800ec02:	1ad3      	subs	r3, r2, r3
 800ec04:	617b      	str	r3, [r7, #20]
	if ( uxCount >= pxBuffer->LENGTH )
 800ec06:	68fb      	ldr	r3, [r7, #12]
 800ec08:	691a      	ldr	r2, [r3, #16]
 800ec0a:	697b      	ldr	r3, [r7, #20]
 800ec0c:	429a      	cmp	r2, r3
 800ec0e:	d804      	bhi.n	800ec1a <uxStreamBufferDistance+0x2e>
	{
		uxCount -= pxBuffer->LENGTH;
 800ec10:	68fb      	ldr	r3, [r7, #12]
 800ec12:	691b      	ldr	r3, [r3, #16]
 800ec14:	697a      	ldr	r2, [r7, #20]
 800ec16:	1ad3      	subs	r3, r2, r3
 800ec18:	617b      	str	r3, [r7, #20]
	}

	return uxCount;
 800ec1a:	697b      	ldr	r3, [r7, #20]
}
 800ec1c:	4618      	mov	r0, r3
 800ec1e:	371c      	adds	r7, #28
 800ec20:	46bd      	mov	sp, r7
 800ec22:	f85d 7b04 	ldr.w	r7, [sp], #4
 800ec26:	4770      	bx	lr

0800ec28 <uxStreamBufferGetSpace>:
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSpace( const StreamBuffer_t *pxBuffer )
{
 800ec28:	b580      	push	{r7, lr}
 800ec2a:	b084      	sub	sp, #16
 800ec2c:	af00      	add	r7, sp, #0
 800ec2e:	6078      	str	r0, [r7, #4]
/* Returns the number of items which can still be added to uxHead
before hitting on uxTail */
size_t uxHead = pxBuffer->uxHead;
 800ec30:	687b      	ldr	r3, [r7, #4]
 800ec32:	689b      	ldr	r3, [r3, #8]
 800ec34:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
 800ec36:	687b      	ldr	r3, [r7, #4]
 800ec38:	681b      	ldr	r3, [r3, #0]
 800ec3a:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferSpace( pxBuffer, uxHead, uxTail );
 800ec3c:	6878      	ldr	r0, [r7, #4]
 800ec3e:	68f9      	ldr	r1, [r7, #12]
 800ec40:	68ba      	ldr	r2, [r7, #8]
 800ec42:	f7ff ffb3 	bl	800ebac <uxStreamBufferSpace>
 800ec46:	4603      	mov	r3, r0
}
 800ec48:	4618      	mov	r0, r3
 800ec4a:	3710      	adds	r7, #16
 800ec4c:	46bd      	mov	sp, r7
 800ec4e:	bd80      	pop	{r7, pc}

0800ec50 <uxStreamBufferGetSize>:
}
/*-----------------------------------------------------------*/

static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer );
static portINLINE size_t uxStreamBufferGetSize( const StreamBuffer_t *pxBuffer )
{
 800ec50:	b580      	push	{r7, lr}
 800ec52:	b084      	sub	sp, #16
 800ec54:	af00      	add	r7, sp, #0
 800ec56:	6078      	str	r0, [r7, #4]
/* Returns the number of items which can be read from uxTail
before reaching uxHead */
size_t uxHead = pxBuffer->uxHead;
 800ec58:	687b      	ldr	r3, [r7, #4]
 800ec5a:	689b      	ldr	r3, [r3, #8]
 800ec5c:	60fb      	str	r3, [r7, #12]
size_t uxTail = pxBuffer->uxTail;
 800ec5e:	687b      	ldr	r3, [r7, #4]
 800ec60:	681b      	ldr	r3, [r3, #0]
 800ec62:	60bb      	str	r3, [r7, #8]

	return uxStreamBufferDistance( pxBuffer, uxTail, uxHead );
 800ec64:	6878      	ldr	r0, [r7, #4]
 800ec66:	68b9      	ldr	r1, [r7, #8]
 800ec68:	68fa      	ldr	r2, [r7, #12]
 800ec6a:	f7ff ffbf 	bl	800ebec <uxStreamBufferDistance>
 800ec6e:	4603      	mov	r3, r0
}
 800ec70:	4618      	mov	r0, r3
 800ec72:	3710      	adds	r7, #16
 800ec74:	46bd      	mov	sp, r7
 800ec76:	bd80      	pop	{r7, pc}

0800ec78 <prvInitialiseLogging>:
static xSocket_t xUDPLoggingSocket = FREERTOS_INVALID_SOCKET;

/*-----------------------------------------------------------*/

static BaseType_t prvInitialiseLogging( void )
{
 800ec78:	b580      	push	{r7, lr}
 800ec7a:	b082      	sub	sp, #8
 800ec7c:	af00      	add	r7, sp, #0
size_t xSize;
static BaseType_t xLoggingInitialised = pdFALSE;

	if( xLoggingInitialised == pdFALSE )
 800ec7e:	4b15      	ldr	r3, [pc, #84]	; (800ecd4 <prvInitialiseLogging+0x5c>)
 800ec80:	681b      	ldr	r3, [r3, #0]
 800ec82:	2b00      	cmp	r3, #0
 800ec84:	d120      	bne.n	800ecc8 <prvInitialiseLogging+0x50>
	{
		/* Don't attempt to log unless the scheduler is running. */
		if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 800ec86:	f7f7 f8cf 	bl	8005e28 <xTaskGetSchedulerState>
 800ec8a:	4603      	mov	r3, r0
 800ec8c:	2b02      	cmp	r3, #2
 800ec8e:	d11b      	bne.n	800ecc8 <prvInitialiseLogging+0x50>
		{
			/* Create a stream buffer large enough for the maximum number of
			bytes + 1. */ /*_RB_ Why is the size of pxStreamBuffer->ucArray
			subtracted here? */
			xSize = sizeof( StreamBuffer_t ) - sizeof( pxStreamBuffer->ucArray ) + logMESSAGE_BUFFER_SIZE_BYTES + 1;
 800ec90:	f640 73b5 	movw	r3, #4021	; 0xfb5
 800ec94:	607b      	str	r3, [r7, #4]
			pxStreamBuffer = pvPortMalloc( xSize );
 800ec96:	6878      	ldr	r0, [r7, #4]
 800ec98:	f7f5 fa0a 	bl	80040b0 <pvPortMalloc>
 800ec9c:	4602      	mov	r2, r0
 800ec9e:	4b0e      	ldr	r3, [pc, #56]	; (800ecd8 <prvInitialiseLogging+0x60>)
 800eca0:	601a      	str	r2, [r3, #0]

			if( pxStreamBuffer != NULL )
 800eca2:	4b0d      	ldr	r3, [pc, #52]	; (800ecd8 <prvInitialiseLogging+0x60>)
 800eca4:	681b      	ldr	r3, [r3, #0]
 800eca6:	2b00      	cmp	r3, #0
 800eca8:	d00e      	beq.n	800ecc8 <prvInitialiseLogging+0x50>
			{
				memset( pxStreamBuffer, '\0', xSize );
 800ecaa:	4b0b      	ldr	r3, [pc, #44]	; (800ecd8 <prvInitialiseLogging+0x60>)
 800ecac:	681b      	ldr	r3, [r3, #0]
 800ecae:	4618      	mov	r0, r3
 800ecb0:	2100      	movs	r1, #0
 800ecb2:	687a      	ldr	r2, [r7, #4]
 800ecb4:	f001 faf8 	bl	80102a8 <memset>
				pxStreamBuffer->LENGTH = logMESSAGE_BUFFER_SIZE_BYTES + 1;
 800ecb8:	4b07      	ldr	r3, [pc, #28]	; (800ecd8 <prvInitialiseLogging+0x60>)
 800ecba:	681b      	ldr	r3, [r3, #0]
 800ecbc:	f640 72a1 	movw	r2, #4001	; 0xfa1
 800ecc0:	611a      	str	r2, [r3, #16]

				xLoggingInitialised = pdTRUE;
 800ecc2:	4b04      	ldr	r3, [pc, #16]	; (800ecd4 <prvInitialiseLogging+0x5c>)
 800ecc4:	2201      	movs	r2, #1
 800ecc6:	601a      	str	r2, [r3, #0]
			}
		}
	}

	return xLoggingInitialised;
 800ecc8:	4b02      	ldr	r3, [pc, #8]	; (800ecd4 <prvInitialiseLogging+0x5c>)
 800ecca:	681b      	ldr	r3, [r3, #0]
}
 800eccc:	4618      	mov	r0, r3
 800ecce:	3708      	adds	r7, #8
 800ecd0:	46bd      	mov	sp, r7
 800ecd2:	bd80      	pop	{r7, pc}
 800ecd4:	2000c40c 	.word	0x2000c40c
 800ecd8:	2000c404 	.word	0x2000c404

0800ecdc <prvGetMessageFromStreamBuffer>:
/*-----------------------------------------------------------*/

static size_t prvGetMessageFromStreamBuffer( char* pcBuffer, size_t xBufferLength )
{
 800ecdc:	b590      	push	{r4, r7, lr}
 800ecde:	b087      	sub	sp, #28
 800ece0:	af02      	add	r7, sp, #8
 800ece2:	6078      	str	r0, [r7, #4]
 800ece4:	6039      	str	r1, [r7, #0]
size_t uxLength;
size_t xMessageLength = 0;
 800ece6:	2300      	movs	r3, #0
 800ece8:	60bb      	str	r3, [r7, #8]

	if( pxStreamBuffer != NULL )
 800ecea:	4b27      	ldr	r3, [pc, #156]	; (800ed88 <prvGetMessageFromStreamBuffer+0xac>)
 800ecec:	681b      	ldr	r3, [r3, #0]
 800ecee:	2b00      	cmp	r3, #0
 800ecf0:	d044      	beq.n	800ed7c <prvGetMessageFromStreamBuffer+0xa0>
	{
		/* Is there data in the stream buffer? */
		uxLength = uxStreamBufferGetSize( pxStreamBuffer );
 800ecf2:	4b25      	ldr	r3, [pc, #148]	; (800ed88 <prvGetMessageFromStreamBuffer+0xac>)
 800ecf4:	681b      	ldr	r3, [r3, #0]
 800ecf6:	4618      	mov	r0, r3
 800ecf8:	f7ff ffaa 	bl	800ec50 <uxStreamBufferGetSize>
 800ecfc:	60f8      	str	r0, [r7, #12]
		if( uxLength > sizeof( size_t ) )
 800ecfe:	68fb      	ldr	r3, [r7, #12]
 800ed00:	2b04      	cmp	r3, #4
 800ed02:	d93b      	bls.n	800ed7c <prvGetMessageFromStreamBuffer+0xa0>
		{
			/* Avoid concurrent access to the buffer. */
			vTaskSuspendAll();
 800ed04:	f7f6 fb8e 	bl	8005424 <vTaskSuspendAll>
			{
				/* Every message is stored as a length followed by the string.
				Obtain the length of the data first. */
				uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) &xMessageLength, sizeof( xMessageLength ), pdFALSE );
 800ed08:	4b1f      	ldr	r3, [pc, #124]	; (800ed88 <prvGetMessageFromStreamBuffer+0xac>)
 800ed0a:	6819      	ldr	r1, [r3, #0]
 800ed0c:	f107 0208 	add.w	r2, r7, #8
 800ed10:	2300      	movs	r3, #0
 800ed12:	9300      	str	r3, [sp, #0]
 800ed14:	4608      	mov	r0, r1
 800ed16:	2100      	movs	r1, #0
 800ed18:	2304      	movs	r3, #4
 800ed1a:	f7fe fe7f 	bl	800da1c <uxStreamBufferGet>

				if( xBufferLength < xMessageLength )
 800ed1e:	68bb      	ldr	r3, [r7, #8]
 800ed20:	683a      	ldr	r2, [r7, #0]
 800ed22:	429a      	cmp	r2, r3
 800ed24:	d218      	bcs.n	800ed58 <prvGetMessageFromStreamBuffer+0x7c>
				{
					/* The 'pcBuffer' provided by the caller is too small.  Load
					the message first into 'xLogEntry.message', and then copy
					as much as possible to 'pcBuffer'. */
					uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) xLogEntry.cMessage, xMessageLength, pdFALSE );
 800ed26:	4b18      	ldr	r3, [pc, #96]	; (800ed88 <prvGetMessageFromStreamBuffer+0xac>)
 800ed28:	681a      	ldr	r2, [r3, #0]
 800ed2a:	68bc      	ldr	r4, [r7, #8]
 800ed2c:	2300      	movs	r3, #0
 800ed2e:	9300      	str	r3, [sp, #0]
 800ed30:	4610      	mov	r0, r2
 800ed32:	2100      	movs	r1, #0
 800ed34:	4a15      	ldr	r2, [pc, #84]	; (800ed8c <prvGetMessageFromStreamBuffer+0xb0>)
 800ed36:	4623      	mov	r3, r4
 800ed38:	f7fe fe70 	bl	800da1c <uxStreamBufferGet>
					memcpy( pcBuffer, xLogEntry.cMessage, xBufferLength );
 800ed3c:	6878      	ldr	r0, [r7, #4]
 800ed3e:	4913      	ldr	r1, [pc, #76]	; (800ed8c <prvGetMessageFromStreamBuffer+0xb0>)
 800ed40:	683a      	ldr	r2, [r7, #0]
 800ed42:	f001 f9b1 	bl	80100a8 <memcpy>
					xMessageLength = xBufferLength;
 800ed46:	683b      	ldr	r3, [r7, #0]
 800ed48:	60bb      	str	r3, [r7, #8]

					/* Terminate the string at the very end of the buffer. */
					pcBuffer[ xBufferLength - 1 ] = 0x00;
 800ed4a:	683b      	ldr	r3, [r7, #0]
 800ed4c:	3b01      	subs	r3, #1
 800ed4e:	687a      	ldr	r2, [r7, #4]
 800ed50:	4413      	add	r3, r2
 800ed52:	2200      	movs	r2, #0
 800ed54:	701a      	strb	r2, [r3, #0]
 800ed56:	e00f      	b.n	800ed78 <prvGetMessageFromStreamBuffer+0x9c>
				}
				else
				{
					/* The 'pcBuffer' provided by the caller is big enough. */
					uxStreamBufferGet( pxStreamBuffer, 0, ( uint8_t * ) pcBuffer, xMessageLength, pdFALSE );
 800ed58:	4b0b      	ldr	r3, [pc, #44]	; (800ed88 <prvGetMessageFromStreamBuffer+0xac>)
 800ed5a:	681a      	ldr	r2, [r3, #0]
 800ed5c:	68bc      	ldr	r4, [r7, #8]
 800ed5e:	2300      	movs	r3, #0
 800ed60:	9300      	str	r3, [sp, #0]
 800ed62:	4610      	mov	r0, r2
 800ed64:	2100      	movs	r1, #0
 800ed66:	687a      	ldr	r2, [r7, #4]
 800ed68:	4623      	mov	r3, r4
 800ed6a:	f7fe fe57 	bl	800da1c <uxStreamBufferGet>

					/* Terminate the string after the string's last character. */
					pcBuffer[ xMessageLength ] = 0x00;
 800ed6e:	68bb      	ldr	r3, [r7, #8]
 800ed70:	687a      	ldr	r2, [r7, #4]
 800ed72:	4413      	add	r3, r2
 800ed74:	2200      	movs	r2, #0
 800ed76:	701a      	strb	r2, [r3, #0]
				}
			}
			xTaskResumeAll();
 800ed78:	f7f6 fb62 	bl	8005440 <xTaskResumeAll>
		}
	}

	return xMessageLength;
 800ed7c:	68bb      	ldr	r3, [r7, #8]
}
 800ed7e:	4618      	mov	r0, r3
 800ed80:	3714      	adds	r7, #20
 800ed82:	46bd      	mov	sp, r7
 800ed84:	bd90      	pop	{r4, r7, pc}
 800ed86:	bf00      	nop
 800ed88:	2000c404 	.word	0x2000c404
 800ed8c:	2000c33c 	.word	0x2000c33c

0800ed90 <prvBufferFormattedString>:
/*-----------------------------------------------------------*/

static size_t prvBufferFormattedString( const char *pcFormatString, va_list xArgs )
{
 800ed90:	b580      	push	{r7, lr}
 800ed92:	b08e      	sub	sp, #56	; 0x38
 800ed94:	af04      	add	r7, sp, #16
 800ed96:	6078      	str	r0, [r7, #4]
 800ed98:	6039      	str	r1, [r7, #0]
size_t xLength, xSpace;
uint64_t ullCurrentTime;
uint32_t ulSeconds, ulMilliSeconds, ulMicroSeconds;

	/* Sanity check. */
	configASSERT( pxStreamBuffer );
 800ed9a:	4b4d      	ldr	r3, [pc, #308]	; (800eed0 <prvBufferFormattedString+0x140>)
 800ed9c:	681b      	ldr	r3, [r3, #0]
 800ed9e:	2b00      	cmp	r3, #0
 800eda0:	d109      	bne.n	800edb6 <prvBufferFormattedString+0x26>
 800eda2:	f04f 0350 	mov.w	r3, #80	; 0x50
 800eda6:	f383 8811 	msr	BASEPRI, r3
 800edaa:	f3bf 8f6f 	isb	sy
 800edae:	f3bf 8f4f 	dsb	sy
 800edb2:	60fb      	str	r3, [r7, #12]
 800edb4:	e7fe      	b.n	800edb4 <prvBufferFormattedString+0x24>

	vTaskSuspendAll();
 800edb6:	f7f6 fb35 	bl	8005424 <vTaskSuspendAll>
	{
		ullCurrentTime = ullGetHighResolutionTime();
 800edba:	f001 fb6b 	bl	8010494 <ullGetHighResolutionTime>
 800edbe:	e9c7 0108 	strd	r0, r1, [r7, #32]
		ulSeconds = ( uint32_t ) ( ullCurrentTime / 1000000ull );
 800edc2:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800edc6:	4610      	mov	r0, r2
 800edc8:	4619      	mov	r1, r3
 800edca:	4a42      	ldr	r2, [pc, #264]	; (800eed4 <prvBufferFormattedString+0x144>)
 800edcc:	f04f 0300 	mov.w	r3, #0
 800edd0:	f7f1 fa44 	bl	800025c <__aeabi_uldivmod>
 800edd4:	4602      	mov	r2, r0
 800edd6:	460b      	mov	r3, r1
 800edd8:	4613      	mov	r3, r2
 800edda:	61fb      	str	r3, [r7, #28]
		ullCurrentTime = ullCurrentTime % 1000000ull;
 800eddc:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800ede0:	4610      	mov	r0, r2
 800ede2:	4619      	mov	r1, r3
 800ede4:	4a3b      	ldr	r2, [pc, #236]	; (800eed4 <prvBufferFormattedString+0x144>)
 800ede6:	f04f 0300 	mov.w	r3, #0
 800edea:	f7f1 fa37 	bl	800025c <__aeabi_uldivmod>
 800edee:	e9c7 2308 	strd	r2, r3, [r7, #32]
		ulMilliSeconds = ( uint32_t ) ( ullCurrentTime / 1000ull );
 800edf2:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800edf6:	4610      	mov	r0, r2
 800edf8:	4619      	mov	r1, r3
 800edfa:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800edfe:	f04f 0300 	mov.w	r3, #0
 800ee02:	f7f1 fa2b 	bl	800025c <__aeabi_uldivmod>
 800ee06:	4602      	mov	r2, r0
 800ee08:	460b      	mov	r3, r1
 800ee0a:	4613      	mov	r3, r2
 800ee0c:	61bb      	str	r3, [r7, #24]
		ulMicroSeconds = ( uint32_t ) ( ullCurrentTime % 1000ull );
 800ee0e:	e9d7 2308 	ldrd	r2, r3, [r7, #32]
 800ee12:	4610      	mov	r0, r2
 800ee14:	4619      	mov	r1, r3
 800ee16:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800ee1a:	f04f 0300 	mov.w	r3, #0
 800ee1e:	f7f1 fa1d 	bl	800025c <__aeabi_uldivmod>
 800ee22:	4613      	mov	r3, r2
 800ee24:	617b      	str	r3, [r7, #20]

		xLength = ( size_t ) snprintf( xLogEntry.cMessage, sizeof( xLogEntry.cMessage ), "%4u.%03u.%03u [%-10s] ",
 800ee26:	2000      	movs	r0, #0
 800ee28:	f7f6 fbce 	bl	80055c8 <pcTaskGetName>
 800ee2c:	4602      	mov	r2, r0
 800ee2e:	69bb      	ldr	r3, [r7, #24]
 800ee30:	9300      	str	r3, [sp, #0]
 800ee32:	697b      	ldr	r3, [r7, #20]
 800ee34:	9301      	str	r3, [sp, #4]
 800ee36:	9202      	str	r2, [sp, #8]
 800ee38:	4827      	ldr	r0, [pc, #156]	; (800eed8 <prvBufferFormattedString+0x148>)
 800ee3a:	21c8      	movs	r1, #200	; 0xc8
 800ee3c:	4a27      	ldr	r2, [pc, #156]	; (800eedc <prvBufferFormattedString+0x14c>)
 800ee3e:	69fb      	ldr	r3, [r7, #28]
 800ee40:	f7ff fe70 	bl	800eb24 <snprintf>
 800ee44:	4603      	mov	r3, r0
 800ee46:	60bb      	str	r3, [r7, #8]
			( unsigned int ) ulSeconds, ( unsigned int ) ulMilliSeconds, ( unsigned int ) ulMicroSeconds, pcTaskGetTaskName( NULL ) );
		xLength += ( size_t ) vsnprintf( xLogEntry.cMessage + xLength, sizeof( xLogEntry.cMessage ) - xLength, pcFormatString, xArgs );
 800ee48:	68bb      	ldr	r3, [r7, #8]
 800ee4a:	3308      	adds	r3, #8
 800ee4c:	4a24      	ldr	r2, [pc, #144]	; (800eee0 <prvBufferFormattedString+0x150>)
 800ee4e:	4413      	add	r3, r2
 800ee50:	1d1a      	adds	r2, r3, #4
 800ee52:	68bb      	ldr	r3, [r7, #8]
 800ee54:	f1c3 03c8 	rsb	r3, r3, #200	; 0xc8
 800ee58:	4610      	mov	r0, r2
 800ee5a:	4619      	mov	r1, r3
 800ee5c:	687a      	ldr	r2, [r7, #4]
 800ee5e:	683b      	ldr	r3, [r7, #0]
 800ee60:	f7ff fe42 	bl	800eae8 <vsnprintf>
 800ee64:	4603      	mov	r3, r0
 800ee66:	461a      	mov	r2, r3
 800ee68:	68bb      	ldr	r3, [r7, #8]
 800ee6a:	4413      	add	r3, r2
 800ee6c:	60bb      	str	r3, [r7, #8]

		xSpace = uxStreamBufferGetSpace( pxStreamBuffer );
 800ee6e:	4b18      	ldr	r3, [pc, #96]	; (800eed0 <prvBufferFormattedString+0x140>)
 800ee70:	681b      	ldr	r3, [r3, #0]
 800ee72:	4618      	mov	r0, r3
 800ee74:	f7ff fed8 	bl	800ec28 <uxStreamBufferGetSpace>
 800ee78:	6138      	str	r0, [r7, #16]

		if( xSpace > ( xLength + sizeof( BaseType_t ) ) )
 800ee7a:	68bb      	ldr	r3, [r7, #8]
 800ee7c:	1d1a      	adds	r2, r3, #4
 800ee7e:	693b      	ldr	r3, [r7, #16]
 800ee80:	429a      	cmp	r2, r3
 800ee82:	d211      	bcs.n	800eea8 <prvBufferFormattedString+0x118>
		{
			uxStreamBufferAdd( pxStreamBuffer, 0, ( const uint8_t * ) &xLength, sizeof( xLength ) );
 800ee84:	4b12      	ldr	r3, [pc, #72]	; (800eed0 <prvBufferFormattedString+0x140>)
 800ee86:	681a      	ldr	r2, [r3, #0]
 800ee88:	f107 0308 	add.w	r3, r7, #8
 800ee8c:	4610      	mov	r0, r2
 800ee8e:	2100      	movs	r1, #0
 800ee90:	461a      	mov	r2, r3
 800ee92:	2304      	movs	r3, #4
 800ee94:	f7fe fd44 	bl	800d920 <uxStreamBufferAdd>
			uxStreamBufferAdd( pxStreamBuffer, 0, ( const uint8_t * ) ( xLogEntry.cMessage ), xLength );
 800ee98:	4b0d      	ldr	r3, [pc, #52]	; (800eed0 <prvBufferFormattedString+0x140>)
 800ee9a:	681a      	ldr	r2, [r3, #0]
 800ee9c:	68bb      	ldr	r3, [r7, #8]
 800ee9e:	4610      	mov	r0, r2
 800eea0:	2100      	movs	r1, #0
 800eea2:	4a0d      	ldr	r2, [pc, #52]	; (800eed8 <prvBufferFormattedString+0x148>)
 800eea4:	f7fe fd3c 	bl	800d920 <uxStreamBufferAdd>
		}
	}
	xTaskResumeAll();
 800eea8:	f7f6 faca 	bl	8005440 <xTaskResumeAll>

	if( xLoggingTask != NULL )
 800eeac:	4b0d      	ldr	r3, [pc, #52]	; (800eee4 <prvBufferFormattedString+0x154>)
 800eeae:	681b      	ldr	r3, [r3, #0]
 800eeb0:	2b00      	cmp	r3, #0
 800eeb2:	d007      	beq.n	800eec4 <prvBufferFormattedString+0x134>
	{
		/* Unblock the logging task so it can output the message. */
		xTaskNotifyGive( xLoggingTask );
 800eeb4:	4b0b      	ldr	r3, [pc, #44]	; (800eee4 <prvBufferFormattedString+0x154>)
 800eeb6:	681b      	ldr	r3, [r3, #0]
 800eeb8:	4618      	mov	r0, r3
 800eeba:	2100      	movs	r1, #0
 800eebc:	2202      	movs	r2, #2
 800eebe:	2300      	movs	r3, #0
 800eec0:	f7f7 f950 	bl	8006164 <xTaskGenericNotify>
	}

	return xLength;
 800eec4:	68bb      	ldr	r3, [r7, #8]
}
 800eec6:	4618      	mov	r0, r3
 800eec8:	3728      	adds	r7, #40	; 0x28
 800eeca:	46bd      	mov	sp, r7
 800eecc:	bd80      	pop	{r7, pc}
 800eece:	bf00      	nop
 800eed0:	2000c404 	.word	0x2000c404
 800eed4:	000f4240 	.word	0x000f4240
 800eed8:	2000c33c 	.word	0x2000c33c
 800eedc:	08012844 	.word	0x08012844
 800eee0:	2000c330 	.word	0x2000c330
 800eee4:	2000c408 	.word	0x2000c408

0800eee8 <lUDPLoggingPrintf>:
/*-----------------------------------------------------------*/

int lUDPLoggingPrintf( const char *pcFormatString, ... )
{
 800eee8:	b40f      	push	{r0, r1, r2, r3}
 800eeea:	b580      	push	{r7, lr}
 800eeec:	b082      	sub	sp, #8
 800eeee:	af00      	add	r7, sp, #0
size_t xLength;

	if( prvInitialiseLogging() != pdFALSE )
 800eef0:	f7ff fec2 	bl	800ec78 <prvInitialiseLogging>
 800eef4:	4603      	mov	r3, r0
 800eef6:	2b00      	cmp	r3, #0
 800eef8:	d008      	beq.n	800ef0c <lUDPLoggingPrintf+0x24>
	{
		va_list args;
		va_start (args, pcFormatString);
 800eefa:	f107 0314 	add.w	r3, r7, #20
 800eefe:	603b      	str	r3, [r7, #0]
		xLength = prvBufferFormattedString (pcFormatString, args);
 800ef00:	6938      	ldr	r0, [r7, #16]
 800ef02:	6839      	ldr	r1, [r7, #0]
 800ef04:	f7ff ff44 	bl	800ed90 <prvBufferFormattedString>
 800ef08:	6078      	str	r0, [r7, #4]
 800ef0a:	e001      	b.n	800ef10 <lUDPLoggingPrintf+0x28>
		va_end (args);
	}
	else
	{
		xLength = 0;
 800ef0c:	2300      	movs	r3, #0
 800ef0e:	607b      	str	r3, [r7, #4]
	}

	return ( int ) xLength;
 800ef10:	687b      	ldr	r3, [r7, #4]
}
 800ef12:	4618      	mov	r0, r3
 800ef14:	3708      	adds	r7, #8
 800ef16:	46bd      	mov	sp, r7
 800ef18:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800ef1c:	b004      	add	sp, #16
 800ef1e:	4770      	bx	lr

0800ef20 <vUDPLoggingTaskCreate>:
/*-----------------------------------------------------------*/

void vUDPLoggingTaskCreate( void )
{
 800ef20:	b580      	push	{r7, lr}
 800ef22:	b082      	sub	sp, #8
 800ef24:	af02      	add	r7, sp, #8
	/* Start a task which will send out the logging lines to a UDP address. */
	xTaskCreate( prvLoggingTask, "LogTask", configUDP_LOGGING_TASK_STACK_SIZE, NULL, configUDP_LOGGING_TASK_PRIORITY, &xLoggingTask );
 800ef26:	2301      	movs	r3, #1
 800ef28:	9300      	str	r3, [sp, #0]
 800ef2a:	4b05      	ldr	r3, [pc, #20]	; (800ef40 <vUDPLoggingTaskCreate+0x20>)
 800ef2c:	9301      	str	r3, [sp, #4]
 800ef2e:	4805      	ldr	r0, [pc, #20]	; (800ef44 <vUDPLoggingTaskCreate+0x24>)
 800ef30:	4905      	ldr	r1, [pc, #20]	; (800ef48 <vUDPLoggingTaskCreate+0x28>)
 800ef32:	f44f 7200 	mov.w	r2, #512	; 0x200
 800ef36:	2300      	movs	r3, #0
 800ef38:	f7f5 fffe 	bl	8004f38 <xTaskCreate>
}
 800ef3c:	46bd      	mov	sp, r7
 800ef3e:	bd80      	pop	{r7, pc}
 800ef40:	2000c408 	.word	0x2000c408
 800ef44:	0800ef4d 	.word	0x0800ef4d
 800ef48:	0801285c 	.word	0x0801285c

0800ef4c <prvLoggingTask>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void prvLoggingTask( void *pvParameters )
{
 800ef4c:	b590      	push	{r4, r7, lr}
 800ef4e:	b091      	sub	sp, #68	; 0x44
 800ef50:	af02      	add	r7, sp, #8
 800ef52:	6078      	str	r0, [r7, #4]
TickType_t xBlockingTime = pdMS_TO_TICKS( logUDP_LOGGING_BLOCK_TIME_MS );
 800ef54:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800ef58:	627b      	str	r3, [r7, #36]	; 0x24
struct freertos_sockaddr xLocalAddress, xRemoteAddress;
BaseType_t xSendTimeOut;
int32_t lLines;
size_t xCount;
static char cLoggingLine[ configUDP_LOGGING_STRING_LENGTH ];
const TickType_t xResolveDelay = pdMS_TO_TICKS( ( TickType_t ) 250 );
 800ef5a:	23fa      	movs	r3, #250	; 0xfa
 800ef5c:	623b      	str	r3, [r7, #32]
	( void ) pvParameters;

	/* A possibility to set some additional task properties. */
	iptraceUDP_LOGGING_TASK_STARTING();

	xRemoteAddress.sin_port = FreeRTOS_htons( configUDP_LOGGING_PORT_REMOTE );
 800ef5e:	f64d 4305 	movw	r3, #56325	; 0xdc05
 800ef62:	827b      	strh	r3, [r7, #18]
	#if defined( configUDP_LOGGING_ADDR0 )
	{
		/* Use a fixed address to where the logging will be sent. */
		xRemoteAddress.sin_addr = FreeRTOS_inet_addr_quick( configUDP_LOGGING_ADDR0,
 800ef64:	4b53      	ldr	r3, [pc, #332]	; (800f0b4 <prvLoggingTask+0x168>)
 800ef66:	617b      	str	r3, [r7, #20]
	#endif

	/* Loop until a socket is created. */
	do
	{
		vTaskDelay( xBlockingTime );
 800ef68:	6a78      	ldr	r0, [r7, #36]	; 0x24
 800ef6a:	f7f6 f94d 	bl	8005208 <vTaskDelay>
		xUDPLoggingSocket = FreeRTOS_socket( FREERTOS_AF_INET, FREERTOS_SOCK_DGRAM, FREERTOS_IPPROTO_UDP );
 800ef6e:	2002      	movs	r0, #2
 800ef70:	2102      	movs	r1, #2
 800ef72:	2211      	movs	r2, #17
 800ef74:	f7f9 ff36 	bl	8008de4 <FreeRTOS_socket>
 800ef78:	4602      	mov	r2, r0
 800ef7a:	4b4f      	ldr	r3, [pc, #316]	; (800f0b8 <prvLoggingTask+0x16c>)
 800ef7c:	601a      	str	r2, [r3, #0]
	} while( xUDPLoggingSocket == FREERTOS_INVALID_SOCKET );
 800ef7e:	4b4e      	ldr	r3, [pc, #312]	; (800f0b8 <prvLoggingTask+0x16c>)
 800ef80:	681b      	ldr	r3, [r3, #0]
 800ef82:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800ef86:	d0ef      	beq.n	800ef68 <prvLoggingTask+0x1c>

	xLocalAddress.sin_port = FreeRTOS_htons( configUDP_LOGGING_PORT_LOCAL );
 800ef88:	f64d 3305 	movw	r3, #56069	; 0xdb05
 800ef8c:	837b      	strh	r3, [r7, #26]
	xLocalAddress.sin_addr = FreeRTOS_GetIPAddress();
 800ef8e:	f7f9 fab9 	bl	8008504 <FreeRTOS_GetIPAddress>
 800ef92:	4603      	mov	r3, r0
 800ef94:	61fb      	str	r3, [r7, #28]

	FreeRTOS_bind( xUDPLoggingSocket, &xLocalAddress, sizeof( xLocalAddress ) );
 800ef96:	4b48      	ldr	r3, [pc, #288]	; (800f0b8 <prvLoggingTask+0x16c>)
 800ef98:	681a      	ldr	r2, [r3, #0]
 800ef9a:	f107 0318 	add.w	r3, r7, #24
 800ef9e:	4610      	mov	r0, r2
 800efa0:	4619      	mov	r1, r3
 800efa2:	2208      	movs	r2, #8
 800efa4:	f7fa f856 	bl	8009054 <FreeRTOS_bind>

	xSendTimeOut = xBlockingTime;
 800efa8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800efaa:	60fb      	str	r3, [r7, #12]
	FreeRTOS_setsockopt( xUDPLoggingSocket, 0, FREERTOS_SO_SNDTIMEO, &xSendTimeOut, sizeof( xSendTimeOut ) );
 800efac:	4b42      	ldr	r3, [pc, #264]	; (800f0b8 <prvLoggingTask+0x16c>)
 800efae:	681a      	ldr	r2, [r3, #0]
 800efb0:	f107 040c 	add.w	r4, r7, #12
 800efb4:	2304      	movs	r3, #4
 800efb6:	9300      	str	r3, [sp, #0]
 800efb8:	4610      	mov	r0, r2
 800efba:	2100      	movs	r1, #0
 800efbc:	2201      	movs	r2, #1
 800efbe:	4623      	mov	r3, r4
 800efc0:	f7fa f9f4 	bl	80093ac <FreeRTOS_setsockopt>

	/* Send a dummy message to resolve the IP address before sending the logging 
	messages. */
	snprintf( cLoggingLine, configUDP_LOGGING_STRING_LENGTH, "Logging Probe\n" );
 800efc4:	483d      	ldr	r0, [pc, #244]	; (800f0bc <prvLoggingTask+0x170>)
 800efc6:	21c8      	movs	r1, #200	; 0xc8
 800efc8:	4a3d      	ldr	r2, [pc, #244]	; (800f0c0 <prvLoggingTask+0x174>)
 800efca:	f7ff fdab 	bl	800eb24 <snprintf>
	FreeRTOS_sendto( xUDPLoggingSocket, ( void * ) cLoggingLine, strlen( cLoggingLine ), 0, &xRemoteAddress, sizeof( xRemoteAddress ) );
 800efce:	4b3a      	ldr	r3, [pc, #232]	; (800f0b8 <prvLoggingTask+0x16c>)
 800efd0:	681c      	ldr	r4, [r3, #0]
 800efd2:	483a      	ldr	r0, [pc, #232]	; (800f0bc <prvLoggingTask+0x170>)
 800efd4:	f003 f9f8 	bl	80123c8 <strlen>
 800efd8:	4602      	mov	r2, r0
 800efda:	f107 0310 	add.w	r3, r7, #16
 800efde:	9300      	str	r3, [sp, #0]
 800efe0:	2308      	movs	r3, #8
 800efe2:	9301      	str	r3, [sp, #4]
 800efe4:	4620      	mov	r0, r4
 800efe6:	4935      	ldr	r1, [pc, #212]	; (800f0bc <prvLoggingTask+0x170>)
 800efe8:	2300      	movs	r3, #0
 800efea:	f7f9 ff95 	bl	8008f18 <FreeRTOS_sendto>
	vTaskDelay( xResolveDelay );
 800efee:	6a38      	ldr	r0, [r7, #32]
 800eff0:	f7f6 f90a 	bl	8005208 <vTaskDelay>

	for( ;; )
	{
		/* Wait for another message to be placed into the stream buffer. */
		ulTaskNotifyTake( pdTRUE, xBlockingTime );
 800eff4:	2001      	movs	r0, #1
 800eff6:	6a79      	ldr	r1, [r7, #36]	; 0x24
 800eff8:	f7f7 f866 	bl	80060c8 <ulTaskNotifyTake>

		if( xGetPhyLinkStatus() != pdFALSE )
 800effc:	f7f8 f9f0 	bl	80073e0 <xGetPhyLinkStatus>
 800f000:	4603      	mov	r3, r0
 800f002:	2b00      	cmp	r3, #0
 800f004:	d054      	beq.n	800f0b0 <prvLoggingTask+0x164>
		{
			/* Check for messages in the buffer. */
			for( lLines = 0; lLines < configUDP_LOGGING_MAX_MESSAGES_IN_BUFFER; lLines++ )
 800f006:	2300      	movs	r3, #0
 800f008:	637b      	str	r3, [r7, #52]	; 0x34
 800f00a:	e04e      	b.n	800f0aa <prvLoggingTask+0x15e>
			{
				xCount = prvGetMessageFromStreamBuffer ( cLoggingLine, sizeof( cLoggingLine ) );
 800f00c:	482b      	ldr	r0, [pc, #172]	; (800f0bc <prvLoggingTask+0x170>)
 800f00e:	21c8      	movs	r1, #200	; 0xc8
 800f010:	f7ff fe64 	bl	800ecdc <prvGetMessageFromStreamBuffer>
 800f014:	6338      	str	r0, [r7, #48]	; 0x30

				if( xCount <= 0 )
 800f016:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f018:	2b00      	cmp	r3, #0
 800f01a:	d100      	bne.n	800f01e <prvLoggingTask+0xd2>
				{
					break;
 800f01c:	e048      	b.n	800f0b0 <prvLoggingTask+0x164>
				const char *pcSource;

					/* Within the code, a single "\n" is used to denote	a
					newline.  If 'configUDP_LOGGING_NEEDS_CR_LF' is defined as non-zero,
					every "\n" will be translated into a "\r\n". */
					pcTarget = cLoggingLine;
 800f01e:	4b27      	ldr	r3, [pc, #156]	; (800f0bc <prvLoggingTask+0x170>)
 800f020:	62fb      	str	r3, [r7, #44]	; 0x2c
					pcSource = cLoggingLine;
 800f022:	4b26      	ldr	r3, [pc, #152]	; (800f0bc <prvLoggingTask+0x170>)
 800f024:	62bb      	str	r3, [r7, #40]	; 0x28

					while( ( *pcSource != 0x00 ) && ( pcSource < ( cLoggingLine + xCount ) ) )
 800f026:	e026      	b.n	800f076 <prvLoggingTask+0x12a>
					{
						*pcTarget = *pcSource;
 800f028:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f02a:	781a      	ldrb	r2, [r3, #0]
 800f02c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f02e:	701a      	strb	r2, [r3, #0]

						if( ( ( pcSource == cLoggingLine ) || ( pcSource[ -1 ] != logASCII_CR ) ) && ( pcSource[ 0 ] == logASCII_NL ) )
 800f030:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f032:	4a22      	ldr	r2, [pc, #136]	; (800f0bc <prvLoggingTask+0x170>)
 800f034:	4293      	cmp	r3, r2
 800f036:	d004      	beq.n	800f042 <prvLoggingTask+0xf6>
 800f038:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f03a:	3b01      	subs	r3, #1
 800f03c:	781b      	ldrb	r3, [r3, #0]
 800f03e:	2b0d      	cmp	r3, #13
 800f040:	d013      	beq.n	800f06a <prvLoggingTask+0x11e>
 800f042:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f044:	781b      	ldrb	r3, [r3, #0]
 800f046:	2b0a      	cmp	r3, #10
 800f048:	d10f      	bne.n	800f06a <prvLoggingTask+0x11e>
						{
							pcTarget[ 0 ] = logASCII_CR;
 800f04a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f04c:	220d      	movs	r2, #13
 800f04e:	701a      	strb	r2, [r3, #0]
							pcTarget[ 1 ] = logASCII_NL;
 800f050:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f052:	3301      	adds	r3, #1
 800f054:	220a      	movs	r2, #10
 800f056:	701a      	strb	r2, [r3, #0]

							if( xCount < ( sizeof( cLoggingLine ) - 1 ) )
 800f058:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f05a:	2bc6      	cmp	r3, #198	; 0xc6
 800f05c:	d805      	bhi.n	800f06a <prvLoggingTask+0x11e>
							{
								xCount++;
 800f05e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f060:	3301      	adds	r3, #1
 800f062:	633b      	str	r3, [r7, #48]	; 0x30
								pcTarget++;
 800f064:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f066:	3301      	adds	r3, #1
 800f068:	62fb      	str	r3, [r7, #44]	; 0x2c
							}
						}

						pcTarget++;
 800f06a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800f06c:	3301      	adds	r3, #1
 800f06e:	62fb      	str	r3, [r7, #44]	; 0x2c
						pcSource++;
 800f070:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f072:	3301      	adds	r3, #1
 800f074:	62bb      	str	r3, [r7, #40]	; 0x28
					newline.  If 'configUDP_LOGGING_NEEDS_CR_LF' is defined as non-zero,
					every "\n" will be translated into a "\r\n". */
					pcTarget = cLoggingLine;
					pcSource = cLoggingLine;

					while( ( *pcSource != 0x00 ) && ( pcSource < ( cLoggingLine + xCount ) ) )
 800f076:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f078:	781b      	ldrb	r3, [r3, #0]
 800f07a:	2b00      	cmp	r3, #0
 800f07c:	d005      	beq.n	800f08a <prvLoggingTask+0x13e>
 800f07e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800f080:	4a0e      	ldr	r2, [pc, #56]	; (800f0bc <prvLoggingTask+0x170>)
 800f082:	441a      	add	r2, r3
 800f084:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800f086:	429a      	cmp	r2, r3
 800f088:	d8ce      	bhi.n	800f028 <prvLoggingTask+0xdc>
						pcSource++;
					}
				}
				#endif

				FreeRTOS_sendto( xUDPLoggingSocket, ( void * ) cLoggingLine, xCount, 0, &xRemoteAddress, sizeof( xRemoteAddress ) );
 800f08a:	4b0b      	ldr	r3, [pc, #44]	; (800f0b8 <prvLoggingTask+0x16c>)
 800f08c:	681a      	ldr	r2, [r3, #0]
 800f08e:	f107 0310 	add.w	r3, r7, #16
 800f092:	9300      	str	r3, [sp, #0]
 800f094:	2308      	movs	r3, #8
 800f096:	9301      	str	r3, [sp, #4]
 800f098:	4610      	mov	r0, r2
 800f09a:	4908      	ldr	r1, [pc, #32]	; (800f0bc <prvLoggingTask+0x170>)
 800f09c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800f09e:	2300      	movs	r3, #0
 800f0a0:	f7f9 ff3a 	bl	8008f18 <FreeRTOS_sendto>
		ulTaskNotifyTake( pdTRUE, xBlockingTime );

		if( xGetPhyLinkStatus() != pdFALSE )
		{
			/* Check for messages in the buffer. */
			for( lLines = 0; lLines < configUDP_LOGGING_MAX_MESSAGES_IN_BUFFER; lLines++ )
 800f0a4:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f0a6:	3301      	adds	r3, #1
 800f0a8:	637b      	str	r3, [r7, #52]	; 0x34
 800f0aa:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800f0ac:	2b13      	cmp	r3, #19
 800f0ae:	ddad      	ble.n	800f00c <prvLoggingTask+0xc0>
				#endif

				FreeRTOS_sendto( xUDPLoggingSocket, ( void * ) cLoggingLine, xCount, 0, &xRemoteAddress, sizeof( xRemoteAddress ) );
			}
		}
	}
 800f0b0:	e7a0      	b.n	800eff4 <prvLoggingTask+0xa8>
 800f0b2:	bf00      	nop
 800f0b4:	6400a8c0 	.word	0x6400a8c0
 800f0b8:	2000bb54 	.word	0x2000bb54
 800f0bc:	2000c410 	.word	0x2000c410
 800f0c0:	08012864 	.word	0x08012864

0800f0c4 <SCB_EnableICache>:
/**
  \brief   Enable I-Cache
  \details Turns on I-Cache
  */
__STATIC_INLINE void SCB_EnableICache (void)
{
 800f0c4:	b480      	push	{r7}
 800f0c6:	af00      	add	r7, sp, #0
 800f0c8:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 800f0cc:	f3bf 8f6f 	isb	sy
  #if (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 800f0d0:	4b08      	ldr	r3, [pc, #32]	; (800f0f4 <SCB_EnableICache+0x30>)
 800f0d2:	2200      	movs	r2, #0
 800f0d4:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 800f0d8:	4a06      	ldr	r2, [pc, #24]	; (800f0f4 <SCB_EnableICache+0x30>)
 800f0da:	4b06      	ldr	r3, [pc, #24]	; (800f0f4 <SCB_EnableICache+0x30>)
 800f0dc:	695b      	ldr	r3, [r3, #20]
 800f0de:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800f0e2:	6153      	str	r3, [r2, #20]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800f0e4:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 800f0e8:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
  #endif
}
 800f0ec:	46bd      	mov	sp, r7
 800f0ee:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f0f2:	4770      	bx	lr
 800f0f4:	e000ed00 	.word	0xe000ed00

0800f0f8 <SCB_EnableDCache>:
/**
  \brief   Enable D-Cache
  \details Turns on D-Cache
  */
__STATIC_INLINE void SCB_EnableDCache (void)
{
 800f0f8:	b480      	push	{r7}
 800f0fa:	b085      	sub	sp, #20
 800f0fc:	af00      	add	r7, sp, #0
  #if (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
 800f0fe:	4b1d      	ldr	r3, [pc, #116]	; (800f174 <SCB_EnableDCache+0x7c>)
 800f100:	2200      	movs	r2, #0
 800f102:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800f106:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 800f10a:	4b1a      	ldr	r3, [pc, #104]	; (800f174 <SCB_EnableDCache+0x7c>)
 800f10c:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 800f110:	607b      	str	r3, [r7, #4]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 800f112:	687a      	ldr	r2, [r7, #4]
 800f114:	4b18      	ldr	r3, [pc, #96]	; (800f178 <SCB_EnableDCache+0x80>)
 800f116:	4013      	ands	r3, r2
 800f118:	0b5b      	lsrs	r3, r3, #13
 800f11a:	60fb      	str	r3, [r7, #12]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 800f11c:	687a      	ldr	r2, [r7, #4]
 800f11e:	f641 73f8 	movw	r3, #8184	; 0x1ff8
 800f122:	4013      	ands	r3, r2
 800f124:	08db      	lsrs	r3, r3, #3
 800f126:	60bb      	str	r3, [r7, #8]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 800f128:	4912      	ldr	r1, [pc, #72]	; (800f174 <SCB_EnableDCache+0x7c>)
 800f12a:	68fb      	ldr	r3, [r7, #12]
 800f12c:	015a      	lsls	r2, r3, #5
 800f12e:	f643 73e0 	movw	r3, #16352	; 0x3fe0
 800f132:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
 800f134:	68ba      	ldr	r2, [r7, #8]
 800f136:	0792      	lsls	r2, r2, #30
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 800f138:	4313      	orrs	r3, r2
 800f13a:	f8c1 3260 	str.w	r3, [r1, #608]	; 0x260
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways--);
 800f13e:	68bb      	ldr	r3, [r7, #8]
 800f140:	1e5a      	subs	r2, r3, #1
 800f142:	60ba      	str	r2, [r7, #8]
 800f144:	2b00      	cmp	r3, #0
 800f146:	d1ef      	bne.n	800f128 <SCB_EnableDCache+0x30>
    } while(sets--);
 800f148:	68fb      	ldr	r3, [r7, #12]
 800f14a:	1e5a      	subs	r2, r3, #1
 800f14c:	60fa      	str	r2, [r7, #12]
 800f14e:	2b00      	cmp	r3, #0
 800f150:	d1e4      	bne.n	800f11c <SCB_EnableDCache+0x24>
 800f152:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 800f156:	4a07      	ldr	r2, [pc, #28]	; (800f174 <SCB_EnableDCache+0x7c>)
 800f158:	4b06      	ldr	r3, [pc, #24]	; (800f174 <SCB_EnableDCache+0x7c>)
 800f15a:	695b      	ldr	r3, [r3, #20]
 800f15c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800f160:	6153      	str	r3, [r2, #20]
 800f162:	f3bf 8f4f 	dsb	sy
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 800f166:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
  #endif
}
 800f16a:	3714      	adds	r7, #20
 800f16c:	46bd      	mov	sp, r7
 800f16e:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f172:	4770      	bx	lr
 800f174:	e000ed00 	.word	0xe000ed00
 800f178:	0fffe000 	.word	0x0fffe000

0800f17c <blink_task>:


/* Private functions ---------------------------------------------------------*/

void blink_task(void *pvParameters)
{
 800f17c:	b580      	push	{r7, lr}
 800f17e:	b082      	sub	sp, #8
 800f180:	af00      	add	r7, sp, #0
 800f182:	6078      	str	r0, [r7, #4]
	/*just to remove compiler warning*/
	(void) pvParameters;
	while(1){
		BSP_LED_Toggle(LED2);	// Debugging, watch Calculation Time
 800f184:	2001      	movs	r0, #1
 800f186:	f001 fb9f 	bl	80108c8 <BSP_LED_Toggle>
		vTaskDelay(200);
 800f18a:	20c8      	movs	r0, #200	; 0xc8
 800f18c:	f7f6 f83c 	bl	8005208 <vTaskDelay>
	}
 800f190:	e7f8      	b.n	800f184 <blink_task+0x8>
 800f192:	bf00      	nop

0800f194 <main>:
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
 800f194:	b580      	push	{r7, lr}
 800f196:	b082      	sub	sp, #8
 800f198:	af02      	add	r7, sp, #8
  /* Enable the CPU Cache */
  CPU_CACHE_Enable();
 800f19a:	f000 ff7d 	bl	8010098 <CPU_CACHE_Enable>
       - Configure the Flash ART accelerator on ITCM interface
       - Configure the Systick to generate an interrupt each 1 msec
       - Set NVIC Group Priority to 4
       - Global MSP (MCU Support Package) initialization
     */
  HAL_Init();
 800f19e:	f7f1 fb0d 	bl	80007bc <HAL_Init>

    /* Configure the system clock to 200 MHz */
  SystemClock_Config(); 
 800f1a2:	f000 fa8b 	bl	800f6bc <SystemClock_Config>
  
  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 800f1a6:	f000 fb89 	bl	800f8bc <MX_GPIO_Init>
  MX_RTC_Init();  
 800f1aa:	f000 fb1f 	bl	800f7ec <MX_RTC_Init>
  MX_FMC_Init();
 800f1ae:	f000 fb41 	bl	800f834 <MX_FMC_Init>
  
  SEGGER_SYSVIEW_Conf();
 800f1b2:	f001 fb41 	bl	8010838 <SEGGER_SYSVIEW_Conf>

  /* Miscellaneous initialisation including preparing the logging and seeding
  the random number generator. */
  prvMiscInitialisation();
 800f1b6:	f000 f839 	bl	800f22c <prvMiscInitialisation>
  ***NOTE*** Tasks that use the network are created in the network event hook
  when the network is connected and ready for use (see the definition of
  vApplicationIPNetworkEventHook() below).  The address values passed in here
  are used if ipconfigUSE_DHCP is set to 0, or if ipconfigUSE_DHCP is set to 1
  but a DHCP server cannot be	contacted. */
  FreeRTOS_printf( ( "FreeRTOS_IPInit\n" ) );
 800f1ba:	4812      	ldr	r0, [pc, #72]	; (800f204 <main+0x70>)
 800f1bc:	f7ff fe94 	bl	800eee8 <lUDPLoggingPrintf>
  FreeRTOS_IPInit( ucIPAddress, ucNetMask, ucGatewayAddress, ucDNSServerAddress, ucMACAddress );
 800f1c0:	4b11      	ldr	r3, [pc, #68]	; (800f208 <main+0x74>)
 800f1c2:	9300      	str	r3, [sp, #0]
 800f1c4:	4811      	ldr	r0, [pc, #68]	; (800f20c <main+0x78>)
 800f1c6:	4912      	ldr	r1, [pc, #72]	; (800f210 <main+0x7c>)
 800f1c8:	4a12      	ldr	r2, [pc, #72]	; (800f214 <main+0x80>)
 800f1ca:	4b13      	ldr	r3, [pc, #76]	; (800f218 <main+0x84>)
 800f1cc:	f7f8 fdae 	bl	8007d2c <FreeRTOS_IPInit>




  xTaskCreate(blink_task, "Blink_task", configMINIMAL_STACK_SIZE*2, NULL, 1, ( TaskHandle_t * )NULL);
 800f1d0:	2301      	movs	r3, #1
 800f1d2:	9300      	str	r3, [sp, #0]
 800f1d4:	2300      	movs	r3, #0
 800f1d6:	9301      	str	r3, [sp, #4]
 800f1d8:	4810      	ldr	r0, [pc, #64]	; (800f21c <main+0x88>)
 800f1da:	4911      	ldr	r1, [pc, #68]	; (800f220 <main+0x8c>)
 800f1dc:	f44f 7280 	mov.w	r2, #256	; 0x100
 800f1e0:	2300      	movs	r3, #0
 800f1e2:	f7f5 fea9 	bl	8004f38 <xTaskCreate>
  xTaskCreate(BSP_Config_task, "BSP_Config", configMINIMAL_STACK_SIZE*2, NULL, 1, ( TaskHandle_t * )NULL);
 800f1e6:	2301      	movs	r3, #1
 800f1e8:	9300      	str	r3, [sp, #0]
 800f1ea:	2300      	movs	r3, #0
 800f1ec:	9301      	str	r3, [sp, #4]
 800f1ee:	480d      	ldr	r0, [pc, #52]	; (800f224 <main+0x90>)
 800f1f0:	490d      	ldr	r1, [pc, #52]	; (800f228 <main+0x94>)
 800f1f2:	f44f 7280 	mov.w	r2, #256	; 0x100
 800f1f6:	2300      	movs	r3, #0
 800f1f8:	f7f5 fe9e 	bl	8004f38 <xTaskCreate>

  //BSP_Config();
  vTaskStartScheduler();
 800f1fc:	f7f6 f8ce 	bl	800539c <vTaskStartScheduler>

  
  /* We should never get here as control is now taken by the scheduler */
  for( ;; );
 800f200:	e7fe      	b.n	800f200 <main+0x6c>
 800f202:	bf00      	nop
 800f204:	08012874 	.word	0x08012874
 800f208:	08012a5c 	.word	0x08012a5c
 800f20c:	08012a4c 	.word	0x08012a4c
 800f210:	08012a50 	.word	0x08012a50
 800f214:	08012a54 	.word	0x08012a54
 800f218:	08012a58 	.word	0x08012a58
 800f21c:	0800f17d 	.word	0x0800f17d
 800f220:	08012888 	.word	0x08012888
 800f224:	0800f699 	.word	0x0800f699
 800f228:	08012894 	.word	0x08012894

0800f22c <prvMiscInitialisation>:
}


static void prvMiscInitialisation( void )
{
 800f22c:	b580      	push	{r7, lr}
 800f22e:	af00      	add	r7, sp, #0
	/* Heap_5 is used so the maximum heap size available can be calculated and
	configured at run time. */
	prvInitialiseHeap();
 800f230:	f000 f93a 	bl	800f4a8 <prvInitialiseHeap>

	/* Timer2 initialization function.
	ullGetHighResolutionTime() will be used to get the running time in uS. */
	vStartHighResolutionTimer();
 800f234:	f001 f8e8 	bl	8010408 <vStartHighResolutionTimer>
}
 800f238:	bd80      	pop	{r7, pc}
 800f23a:	bf00      	nop

0800f23c <vApplicationIdleHook>:

void vApplicationIdleHook( void )
{
 800f23c:	b580      	push	{r7, lr}
 800f23e:	b082      	sub	sp, #8
 800f240:	af00      	add	r7, sp, #0
const TickType_t xToggleRate = pdMS_TO_TICKS( 1000UL );
 800f242:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800f246:	607b      	str	r3, [r7, #4]
static TickType_t xLastToggle = 0, xTimeNow;

	xTimeNow = xTaskGetTickCount();
 800f248:	f7f6 f99c 	bl	8005584 <xTaskGetTickCount>
 800f24c:	4602      	mov	r2, r0
 800f24e:	4b0b      	ldr	r3, [pc, #44]	; (800f27c <vApplicationIdleHook+0x40>)
 800f250:	601a      	str	r2, [r3, #0]

	/* As there is not Timer task, toggle the LED 'manually'.  Doing this from
	the Idle task will also provide visual feedback of the processor load. */
	if( ( xTimeNow - xLastToggle ) >= xToggleRate )
 800f252:	4b0a      	ldr	r3, [pc, #40]	; (800f27c <vApplicationIdleHook+0x40>)
 800f254:	681a      	ldr	r2, [r3, #0]
 800f256:	4b0a      	ldr	r3, [pc, #40]	; (800f280 <vApplicationIdleHook+0x44>)
 800f258:	681b      	ldr	r3, [r3, #0]
 800f25a:	1ad2      	subs	r2, r2, r3
 800f25c:	687b      	ldr	r3, [r7, #4]
 800f25e:	429a      	cmp	r2, r3
 800f260:	d308      	bcc.n	800f274 <vApplicationIdleHook+0x38>
	{
		BSP_LED_Toggle(LED1);
 800f262:	2000      	movs	r0, #0
 800f264:	f001 fb30 	bl	80108c8 <BSP_LED_Toggle>
		xLastToggle += xToggleRate;
 800f268:	4b05      	ldr	r3, [pc, #20]	; (800f280 <vApplicationIdleHook+0x44>)
 800f26a:	681a      	ldr	r2, [r3, #0]
 800f26c:	687b      	ldr	r3, [r7, #4]
 800f26e:	4413      	add	r3, r2
 800f270:	4a03      	ldr	r2, [pc, #12]	; (800f280 <vApplicationIdleHook+0x44>)
 800f272:	6013      	str	r3, [r2, #0]
	}
}
 800f274:	3708      	adds	r7, #8
 800f276:	46bd      	mov	sp, r7
 800f278:	bd80      	pop	{r7, pc}
 800f27a:	bf00      	nop
 800f27c:	2000c4dc 	.word	0x2000c4dc
 800f280:	2000c4e0 	.word	0x2000c4e0

0800f284 <vApplicationIPNetworkEventHook>:

/* Called by FreeRTOS+TCP when the network connects or disconnects.  Disconnect
events are only received if implemented in the MAC driver. */
void vApplicationIPNetworkEventHook( eIPCallbackEvent_t eNetworkEvent )
{
 800f284:	b5b0      	push	{r4, r5, r7, lr}
 800f286:	b08c      	sub	sp, #48	; 0x30
 800f288:	af02      	add	r7, sp, #8
 800f28a:	4603      	mov	r3, r0
 800f28c:	71fb      	strb	r3, [r7, #7]
uint32_t ulIPAddress, ulNetMask, ulGatewayAddress, ulDNSServerAddress;
char cBuffer[ 16 ];
static BaseType_t xTasksAlreadyCreated = pdFALSE;

	FreeRTOS_printf( ( "vApplicationIPNetworkEventHook: event %ld\n", eNetworkEvent ) );
 800f28e:	79fb      	ldrb	r3, [r7, #7]
 800f290:	4842      	ldr	r0, [pc, #264]	; (800f39c <vApplicationIPNetworkEventHook+0x118>)
 800f292:	4619      	mov	r1, r3
 800f294:	f7ff fe28 	bl	800eee8 <lUDPLoggingPrintf>

	/* If the network has just come up...*/
	if( eNetworkEvent == eNetworkUp )
 800f298:	79fb      	ldrb	r3, [r7, #7]
 800f29a:	2b00      	cmp	r3, #0
 800f29c:	d17a      	bne.n	800f394 <vApplicationIPNetworkEventHook+0x110>
	{
		/* Create the tasks that use the IP stack if they have not already been
		created. */
		if( xTasksAlreadyCreated == pdFALSE )
 800f29e:	4b40      	ldr	r3, [pc, #256]	; (800f3a0 <vApplicationIPNetworkEventHook+0x11c>)
 800f2a0:	681b      	ldr	r3, [r3, #0]
 800f2a2:	2b00      	cmp	r3, #0
 800f2a4:	d104      	bne.n	800f2b0 <vApplicationIPNetworkEventHook+0x2c>
			/* Tasks that use the TCP/IP stack can be created here. */

			/* Start a new task to fetch logging lines and send them out. */
			#if( mainCREATE_UDP_LOGGING_TASK == 1 )
			{
				vUDPLoggingTaskCreate();
 800f2a6:	f7ff fe3b 	bl	800ef20 <vUDPLoggingTaskCreate>
				vRegisterTCPCLICommands();
				vStartUDPCommandInterpreterTask( mainUDP_CLI_TASK_STACK_SIZE, mainUDP_CLI_PORT_NUMBER, mainUDP_CLI_TASK_PRIORITY );
			}
			#endif

			xTasksAlreadyCreated = pdTRUE;
 800f2aa:	4b3d      	ldr	r3, [pc, #244]	; (800f3a0 <vApplicationIPNetworkEventHook+0x11c>)
 800f2ac:	2201      	movs	r2, #1
 800f2ae:	601a      	str	r2, [r3, #0]
		}

		/* Print out the network configuration, which may have come from a DHCP
		server. */
		FreeRTOS_GetAddressConfiguration( &ulIPAddress, &ulNetMask, &ulGatewayAddress, &ulDNSServerAddress );
 800f2b0:	f107 0024 	add.w	r0, r7, #36	; 0x24
 800f2b4:	f107 0120 	add.w	r1, r7, #32
 800f2b8:	f107 021c 	add.w	r2, r7, #28
 800f2bc:	f107 0318 	add.w	r3, r7, #24
 800f2c0:	f7f8 fe34 	bl	8007f2c <FreeRTOS_GetAddressConfiguration>
		FreeRTOS_inet_ntoa( ulIPAddress, cBuffer );
 800f2c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f2c6:	b2dd      	uxtb	r5, r3
 800f2c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f2ca:	0a1b      	lsrs	r3, r3, #8
 800f2cc:	b2dc      	uxtb	r4, r3
 800f2ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f2d0:	0c1b      	lsrs	r3, r3, #16
 800f2d2:	b2da      	uxtb	r2, r3
 800f2d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800f2d6:	0e1b      	lsrs	r3, r3, #24
 800f2d8:	f107 0108 	add.w	r1, r7, #8
 800f2dc:	9200      	str	r2, [sp, #0]
 800f2de:	9301      	str	r3, [sp, #4]
 800f2e0:	4608      	mov	r0, r1
 800f2e2:	4930      	ldr	r1, [pc, #192]	; (800f3a4 <vApplicationIPNetworkEventHook+0x120>)
 800f2e4:	462a      	mov	r2, r5
 800f2e6:	4623      	mov	r3, r4
 800f2e8:	f7ff fc3e 	bl	800eb68 <sprintf>
		FreeRTOS_printf( ( "IP Address: %s\n", cBuffer ) );
 800f2ec:	f107 0308 	add.w	r3, r7, #8
 800f2f0:	482d      	ldr	r0, [pc, #180]	; (800f3a8 <vApplicationIPNetworkEventHook+0x124>)
 800f2f2:	4619      	mov	r1, r3
 800f2f4:	f7ff fdf8 	bl	800eee8 <lUDPLoggingPrintf>

		FreeRTOS_inet_ntoa( ulNetMask, cBuffer );
 800f2f8:	6a3b      	ldr	r3, [r7, #32]
 800f2fa:	b2dd      	uxtb	r5, r3
 800f2fc:	6a3b      	ldr	r3, [r7, #32]
 800f2fe:	0a1b      	lsrs	r3, r3, #8
 800f300:	b2dc      	uxtb	r4, r3
 800f302:	6a3b      	ldr	r3, [r7, #32]
 800f304:	0c1b      	lsrs	r3, r3, #16
 800f306:	b2da      	uxtb	r2, r3
 800f308:	6a3b      	ldr	r3, [r7, #32]
 800f30a:	0e1b      	lsrs	r3, r3, #24
 800f30c:	f107 0108 	add.w	r1, r7, #8
 800f310:	9200      	str	r2, [sp, #0]
 800f312:	9301      	str	r3, [sp, #4]
 800f314:	4608      	mov	r0, r1
 800f316:	4923      	ldr	r1, [pc, #140]	; (800f3a4 <vApplicationIPNetworkEventHook+0x120>)
 800f318:	462a      	mov	r2, r5
 800f31a:	4623      	mov	r3, r4
 800f31c:	f7ff fc24 	bl	800eb68 <sprintf>
		FreeRTOS_printf( ( "Subnet Mask: %s\n", cBuffer ) );
 800f320:	f107 0308 	add.w	r3, r7, #8
 800f324:	4821      	ldr	r0, [pc, #132]	; (800f3ac <vApplicationIPNetworkEventHook+0x128>)
 800f326:	4619      	mov	r1, r3
 800f328:	f7ff fdde 	bl	800eee8 <lUDPLoggingPrintf>

		FreeRTOS_inet_ntoa( ulGatewayAddress, cBuffer );
 800f32c:	69fb      	ldr	r3, [r7, #28]
 800f32e:	b2dd      	uxtb	r5, r3
 800f330:	69fb      	ldr	r3, [r7, #28]
 800f332:	0a1b      	lsrs	r3, r3, #8
 800f334:	b2dc      	uxtb	r4, r3
 800f336:	69fb      	ldr	r3, [r7, #28]
 800f338:	0c1b      	lsrs	r3, r3, #16
 800f33a:	b2da      	uxtb	r2, r3
 800f33c:	69fb      	ldr	r3, [r7, #28]
 800f33e:	0e1b      	lsrs	r3, r3, #24
 800f340:	f107 0108 	add.w	r1, r7, #8
 800f344:	9200      	str	r2, [sp, #0]
 800f346:	9301      	str	r3, [sp, #4]
 800f348:	4608      	mov	r0, r1
 800f34a:	4916      	ldr	r1, [pc, #88]	; (800f3a4 <vApplicationIPNetworkEventHook+0x120>)
 800f34c:	462a      	mov	r2, r5
 800f34e:	4623      	mov	r3, r4
 800f350:	f7ff fc0a 	bl	800eb68 <sprintf>
		FreeRTOS_printf( ( "Gateway Address: %s\n", cBuffer ) );
 800f354:	f107 0308 	add.w	r3, r7, #8
 800f358:	4815      	ldr	r0, [pc, #84]	; (800f3b0 <vApplicationIPNetworkEventHook+0x12c>)
 800f35a:	4619      	mov	r1, r3
 800f35c:	f7ff fdc4 	bl	800eee8 <lUDPLoggingPrintf>

		FreeRTOS_inet_ntoa( ulDNSServerAddress, cBuffer );
 800f360:	69bb      	ldr	r3, [r7, #24]
 800f362:	b2dd      	uxtb	r5, r3
 800f364:	69bb      	ldr	r3, [r7, #24]
 800f366:	0a1b      	lsrs	r3, r3, #8
 800f368:	b2dc      	uxtb	r4, r3
 800f36a:	69bb      	ldr	r3, [r7, #24]
 800f36c:	0c1b      	lsrs	r3, r3, #16
 800f36e:	b2da      	uxtb	r2, r3
 800f370:	69bb      	ldr	r3, [r7, #24]
 800f372:	0e1b      	lsrs	r3, r3, #24
 800f374:	f107 0108 	add.w	r1, r7, #8
 800f378:	9200      	str	r2, [sp, #0]
 800f37a:	9301      	str	r3, [sp, #4]
 800f37c:	4608      	mov	r0, r1
 800f37e:	4909      	ldr	r1, [pc, #36]	; (800f3a4 <vApplicationIPNetworkEventHook+0x120>)
 800f380:	462a      	mov	r2, r5
 800f382:	4623      	mov	r3, r4
 800f384:	f7ff fbf0 	bl	800eb68 <sprintf>
		FreeRTOS_printf( ( "DNS Server Address: %s\n", cBuffer ) );
 800f388:	f107 0308 	add.w	r3, r7, #8
 800f38c:	4809      	ldr	r0, [pc, #36]	; (800f3b4 <vApplicationIPNetworkEventHook+0x130>)
 800f38e:	4619      	mov	r1, r3
 800f390:	f7ff fdaa 	bl	800eee8 <lUDPLoggingPrintf>
	}
}
 800f394:	3728      	adds	r7, #40	; 0x28
 800f396:	46bd      	mov	sp, r7
 800f398:	bdb0      	pop	{r4, r5, r7, pc}
 800f39a:	bf00      	nop
 800f39c:	080128a0 	.word	0x080128a0
 800f3a0:	2000c4e4 	.word	0x2000c4e4
 800f3a4:	080128cc 	.word	0x080128cc
 800f3a8:	080128d8 	.word	0x080128d8
 800f3ac:	080128e8 	.word	0x080128e8
 800f3b0:	080128fc 	.word	0x080128fc
 800f3b4:	08012914 	.word	0x08012914

0800f3b8 <vApplicationMallocFailedHook>:
/*-----------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
 800f3b8:	b480      	push	{r7}
 800f3ba:	b083      	sub	sp, #12
 800f3bc:	af00      	add	r7, sp, #0
volatile uint32_t ulMallocFailures = 0;
 800f3be:	2300      	movs	r3, #0
 800f3c0:	607b      	str	r3, [r7, #4]
	/* Called if a call to pvPortMalloc() fails because there is insufficient
	free memory available in the FreeRTOS heap.  pvPortMalloc() is called
	internally by FreeRTOS API functions that create tasks, queues, software
	timers, and semaphores.  The size of the FreeRTOS heap is set by the
	configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
	ulMallocFailures++;
 800f3c2:	687b      	ldr	r3, [r7, #4]
 800f3c4:	3301      	adds	r3, #1
 800f3c6:	607b      	str	r3, [r7, #4]
}
 800f3c8:	370c      	adds	r7, #12
 800f3ca:	46bd      	mov	sp, r7
 800f3cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f3d0:	4770      	bx	lr
 800f3d2:	bf00      	nop

0800f3d4 <vApplicationStackOverflowHook>:
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName )
{
 800f3d4:	b480      	push	{r7}
 800f3d6:	b085      	sub	sp, #20
 800f3d8:	af00      	add	r7, sp, #0
 800f3da:	6078      	str	r0, [r7, #4]
 800f3dc:	6039      	str	r1, [r7, #0]
 800f3de:	f04f 0350 	mov.w	r3, #80	; 0x50
 800f3e2:	f383 8811 	msr	BASEPRI, r3
 800f3e6:	f3bf 8f6f 	isb	sy
 800f3ea:	f3bf 8f4f 	dsb	sy
 800f3ee:	60fb      	str	r3, [r7, #12]

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
	for( ;; );
 800f3f0:	e7fe      	b.n	800f3f0 <vApplicationStackOverflowHook+0x1c>
 800f3f2:	bf00      	nop

0800f3f4 <uxRand>:
}
/*-----------------------------------------------------------*/

UBaseType_t uxRand( void )
{
 800f3f4:	b580      	push	{r7, lr}
 800f3f6:	b086      	sub	sp, #24
 800f3f8:	af00      	add	r7, sp, #0
const uint32_t ulMultiplier = 0x015a4e35UL, ulIncrement = 1UL;
 800f3fa:	4b1a      	ldr	r3, [pc, #104]	; (800f464 <uxRand+0x70>)
 800f3fc:	617b      	str	r3, [r7, #20]
 800f3fe:	2301      	movs	r3, #1
 800f400:	613b      	str	r3, [r7, #16]
static BaseType_t xInitialised = pdFALSE;

	/* Don't initialise until the scheduler is running, as the timeout in the
	random number generator uses the tick count. */
	if( xInitialised == pdFALSE )
 800f402:	4b19      	ldr	r3, [pc, #100]	; (800f468 <uxRand+0x74>)
 800f404:	681b      	ldr	r3, [r3, #0]
 800f406:	2b00      	cmp	r3, #0
 800f408:	d119      	bne.n	800f43e <uxRand+0x4a>
	{
		if( xTaskGetSchedulerState() !=  taskSCHEDULER_NOT_STARTED )
 800f40a:	f7f6 fd0d 	bl	8005e28 <xTaskGetSchedulerState>
 800f40e:	4603      	mov	r3, r0
 800f410:	2b01      	cmp	r3, #1
 800f412:	d014      	beq.n	800f43e <uxRand+0x4a>
		RNG_HandleTypeDef xRND;
		uint32_t ulSeed;

			/* Generate a random number with which to seed the local pseudo random
			number generating function. */
			HAL_RNG_Init( &xRND );
 800f414:	1d3b      	adds	r3, r7, #4
 800f416:	4618      	mov	r0, r3
 800f418:	f7f3 fd20 	bl	8002e5c <HAL_RNG_Init>
			HAL_RNG_MspInit(&xRND);
 800f41c:	1d3b      	adds	r3, r7, #4
 800f41e:	4618      	mov	r0, r3
 800f420:	f001 f8e8 	bl	80105f4 <HAL_RNG_MspInit>
			HAL_RNG_GenerateRandomNumber( &xRND, &ulSeed );
 800f424:	1d3a      	adds	r2, r7, #4
 800f426:	463b      	mov	r3, r7
 800f428:	4610      	mov	r0, r2
 800f42a:	4619      	mov	r1, r3
 800f42c:	f7f3 fd4a 	bl	8002ec4 <HAL_RNG_GenerateRandomNumber>
			prvSRand( ulSeed );
 800f430:	683b      	ldr	r3, [r7, #0]
 800f432:	4618      	mov	r0, r3
 800f434:	f000 f81c 	bl	800f470 <prvSRand>
			xInitialised = pdTRUE;
 800f438:	4b0b      	ldr	r3, [pc, #44]	; (800f468 <uxRand+0x74>)
 800f43a:	2201      	movs	r2, #1
 800f43c:	601a      	str	r2, [r3, #0]
		}
	}

	/* Utility function to generate a pseudo random number. */

	ulNextRand = ( ulMultiplier * ulNextRand ) + ulIncrement;
 800f43e:	4b0b      	ldr	r3, [pc, #44]	; (800f46c <uxRand+0x78>)
 800f440:	681b      	ldr	r3, [r3, #0]
 800f442:	697a      	ldr	r2, [r7, #20]
 800f444:	fb02 f203 	mul.w	r2, r2, r3
 800f448:	693b      	ldr	r3, [r7, #16]
 800f44a:	4413      	add	r3, r2
 800f44c:	4a07      	ldr	r2, [pc, #28]	; (800f46c <uxRand+0x78>)
 800f44e:	6013      	str	r3, [r2, #0]
	return( ( int ) ( ulNextRand >> 16UL ) & 0x7fffUL );
 800f450:	4b06      	ldr	r3, [pc, #24]	; (800f46c <uxRand+0x78>)
 800f452:	681b      	ldr	r3, [r3, #0]
 800f454:	0c1b      	lsrs	r3, r3, #16
 800f456:	f3c3 030e 	ubfx	r3, r3, #0, #15
}
 800f45a:	4618      	mov	r0, r3
 800f45c:	3718      	adds	r7, #24
 800f45e:	46bd      	mov	sp, r7
 800f460:	bd80      	pop	{r7, pc}
 800f462:	bf00      	nop
 800f464:	015a4e35 	.word	0x015a4e35
 800f468:	2000c4e8 	.word	0x2000c4e8
 800f46c:	2000c4d8 	.word	0x2000c4d8

0800f470 <prvSRand>:
/*-----------------------------------------------------------*/

static void prvSRand( UBaseType_t ulSeed )
{
 800f470:	b480      	push	{r7}
 800f472:	b083      	sub	sp, #12
 800f474:	af00      	add	r7, sp, #0
 800f476:	6078      	str	r0, [r7, #4]
	/* Utility function to seed the pseudo random number generator. */
	ulNextRand = ulSeed;
 800f478:	4a03      	ldr	r2, [pc, #12]	; (800f488 <prvSRand+0x18>)
 800f47a:	687b      	ldr	r3, [r7, #4]
 800f47c:	6013      	str	r3, [r2, #0]
}
 800f47e:	370c      	adds	r7, #12
 800f480:	46bd      	mov	sp, r7
 800f482:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f486:	4770      	bx	lr
 800f488:	2000c4d8 	.word	0x2000c4d8

0800f48c <vApplicationPingReplyHook>:
/*-----------------------------------------------------------*/

void vApplicationPingReplyHook( ePingReplyStatus_t eStatus, uint16_t usIdentifier )
{
 800f48c:	b480      	push	{r7}
 800f48e:	b083      	sub	sp, #12
 800f490:	af00      	add	r7, sp, #0
 800f492:	4603      	mov	r3, r0
 800f494:	460a      	mov	r2, r1
 800f496:	71fb      	strb	r3, [r7, #7]
 800f498:	4613      	mov	r3, r2
 800f49a:	80bb      	strh	r3, [r7, #4]
}
 800f49c:	370c      	adds	r7, #12
 800f49e:	46bd      	mov	sp, r7
 800f4a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f4a4:	4770      	bx	lr
 800f4a6:	bf00      	nop

0800f4a8 <prvInitialiseHeap>:
/*-----------------------------------------------------------*/

static void prvInitialiseHeap( void )
{
 800f4a8:	b580      	push	{r7, lr}
 800f4aa:	b086      	sub	sp, #24
 800f4ac:	af00      	add	r7, sp, #0
volatile uint32_t ulHeapSize;
volatile uint8_t *pucHeapStart;

	/* Heap_5 is used so the maximum heap size can be calculated and initialised
	at run time. */
	pucHeapStart = ( uint8_t * ) ( ( ( ( uint32_t ) &HEAP_START ) + 7 ) & ~0x07ul );
 800f4ae:	4b10      	ldr	r3, [pc, #64]	; (800f4f0 <prvInitialiseHeap+0x48>)
 800f4b0:	3307      	adds	r3, #7
 800f4b2:	f023 0307 	bic.w	r3, r3, #7
 800f4b6:	617b      	str	r3, [r7, #20]

	ulHeapSize = ( uint32_t ) ( &HEAP_END - &HEAP_START );
 800f4b8:	4a0e      	ldr	r2, [pc, #56]	; (800f4f4 <prvInitialiseHeap+0x4c>)
 800f4ba:	4b0d      	ldr	r3, [pc, #52]	; (800f4f0 <prvInitialiseHeap+0x48>)
 800f4bc:	1ad3      	subs	r3, r2, r3
 800f4be:	613b      	str	r3, [r7, #16]
	ulHeapSize &= ~0x07ul;
 800f4c0:	693b      	ldr	r3, [r7, #16]
 800f4c2:	f023 0307 	bic.w	r3, r3, #7
 800f4c6:	613b      	str	r3, [r7, #16]
	ulHeapSize -= 1024;
 800f4c8:	693b      	ldr	r3, [r7, #16]
 800f4ca:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
 800f4ce:	613b      	str	r3, [r7, #16]

	HeapRegion_t xHeapRegions[] =
 800f4d0:	697b      	ldr	r3, [r7, #20]
 800f4d2:	603b      	str	r3, [r7, #0]
 800f4d4:	693b      	ldr	r3, [r7, #16]
 800f4d6:	607b      	str	r3, [r7, #4]
 800f4d8:	2300      	movs	r3, #0
 800f4da:	60bb      	str	r3, [r7, #8]
 800f4dc:	2300      	movs	r3, #0
 800f4de:	60fb      	str	r3, [r7, #12]
	{
		{ ( unsigned char *) pucHeapStart, ulHeapSize },
		{ NULL, 0 }
 	};

	vPortDefineHeapRegions( xHeapRegions );
 800f4e0:	463b      	mov	r3, r7
 800f4e2:	4618      	mov	r0, r3
 800f4e4:	f7f4 ff34 	bl	8004350 <vPortDefineHeapRegions>
}
 800f4e8:	3718      	adds	r7, #24
 800f4ea:	46bd      	mov	sp, r7
 800f4ec:	bd80      	pop	{r7, pc}
 800f4ee:	bf00      	nop
 800f4f0:	2000d0b0 	.word	0x2000d0b0
 800f4f4:	20080000 	.word	0x20080000

0800f4f8 <vOutputChar>:
/*-----------------------------------------------------------*/

void vOutputChar( const char cChar, const TickType_t xTicksToWait  )
{
 800f4f8:	b480      	push	{r7}
 800f4fa:	b083      	sub	sp, #12
 800f4fc:	af00      	add	r7, sp, #0
 800f4fe:	4603      	mov	r3, r0
 800f500:	6039      	str	r1, [r7, #0]
 800f502:	71fb      	strb	r3, [r7, #7]
	/* Not doing anything - just required for printf-stdarg.c to link. */
}
 800f504:	370c      	adds	r7, #12
 800f506:	46bd      	mov	sp, r7
 800f508:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f50c:	4770      	bx	lr
 800f50e:	bf00      	nop

0800f510 <pcApplicationHostnameHook>:
/*-----------------------------------------------------------*/

const char *pcApplicationHostnameHook( void )
{
 800f510:	b480      	push	{r7}
 800f512:	af00      	add	r7, sp, #0
	/* Assign the name "rtosdemo" to this network node.  This function will be
	called during the DHCP: the machine will be registered with an IP address
	plus this name. */
	return mainHOST_NAME;
 800f514:	4b02      	ldr	r3, [pc, #8]	; (800f520 <pcApplicationHostnameHook+0x10>)
}
 800f516:	4618      	mov	r0, r3
 800f518:	46bd      	mov	sp, r7
 800f51a:	f85d 7b04 	ldr.w	r7, [sp], #4
 800f51e:	4770      	bx	lr
 800f520:	0801292c 	.word	0x0801292c

0800f524 <xApplicationDNSQueryHook>:
/*-----------------------------------------------------------*/


BaseType_t xApplicationDNSQueryHook( const char *pcName )
{
 800f524:	b580      	push	{r7, lr}
 800f526:	b084      	sub	sp, #16
 800f528:	af00      	add	r7, sp, #0
 800f52a:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	/* Determine if a name lookup is for this node.  Two names are given
	to this node: that returned by pcApplicationHostnameHook() and that set
	by mainDEVICE_NICK_NAME. */
	if( strcasecmp( pcName, pcApplicationHostnameHook() ) == 0 )
 800f52c:	f7ff fff0 	bl	800f510 <pcApplicationHostnameHook>
 800f530:	4603      	mov	r3, r0
 800f532:	6878      	ldr	r0, [r7, #4]
 800f534:	4619      	mov	r1, r3
 800f536:	f002 ff21 	bl	801237c <strcasecmp>
 800f53a:	4603      	mov	r3, r0
 800f53c:	2b00      	cmp	r3, #0
 800f53e:	d102      	bne.n	800f546 <xApplicationDNSQueryHook+0x22>
	{
		xReturn = pdPASS;
 800f540:	2301      	movs	r3, #1
 800f542:	60fb      	str	r3, [r7, #12]
 800f544:	e00b      	b.n	800f55e <xApplicationDNSQueryHook+0x3a>
	}
	else if( strcasecmp( pcName, mainDEVICE_NICK_NAME ) == 0 )
 800f546:	6878      	ldr	r0, [r7, #4]
 800f548:	4907      	ldr	r1, [pc, #28]	; (800f568 <xApplicationDNSQueryHook+0x44>)
 800f54a:	f002 ff17 	bl	801237c <strcasecmp>
 800f54e:	4603      	mov	r3, r0
 800f550:	2b00      	cmp	r3, #0
 800f552:	d102      	bne.n	800f55a <xApplicationDNSQueryHook+0x36>
	{
		xReturn = pdPASS;
 800f554:	2301      	movs	r3, #1
 800f556:	60fb      	str	r3, [r7, #12]
 800f558:	e001      	b.n	800f55e <xApplicationDNSQueryHook+0x3a>
	}
	else
	{
		xReturn = pdFAIL;
 800f55a:	2300      	movs	r3, #0
 800f55c:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
 800f55e:	68fb      	ldr	r3, [r7, #12]
}
 800f560:	4618      	mov	r0, r3
 800f562:	3710      	adds	r7, #16
 800f564:	46bd      	mov	sp, r7
 800f566:	bd80      	pop	{r7, pc}
 800f568:	08012938 	.word	0x08012938

0800f56c <xGetRunTimeCounterValue>:
/*-----------------------------------------------------------*/

uint32_t xGetRunTimeCounterValue( void )
{
 800f56c:	b580      	push	{r7, lr}
 800f56e:	af00      	add	r7, sp, #0
static uint64_t ullHiresTime = 0; /* Is always 0? */

	return ( uint32_t ) ( ullGetHighResolutionTime() - ullHiresTime );
 800f570:	f000 ff90 	bl	8010494 <ullGetHighResolutionTime>
 800f574:	4602      	mov	r2, r0
 800f576:	460b      	mov	r3, r1
 800f578:	4611      	mov	r1, r2
 800f57a:	4b03      	ldr	r3, [pc, #12]	; (800f588 <xGetRunTimeCounterValue+0x1c>)
 800f57c:	e9d3 2300 	ldrd	r2, r3, [r3]
 800f580:	4613      	mov	r3, r2
 800f582:	1acb      	subs	r3, r1, r3
}
 800f584:	4618      	mov	r0, r3
 800f586:	bd80      	pop	{r7, pc}
 800f588:	2000c4f0 	.word	0x2000c4f0

0800f58c <vApplicationTickHook>:
/*-----------------------------------------------------------*/

void vApplicationTickHook( void )
{
 800f58c:	b580      	push	{r7, lr}
 800f58e:	af00      	add	r7, sp, #0
	/* Call the ST HAL tick function. */
	HAL_IncTick();
 800f590:	f7f1 f92a 	bl	80007e8 <HAL_IncTick>
}
 800f594:	bd80      	pop	{r7, pc}
 800f596:	bf00      	nop

0800f598 <HAL_ETH_MspInit>:
  * @brief  Initializes the ETH MSP.
  * @param  heth: ETH handle
  * @retval None
  */
void HAL_ETH_MspInit(ETH_HandleTypeDef *heth)
{
 800f598:	b580      	push	{r7, lr}
 800f59a:	b08e      	sub	sp, #56	; 0x38
 800f59c:	af00      	add	r7, sp, #0
 800f59e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStructure;

  /* Enable GPIOs clocks */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800f5a0:	4a39      	ldr	r2, [pc, #228]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f5a2:	4b39      	ldr	r3, [pc, #228]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f5a4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f5a6:	f043 0301 	orr.w	r3, r3, #1
 800f5aa:	6313      	str	r3, [r2, #48]	; 0x30
 800f5ac:	4b36      	ldr	r3, [pc, #216]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f5ae:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f5b0:	f003 0301 	and.w	r3, r3, #1
 800f5b4:	623b      	str	r3, [r7, #32]
 800f5b6:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800f5b8:	4a33      	ldr	r2, [pc, #204]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f5ba:	4b33      	ldr	r3, [pc, #204]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f5bc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f5be:	f043 0304 	orr.w	r3, r3, #4
 800f5c2:	6313      	str	r3, [r2, #48]	; 0x30
 800f5c4:	4b30      	ldr	r3, [pc, #192]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f5c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f5c8:	f003 0304 	and.w	r3, r3, #4
 800f5cc:	61fb      	str	r3, [r7, #28]
 800f5ce:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 800f5d0:	4a2d      	ldr	r2, [pc, #180]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f5d2:	4b2d      	ldr	r3, [pc, #180]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f5d4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f5d6:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800f5da:	6313      	str	r3, [r2, #48]	; 0x30
 800f5dc:	4b2a      	ldr	r3, [pc, #168]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f5de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f5e0:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f5e4:	61bb      	str	r3, [r7, #24]
 800f5e6:	69bb      	ldr	r3, [r7, #24]
        RMII_MII_TXD0 ---------------------> PG13
        RMII_MII_TXD1 ---------------------> PG14
  */

  /* Configure PA1, PA2 and PA7 */
  GPIO_InitStructure.Speed = GPIO_SPEED_HIGH;
 800f5e8:	2303      	movs	r3, #3
 800f5ea:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStructure.Mode = GPIO_MODE_AF_PP;
 800f5ec:	2302      	movs	r3, #2
 800f5ee:	62bb      	str	r3, [r7, #40]	; 0x28
  GPIO_InitStructure.Pull = GPIO_NOPULL;
 800f5f0:	2300      	movs	r3, #0
 800f5f2:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStructure.Alternate = GPIO_AF11_ETH;
 800f5f4:	230b      	movs	r3, #11
 800f5f6:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7;
 800f5f8:	2386      	movs	r3, #134	; 0x86
 800f5fa:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 800f5fc:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800f600:	4822      	ldr	r0, [pc, #136]	; (800f68c <HAL_ETH_MspInit+0xf4>)
 800f602:	4619      	mov	r1, r3
 800f604:	f7f1 fa44 	bl	8000a90 <HAL_GPIO_Init>

  /* Configure PC1, PC4 and PC5 */
  GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;
 800f608:	2332      	movs	r3, #50	; 0x32
 800f60a:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 800f60c:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800f610:	481f      	ldr	r0, [pc, #124]	; (800f690 <HAL_ETH_MspInit+0xf8>)
 800f612:	4619      	mov	r1, r3
 800f614:	f7f1 fa3c 	bl	8000a90 <HAL_GPIO_Init>

  /* Configure PG2, PG11, PG13 and PG14 */
  GPIO_InitStructure.Pin =  GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;
 800f618:	f646 0304 	movw	r3, #26628	; 0x6804
 800f61c:	627b      	str	r3, [r7, #36]	; 0x24
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 800f61e:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800f622:	481c      	ldr	r0, [pc, #112]	; (800f694 <HAL_ETH_MspInit+0xfc>)
 800f624:	4619      	mov	r1, r3
 800f626:	f7f1 fa33 	bl	8000a90 <HAL_GPIO_Init>

  /* Enable the Ethernet global Interrupt */
  HAL_NVIC_SetPriority(ETH_IRQn, 0x7, 0);
 800f62a:	203d      	movs	r0, #61	; 0x3d
 800f62c:	2107      	movs	r1, #7
 800f62e:	2200      	movs	r2, #0
 800f630:	f7f1 f9dc 	bl	80009ec <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(ETH_IRQn);
 800f634:	203d      	movs	r0, #61	; 0x3d
 800f636:	f7f1 f9f5 	bl	8000a24 <HAL_NVIC_EnableIRQ>

  /* Enable ETHERNET clock  */
  __HAL_RCC_ETH_CLK_ENABLE();
 800f63a:	4a13      	ldr	r2, [pc, #76]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f63c:	4b12      	ldr	r3, [pc, #72]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f63e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f640:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 800f644:	6313      	str	r3, [r2, #48]	; 0x30
 800f646:	4b10      	ldr	r3, [pc, #64]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f648:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f64a:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800f64e:	617b      	str	r3, [r7, #20]
 800f650:	697b      	ldr	r3, [r7, #20]
 800f652:	4a0d      	ldr	r2, [pc, #52]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f654:	4b0c      	ldr	r3, [pc, #48]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f656:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f658:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800f65c:	6313      	str	r3, [r2, #48]	; 0x30
 800f65e:	4b0a      	ldr	r3, [pc, #40]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f660:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f662:	f003 6380 	and.w	r3, r3, #67108864	; 0x4000000
 800f666:	613b      	str	r3, [r7, #16]
 800f668:	693b      	ldr	r3, [r7, #16]
 800f66a:	4a07      	ldr	r2, [pc, #28]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f66c:	4b06      	ldr	r3, [pc, #24]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f66e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f670:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
 800f674:	6313      	str	r3, [r2, #48]	; 0x30
 800f676:	4b04      	ldr	r3, [pc, #16]	; (800f688 <HAL_ETH_MspInit+0xf0>)
 800f678:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f67a:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800f67e:	60fb      	str	r3, [r7, #12]
 800f680:	68fb      	ldr	r3, [r7, #12]
}
 800f682:	3738      	adds	r7, #56	; 0x38
 800f684:	46bd      	mov	sp, r7
 800f686:	bd80      	pop	{r7, pc}
 800f688:	40023800 	.word	0x40023800
 800f68c:	40020000 	.word	0x40020000
 800f690:	40020800 	.word	0x40020800
 800f694:	40021800 	.word	0x40021800

0800f698 <BSP_Config_task>:
  * @brief  Initializes the STM32F769I-DISOVERY's LCD and LEDs resources.
  * @param  None
  * @retval None
  */
static void BSP_Config_task(void *pvParameters)
{
 800f698:	b580      	push	{r7, lr}
 800f69a:	b082      	sub	sp, #8
 800f69c:	af00      	add	r7, sp, #0
 800f69e:	6078      	str	r0, [r7, #4]
  (void) pvParameters;
  /* Configure LED1 and LED2 */
  BSP_LED_Init(LED1);
 800f6a0:	2000      	movs	r0, #0
 800f6a2:	f001 f8e1 	bl	8010868 <BSP_LED_Init>
  BSP_LED_Init(LED2);
 800f6a6:	2001      	movs	r0, #1
 800f6a8:	f001 f8de 	bl	8010868 <BSP_LED_Init>
  //LCD_LOG_SetFooter((uint8_t *)"STM32F769I-DISOVERY board");
  
  //LCD_UsrLog ("  Blink LED BLINK!!!...\n");

  while(1){
      vTaskDelay(1000);
 800f6ac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800f6b0:	f7f5 fdaa 	bl	8005208 <vTaskDelay>
	  //HAL_Delay(100);
	  vTaskSuspend(NULL);
 800f6b4:	2000      	movs	r0, #0
 800f6b6:	f7f5 fddd 	bl	8005274 <vTaskSuspend>
  }
 800f6ba:	e7f7      	b.n	800f6ac <BSP_Config_task+0x14>

0800f6bc <SystemClock_Config>:


/** System Clock Configuration
*/
void SystemClock_Config(void)
{
 800f6bc:	b580      	push	{r7, lr}
 800f6be:	b0b8      	sub	sp, #224	; 0xe0
 800f6c0:	af00      	add	r7, sp, #0
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;

    /**Configure the main internal regulator output voltage 
    */
  __HAL_RCC_PWR_CLK_ENABLE();
 800f6c2:	4a47      	ldr	r2, [pc, #284]	; (800f7e0 <SystemClock_Config+0x124>)
 800f6c4:	4b46      	ldr	r3, [pc, #280]	; (800f7e0 <SystemClock_Config+0x124>)
 800f6c6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f6c8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800f6cc:	6413      	str	r3, [r2, #64]	; 0x40
 800f6ce:	4b44      	ldr	r3, [pc, #272]	; (800f7e0 <SystemClock_Config+0x124>)
 800f6d0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800f6d2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800f6d6:	607b      	str	r3, [r7, #4]
 800f6d8:	687b      	ldr	r3, [r7, #4]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 800f6da:	4a42      	ldr	r2, [pc, #264]	; (800f7e4 <SystemClock_Config+0x128>)
 800f6dc:	4b41      	ldr	r3, [pc, #260]	; (800f7e4 <SystemClock_Config+0x128>)
 800f6de:	681b      	ldr	r3, [r3, #0]
 800f6e0:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800f6e4:	6013      	str	r3, [r2, #0]
 800f6e6:	4b3f      	ldr	r3, [pc, #252]	; (800f7e4 <SystemClock_Config+0x128>)
 800f6e8:	681b      	ldr	r3, [r3, #0]
 800f6ea:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800f6ee:	603b      	str	r3, [r7, #0]
 800f6f0:	683b      	ldr	r3, [r7, #0]

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
 800f6f2:	2305      	movs	r3, #5
 800f6f4:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800f6f8:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800f6fc:	f8c7 30b0 	str.w	r3, [r7, #176]	; 0xb0
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800f700:	2301      	movs	r3, #1
 800f702:	f8c7 30b4 	str.w	r3, [r7, #180]	; 0xb4
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800f706:	2302      	movs	r3, #2
 800f708:	f8c7 30c4 	str.w	r3, [r7, #196]	; 0xc4
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800f70c:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 800f710:	f8c7 30c8 	str.w	r3, [r7, #200]	; 0xc8
  RCC_OscInitStruct.PLL.PLLM = 25;
 800f714:	2319      	movs	r3, #25
 800f716:	f8c7 30cc 	str.w	r3, [r7, #204]	; 0xcc
  RCC_OscInitStruct.PLL.PLLN = 400;
 800f71a:	f44f 73c8 	mov.w	r3, #400	; 0x190
 800f71e:	f8c7 30d0 	str.w	r3, [r7, #208]	; 0xd0
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 800f722:	2302      	movs	r3, #2
 800f724:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
  RCC_OscInitStruct.PLL.PLLQ = 4;
 800f728:	2304      	movs	r3, #4
 800f72a:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800f72e:	f107 03ac 	add.w	r3, r7, #172	; 0xac
 800f732:	4618      	mov	r0, r3
 800f734:	f7f1 fbb2 	bl	8000e9c <HAL_RCC_OscConfig>
 800f738:	4603      	mov	r3, r0
 800f73a:	2b00      	cmp	r3, #0
 800f73c:	d001      	beq.n	800f742 <SystemClock_Config+0x86>
  {
    Error_Handler();
 800f73e:	f000 fca7 	bl	8010090 <Error_Handler>
  }

    /**Activate the Over-Drive mode 
    */
  if (HAL_PWREx_EnableOverDrive() != HAL_OK)
 800f742:	f7f1 fb5d 	bl	8000e00 <HAL_PWREx_EnableOverDrive>
 800f746:	4603      	mov	r3, r0
 800f748:	2b00      	cmp	r3, #0
 800f74a:	d001      	beq.n	800f750 <SystemClock_Config+0x94>
  {
    Error_Handler();
 800f74c:	f000 fca0 	bl	8010090 <Error_Handler>
  }

    /**Initializes the CPU, AHB and APB busses clocks 
    */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800f750:	230f      	movs	r3, #15
 800f752:	f8c7 3098 	str.w	r3, [r7, #152]	; 0x98
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800f756:	2302      	movs	r3, #2
 800f758:	f8c7 309c 	str.w	r3, [r7, #156]	; 0x9c
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800f75c:	2300      	movs	r3, #0
 800f75e:	f8c7 30a0 	str.w	r3, [r7, #160]	; 0xa0
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 800f762:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
 800f766:	f8c7 30a4 	str.w	r3, [r7, #164]	; 0xa4
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 800f76a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800f76e:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6) != HAL_OK)
 800f772:	f107 0398 	add.w	r3, r7, #152	; 0x98
 800f776:	4618      	mov	r0, r3
 800f778:	2106      	movs	r1, #6
 800f77a:	f7f1 fe27 	bl	80013cc <HAL_RCC_ClockConfig>
 800f77e:	4603      	mov	r3, r0
 800f780:	2b00      	cmp	r3, #0
 800f782:	d001      	beq.n	800f788 <SystemClock_Config+0xcc>
  {
    Error_Handler();
 800f784:	f000 fc84 	bl	8010090 <Error_Handler>
  }

  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
 800f788:	2320      	movs	r3, #32
 800f78a:	60bb      	str	r3, [r7, #8]
  PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 800f78c:	f44f 7380 	mov.w	r3, #256	; 0x100
 800f790:	63bb      	str	r3, [r7, #56]	; 0x38
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 800f792:	f107 0308 	add.w	r3, r7, #8
 800f796:	4618      	mov	r0, r3
 800f798:	f7f1 fff4 	bl	8001784 <HAL_RCCEx_PeriphCLKConfig>
 800f79c:	4603      	mov	r3, r0
 800f79e:	2b00      	cmp	r3, #0
 800f7a0:	d001      	beq.n	800f7a6 <SystemClock_Config+0xea>
  {
    Error_Handler();
 800f7a2:	f000 fc75 	bl	8010090 <Error_Handler>
  }

    /**Configure LSE Drive Capability 
    */
  __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 800f7a6:	4a0e      	ldr	r2, [pc, #56]	; (800f7e0 <SystemClock_Config+0x124>)
 800f7a8:	4b0d      	ldr	r3, [pc, #52]	; (800f7e0 <SystemClock_Config+0x124>)
 800f7aa:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800f7ac:	f023 0318 	bic.w	r3, r3, #24
 800f7b0:	6713      	str	r3, [r2, #112]	; 0x70

    /**Configure the Systick interrupt time 
    */
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 800f7b2:	f7f1 ff89 	bl	80016c8 <HAL_RCC_GetHCLKFreq>
 800f7b6:	4602      	mov	r2, r0
 800f7b8:	4b0b      	ldr	r3, [pc, #44]	; (800f7e8 <SystemClock_Config+0x12c>)
 800f7ba:	fba3 2302 	umull	r2, r3, r3, r2
 800f7be:	099b      	lsrs	r3, r3, #6
 800f7c0:	4618      	mov	r0, r3
 800f7c2:	f7f1 f93d 	bl	8000a40 <HAL_SYSTICK_Config>

    /**Configure the Systick 
    */
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 800f7c6:	2004      	movs	r0, #4
 800f7c8:	f7f1 f946 	bl	8000a58 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 800f7cc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800f7d0:	210f      	movs	r1, #15
 800f7d2:	2200      	movs	r2, #0
 800f7d4:	f7f1 f90a 	bl	80009ec <HAL_NVIC_SetPriority>
}
 800f7d8:	37e0      	adds	r7, #224	; 0xe0
 800f7da:	46bd      	mov	sp, r7
 800f7dc:	bd80      	pop	{r7, pc}
 800f7de:	bf00      	nop
 800f7e0:	40023800 	.word	0x40023800
 800f7e4:	40007000 	.word	0x40007000
 800f7e8:	10624dd3 	.word	0x10624dd3

0800f7ec <MX_RTC_Init>:

/* RTC init function */
static void MX_RTC_Init(void)
{
 800f7ec:	b580      	push	{r7, lr}
 800f7ee:	af00      	add	r7, sp, #0

    /**Initialize RTC Only 
    */
  hrtc.Instance = RTC;
 800f7f0:	4b0e      	ldr	r3, [pc, #56]	; (800f82c <MX_RTC_Init+0x40>)
 800f7f2:	4a0f      	ldr	r2, [pc, #60]	; (800f830 <MX_RTC_Init+0x44>)
 800f7f4:	601a      	str	r2, [r3, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 800f7f6:	4b0d      	ldr	r3, [pc, #52]	; (800f82c <MX_RTC_Init+0x40>)
 800f7f8:	2200      	movs	r2, #0
 800f7fa:	605a      	str	r2, [r3, #4]
  hrtc.Init.AsynchPrediv = 127;
 800f7fc:	4b0b      	ldr	r3, [pc, #44]	; (800f82c <MX_RTC_Init+0x40>)
 800f7fe:	227f      	movs	r2, #127	; 0x7f
 800f800:	609a      	str	r2, [r3, #8]
  hrtc.Init.SynchPrediv = 255;
 800f802:	4b0a      	ldr	r3, [pc, #40]	; (800f82c <MX_RTC_Init+0x40>)
 800f804:	22ff      	movs	r2, #255	; 0xff
 800f806:	60da      	str	r2, [r3, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 800f808:	4b08      	ldr	r3, [pc, #32]	; (800f82c <MX_RTC_Init+0x40>)
 800f80a:	2200      	movs	r2, #0
 800f80c:	611a      	str	r2, [r3, #16]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 800f80e:	4b07      	ldr	r3, [pc, #28]	; (800f82c <MX_RTC_Init+0x40>)
 800f810:	2200      	movs	r2, #0
 800f812:	615a      	str	r2, [r3, #20]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 800f814:	4b05      	ldr	r3, [pc, #20]	; (800f82c <MX_RTC_Init+0x40>)
 800f816:	2200      	movs	r2, #0
 800f818:	619a      	str	r2, [r3, #24]

  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 800f81a:	4804      	ldr	r0, [pc, #16]	; (800f82c <MX_RTC_Init+0x40>)
 800f81c:	f7f3 fa76 	bl	8002d0c <HAL_RTC_Init>
 800f820:	4603      	mov	r3, r0
 800f822:	2b00      	cmp	r3, #0
 800f824:	d001      	beq.n	800f82a <MX_RTC_Init+0x3e>
  {
    Error_Handler();
 800f826:	f000 fc33 	bl	8010090 <Error_Handler>
  }


}
 800f82a:	bd80      	pop	{r7, pc}
 800f82c:	2000cf38 	.word	0x2000cf38
 800f830:	40002800 	.word	0x40002800

0800f834 <MX_FMC_Init>:

/* FMC initialization function */
static void MX_FMC_Init(void)
{
 800f834:	b580      	push	{r7, lr}
 800f836:	b088      	sub	sp, #32
 800f838:	af00      	add	r7, sp, #0
  FMC_SDRAM_TimingTypeDef SdramTiming;

  /** Perform the SDRAM1 memory initialization sequence
  */
  hsdram1.Instance = FMC_SDRAM_DEVICE;
 800f83a:	4b1e      	ldr	r3, [pc, #120]	; (800f8b4 <MX_FMC_Init+0x80>)
 800f83c:	4a1e      	ldr	r2, [pc, #120]	; (800f8b8 <MX_FMC_Init+0x84>)
 800f83e:	601a      	str	r2, [r3, #0]
  /* hsdram1.Init */
  hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
 800f840:	4b1c      	ldr	r3, [pc, #112]	; (800f8b4 <MX_FMC_Init+0x80>)
 800f842:	2200      	movs	r2, #0
 800f844:	605a      	str	r2, [r3, #4]
  hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_8;
 800f846:	4b1b      	ldr	r3, [pc, #108]	; (800f8b4 <MX_FMC_Init+0x80>)
 800f848:	2200      	movs	r2, #0
 800f84a:	609a      	str	r2, [r3, #8]
  hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_13;
 800f84c:	4b19      	ldr	r3, [pc, #100]	; (800f8b4 <MX_FMC_Init+0x80>)
 800f84e:	2208      	movs	r2, #8
 800f850:	60da      	str	r2, [r3, #12]
  hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_32;
 800f852:	4b18      	ldr	r3, [pc, #96]	; (800f8b4 <MX_FMC_Init+0x80>)
 800f854:	2220      	movs	r2, #32
 800f856:	611a      	str	r2, [r3, #16]
  hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 800f858:	4b16      	ldr	r3, [pc, #88]	; (800f8b4 <MX_FMC_Init+0x80>)
 800f85a:	2240      	movs	r2, #64	; 0x40
 800f85c:	615a      	str	r2, [r3, #20]
  hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_1;
 800f85e:	4b15      	ldr	r3, [pc, #84]	; (800f8b4 <MX_FMC_Init+0x80>)
 800f860:	2280      	movs	r2, #128	; 0x80
 800f862:	619a      	str	r2, [r3, #24]
  hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 800f864:	4b13      	ldr	r3, [pc, #76]	; (800f8b4 <MX_FMC_Init+0x80>)
 800f866:	2200      	movs	r2, #0
 800f868:	61da      	str	r2, [r3, #28]
  hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_DISABLE;
 800f86a:	4b12      	ldr	r3, [pc, #72]	; (800f8b4 <MX_FMC_Init+0x80>)
 800f86c:	2200      	movs	r2, #0
 800f86e:	621a      	str	r2, [r3, #32]
  hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_DISABLE;
 800f870:	4b10      	ldr	r3, [pc, #64]	; (800f8b4 <MX_FMC_Init+0x80>)
 800f872:	2200      	movs	r2, #0
 800f874:	625a      	str	r2, [r3, #36]	; 0x24
  hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
 800f876:	4b0f      	ldr	r3, [pc, #60]	; (800f8b4 <MX_FMC_Init+0x80>)
 800f878:	2200      	movs	r2, #0
 800f87a:	629a      	str	r2, [r3, #40]	; 0x28
  /* SdramTiming */
  SdramTiming.LoadToActiveDelay = 16;
 800f87c:	2310      	movs	r3, #16
 800f87e:	607b      	str	r3, [r7, #4]
  SdramTiming.ExitSelfRefreshDelay = 16;
 800f880:	2310      	movs	r3, #16
 800f882:	60bb      	str	r3, [r7, #8]
  SdramTiming.SelfRefreshTime = 16;
 800f884:	2310      	movs	r3, #16
 800f886:	60fb      	str	r3, [r7, #12]
  SdramTiming.RowCycleDelay = 16;
 800f888:	2310      	movs	r3, #16
 800f88a:	613b      	str	r3, [r7, #16]
  SdramTiming.WriteRecoveryTime = 16;
 800f88c:	2310      	movs	r3, #16
 800f88e:	617b      	str	r3, [r7, #20]
  SdramTiming.RPDelay = 16;
 800f890:	2310      	movs	r3, #16
 800f892:	61bb      	str	r3, [r7, #24]
  SdramTiming.RCDDelay = 16;
 800f894:	2310      	movs	r3, #16
 800f896:	61fb      	str	r3, [r7, #28]

  if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
 800f898:	1d3b      	adds	r3, r7, #4
 800f89a:	4806      	ldr	r0, [pc, #24]	; (800f8b4 <MX_FMC_Init+0x80>)
 800f89c:	4619      	mov	r1, r3
 800f89e:	f7f2 feb3 	bl	8002608 <HAL_SDRAM_Init>
 800f8a2:	4603      	mov	r3, r0
 800f8a4:	2b00      	cmp	r3, #0
 800f8a6:	d001      	beq.n	800f8ac <MX_FMC_Init+0x78>
  {
    Error_Handler();
 800f8a8:	f000 fbf2 	bl	8010090 <Error_Handler>
  }

}
 800f8ac:	3720      	adds	r7, #32
 800f8ae:	46bd      	mov	sp, r7
 800f8b0:	bd80      	pop	{r7, pc}
 800f8b2:	bf00      	nop
 800f8b4:	2000cf58 	.word	0x2000cf58
 800f8b8:	a0000140 	.word	0xa0000140

0800f8bc <MX_GPIO_Init>:
     PB11   ------> USB_OTG_HS_ULPI_D4
     PB14   ------> SPI2_MISO
     PB15   ------> SPI2_MOSI
*/
static void MX_GPIO_Init(void)
{
 800f8bc:	b580      	push	{r7, lr}
 800f8be:	b090      	sub	sp, #64	; 0x40
 800f8c0:	af00      	add	r7, sp, #0

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 800f8c2:	4aac      	ldr	r2, [pc, #688]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f8c4:	4bab      	ldr	r3, [pc, #684]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f8c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f8c8:	f043 0310 	orr.w	r3, r3, #16
 800f8cc:	6313      	str	r3, [r2, #48]	; 0x30
 800f8ce:	4ba9      	ldr	r3, [pc, #676]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f8d0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f8d2:	f003 0310 	and.w	r3, r3, #16
 800f8d6:	62bb      	str	r3, [r7, #40]	; 0x28
 800f8d8:	6abb      	ldr	r3, [r7, #40]	; 0x28
  __HAL_RCC_GPIOG_CLK_ENABLE();
 800f8da:	4aa6      	ldr	r2, [pc, #664]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f8dc:	4ba5      	ldr	r3, [pc, #660]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f8de:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f8e0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800f8e4:	6313      	str	r3, [r2, #48]	; 0x30
 800f8e6:	4ba3      	ldr	r3, [pc, #652]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f8e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f8ea:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800f8ee:	627b      	str	r3, [r7, #36]	; 0x24
 800f8f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800f8f2:	4aa0      	ldr	r2, [pc, #640]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f8f4:	4b9f      	ldr	r3, [pc, #636]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f8f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f8f8:	f043 0302 	orr.w	r3, r3, #2
 800f8fc:	6313      	str	r3, [r2, #48]	; 0x30
 800f8fe:	4b9d      	ldr	r3, [pc, #628]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f900:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f902:	f003 0302 	and.w	r3, r3, #2
 800f906:	623b      	str	r3, [r7, #32]
 800f908:	6a3b      	ldr	r3, [r7, #32]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 800f90a:	4a9a      	ldr	r2, [pc, #616]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f90c:	4b99      	ldr	r3, [pc, #612]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f90e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f910:	f043 0308 	orr.w	r3, r3, #8
 800f914:	6313      	str	r3, [r2, #48]	; 0x30
 800f916:	4b97      	ldr	r3, [pc, #604]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f918:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f91a:	f003 0308 	and.w	r3, r3, #8
 800f91e:	61fb      	str	r3, [r7, #28]
 800f920:	69fb      	ldr	r3, [r7, #28]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800f922:	4a94      	ldr	r2, [pc, #592]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f924:	4b93      	ldr	r3, [pc, #588]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f926:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f928:	f043 0304 	orr.w	r3, r3, #4
 800f92c:	6313      	str	r3, [r2, #48]	; 0x30
 800f92e:	4b91      	ldr	r3, [pc, #580]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f930:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f932:	f003 0304 	and.w	r3, r3, #4
 800f936:	61bb      	str	r3, [r7, #24]
 800f938:	69bb      	ldr	r3, [r7, #24]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800f93a:	4a8e      	ldr	r2, [pc, #568]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f93c:	4b8d      	ldr	r3, [pc, #564]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f93e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f940:	f043 0301 	orr.w	r3, r3, #1
 800f944:	6313      	str	r3, [r2, #48]	; 0x30
 800f946:	4b8b      	ldr	r3, [pc, #556]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f948:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f94a:	f003 0301 	and.w	r3, r3, #1
 800f94e:	617b      	str	r3, [r7, #20]
 800f950:	697b      	ldr	r3, [r7, #20]
  __HAL_RCC_GPIOJ_CLK_ENABLE();
 800f952:	4a88      	ldr	r2, [pc, #544]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f954:	4b87      	ldr	r3, [pc, #540]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f956:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f958:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800f95c:	6313      	str	r3, [r2, #48]	; 0x30
 800f95e:	4b85      	ldr	r3, [pc, #532]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f960:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f962:	f403 7300 	and.w	r3, r3, #512	; 0x200
 800f966:	613b      	str	r3, [r7, #16]
 800f968:	693b      	ldr	r3, [r7, #16]
  __HAL_RCC_GPIOI_CLK_ENABLE();
 800f96a:	4a82      	ldr	r2, [pc, #520]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f96c:	4b81      	ldr	r3, [pc, #516]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f96e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f970:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800f974:	6313      	str	r3, [r2, #48]	; 0x30
 800f976:	4b7f      	ldr	r3, [pc, #508]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f978:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f97a:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800f97e:	60fb      	str	r3, [r7, #12]
 800f980:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOK_CLK_ENABLE();
 800f982:	4a7c      	ldr	r2, [pc, #496]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f984:	4b7b      	ldr	r3, [pc, #492]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f986:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f988:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 800f98c:	6313      	str	r3, [r2, #48]	; 0x30
 800f98e:	4b79      	ldr	r3, [pc, #484]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f990:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f992:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 800f996:	60bb      	str	r3, [r7, #8]
 800f998:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 800f99a:	4a76      	ldr	r2, [pc, #472]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f99c:	4b75      	ldr	r3, [pc, #468]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f99e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f9a0:	f043 0320 	orr.w	r3, r3, #32
 800f9a4:	6313      	str	r3, [r2, #48]	; 0x30
 800f9a6:	4b73      	ldr	r3, [pc, #460]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f9a8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f9aa:	f003 0320 	and.w	r3, r3, #32
 800f9ae:	607b      	str	r3, [r7, #4]
 800f9b0:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 800f9b2:	4a70      	ldr	r2, [pc, #448]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f9b4:	4b6f      	ldr	r3, [pc, #444]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f9b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f9b8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800f9bc:	6313      	str	r3, [r2, #48]	; 0x30
 800f9be:	4b6d      	ldr	r3, [pc, #436]	; (800fb74 <MX_GPIO_Init+0x2b8>)
 800f9c0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800f9c2:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800f9c6:	603b      	str	r3, [r7, #0]
 800f9c8:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pins : SAI1_FSA_Pin SAI1_SDB_Pin SAI1_SCKA_Pin SAI1_SDA_Pin */
  GPIO_InitStruct.Pin = SAI1_FSA_Pin|SAI1_SDB_Pin|SAI1_SCKA_Pin|SAI1_SDA_Pin;
 800f9ca:	2378      	movs	r3, #120	; 0x78
 800f9cc:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f9ce:	2302      	movs	r3, #2
 800f9d0:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800f9d2:	2300      	movs	r3, #0
 800f9d4:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800f9d6:	2300      	movs	r3, #0
 800f9d8:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 800f9da:	2306      	movs	r3, #6
 800f9dc:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
 800f9de:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800f9e2:	4865      	ldr	r0, [pc, #404]	; (800fb78 <MX_GPIO_Init+0x2bc>)
 800f9e4:	4619      	mov	r1, r3
 800f9e6:	f7f1 f853 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : QSPI_D2_Pin */
  GPIO_InitStruct.Pin = QSPI_D2_Pin;
 800f9ea:	2304      	movs	r3, #4
 800f9ec:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800f9ee:	2302      	movs	r3, #2
 800f9f0:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800f9f2:	2300      	movs	r3, #0
 800f9f4:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800f9f6:	2303      	movs	r3, #3
 800f9f8:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
 800f9fa:	2309      	movs	r3, #9
 800f9fc:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_D2_GPIO_Port, &GPIO_InitStruct);
 800f9fe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fa02:	485d      	ldr	r0, [pc, #372]	; (800fb78 <MX_GPIO_Init+0x2bc>)
 800fa04:	4619      	mov	r1, r3
 800fa06:	f7f1 f843 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : RMII_TXD1_Pin RMII_TXD0_Pin RMII_TX_EN_Pin */
  GPIO_InitStruct.Pin = RMII_TXD1_Pin|RMII_TXD0_Pin|RMII_TX_EN_Pin;
 800fa0a:	f44f 43d0 	mov.w	r3, #26624	; 0x6800
 800fa0e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fa10:	2302      	movs	r3, #2
 800fa12:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fa14:	2300      	movs	r3, #0
 800fa16:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fa18:	2303      	movs	r3, #3
 800fa1a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800fa1c:	230b      	movs	r3, #11
 800fa1e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 800fa20:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fa24:	4855      	ldr	r0, [pc, #340]	; (800fb7c <MX_GPIO_Init+0x2c0>)
 800fa26:	4619      	mov	r1, r3
 800fa28:	f7f1 f832 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_SCL_D15_Pin ARDUINO_SDA_D14_Pin */
  GPIO_InitStruct.Pin = ARDUINO_SCL_D15_Pin|ARDUINO_SDA_D14_Pin;
 800fa2c:	f44f 7340 	mov.w	r3, #768	; 0x300
 800fa30:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800fa32:	2312      	movs	r3, #18
 800fa34:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800fa36:	2301      	movs	r3, #1
 800fa38:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800fa3a:	2300      	movs	r3, #0
 800fa3c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 800fa3e:	2304      	movs	r3, #4
 800fa40:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800fa42:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fa46:	484e      	ldr	r0, [pc, #312]	; (800fb80 <MX_GPIO_Init+0x2c4>)
 800fa48:	4619      	mov	r1, r3
 800fa4a:	f7f1 f821 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : ULPI_D7_Pin ULPI_D6_Pin ULPI_D5_Pin ULPI_D3_Pin 
                           ULPI_D2_Pin ULPI_D1_Pin ULPI_D4_Pin */
  GPIO_InitStruct.Pin = ULPI_D7_Pin|ULPI_D6_Pin|ULPI_D5_Pin|ULPI_D3_Pin 
 800fa4e:	f643 4323 	movw	r3, #15395	; 0x3c23
 800fa52:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |ULPI_D2_Pin|ULPI_D1_Pin|ULPI_D4_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fa54:	2302      	movs	r3, #2
 800fa56:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fa58:	2300      	movs	r3, #0
 800fa5a:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fa5c:	2303      	movs	r3, #3
 800fa5e:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 800fa60:	230a      	movs	r3, #10
 800fa62:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800fa64:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fa68:	4845      	ldr	r0, [pc, #276]	; (800fb80 <MX_GPIO_Init+0x2c4>)
 800fa6a:	4619      	mov	r1, r3
 800fa6c:	f7f1 f810 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : uSD_D3_Pin uSD_D2_Pin */
  GPIO_InitStruct.Pin = uSD_D3_Pin|uSD_D2_Pin;
 800fa70:	2318      	movs	r3, #24
 800fa72:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fa74:	2302      	movs	r3, #2
 800fa76:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fa78:	2300      	movs	r3, #0
 800fa7a:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fa7c:	2303      	movs	r3, #3
 800fa7e:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_SDMMC2;
 800fa80:	230a      	movs	r3, #10
 800fa82:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800fa84:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fa88:	483d      	ldr	r0, [pc, #244]	; (800fb80 <MX_GPIO_Init+0x2c4>)
 800fa8a:	4619      	mov	r1, r3
 800fa8c:	f7f1 f800 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : uSD_CMD_Pin uSD_CLK_Pin */
  GPIO_InitStruct.Pin = uSD_CMD_Pin|uSD_CLK_Pin;
 800fa90:	23c0      	movs	r3, #192	; 0xc0
 800fa92:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fa94:	2302      	movs	r3, #2
 800fa96:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fa98:	2300      	movs	r3, #0
 800fa9a:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fa9c:	2303      	movs	r3, #3
 800fa9e:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF11_SDMMC2;
 800faa0:	230b      	movs	r3, #11
 800faa2:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800faa4:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800faa8:	4836      	ldr	r0, [pc, #216]	; (800fb84 <MX_GPIO_Init+0x2c8>)
 800faaa:	4619      	mov	r1, r3
 800faac:	f7f0 fff0 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : WIFI_RX_Pin */
  GPIO_InitStruct.Pin = WIFI_RX_Pin;
 800fab0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800fab4:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fab6:	2302      	movs	r3, #2
 800fab8:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800faba:	2300      	movs	r3, #0
 800fabc:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fabe:	2303      	movs	r3, #3
 800fac0:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF8_UART5;
 800fac2:	2308      	movs	r3, #8
 800fac4:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(WIFI_RX_GPIO_Port, &GPIO_InitStruct);
 800fac6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800faca:	482f      	ldr	r0, [pc, #188]	; (800fb88 <MX_GPIO_Init+0x2cc>)
 800facc:	4619      	mov	r1, r3
 800face:	f7f0 ffdf 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : CEC_Pin */
  GPIO_InitStruct.Pin = CEC_Pin;
 800fad2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800fad6:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800fad8:	2312      	movs	r3, #18
 800fada:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fadc:	2300      	movs	r3, #0
 800fade:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800fae0:	2300      	movs	r3, #0
 800fae2:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF4_CEC;
 800fae4:	2304      	movs	r3, #4
 800fae6:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(CEC_GPIO_Port, &GPIO_InitStruct);
 800fae8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800faec:	4827      	ldr	r0, [pc, #156]	; (800fb8c <MX_GPIO_Init+0x2d0>)
 800faee:	4619      	mov	r1, r3
 800faf0:	f7f0 ffce 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : AUDIO_SDA_Pin */
  GPIO_InitStruct.Pin = AUDIO_SDA_Pin;
 800faf4:	2380      	movs	r3, #128	; 0x80
 800faf6:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800faf8:	2312      	movs	r3, #18
 800fafa:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800fafc:	2301      	movs	r3, #1
 800fafe:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fb00:	2303      	movs	r3, #3
 800fb02:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF11_I2C4;
 800fb04:	230b      	movs	r3, #11
 800fb06:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(AUDIO_SDA_GPIO_Port, &GPIO_InitStruct);
 800fb08:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fb0c:	481c      	ldr	r0, [pc, #112]	; (800fb80 <MX_GPIO_Init+0x2c4>)
 800fb0e:	4619      	mov	r1, r3
 800fb10:	f7f0 ffbe 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : QSPI_NCS_Pin */
  GPIO_InitStruct.Pin = QSPI_NCS_Pin;
 800fb14:	2340      	movs	r3, #64	; 0x40
 800fb16:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fb18:	2302      	movs	r3, #2
 800fb1a:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fb1c:	2300      	movs	r3, #0
 800fb1e:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fb20:	2303      	movs	r3, #3
 800fb22:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_QUADSPI;
 800fb24:	230a      	movs	r3, #10
 800fb26:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_NCS_GPIO_Port, &GPIO_InitStruct);
 800fb28:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fb2c:	4814      	ldr	r0, [pc, #80]	; (800fb80 <MX_GPIO_Init+0x2c4>)
 800fb2e:	4619      	mov	r1, r3
 800fb30:	f7f0 ffae 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : LD_USER1_Pin Audio_INT_Pin WIFI_RST_Pin DSI_RESET_Pin 
                           ARD_D8_Pin LD_USER2_Pin ARD_D7_Pin ARD_D4_Pin 
                           ARD_D2_Pin */
  GPIO_InitStruct.Pin = LD_USER1_Pin|Audio_INT_Pin|WIFI_RST_Pin|DSI_RESET_Pin 
 800fb34:	f24f 033b 	movw	r3, #61499	; 0xf03b
 800fb38:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |ARD_D8_Pin|LD_USER2_Pin|ARD_D7_Pin|ARD_D4_Pin 
                          |ARD_D2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800fb3a:	2300      	movs	r3, #0
 800fb3c:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fb3e:	2300      	movs	r3, #0
 800fb40:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOJ, &GPIO_InitStruct);
 800fb42:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fb46:	4812      	ldr	r0, [pc, #72]	; (800fb90 <MX_GPIO_Init+0x2d4>)
 800fb48:	4619      	mov	r1, r3
 800fb4a:	f7f0 ffa1 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : DFSDM_DATIN5_Pin DFSDM_DATIN1_Pin */
  GPIO_InitStruct.Pin = DFSDM_DATIN5_Pin|DFSDM_DATIN1_Pin;
 800fb4e:	f640 0308 	movw	r3, #2056	; 0x808
 800fb52:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fb54:	2302      	movs	r3, #2
 800fb56:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fb58:	2300      	movs	r3, #0
 800fb5a:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800fb5c:	2300      	movs	r3, #0
 800fb5e:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF3_DFSDM1;
 800fb60:	2303      	movs	r3, #3
 800fb62:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800fb64:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fb68:	4807      	ldr	r0, [pc, #28]	; (800fb88 <MX_GPIO_Init+0x2cc>)
 800fb6a:	4619      	mov	r1, r3
 800fb6c:	f7f0 ff90 	bl	8000a90 <HAL_GPIO_Init>
 800fb70:	e010      	b.n	800fb94 <MX_GPIO_Init+0x2d8>
 800fb72:	bf00      	nop
 800fb74:	40023800 	.word	0x40023800
 800fb78:	40021000 	.word	0x40021000
 800fb7c:	40021800 	.word	0x40021800
 800fb80:	40020400 	.word	0x40020400
 800fb84:	40020c00 	.word	0x40020c00
 800fb88:	40020800 	.word	0x40020800
 800fb8c:	40020000 	.word	0x40020000
 800fb90:	40022400 	.word	0x40022400

  /*Configure GPIO pins : QSPI_D1_Pin QSPI_D0_Pin */
  GPIO_InitStruct.Pin = QSPI_D1_Pin|QSPI_D0_Pin;
 800fb94:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 800fb98:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fb9a:	2302      	movs	r3, #2
 800fb9c:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fb9e:	2300      	movs	r3, #0
 800fba0:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fba2:	2303      	movs	r3, #3
 800fba4:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
 800fba6:	2309      	movs	r3, #9
 800fba8:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800fbaa:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fbae:	48ba      	ldr	r0, [pc, #744]	; (800fe98 <MX_GPIO_Init+0x5dc>)
 800fbb0:	4619      	mov	r1, r3
 800fbb2:	f7f0 ff6d 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARD_D13_SCK_Pin */
  GPIO_InitStruct.Pin = ARD_D13_SCK_Pin;
 800fbb6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800fbba:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fbbc:	2302      	movs	r3, #2
 800fbbe:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fbc0:	2300      	movs	r3, #0
 800fbc2:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800fbc4:	2300      	movs	r3, #0
 800fbc6:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 800fbc8:	2305      	movs	r3, #5
 800fbca:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ARD_D13_SCK_GPIO_Port, &GPIO_InitStruct);
 800fbcc:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fbd0:	48b2      	ldr	r0, [pc, #712]	; (800fe9c <MX_GPIO_Init+0x5e0>)
 800fbd2:	4619      	mov	r1, r3
 800fbd4:	f7f0 ff5c 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : NC4_Pin NC5_Pin uSD_Detect_Pin LCD_BL_CTRL_Pin */
  GPIO_InitStruct.Pin = NC4_Pin|NC5_Pin|uSD_Detect_Pin|LCD_BL_CTRL_Pin;
 800fbd8:	f44f 4351 	mov.w	r3, #53504	; 0xd100
 800fbdc:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800fbde:	2300      	movs	r3, #0
 800fbe0:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fbe2:	2300      	movs	r3, #0
 800fbe4:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
 800fbe6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fbea:	48ad      	ldr	r0, [pc, #692]	; (800fea0 <MX_GPIO_Init+0x5e4>)
 800fbec:	4619      	mov	r1, r3
 800fbee:	f7f0 ff4f 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : NC3_Pin NC2_Pin NC1_Pin NC8_Pin 
                           NC7_Pin */
  GPIO_InitStruct.Pin = NC3_Pin|NC2_Pin|NC1_Pin|NC8_Pin 
 800fbf2:	23f8      	movs	r3, #248	; 0xf8
 800fbf4:	62fb      	str	r3, [r7, #44]	; 0x2c
                          |NC7_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800fbf6:	2300      	movs	r3, #0
 800fbf8:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fbfa:	2300      	movs	r3, #0
 800fbfc:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOK, &GPIO_InitStruct);
 800fbfe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fc02:	48a8      	ldr	r0, [pc, #672]	; (800fea4 <MX_GPIO_Init+0x5e8>)
 800fc04:	4619      	mov	r1, r3
 800fc06:	f7f0 ff43 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : SPDIF_RX_Pin */
  GPIO_InitStruct.Pin = SPDIF_RX_Pin;
 800fc0a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800fc0e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fc10:	2302      	movs	r3, #2
 800fc12:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fc14:	2300      	movs	r3, #0
 800fc16:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800fc18:	2300      	movs	r3, #0
 800fc1a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF7_SPDIFRX;
 800fc1c:	2307      	movs	r3, #7
 800fc1e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(SPDIF_RX_GPIO_Port, &GPIO_InitStruct);
 800fc20:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fc24:	48a0      	ldr	r0, [pc, #640]	; (800fea8 <MX_GPIO_Init+0x5ec>)
 800fc26:	4619      	mov	r1, r3
 800fc28:	f7f0 ff32 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : uSD_D1_Pin uSD_D0_Pin */
  GPIO_InitStruct.Pin = uSD_D1_Pin|uSD_D0_Pin;
 800fc2c:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 800fc30:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fc32:	2302      	movs	r3, #2
 800fc34:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fc36:	2300      	movs	r3, #0
 800fc38:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fc3a:	2303      	movs	r3, #3
 800fc3c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF11_SDMMC2;
 800fc3e:	230b      	movs	r3, #11
 800fc40:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 800fc42:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fc46:	4898      	ldr	r0, [pc, #608]	; (800fea8 <MX_GPIO_Init+0x5ec>)
 800fc48:	4619      	mov	r1, r3
 800fc4a:	f7f0 ff21 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : RMII_RXER_Pin OTG_FS_OverCurrent_Pin */
  GPIO_InitStruct.Pin = RMII_RXER_Pin|OTG_FS_OverCurrent_Pin;
 800fc4e:	2330      	movs	r3, #48	; 0x30
 800fc50:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800fc52:	2300      	movs	r3, #0
 800fc54:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fc56:	2300      	movs	r3, #0
 800fc58:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800fc5a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fc5e:	4893      	ldr	r0, [pc, #588]	; (800feac <MX_GPIO_Init+0x5f0>)
 800fc60:	4619      	mov	r1, r3
 800fc62:	f7f0 ff15 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : DFSDM_CKOUT_Pin */
  GPIO_InitStruct.Pin = DFSDM_CKOUT_Pin;
 800fc66:	2308      	movs	r3, #8
 800fc68:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fc6a:	2302      	movs	r3, #2
 800fc6c:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fc6e:	2300      	movs	r3, #0
 800fc70:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800fc72:	2300      	movs	r3, #0
 800fc74:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF3_DFSDM1;
 800fc76:	2303      	movs	r3, #3
 800fc78:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(DFSDM_CKOUT_GPIO_Port, &GPIO_InitStruct);
 800fc7a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fc7e:	488b      	ldr	r0, [pc, #556]	; (800feac <MX_GPIO_Init+0x5f0>)
 800fc80:	4619      	mov	r1, r3
 800fc82:	f7f0 ff05 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : SPI2_NSS_Pin */
  GPIO_InitStruct.Pin = SPI2_NSS_Pin;
 800fc86:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800fc8a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fc8c:	2302      	movs	r3, #2
 800fc8e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fc90:	2300      	movs	r3, #0
 800fc92:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fc94:	2303      	movs	r3, #3
 800fc96:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 800fc98:	2305      	movs	r3, #5
 800fc9a:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(SPI2_NSS_GPIO_Port, &GPIO_InitStruct);
 800fc9c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fca0:	487e      	ldr	r0, [pc, #504]	; (800fe9c <MX_GPIO_Init+0x5e0>)
 800fca2:	4619      	mov	r1, r3
 800fca4:	f7f0 fef4 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : WIFI_TX_Pin */
  GPIO_InitStruct.Pin = WIFI_TX_Pin;
 800fca8:	2304      	movs	r3, #4
 800fcaa:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fcac:	2302      	movs	r3, #2
 800fcae:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fcb0:	2300      	movs	r3, #0
 800fcb2:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fcb4:	2303      	movs	r3, #3
 800fcb6:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF8_UART5;
 800fcb8:	2308      	movs	r3, #8
 800fcba:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(WIFI_TX_GPIO_Port, &GPIO_InitStruct);
 800fcbc:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fcc0:	487a      	ldr	r0, [pc, #488]	; (800feac <MX_GPIO_Init+0x5f0>)
 800fcc2:	4619      	mov	r1, r3
 800fcc4:	f7f0 fee4 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : VCP_RX_Pin */
  GPIO_InitStruct.Pin = VCP_RX_Pin;
 800fcc8:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800fccc:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fcce:	2302      	movs	r3, #2
 800fcd0:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fcd2:	2300      	movs	r3, #0
 800fcd4:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fcd6:	2303      	movs	r3, #3
 800fcd8:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 800fcda:	2307      	movs	r3, #7
 800fcdc:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(VCP_RX_GPIO_Port, &GPIO_InitStruct);
 800fcde:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fce2:	486e      	ldr	r0, [pc, #440]	; (800fe9c <MX_GPIO_Init+0x5e0>)
 800fce4:	4619      	mov	r1, r3
 800fce6:	f7f0 fed3 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : VCP_TX_Pin */
  GPIO_InitStruct.Pin = VCP_TX_Pin;
 800fcea:	f44f 7300 	mov.w	r3, #512	; 0x200
 800fcee:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fcf0:	2302      	movs	r3, #2
 800fcf2:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fcf4:	2300      	movs	r3, #0
 800fcf6:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800fcf8:	2300      	movs	r3, #0
 800fcfa:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 800fcfc:	2307      	movs	r3, #7
 800fcfe:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(VCP_TX_GPIO_Port, &GPIO_InitStruct);
 800fd00:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fd04:	4865      	ldr	r0, [pc, #404]	; (800fe9c <MX_GPIO_Init+0x5e0>)
 800fd06:	4619      	mov	r1, r3
 800fd08:	f7f0 fec2 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : ULPI_DIR_Pin */
  GPIO_InitStruct.Pin = ULPI_DIR_Pin;
 800fd0c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800fd10:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fd12:	2302      	movs	r3, #2
 800fd14:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fd16:	2300      	movs	r3, #0
 800fd18:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fd1a:	2303      	movs	r3, #3
 800fd1c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 800fd1e:	230a      	movs	r3, #10
 800fd20:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ULPI_DIR_GPIO_Port, &GPIO_InitStruct);
 800fd22:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fd26:	485e      	ldr	r0, [pc, #376]	; (800fea0 <MX_GPIO_Init+0x5e4>)
 800fd28:	4619      	mov	r1, r3
 800fd2a:	f7f0 feb1 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : CEC_CLK_Pin */
  GPIO_InitStruct.Pin = CEC_CLK_Pin;
 800fd2e:	f44f 7380 	mov.w	r3, #256	; 0x100
 800fd32:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fd34:	2302      	movs	r3, #2
 800fd36:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fd38:	2300      	movs	r3, #0
 800fd3a:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800fd3c:	2300      	movs	r3, #0
 800fd3e:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
 800fd40:	2300      	movs	r3, #0
 800fd42:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(CEC_CLK_GPIO_Port, &GPIO_InitStruct);
 800fd44:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fd48:	4854      	ldr	r0, [pc, #336]	; (800fe9c <MX_GPIO_Init+0x5e0>)
 800fd4a:	4619      	mov	r1, r3
 800fd4c:	f7f0 fea0 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : LCD_INT_Pin */
  GPIO_InitStruct.Pin = LCD_INT_Pin;
 800fd50:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800fd54:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
 800fd56:	4b56      	ldr	r3, [pc, #344]	; (800feb0 <MX_GPIO_Init+0x5f4>)
 800fd58:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fd5a:	2300      	movs	r3, #0
 800fd5c:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(LCD_INT_GPIO_Port, &GPIO_InitStruct);
 800fd5e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fd62:	484f      	ldr	r0, [pc, #316]	; (800fea0 <MX_GPIO_Init+0x5e4>)
 800fd64:	4619      	mov	r1, r3
 800fd66:	f7f0 fe93 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARD_D5_PWM_Pin */
  GPIO_InitStruct.Pin = ARD_D5_PWM_Pin;
 800fd6a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800fd6e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fd70:	2302      	movs	r3, #2
 800fd72:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fd74:	2300      	movs	r3, #0
 800fd76:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800fd78:	2300      	movs	r3, #0
 800fd7a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF2_TIM3;
 800fd7c:	2302      	movs	r3, #2
 800fd7e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ARD_D5_PWM_GPIO_Port, &GPIO_InitStruct);
 800fd80:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fd84:	4844      	ldr	r0, [pc, #272]	; (800fe98 <MX_GPIO_Init+0x5dc>)
 800fd86:	4619      	mov	r1, r3
 800fd88:	f7f0 fe82 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARD_D0_RX_Pin ARDUINO_TX_D1_Pin */
  GPIO_InitStruct.Pin = ARD_D0_RX_Pin|ARDUINO_TX_D1_Pin;
 800fd8c:	23c0      	movs	r3, #192	; 0xc0
 800fd8e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fd90:	2302      	movs	r3, #2
 800fd92:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fd94:	2300      	movs	r3, #0
 800fd96:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fd98:	2303      	movs	r3, #3
 800fd9a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
 800fd9c:	2308      	movs	r3, #8
 800fd9e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800fda0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fda4:	483c      	ldr	r0, [pc, #240]	; (800fe98 <MX_GPIO_Init+0x5dc>)
 800fda6:	4619      	mov	r1, r3
 800fda8:	f7f0 fe72 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : ULPI_NXT_Pin */
  GPIO_InitStruct.Pin = ULPI_NXT_Pin;
 800fdac:	2310      	movs	r3, #16
 800fdae:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fdb0:	2302      	movs	r3, #2
 800fdb2:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fdb4:	2300      	movs	r3, #0
 800fdb6:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fdb8:	2303      	movs	r3, #3
 800fdba:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 800fdbc:	230a      	movs	r3, #10
 800fdbe:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ULPI_NXT_GPIO_Port, &GPIO_InitStruct);
 800fdc0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fdc4:	483b      	ldr	r0, [pc, #236]	; (800feb4 <MX_GPIO_Init+0x5f8>)
 800fdc6:	4619      	mov	r1, r3
 800fdc8:	f7f0 fe62 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : SAI1_MCLKA_Pin */
  GPIO_InitStruct.Pin = SAI1_MCLKA_Pin;
 800fdcc:	2380      	movs	r3, #128	; 0x80
 800fdce:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fdd0:	2302      	movs	r3, #2
 800fdd2:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fdd4:	2300      	movs	r3, #0
 800fdd6:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800fdd8:	2300      	movs	r3, #0
 800fdda:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF6_SAI1;
 800fddc:	2306      	movs	r3, #6
 800fdde:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(SAI1_MCLKA_GPIO_Port, &GPIO_InitStruct);
 800fde0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fde4:	4830      	ldr	r0, [pc, #192]	; (800fea8 <MX_GPIO_Init+0x5ec>)
 800fde6:	4619      	mov	r1, r3
 800fde8:	f7f0 fe52 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : EXT_SDA_Pin EXT_SCL_Pin */
  GPIO_InitStruct.Pin = EXT_SDA_Pin|EXT_SCL_Pin;
 800fdec:	2348      	movs	r3, #72	; 0x48
 800fdee:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800fdf0:	2300      	movs	r3, #0
 800fdf2:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fdf4:	2300      	movs	r3, #0
 800fdf6:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 800fdf8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fdfc:	482a      	ldr	r0, [pc, #168]	; (800fea8 <MX_GPIO_Init+0x5ec>)
 800fdfe:	4619      	mov	r1, r3
 800fe00:	f7f0 fe46 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARD_D6_PWM_Pin */
  GPIO_InitStruct.Pin = ARD_D6_PWM_Pin;
 800fe04:	2380      	movs	r3, #128	; 0x80
 800fe06:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fe08:	2302      	movs	r3, #2
 800fe0a:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fe0c:	2300      	movs	r3, #0
 800fe0e:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800fe10:	2300      	movs	r3, #0
 800fe12:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF3_TIM11;
 800fe14:	2303      	movs	r3, #3
 800fe16:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ARD_D6_PWM_GPIO_Port, &GPIO_InitStruct);
 800fe18:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fe1c:	4826      	ldr	r0, [pc, #152]	; (800feb8 <MX_GPIO_Init+0x5fc>)
 800fe1e:	4619      	mov	r1, r3
 800fe20:	f7f0 fe36 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARD_D3_PWM_Pin */
  GPIO_InitStruct.Pin = ARD_D3_PWM_Pin;
 800fe24:	2340      	movs	r3, #64	; 0x40
 800fe26:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fe28:	2302      	movs	r3, #2
 800fe2a:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fe2c:	2300      	movs	r3, #0
 800fe2e:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800fe30:	2300      	movs	r3, #0
 800fe32:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF3_TIM10;
 800fe34:	2303      	movs	r3, #3
 800fe36:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ARD_D3_PWM_GPIO_Port, &GPIO_InitStruct);
 800fe38:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fe3c:	481e      	ldr	r0, [pc, #120]	; (800feb8 <MX_GPIO_Init+0x5fc>)
 800fe3e:	4619      	mov	r1, r3
 800fe40:	f7f0 fe26 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_A1_Pin ARDUINO_A2_Pin ARDUINO_A3_Pin */
  GPIO_InitStruct.Pin = ARDUINO_A1_Pin|ARDUINO_A2_Pin|ARDUINO_A3_Pin;
 800fe44:	f44f 63e0 	mov.w	r3, #1792	; 0x700
 800fe48:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800fe4a:	2303      	movs	r3, #3
 800fe4c:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fe4e:	2300      	movs	r3, #0
 800fe50:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
 800fe52:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fe56:	4818      	ldr	r0, [pc, #96]	; (800feb8 <MX_GPIO_Init+0x5fc>)
 800fe58:	4619      	mov	r1, r3
 800fe5a:	f7f0 fe19 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : ULPI_STP_Pin */
  GPIO_InitStruct.Pin = ULPI_STP_Pin;
 800fe5e:	2301      	movs	r3, #1
 800fe60:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fe62:	2302      	movs	r3, #2
 800fe64:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fe66:	2300      	movs	r3, #0
 800fe68:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fe6a:	2303      	movs	r3, #3
 800fe6c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 800fe6e:	230a      	movs	r3, #10
 800fe70:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ULPI_STP_GPIO_Port, &GPIO_InitStruct);
 800fe72:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fe76:	4808      	ldr	r0, [pc, #32]	; (800fe98 <MX_GPIO_Init+0x5dc>)
 800fe78:	4619      	mov	r1, r3
 800fe7a:	f7f0 fe09 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : RMII_MDC_Pin RMII_RXD0_Pin RMII_RXD1_Pin */
  GPIO_InitStruct.Pin = RMII_MDC_Pin|RMII_RXD0_Pin|RMII_RXD1_Pin;
 800fe7e:	2332      	movs	r3, #50	; 0x32
 800fe80:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fe82:	2302      	movs	r3, #2
 800fe84:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fe86:	2300      	movs	r3, #0
 800fe88:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fe8a:	2303      	movs	r3, #3
 800fe8c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800fe8e:	230b      	movs	r3, #11
 800fe90:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800fe92:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fe96:	e011      	b.n	800febc <MX_GPIO_Init+0x600>
 800fe98:	40020800 	.word	0x40020800
 800fe9c:	40020000 	.word	0x40020000
 800fea0:	40022000 	.word	0x40022000
 800fea4:	40022800 	.word	0x40022800
 800fea8:	40021800 	.word	0x40021800
 800feac:	40020c00 	.word	0x40020c00
 800feb0:	10120000 	.word	0x10120000
 800feb4:	40021c00 	.word	0x40021c00
 800feb8:	40021400 	.word	0x40021400
 800febc:	4865      	ldr	r0, [pc, #404]	; (8010054 <MX_GPIO_Init+0x798>)
 800febe:	4619      	mov	r1, r3
 800fec0:	f7f0 fde6 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARD_A2_Pin */
  GPIO_InitStruct.Pin = ARD_A2_Pin;
 800fec4:	2304      	movs	r3, #4
 800fec6:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800fec8:	2303      	movs	r3, #3
 800feca:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fecc:	2300      	movs	r3, #0
 800fece:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(ARD_A2_GPIO_Port, &GPIO_InitStruct);
 800fed0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fed4:	485f      	ldr	r0, [pc, #380]	; (8010054 <MX_GPIO_Init+0x798>)
 800fed6:	4619      	mov	r1, r3
 800fed8:	f7f0 fdda 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : PB2 */
  GPIO_InitStruct.Pin = GPIO_PIN_2;
 800fedc:	2304      	movs	r3, #4
 800fede:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800fee0:	2302      	movs	r3, #2
 800fee2:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fee4:	2300      	movs	r3, #0
 800fee6:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fee8:	2303      	movs	r3, #3
 800feea:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
 800feec:	2309      	movs	r3, #9
 800feee:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 800fef0:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800fef4:	4858      	ldr	r0, [pc, #352]	; (8010058 <MX_GPIO_Init+0x79c>)
 800fef6:	4619      	mov	r1, r3
 800fef8:	f7f0 fdca 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : AUDIO_SCL_Pin */
  GPIO_InitStruct.Pin = AUDIO_SCL_Pin;
 800fefc:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800ff00:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 800ff02:	2312      	movs	r3, #18
 800ff04:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 800ff06:	2301      	movs	r3, #1
 800ff08:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800ff0a:	2303      	movs	r3, #3
 800ff0c:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF4_I2C4;
 800ff0e:	2304      	movs	r3, #4
 800ff10:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(AUDIO_SCL_GPIO_Port, &GPIO_InitStruct);
 800ff12:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800ff16:	4851      	ldr	r0, [pc, #324]	; (801005c <MX_GPIO_Init+0x7a0>)
 800ff18:	4619      	mov	r1, r3
 800ff1a:	f7f0 fdb9 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : QSPI_D3_Pin */
  GPIO_InitStruct.Pin = QSPI_D3_Pin;
 800ff1e:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800ff22:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ff24:	2302      	movs	r3, #2
 800ff26:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ff28:	2300      	movs	r3, #0
 800ff2a:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800ff2c:	2303      	movs	r3, #3
 800ff2e:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_QUADSPI;
 800ff30:	2309      	movs	r3, #9
 800ff32:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_D3_GPIO_Port, &GPIO_InitStruct);
 800ff34:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800ff38:	4848      	ldr	r0, [pc, #288]	; (801005c <MX_GPIO_Init+0x7a0>)
 800ff3a:	4619      	mov	r1, r3
 800ff3c:	f7f0 fda8 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : RMII_REF_CLK_Pin RMII_MDIO_Pin RMII_CRS_DV_Pin */
  GPIO_InitStruct.Pin = RMII_REF_CLK_Pin|RMII_MDIO_Pin|RMII_CRS_DV_Pin;
 800ff40:	2386      	movs	r3, #134	; 0x86
 800ff42:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ff44:	2302      	movs	r3, #2
 800ff46:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ff48:	2300      	movs	r3, #0
 800ff4a:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800ff4c:	2303      	movs	r3, #3
 800ff4e:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
 800ff50:	230b      	movs	r3, #11
 800ff52:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800ff54:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800ff58:	4841      	ldr	r0, [pc, #260]	; (8010060 <MX_GPIO_Init+0x7a4>)
 800ff5a:	4619      	mov	r1, r3
 800ff5c:	f7f0 fd98 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : B_USER_Pin */
  GPIO_InitStruct.Pin = B_USER_Pin;
 800ff60:	2301      	movs	r3, #1
 800ff62:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
 800ff64:	4b3f      	ldr	r3, [pc, #252]	; (8010064 <MX_GPIO_Init+0x7a8>)
 800ff66:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ff68:	2300      	movs	r3, #0
 800ff6a:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(B_USER_GPIO_Port, &GPIO_InitStruct);
 800ff6c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800ff70:	483b      	ldr	r0, [pc, #236]	; (8010060 <MX_GPIO_Init+0x7a4>)
 800ff72:	4619      	mov	r1, r3
 800ff74:	f7f0 fd8c 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARD_A1_Pin ARD_A0_Pin */
  GPIO_InitStruct.Pin = ARD_A1_Pin|ARD_A0_Pin;
 800ff78:	2350      	movs	r3, #80	; 0x50
 800ff7a:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 800ff7c:	2303      	movs	r3, #3
 800ff7e:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ff80:	2300      	movs	r3, #0
 800ff82:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800ff84:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800ff88:	4835      	ldr	r0, [pc, #212]	; (8010060 <MX_GPIO_Init+0x7a4>)
 800ff8a:	4619      	mov	r1, r3
 800ff8c:	f7f0 fd80 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : SPDIF_TX_Pin */
  GPIO_InitStruct.Pin = SPDIF_TX_Pin;
 800ff90:	f44f 6300 	mov.w	r3, #2048	; 0x800
 800ff94:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ff96:	2302      	movs	r3, #2
 800ff98:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ff9a:	2300      	movs	r3, #0
 800ff9c:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 800ff9e:	2300      	movs	r3, #0
 800ffa0:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_SAI2;
 800ffa2:	230a      	movs	r3, #10
 800ffa4:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(SPDIF_TX_GPIO_Port, &GPIO_InitStruct);
 800ffa6:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800ffaa:	482c      	ldr	r0, [pc, #176]	; (801005c <MX_GPIO_Init+0x7a0>)
 800ffac:	4619      	mov	r1, r3
 800ffae:	f7f0 fd6f 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : EXT_RST_Pin */
  GPIO_InitStruct.Pin = EXT_RST_Pin;
 800ffb2:	2380      	movs	r3, #128	; 0x80
 800ffb4:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 800ffb6:	2300      	movs	r3, #0
 800ffb8:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ffba:	2300      	movs	r3, #0
 800ffbc:	637b      	str	r3, [r7, #52]	; 0x34
  HAL_GPIO_Init(EXT_RST_GPIO_Port, &GPIO_InitStruct);
 800ffbe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800ffc2:	4829      	ldr	r0, [pc, #164]	; (8010068 <MX_GPIO_Init+0x7ac>)
 800ffc4:	4619      	mov	r1, r3
 800ffc6:	f7f0 fd63 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : ULPI_CLK_Pin ULPI_D0_Pin */
  GPIO_InitStruct.Pin = ULPI_CLK_Pin|ULPI_D0_Pin;
 800ffca:	2328      	movs	r3, #40	; 0x28
 800ffcc:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ffce:	2302      	movs	r3, #2
 800ffd0:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800ffd2:	2300      	movs	r3, #0
 800ffd4:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800ffd6:	2303      	movs	r3, #3
 800ffd8:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF10_OTG_HS;
 800ffda:	230a      	movs	r3, #10
 800ffdc:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800ffde:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800ffe2:	481f      	ldr	r0, [pc, #124]	; (8010060 <MX_GPIO_Init+0x7a4>)
 800ffe4:	4619      	mov	r1, r3
 800ffe6:	f7f0 fd53 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : DSIHOST_TE_Pin */
  GPIO_InitStruct.Pin = DSIHOST_TE_Pin;
 800ffea:	2304      	movs	r3, #4
 800ffec:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800ffee:	2302      	movs	r3, #2
 800fff0:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 800fff2:	2300      	movs	r3, #0
 800fff4:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800fff6:	2303      	movs	r3, #3
 800fff8:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF13_DSI;
 800fffa:	230d      	movs	r3, #13
 800fffc:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(DSIHOST_TE_GPIO_Port, &GPIO_InitStruct);
 800fffe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010002:	481a      	ldr	r0, [pc, #104]	; (801006c <MX_GPIO_Init+0x7b0>)
 8010004:	4619      	mov	r1, r3
 8010006:	f7f0 fd43 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pin : ARDUINO_PWM_D6_Pin */
  GPIO_InitStruct.Pin = ARDUINO_PWM_D6_Pin;
 801000a:	2340      	movs	r3, #64	; 0x40
 801000c:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 801000e:	2302      	movs	r3, #2
 8010010:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010012:	2300      	movs	r3, #0
 8010014:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8010016:	2300      	movs	r3, #0
 8010018:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF9_TIM12;
 801001a:	2309      	movs	r3, #9
 801001c:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(ARDUINO_PWM_D6_GPIO_Port, &GPIO_InitStruct);
 801001e:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010022:	4811      	ldr	r0, [pc, #68]	; (8010068 <MX_GPIO_Init+0x7ac>)
 8010024:	4619      	mov	r1, r3
 8010026:	f7f0 fd33 	bl	8000a90 <HAL_GPIO_Init>

  /*Configure GPIO pins : ARDUINO_MISO_D12_Pin ARDUINO_MOSI_PWM_D11_Pin */
  GPIO_InitStruct.Pin = ARDUINO_MISO_D12_Pin|ARDUINO_MOSI_PWM_D11_Pin;
 801002a:	f44f 4340 	mov.w	r3, #49152	; 0xc000
 801002e:	62fb      	str	r3, [r7, #44]	; 0x2c
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8010030:	2302      	movs	r3, #2
 8010032:	633b      	str	r3, [r7, #48]	; 0x30
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8010034:	2300      	movs	r3, #0
 8010036:	637b      	str	r3, [r7, #52]	; 0x34
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8010038:	2300      	movs	r3, #0
 801003a:	63bb      	str	r3, [r7, #56]	; 0x38
  GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
 801003c:	2305      	movs	r3, #5
 801003e:	63fb      	str	r3, [r7, #60]	; 0x3c
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8010040:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8010044:	4804      	ldr	r0, [pc, #16]	; (8010058 <MX_GPIO_Init+0x79c>)
 8010046:	4619      	mov	r1, r3
 8010048:	f7f0 fd22 	bl	8000a90 <HAL_GPIO_Init>

}
 801004c:	3740      	adds	r7, #64	; 0x40
 801004e:	46bd      	mov	sp, r7
 8010050:	bd80      	pop	{r7, pc}
 8010052:	bf00      	nop
 8010054:	40020800 	.word	0x40020800
 8010058:	40020400 	.word	0x40020400
 801005c:	40020c00 	.word	0x40020c00
 8010060:	40020000 	.word	0x40020000
 8010064:	10110000 	.word	0x10110000
 8010068:	40021c00 	.word	0x40021c00
 801006c:	40022400 	.word	0x40022400

08010070 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 8010070:	b580      	push	{r7, lr}
 8010072:	b082      	sub	sp, #8
 8010074:	af00      	add	r7, sp, #0
 8010076:	6078      	str	r0, [r7, #4]

  if (htim->Instance == TIM13) {
 8010078:	687b      	ldr	r3, [r7, #4]
 801007a:	681b      	ldr	r3, [r3, #0]
 801007c:	4a03      	ldr	r2, [pc, #12]	; (801008c <HAL_TIM_PeriodElapsedCallback+0x1c>)
 801007e:	4293      	cmp	r3, r2
 8010080:	d101      	bne.n	8010086 <HAL_TIM_PeriodElapsedCallback+0x16>
    HAL_IncTick();
 8010082:	f7f0 fbb1 	bl	80007e8 <HAL_IncTick>
  }

}
 8010086:	3708      	adds	r7, #8
 8010088:	46bd      	mov	sp, r7
 801008a:	bd80      	pop	{r7, pc}
 801008c:	40001c00 	.word	0x40001c00

08010090 <Error_Handler>:
  * @brief  This function is executed in case of error occurrence.
  * @param  None
  * @retval None
  */
void Error_Handler(void)
{
 8010090:	b480      	push	{r7}
 8010092:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN Error_Handler */
  /* User can add his own implementation to report the HAL error return state */
  while(1) 
  {
  }
 8010094:	e7fe      	b.n	8010094 <Error_Handler+0x4>
 8010096:	bf00      	nop

08010098 <CPU_CACHE_Enable>:
  * @brief  CPU L1-Cache enable.
  * @param  None
  * @retval None
  */
static void CPU_CACHE_Enable(void)
{
 8010098:	b580      	push	{r7, lr}
 801009a:	af00      	add	r7, sp, #0
  /* Enable I-Cache */
  SCB_EnableICache();
 801009c:	f7ff f812 	bl	800f0c4 <SCB_EnableICache>

  /* Enable D-Cache */
  SCB_EnableDCache();
 80100a0:	f7ff f82a 	bl	800f0f8 <SCB_EnableDCache>
}
 80100a4:	bd80      	pop	{r7, pc}
 80100a6:	bf00      	nop

080100a8 <memcpy>:
};


#if( SIMPLE_MEMCPY == 0 )
void *memcpy( void *pvDest, const void *pvSource, size_t ulBytes )
{
 80100a8:	b480      	push	{r7}
 80100aa:	b08d      	sub	sp, #52	; 0x34
 80100ac:	af00      	add	r7, sp, #0
 80100ae:	60f8      	str	r0, [r7, #12]
 80100b0:	60b9      	str	r1, [r7, #8]
 80100b2:	607a      	str	r2, [r7, #4]
union xPointer pxDestination;
union xPointer pxSource;
union xPointer pxLastSource;
uint32_t ulAlignBits;

	pxDestination.u8 = ( uint8_t * ) pvDest;
 80100b4:	68fb      	ldr	r3, [r7, #12]
 80100b6:	61bb      	str	r3, [r7, #24]
	pxSource.u8 = ( uint8_t * ) pvSource;
 80100b8:	68bb      	ldr	r3, [r7, #8]
 80100ba:	617b      	str	r3, [r7, #20]
	pxLastSource.u8 = pxSource.u8 + ulBytes;
 80100bc:	697a      	ldr	r2, [r7, #20]
 80100be:	687b      	ldr	r3, [r7, #4]
 80100c0:	4413      	add	r3, r2
 80100c2:	613b      	str	r3, [r7, #16]

	ulAlignBits = ( pxDestination.uint32 & 0x03 ) ^ ( pxSource.uint32 & 0x03 );
 80100c4:	69bb      	ldr	r3, [r7, #24]
 80100c6:	f003 0203 	and.w	r2, r3, #3
 80100ca:	697b      	ldr	r3, [r7, #20]
 80100cc:	f003 0303 	and.w	r3, r3, #3
 80100d0:	4053      	eors	r3, r2
 80100d2:	627b      	str	r3, [r7, #36]	; 0x24

	if( ( ulAlignBits & 0x01 ) == 0 )
 80100d4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80100d6:	f003 0301 	and.w	r3, r3, #1
 80100da:	2b00      	cmp	r3, #0
 80100dc:	f040 8096 	bne.w	801020c <memcpy+0x164>
	{
		if( ( ( pxSource.uint32 & 1 ) != 0 ) && ( pxSource.u8 < pxLastSource.u8 ) )
 80100e0:	697b      	ldr	r3, [r7, #20]
 80100e2:	f003 0301 	and.w	r3, r3, #1
 80100e6:	2b00      	cmp	r3, #0
 80100e8:	d00b      	beq.n	8010102 <memcpy+0x5a>
 80100ea:	697a      	ldr	r2, [r7, #20]
 80100ec:	693b      	ldr	r3, [r7, #16]
 80100ee:	429a      	cmp	r2, r3
 80100f0:	d207      	bcs.n	8010102 <memcpy+0x5a>
		{
			*( pxDestination.u8++ ) = *( pxSource.u8++) ;
 80100f2:	69bb      	ldr	r3, [r7, #24]
 80100f4:	1c5a      	adds	r2, r3, #1
 80100f6:	61ba      	str	r2, [r7, #24]
 80100f8:	697a      	ldr	r2, [r7, #20]
 80100fa:	1c51      	adds	r1, r2, #1
 80100fc:	6179      	str	r1, [r7, #20]
 80100fe:	7812      	ldrb	r2, [r2, #0]
 8010100:	701a      	strb	r2, [r3, #0]
		}
		/* 16-bit aligned here */
		if( ( ulAlignBits & 0x02 ) != 0 )
 8010102:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010104:	f003 0302 	and.w	r3, r3, #2
 8010108:	2b00      	cmp	r3, #0
 801010a:	d019      	beq.n	8010140 <memcpy+0x98>
		{
			uint32_t extra = pxLastSource.uint32 & 0x01ul;
 801010c:	693b      	ldr	r3, [r7, #16]
 801010e:	f003 0301 	and.w	r3, r3, #1
 8010112:	623b      	str	r3, [r7, #32]

			pxLastSource.uint32 &= ~0x01ul;
 8010114:	693b      	ldr	r3, [r7, #16]
 8010116:	f023 0301 	bic.w	r3, r3, #1
 801011a:	613b      	str	r3, [r7, #16]

			while( pxSource.u16 < pxLastSource.u16 )
 801011c:	e007      	b.n	801012e <memcpy+0x86>
			{
				*( pxDestination.u16++ ) = *( pxSource.u16++) ;
 801011e:	69bb      	ldr	r3, [r7, #24]
 8010120:	1c9a      	adds	r2, r3, #2
 8010122:	61ba      	str	r2, [r7, #24]
 8010124:	697a      	ldr	r2, [r7, #20]
 8010126:	1c91      	adds	r1, r2, #2
 8010128:	6179      	str	r1, [r7, #20]
 801012a:	8812      	ldrh	r2, [r2, #0]
 801012c:	801a      	strh	r2, [r3, #0]
		{
			uint32_t extra = pxLastSource.uint32 & 0x01ul;

			pxLastSource.uint32 &= ~0x01ul;

			while( pxSource.u16 < pxLastSource.u16 )
 801012e:	697a      	ldr	r2, [r7, #20]
 8010130:	693b      	ldr	r3, [r7, #16]
 8010132:	429a      	cmp	r2, r3
 8010134:	d3f3      	bcc.n	801011e <memcpy+0x76>
			{
				*( pxDestination.u16++ ) = *( pxSource.u16++) ;
			}

			pxLastSource.uint32 |= extra;
 8010136:	693a      	ldr	r2, [r7, #16]
 8010138:	6a3b      	ldr	r3, [r7, #32]
 801013a:	4313      	orrs	r3, r2
 801013c:	613b      	str	r3, [r7, #16]
 801013e:	e09e      	b.n	801027e <memcpy+0x1d6>
		else
		{
			int iCount;
			uint32_t extra;

			if( ( ( pxSource.uint32 & 2 ) != 0 ) && ( pxSource.u8 < pxLastSource.u8 - 1 ) )
 8010140:	697b      	ldr	r3, [r7, #20]
 8010142:	f003 0302 	and.w	r3, r3, #2
 8010146:	2b00      	cmp	r3, #0
 8010148:	d00c      	beq.n	8010164 <memcpy+0xbc>
 801014a:	697a      	ldr	r2, [r7, #20]
 801014c:	693b      	ldr	r3, [r7, #16]
 801014e:	3b01      	subs	r3, #1
 8010150:	429a      	cmp	r2, r3
 8010152:	d207      	bcs.n	8010164 <memcpy+0xbc>
			{
				*( pxDestination.u16++ ) = *( pxSource.u16++) ;
 8010154:	69bb      	ldr	r3, [r7, #24]
 8010156:	1c9a      	adds	r2, r3, #2
 8010158:	61ba      	str	r2, [r7, #24]
 801015a:	697a      	ldr	r2, [r7, #20]
 801015c:	1c91      	adds	r1, r2, #2
 801015e:	6179      	str	r1, [r7, #20]
 8010160:	8812      	ldrh	r2, [r2, #0]
 8010162:	801a      	strh	r2, [r3, #0]
			}
			// 32-bit aligned
			extra = pxLastSource.uint32 & 0x03ul;
 8010164:	693b      	ldr	r3, [r7, #16]
 8010166:	f003 0303 	and.w	r3, r3, #3
 801016a:	61fb      	str	r3, [r7, #28]

			pxLastSource.uint32 &= ~0x03ul;
 801016c:	693b      	ldr	r3, [r7, #16]
 801016e:	f023 0303 	bic.w	r3, r3, #3
 8010172:	613b      	str	r3, [r7, #16]
			iCount = pxLastSource.u32 - pxSource.u32;
 8010174:	693b      	ldr	r3, [r7, #16]
 8010176:	461a      	mov	r2, r3
 8010178:	697b      	ldr	r3, [r7, #20]
 801017a:	1ad3      	subs	r3, r2, r3
 801017c:	109b      	asrs	r3, r3, #2
 801017e:	62fb      	str	r3, [r7, #44]	; 0x2c
			while( iCount > 8 )
 8010180:	e02f      	b.n	80101e2 <memcpy+0x13a>
			{
				/* Copy 32 bytes */
				/* Normally it doesn't make sense to make this list much longer because
				the indexes will get too big, and therefore longer instructions are needed. */
				pxDestination.u32[ 0 ] = pxSource.u32[ 0 ];
 8010182:	69bb      	ldr	r3, [r7, #24]
 8010184:	697a      	ldr	r2, [r7, #20]
 8010186:	6812      	ldr	r2, [r2, #0]
 8010188:	601a      	str	r2, [r3, #0]
				pxDestination.u32[ 1 ] = pxSource.u32[ 1 ];
 801018a:	69bb      	ldr	r3, [r7, #24]
 801018c:	3304      	adds	r3, #4
 801018e:	697a      	ldr	r2, [r7, #20]
 8010190:	6852      	ldr	r2, [r2, #4]
 8010192:	601a      	str	r2, [r3, #0]
				pxDestination.u32[ 2 ] = pxSource.u32[ 2 ];
 8010194:	69bb      	ldr	r3, [r7, #24]
 8010196:	3308      	adds	r3, #8
 8010198:	697a      	ldr	r2, [r7, #20]
 801019a:	6892      	ldr	r2, [r2, #8]
 801019c:	601a      	str	r2, [r3, #0]
				pxDestination.u32[ 3 ] = pxSource.u32[ 3 ];
 801019e:	69bb      	ldr	r3, [r7, #24]
 80101a0:	330c      	adds	r3, #12
 80101a2:	697a      	ldr	r2, [r7, #20]
 80101a4:	68d2      	ldr	r2, [r2, #12]
 80101a6:	601a      	str	r2, [r3, #0]
				pxDestination.u32[ 4 ] = pxSource.u32[ 4 ];
 80101a8:	69bb      	ldr	r3, [r7, #24]
 80101aa:	3310      	adds	r3, #16
 80101ac:	697a      	ldr	r2, [r7, #20]
 80101ae:	6912      	ldr	r2, [r2, #16]
 80101b0:	601a      	str	r2, [r3, #0]
				pxDestination.u32[ 5 ] = pxSource.u32[ 5 ];
 80101b2:	69bb      	ldr	r3, [r7, #24]
 80101b4:	3314      	adds	r3, #20
 80101b6:	697a      	ldr	r2, [r7, #20]
 80101b8:	6952      	ldr	r2, [r2, #20]
 80101ba:	601a      	str	r2, [r3, #0]
				pxDestination.u32[ 6 ] = pxSource.u32[ 6 ];
 80101bc:	69bb      	ldr	r3, [r7, #24]
 80101be:	3318      	adds	r3, #24
 80101c0:	697a      	ldr	r2, [r7, #20]
 80101c2:	6992      	ldr	r2, [r2, #24]
 80101c4:	601a      	str	r2, [r3, #0]
				pxDestination.u32[ 7 ] = pxSource.u32[ 7 ];
 80101c6:	69bb      	ldr	r3, [r7, #24]
 80101c8:	331c      	adds	r3, #28
 80101ca:	697a      	ldr	r2, [r7, #20]
 80101cc:	69d2      	ldr	r2, [r2, #28]
 80101ce:	601a      	str	r2, [r3, #0]
				pxDestination.u32 += 8;
 80101d0:	69bb      	ldr	r3, [r7, #24]
 80101d2:	3320      	adds	r3, #32
 80101d4:	61bb      	str	r3, [r7, #24]
				pxSource.u32 += 8;
 80101d6:	697b      	ldr	r3, [r7, #20]
 80101d8:	3320      	adds	r3, #32
 80101da:	617b      	str	r3, [r7, #20]
				iCount -= 8;
 80101dc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80101de:	3b08      	subs	r3, #8
 80101e0:	62fb      	str	r3, [r7, #44]	; 0x2c
			// 32-bit aligned
			extra = pxLastSource.uint32 & 0x03ul;

			pxLastSource.uint32 &= ~0x03ul;
			iCount = pxLastSource.u32 - pxSource.u32;
			while( iCount > 8 )
 80101e2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80101e4:	2b08      	cmp	r3, #8
 80101e6:	dccc      	bgt.n	8010182 <memcpy+0xda>
				pxDestination.u32 += 8;
				pxSource.u32 += 8;
				iCount -= 8;
			}

			while( pxSource.u32 < pxLastSource.u32 )
 80101e8:	e007      	b.n	80101fa <memcpy+0x152>
			{
				*( pxDestination.u32++ ) = *( pxSource.u32++) ;
 80101ea:	69bb      	ldr	r3, [r7, #24]
 80101ec:	1d1a      	adds	r2, r3, #4
 80101ee:	61ba      	str	r2, [r7, #24]
 80101f0:	697a      	ldr	r2, [r7, #20]
 80101f2:	1d11      	adds	r1, r2, #4
 80101f4:	6179      	str	r1, [r7, #20]
 80101f6:	6812      	ldr	r2, [r2, #0]
 80101f8:	601a      	str	r2, [r3, #0]
				pxDestination.u32 += 8;
				pxSource.u32 += 8;
				iCount -= 8;
			}

			while( pxSource.u32 < pxLastSource.u32 )
 80101fa:	697a      	ldr	r2, [r7, #20]
 80101fc:	693b      	ldr	r3, [r7, #16]
 80101fe:	429a      	cmp	r2, r3
 8010200:	d3f3      	bcc.n	80101ea <memcpy+0x142>
			{
				*( pxDestination.u32++ ) = *( pxSource.u32++) ;
			}

			pxLastSource.uint32 |= extra;
 8010202:	693a      	ldr	r2, [r7, #16]
 8010204:	69fb      	ldr	r3, [r7, #28]
 8010206:	4313      	orrs	r3, r2
 8010208:	613b      	str	r3, [r7, #16]
 801020a:	e041      	b.n	8010290 <memcpy+0x1e8>
	}
	else
	{
		/* This it the worst alignment, e.g. 0x80000 and 0xA0001,
		only 8-bits copying is possible. */
		int iCount = pxLastSource.u8 - pxSource.u8;
 801020c:	693b      	ldr	r3, [r7, #16]
 801020e:	461a      	mov	r2, r3
 8010210:	697b      	ldr	r3, [r7, #20]
 8010212:	1ad3      	subs	r3, r2, r3
 8010214:	62bb      	str	r3, [r7, #40]	; 0x28
		while( iCount > 8 )
 8010216:	e02f      	b.n	8010278 <memcpy+0x1d0>
		{
			/* Copy 8 bytes the hard way */
			pxDestination.u8[ 0 ] = pxSource.u8[ 0 ];
 8010218:	69bb      	ldr	r3, [r7, #24]
 801021a:	697a      	ldr	r2, [r7, #20]
 801021c:	7812      	ldrb	r2, [r2, #0]
 801021e:	701a      	strb	r2, [r3, #0]
			pxDestination.u8[ 1 ] = pxSource.u8[ 1 ];
 8010220:	69bb      	ldr	r3, [r7, #24]
 8010222:	3301      	adds	r3, #1
 8010224:	697a      	ldr	r2, [r7, #20]
 8010226:	7852      	ldrb	r2, [r2, #1]
 8010228:	701a      	strb	r2, [r3, #0]
			pxDestination.u8[ 2 ] = pxSource.u8[ 2 ];
 801022a:	69bb      	ldr	r3, [r7, #24]
 801022c:	3302      	adds	r3, #2
 801022e:	697a      	ldr	r2, [r7, #20]
 8010230:	7892      	ldrb	r2, [r2, #2]
 8010232:	701a      	strb	r2, [r3, #0]
			pxDestination.u8[ 3 ] = pxSource.u8[ 3 ];
 8010234:	69bb      	ldr	r3, [r7, #24]
 8010236:	3303      	adds	r3, #3
 8010238:	697a      	ldr	r2, [r7, #20]
 801023a:	78d2      	ldrb	r2, [r2, #3]
 801023c:	701a      	strb	r2, [r3, #0]
			pxDestination.u8[ 4 ] = pxSource.u8[ 4 ];
 801023e:	69bb      	ldr	r3, [r7, #24]
 8010240:	3304      	adds	r3, #4
 8010242:	697a      	ldr	r2, [r7, #20]
 8010244:	7912      	ldrb	r2, [r2, #4]
 8010246:	701a      	strb	r2, [r3, #0]
			pxDestination.u8[ 5 ] = pxSource.u8[ 5 ];
 8010248:	69bb      	ldr	r3, [r7, #24]
 801024a:	3305      	adds	r3, #5
 801024c:	697a      	ldr	r2, [r7, #20]
 801024e:	7952      	ldrb	r2, [r2, #5]
 8010250:	701a      	strb	r2, [r3, #0]
			pxDestination.u8[ 6 ] = pxSource.u8[ 6 ];
 8010252:	69bb      	ldr	r3, [r7, #24]
 8010254:	3306      	adds	r3, #6
 8010256:	697a      	ldr	r2, [r7, #20]
 8010258:	7992      	ldrb	r2, [r2, #6]
 801025a:	701a      	strb	r2, [r3, #0]
			pxDestination.u8[ 7 ] = pxSource.u8[ 7 ];
 801025c:	69bb      	ldr	r3, [r7, #24]
 801025e:	3307      	adds	r3, #7
 8010260:	697a      	ldr	r2, [r7, #20]
 8010262:	79d2      	ldrb	r2, [r2, #7]
 8010264:	701a      	strb	r2, [r3, #0]
			pxDestination.u8 += 8;
 8010266:	69bb      	ldr	r3, [r7, #24]
 8010268:	3308      	adds	r3, #8
 801026a:	61bb      	str	r3, [r7, #24]
			pxSource.u8 += 8;
 801026c:	697b      	ldr	r3, [r7, #20]
 801026e:	3308      	adds	r3, #8
 8010270:	617b      	str	r3, [r7, #20]
			iCount -= 8;
 8010272:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010274:	3b08      	subs	r3, #8
 8010276:	62bb      	str	r3, [r7, #40]	; 0x28
	else
	{
		/* This it the worst alignment, e.g. 0x80000 and 0xA0001,
		only 8-bits copying is possible. */
		int iCount = pxLastSource.u8 - pxSource.u8;
		while( iCount > 8 )
 8010278:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801027a:	2b08      	cmp	r3, #8
 801027c:	dccc      	bgt.n	8010218 <memcpy+0x170>
			pxDestination.u8 += 8;
			pxSource.u8 += 8;
			iCount -= 8;
		}
	}
	while( pxSource.u8 < pxLastSource.u8 )
 801027e:	e007      	b.n	8010290 <memcpy+0x1e8>
	{
		*( pxDestination.u8++ ) = *( pxSource.u8++ );
 8010280:	69bb      	ldr	r3, [r7, #24]
 8010282:	1c5a      	adds	r2, r3, #1
 8010284:	61ba      	str	r2, [r7, #24]
 8010286:	697a      	ldr	r2, [r7, #20]
 8010288:	1c51      	adds	r1, r2, #1
 801028a:	6179      	str	r1, [r7, #20]
 801028c:	7812      	ldrb	r2, [r2, #0]
 801028e:	701a      	strb	r2, [r3, #0]
			pxDestination.u8 += 8;
			pxSource.u8 += 8;
			iCount -= 8;
		}
	}
	while( pxSource.u8 < pxLastSource.u8 )
 8010290:	697a      	ldr	r2, [r7, #20]
 8010292:	693b      	ldr	r3, [r7, #16]
 8010294:	429a      	cmp	r2, r3
 8010296:	d3f3      	bcc.n	8010280 <memcpy+0x1d8>
	{
		*( pxDestination.u8++ ) = *( pxSource.u8++ );
	}
	return pvDest;
 8010298:	68fb      	ldr	r3, [r7, #12]
}
 801029a:	4618      	mov	r0, r3
 801029c:	3734      	adds	r7, #52	; 0x34
 801029e:	46bd      	mov	sp, r7
 80102a0:	f85d 7b04 	ldr.w	r7, [sp], #4
 80102a4:	4770      	bx	lr
 80102a6:	bf00      	nop

080102a8 <memset>:
/*-----------------------------------------------------------*/


#if( SIMPLE_MEMSET == 0 )
void *memset(void *pvDest, int iValue, size_t ulBytes)
{
 80102a8:	b480      	push	{r7}
 80102aa:	b08b      	sub	sp, #44	; 0x2c
 80102ac:	af00      	add	r7, sp, #0
 80102ae:	60f8      	str	r0, [r7, #12]
 80102b0:	60b9      	str	r1, [r7, #8]
 80102b2:	607a      	str	r2, [r7, #4]
union xPointer pxDestination;
union xPointer pxLast;
uint32_t ulPattern;

	pxDestination.u8 = ( unsigned char * ) pvDest;
 80102b4:	68fb      	ldr	r3, [r7, #12]
 80102b6:	617b      	str	r3, [r7, #20]
	pxLast.u8 = pxDestination.u8 + ulBytes;
 80102b8:	697a      	ldr	r2, [r7, #20]
 80102ba:	687b      	ldr	r3, [r7, #4]
 80102bc:	4413      	add	r3, r2
 80102be:	613b      	str	r3, [r7, #16]

	if( ulBytes >= 8 )
 80102c0:	687b      	ldr	r3, [r7, #4]
 80102c2:	2b07      	cmp	r3, #7
 80102c4:	d96a      	bls.n	801039c <memset+0xf4>
	{
	uint32_t ulAlignBits;
	uint32_t ulExtra;
	int iCount;

		ulPattern = iValue & 0xff;
 80102c6:	68bb      	ldr	r3, [r7, #8]
 80102c8:	b2db      	uxtb	r3, r3
 80102ca:	61fb      	str	r3, [r7, #28]
		ulPattern |= ( ulPattern << 8 ) | ( ulPattern << 16 ) | ( ulPattern << 24 );
 80102cc:	69fb      	ldr	r3, [r7, #28]
 80102ce:	021a      	lsls	r2, r3, #8
 80102d0:	69fb      	ldr	r3, [r7, #28]
 80102d2:	041b      	lsls	r3, r3, #16
 80102d4:	431a      	orrs	r2, r3
 80102d6:	69fb      	ldr	r3, [r7, #28]
 80102d8:	061b      	lsls	r3, r3, #24
 80102da:	4313      	orrs	r3, r2
 80102dc:	69fa      	ldr	r2, [r7, #28]
 80102de:	4313      	orrs	r3, r2
 80102e0:	61fb      	str	r3, [r7, #28]
		ulAlignBits = ( pxDestination.uint32 & 0x03 );
 80102e2:	697b      	ldr	r3, [r7, #20]
 80102e4:	f003 0303 	and.w	r3, r3, #3
 80102e8:	627b      	str	r3, [r7, #36]	; 0x24
		if( ulAlignBits != 0 )
 80102ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80102ec:	2b00      	cmp	r3, #0
 80102ee:	d010      	beq.n	8010312 <memset+0x6a>
		{
			ulAlignBits = 4 - ulAlignBits;
 80102f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80102f2:	f1c3 0304 	rsb	r3, r3, #4
 80102f6:	627b      	str	r3, [r7, #36]	; 0x24
			while( ulAlignBits-- > 0 )
 80102f8:	e006      	b.n	8010308 <memset+0x60>
			{
				pxDestination.u8[ 0 ] = ( unsigned char )iValue;
 80102fa:	697b      	ldr	r3, [r7, #20]
 80102fc:	68ba      	ldr	r2, [r7, #8]
 80102fe:	b2d2      	uxtb	r2, r2
 8010300:	701a      	strb	r2, [r3, #0]
				pxDestination.u8++;
 8010302:	697b      	ldr	r3, [r7, #20]
 8010304:	3301      	adds	r3, #1
 8010306:	617b      	str	r3, [r7, #20]
		ulPattern |= ( ulPattern << 8 ) | ( ulPattern << 16 ) | ( ulPattern << 24 );
		ulAlignBits = ( pxDestination.uint32 & 0x03 );
		if( ulAlignBits != 0 )
		{
			ulAlignBits = 4 - ulAlignBits;
			while( ulAlignBits-- > 0 )
 8010308:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801030a:	1e5a      	subs	r2, r3, #1
 801030c:	627a      	str	r2, [r7, #36]	; 0x24
 801030e:	2b00      	cmp	r3, #0
 8010310:	d1f3      	bne.n	80102fa <memset+0x52>
				pxDestination.u8++;
			}
		}
		/* Strip-off the last 1 up-to 3 bytes because they can not be set in a 32-bit
		memory instruction. */
		ulExtra = pxLast.uint32 & 0x03ul;
 8010312:	693b      	ldr	r3, [r7, #16]
 8010314:	f003 0303 	and.w	r3, r3, #3
 8010318:	61bb      	str	r3, [r7, #24]

		pxLast.uint32 &= ~0x03ul;
 801031a:	693b      	ldr	r3, [r7, #16]
 801031c:	f023 0303 	bic.w	r3, r3, #3
 8010320:	613b      	str	r3, [r7, #16]
		iCount = ( int ) ( pxLast.u32 - pxDestination.u32 );
 8010322:	693b      	ldr	r3, [r7, #16]
 8010324:	461a      	mov	r2, r3
 8010326:	697b      	ldr	r3, [r7, #20]
 8010328:	1ad3      	subs	r3, r2, r3
 801032a:	109b      	asrs	r3, r3, #2
 801032c:	623b      	str	r3, [r7, #32]
		while( iCount > 8 )
 801032e:	e024      	b.n	801037a <memset+0xd2>
		{
			/* Set 8 * 4 bytes and save some increments */
			/* It won't make sense to make this list much longer than 8 assignments. */
			pxDestination.u32[ 0 ] = ulPattern;
 8010330:	697b      	ldr	r3, [r7, #20]
 8010332:	69fa      	ldr	r2, [r7, #28]
 8010334:	601a      	str	r2, [r3, #0]
			pxDestination.u32[ 1 ] = ulPattern;
 8010336:	697b      	ldr	r3, [r7, #20]
 8010338:	3304      	adds	r3, #4
 801033a:	69fa      	ldr	r2, [r7, #28]
 801033c:	601a      	str	r2, [r3, #0]
			pxDestination.u32[ 2 ] = ulPattern;
 801033e:	697b      	ldr	r3, [r7, #20]
 8010340:	3308      	adds	r3, #8
 8010342:	69fa      	ldr	r2, [r7, #28]
 8010344:	601a      	str	r2, [r3, #0]
			pxDestination.u32[ 3 ] = ulPattern;
 8010346:	697b      	ldr	r3, [r7, #20]
 8010348:	330c      	adds	r3, #12
 801034a:	69fa      	ldr	r2, [r7, #28]
 801034c:	601a      	str	r2, [r3, #0]
			pxDestination.u32[ 4 ] = ulPattern;
 801034e:	697b      	ldr	r3, [r7, #20]
 8010350:	3310      	adds	r3, #16
 8010352:	69fa      	ldr	r2, [r7, #28]
 8010354:	601a      	str	r2, [r3, #0]
			pxDestination.u32[ 5 ] = ulPattern;
 8010356:	697b      	ldr	r3, [r7, #20]
 8010358:	3314      	adds	r3, #20
 801035a:	69fa      	ldr	r2, [r7, #28]
 801035c:	601a      	str	r2, [r3, #0]
			pxDestination.u32[ 6 ] = ulPattern;
 801035e:	697b      	ldr	r3, [r7, #20]
 8010360:	3318      	adds	r3, #24
 8010362:	69fa      	ldr	r2, [r7, #28]
 8010364:	601a      	str	r2, [r3, #0]
			pxDestination.u32[ 7 ] = ulPattern;
 8010366:	697b      	ldr	r3, [r7, #20]
 8010368:	331c      	adds	r3, #28
 801036a:	69fa      	ldr	r2, [r7, #28]
 801036c:	601a      	str	r2, [r3, #0]
			pxDestination.u32 += 8;
 801036e:	697b      	ldr	r3, [r7, #20]
 8010370:	3320      	adds	r3, #32
 8010372:	617b      	str	r3, [r7, #20]
			iCount -= 8;
 8010374:	6a3b      	ldr	r3, [r7, #32]
 8010376:	3b08      	subs	r3, #8
 8010378:	623b      	str	r3, [r7, #32]
		memory instruction. */
		ulExtra = pxLast.uint32 & 0x03ul;

		pxLast.uint32 &= ~0x03ul;
		iCount = ( int ) ( pxLast.u32 - pxDestination.u32 );
		while( iCount > 8 )
 801037a:	6a3b      	ldr	r3, [r7, #32]
 801037c:	2b08      	cmp	r3, #8
 801037e:	dcd7      	bgt.n	8010330 <memset+0x88>
			pxDestination.u32[ 7 ] = ulPattern;
			pxDestination.u32 += 8;
			iCount -= 8;
		}

		while( pxDestination.u32 < pxLast.u32 )
 8010380:	e004      	b.n	801038c <memset+0xe4>
		{
			*( pxDestination.u32++ ) = ulPattern;
 8010382:	697b      	ldr	r3, [r7, #20]
 8010384:	1d1a      	adds	r2, r3, #4
 8010386:	617a      	str	r2, [r7, #20]
 8010388:	69fa      	ldr	r2, [r7, #28]
 801038a:	601a      	str	r2, [r3, #0]
			pxDestination.u32[ 7 ] = ulPattern;
			pxDestination.u32 += 8;
			iCount -= 8;
		}

		while( pxDestination.u32 < pxLast.u32 )
 801038c:	697a      	ldr	r2, [r7, #20]
 801038e:	693b      	ldr	r3, [r7, #16]
 8010390:	429a      	cmp	r2, r3
 8010392:	d3f6      	bcc.n	8010382 <memset+0xda>
		{
			*( pxDestination.u32++ ) = ulPattern;
		}

		pxLast.uint32 |= ulExtra;
 8010394:	693a      	ldr	r2, [r7, #16]
 8010396:	69bb      	ldr	r3, [r7, #24]
 8010398:	4313      	orrs	r3, r2
 801039a:	613b      	str	r3, [r7, #16]
	}

	while( pxDestination.u8 < pxLast.u8 )
 801039c:	e006      	b.n	80103ac <memset+0x104>
	{
		pxDestination.u8[ 0 ] = ( unsigned char ) iValue;
 801039e:	697b      	ldr	r3, [r7, #20]
 80103a0:	68ba      	ldr	r2, [r7, #8]
 80103a2:	b2d2      	uxtb	r2, r2
 80103a4:	701a      	strb	r2, [r3, #0]
		pxDestination.u8++;
 80103a6:	697b      	ldr	r3, [r7, #20]
 80103a8:	3301      	adds	r3, #1
 80103aa:	617b      	str	r3, [r7, #20]
		}

		pxLast.uint32 |= ulExtra;
	}

	while( pxDestination.u8 < pxLast.u8 )
 80103ac:	697a      	ldr	r2, [r7, #20]
 80103ae:	693b      	ldr	r3, [r7, #16]
 80103b0:	429a      	cmp	r2, r3
 80103b2:	d3f4      	bcc.n	801039e <memset+0xf6>
	{
		pxDestination.u8[ 0 ] = ( unsigned char ) iValue;
		pxDestination.u8++;
	}

	return pvDest;
 80103b4:	68fb      	ldr	r3, [r7, #12]
}
 80103b6:	4618      	mov	r0, r3
 80103b8:	372c      	adds	r7, #44	; 0x2c
 80103ba:	46bd      	mov	sp, r7
 80103bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 80103c0:	4770      	bx	lr
 80103c2:	bf00      	nop

080103c4 <TIM2_IRQHandler>:

static uint32_t ulInterruptCount = 0;

uint32_t ulTimer2Flags;
void TIM2_IRQHandler(void)
{
 80103c4:	b480      	push	{r7}
 80103c6:	af00      	add	r7, sp, #0
	ulTimer2Flags = tim2_handle.Instance->SR;
 80103c8:	4b0c      	ldr	r3, [pc, #48]	; (80103fc <TIM2_IRQHandler+0x38>)
 80103ca:	681b      	ldr	r3, [r3, #0]
 80103cc:	691b      	ldr	r3, [r3, #16]
 80103ce:	4a0c      	ldr	r2, [pc, #48]	; (8010400 <TIM2_IRQHandler+0x3c>)
 80103d0:	6013      	str	r3, [r2, #0]
	if( ( ulTimer2Flags & TIM_FLAG_UPDATE ) != 0 )
 80103d2:	4b0b      	ldr	r3, [pc, #44]	; (8010400 <TIM2_IRQHandler+0x3c>)
 80103d4:	681b      	ldr	r3, [r3, #0]
 80103d6:	f003 0301 	and.w	r3, r3, #1
 80103da:	2b00      	cmp	r3, #0
 80103dc:	d009      	beq.n	80103f2 <TIM2_IRQHandler+0x2e>
	{
		__HAL_TIM_CLEAR_FLAG( &tim2_handle, TIM_FLAG_UPDATE );
 80103de:	4b07      	ldr	r3, [pc, #28]	; (80103fc <TIM2_IRQHandler+0x38>)
 80103e0:	681b      	ldr	r3, [r3, #0]
 80103e2:	f06f 0201 	mvn.w	r2, #1
 80103e6:	611a      	str	r2, [r3, #16]
		ulInterruptCount++;
 80103e8:	4b06      	ldr	r3, [pc, #24]	; (8010404 <TIM2_IRQHandler+0x40>)
 80103ea:	681b      	ldr	r3, [r3, #0]
 80103ec:	3301      	adds	r3, #1
 80103ee:	4a05      	ldr	r2, [pc, #20]	; (8010404 <TIM2_IRQHandler+0x40>)
 80103f0:	6013      	str	r3, [r2, #0]
	}
}
 80103f2:	46bd      	mov	sp, r7
 80103f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 80103f8:	4770      	bx	lr
 80103fa:	bf00      	nop
 80103fc:	2000cf90 	.word	0x2000cf90
 8010400:	2000cf8c 	.word	0x2000cf8c
 8010404:	2000c4f8 	.word	0x2000c4f8

08010408 <vStartHighResolutionTimer>:


/* Timer2 initialization function */
void vStartHighResolutionTimer( void )
{
 8010408:	b580      	push	{r7, lr}
 801040a:	b082      	sub	sp, #8
 801040c:	af00      	add	r7, sp, #0
	/* TIM2 clock enable */
	__HAL_RCC_TIM2_CLK_ENABLE();
 801040e:	4a1d      	ldr	r2, [pc, #116]	; (8010484 <vStartHighResolutionTimer+0x7c>)
 8010410:	4b1c      	ldr	r3, [pc, #112]	; (8010484 <vStartHighResolutionTimer+0x7c>)
 8010412:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010414:	f043 0301 	orr.w	r3, r3, #1
 8010418:	6413      	str	r3, [r2, #64]	; 0x40
 801041a:	4b1a      	ldr	r3, [pc, #104]	; (8010484 <vStartHighResolutionTimer+0x7c>)
 801041c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801041e:	f003 0301 	and.w	r3, r3, #1
 8010422:	607b      	str	r3, [r7, #4]
 8010424:	687b      	ldr	r3, [r7, #4]

	tim2_handle.Instance = TIM2;     /* Register base address             */
 8010426:	4b18      	ldr	r3, [pc, #96]	; (8010488 <vStartHighResolutionTimer+0x80>)
 8010428:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 801042c:	601a      	str	r2, [r3, #0]

	tim2_handle.Init.Prescaler = ( ulPrescale - 1ul );			/* Specifies the prescaler value used to divide the TIM clock. */
 801042e:	2354      	movs	r3, #84	; 0x54
 8010430:	3b01      	subs	r3, #1
 8010432:	4a15      	ldr	r2, [pc, #84]	; (8010488 <vStartHighResolutionTimer+0x80>)
 8010434:	6053      	str	r3, [r2, #4]
	tim2_handle.Init.CounterMode = TIM_COUNTERMODE_UP;			/* Specifies the counter mode. */
 8010436:	4b14      	ldr	r3, [pc, #80]	; (8010488 <vStartHighResolutionTimer+0x80>)
 8010438:	2200      	movs	r2, #0
 801043a:	609a      	str	r2, [r3, #8]
	tim2_handle.Init.Period = ( ulReloadCount - 1ul );			/* Specifies the period value to be loaded into the active. */
 801043c:	4b13      	ldr	r3, [pc, #76]	; (801048c <vStartHighResolutionTimer+0x84>)
 801043e:	3b01      	subs	r3, #1
 8010440:	4a11      	ldr	r2, [pc, #68]	; (8010488 <vStartHighResolutionTimer+0x80>)
 8010442:	60d3      	str	r3, [r2, #12]
	tim2_handle.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;	/* Specifies the clock division. */
 8010444:	4b10      	ldr	r3, [pc, #64]	; (8010488 <vStartHighResolutionTimer+0x80>)
 8010446:	2200      	movs	r2, #0
 8010448:	611a      	str	r2, [r3, #16]
	tim2_handle.Init.RepetitionCounter = 0ul;					/* Specifies the repetition counter value. */
 801044a:	4b0f      	ldr	r3, [pc, #60]	; (8010488 <vStartHighResolutionTimer+0x80>)
 801044c:	2200      	movs	r2, #0
 801044e:	615a      	str	r2, [r3, #20]
	tim2_handle.Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8010450:	4b0d      	ldr	r3, [pc, #52]	; (8010488 <vStartHighResolutionTimer+0x80>)
 8010452:	2201      	movs	r2, #1
 8010454:	761a      	strb	r2, [r3, #24]

	/* NVIC configuration for DMA transfer complete interrupt */
	HAL_NVIC_SetPriority( TIM2_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY + 1, 0 );
 8010456:	201c      	movs	r0, #28
 8010458:	2106      	movs	r1, #6
 801045a:	2200      	movs	r2, #0
 801045c:	f7f0 fac6 	bl	80009ec <HAL_NVIC_SetPriority>
	HAL_NVIC_EnableIRQ( TIM2_IRQn );
 8010460:	201c      	movs	r0, #28
 8010462:	f7f0 fadf 	bl	8000a24 <HAL_NVIC_EnableIRQ>


	HAL_TIM_Base_Init( &tim2_handle );
 8010466:	4808      	ldr	r0, [pc, #32]	; (8010488 <vStartHighResolutionTimer+0x80>)
 8010468:	f7f2 f90e 	bl	8002688 <HAL_TIM_Base_Init>
	HAL_TIM_Base_Start_IT( &tim2_handle );
 801046c:	4806      	ldr	r0, [pc, #24]	; (8010488 <vStartHighResolutionTimer+0x80>)
 801046e:	f7f2 f93d 	bl	80026ec <HAL_TIM_Base_Start_IT>
	ulTimer2Flags = tim2_handle.Instance->SR;
 8010472:	4b05      	ldr	r3, [pc, #20]	; (8010488 <vStartHighResolutionTimer+0x80>)
 8010474:	681b      	ldr	r3, [r3, #0]
 8010476:	691b      	ldr	r3, [r3, #16]
 8010478:	4a05      	ldr	r2, [pc, #20]	; (8010490 <vStartHighResolutionTimer+0x88>)
 801047a:	6013      	str	r3, [r2, #0]
}
 801047c:	3708      	adds	r7, #8
 801047e:	46bd      	mov	sp, r7
 8010480:	bd80      	pop	{r7, pc}
 8010482:	bf00      	nop
 8010484:	40023800 	.word	0x40023800
 8010488:	2000cf90 	.word	0x2000cf90
 801048c:	00989680 	.word	0x00989680
 8010490:	2000cf8c 	.word	0x2000cf8c

08010494 <ullGetHighResolutionTime>:

uint64_t ullGetHighResolutionTime()
{
 8010494:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 8010498:	b086      	sub	sp, #24
 801049a:	af00      	add	r7, sp, #0
uint64_t ullReturn;
	if( tim2_handle.Instance == NULL )
 801049c:	4b2e      	ldr	r3, [pc, #184]	; (8010558 <ullGetHighResolutionTime+0xc4>)
 801049e:	681b      	ldr	r3, [r3, #0]
 80104a0:	2b00      	cmp	r3, #0
 80104a2:	d124      	bne.n	80104ee <ullGetHighResolutionTime+0x5a>
	{
		ullReturn = 1000ull * xTaskGetTickCount();
 80104a4:	f7f5 f86e 	bl	8005584 <xTaskGetTickCount>
 80104a8:	4603      	mov	r3, r0
 80104aa:	4618      	mov	r0, r3
 80104ac:	f04f 0100 	mov.w	r1, #0
 80104b0:	4602      	mov	r2, r0
 80104b2:	460b      	mov	r3, r1
 80104b4:	ea4f 0b83 	mov.w	fp, r3, lsl #2
 80104b8:	ea4b 7b92 	orr.w	fp, fp, r2, lsr #30
 80104bc:	ea4f 0a82 	mov.w	sl, r2, lsl #2
 80104c0:	4652      	mov	r2, sl
 80104c2:	465b      	mov	r3, fp
 80104c4:	015d      	lsls	r5, r3, #5
 80104c6:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 80104ca:	0154      	lsls	r4, r2, #5
 80104cc:	1aa4      	subs	r4, r4, r2
 80104ce:	eb65 0503 	sbc.w	r5, r5, r3
 80104d2:	1824      	adds	r4, r4, r0
 80104d4:	eb45 0501 	adc.w	r5, r5, r1
 80104d8:	ea4f 09c5 	mov.w	r9, r5, lsl #3
 80104dc:	ea49 7954 	orr.w	r9, r9, r4, lsr #29
 80104e0:	ea4f 08c4 	mov.w	r8, r4, lsl #3
 80104e4:	4644      	mov	r4, r8
 80104e6:	464d      	mov	r5, r9
 80104e8:	e9c7 4504 	strd	r4, r5, [r7, #16]
 80104ec:	e02b      	b.n	8010546 <ullGetHighResolutionTime+0xb2>
	uint32_t ulCounts[2];
	uint32_t ulSlowCount;

		for( ;; )
		{
			ulCounts[ 0 ] = tim2_handle.Instance->CNT;
 80104ee:	4b1a      	ldr	r3, [pc, #104]	; (8010558 <ullGetHighResolutionTime+0xc4>)
 80104f0:	681b      	ldr	r3, [r3, #0]
 80104f2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80104f4:	607b      	str	r3, [r7, #4]
			ulSlowCount = ulInterruptCount;
 80104f6:	4b19      	ldr	r3, [pc, #100]	; (801055c <ullGetHighResolutionTime+0xc8>)
 80104f8:	681b      	ldr	r3, [r3, #0]
 80104fa:	60fb      	str	r3, [r7, #12]
			ulCounts[ 1 ] = tim2_handle.Instance->CNT;
 80104fc:	4b16      	ldr	r3, [pc, #88]	; (8010558 <ullGetHighResolutionTime+0xc4>)
 80104fe:	681b      	ldr	r3, [r3, #0]
 8010500:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8010502:	60bb      	str	r3, [r7, #8]
			if( ulCounts[ 1 ] >= ulCounts[ 0 ] )
 8010504:	68ba      	ldr	r2, [r7, #8]
 8010506:	687b      	ldr	r3, [r7, #4]
 8010508:	429a      	cmp	r2, r3
 801050a:	d31b      	bcc.n	8010544 <ullGetHighResolutionTime+0xb0>
			{
				/* TIM2_IRQHandler() has not occurred in between. */
				break;
 801050c:	bf00      	nop
			}
		}
		ullReturn = ( uint64_t )ulSlowCount * ulReloadCount + ulCounts[ 1 ];
 801050e:	68fb      	ldr	r3, [r7, #12]
 8010510:	4618      	mov	r0, r3
 8010512:	f04f 0100 	mov.w	r1, #0
 8010516:	4b12      	ldr	r3, [pc, #72]	; (8010560 <ullGetHighResolutionTime+0xcc>)
 8010518:	461a      	mov	r2, r3
 801051a:	f04f 0300 	mov.w	r3, #0
 801051e:	fb02 f501 	mul.w	r5, r2, r1
 8010522:	fb00 f403 	mul.w	r4, r0, r3
 8010526:	442c      	add	r4, r5
 8010528:	fba0 2302 	umull	r2, r3, r0, r2
 801052c:	18e1      	adds	r1, r4, r3
 801052e:	460b      	mov	r3, r1
 8010530:	68b9      	ldr	r1, [r7, #8]
 8010532:	4608      	mov	r0, r1
 8010534:	f04f 0100 	mov.w	r1, #0
 8010538:	1812      	adds	r2, r2, r0
 801053a:	eb43 0301 	adc.w	r3, r3, r1
 801053e:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8010542:	e000      	b.n	8010546 <ullGetHighResolutionTime+0xb2>
			if( ulCounts[ 1 ] >= ulCounts[ 0 ] )
			{
				/* TIM2_IRQHandler() has not occurred in between. */
				break;
			}
		}
 8010544:	e7d3      	b.n	80104ee <ullGetHighResolutionTime+0x5a>
		ullReturn = ( uint64_t )ulSlowCount * ulReloadCount + ulCounts[ 1 ];
	}

	return ullReturn;
 8010546:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
}
 801054a:	4610      	mov	r0, r2
 801054c:	4619      	mov	r1, r3
 801054e:	3718      	adds	r7, #24
 8010550:	46bd      	mov	sp, r7
 8010552:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 8010556:	bf00      	nop
 8010558:	2000cf90 	.word	0x2000cf90
 801055c:	2000c4f8 	.word	0x2000c4f8
 8010560:	00989680 	.word	0x00989680

08010564 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8010564:	b580      	push	{r7, lr}
 8010566:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8010568:	2003      	movs	r0, #3
 801056a:	f7f0 fa35 	bl	80009d8 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 801056e:	f06f 000b 	mvn.w	r0, #11
 8010572:	2100      	movs	r1, #0
 8010574:	2200      	movs	r2, #0
 8010576:	f7f0 fa39 	bl	80009ec <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 801057a:	f06f 000a 	mvn.w	r0, #10
 801057e:	2100      	movs	r1, #0
 8010580:	2200      	movs	r2, #0
 8010582:	f7f0 fa33 	bl	80009ec <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 8010586:	f06f 0009 	mvn.w	r0, #9
 801058a:	2100      	movs	r1, #0
 801058c:	2200      	movs	r2, #0
 801058e:	f7f0 fa2d 	bl	80009ec <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 8010592:	f06f 0004 	mvn.w	r0, #4
 8010596:	2100      	movs	r1, #0
 8010598:	2200      	movs	r2, #0
 801059a:	f7f0 fa27 	bl	80009ec <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 801059e:	f06f 0003 	mvn.w	r0, #3
 80105a2:	2100      	movs	r1, #0
 80105a4:	2200      	movs	r2, #0
 80105a6:	f7f0 fa21 	bl	80009ec <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80105aa:	f06f 0001 	mvn.w	r0, #1
 80105ae:	210f      	movs	r1, #15
 80105b0:	2200      	movs	r2, #0
 80105b2:	f7f0 fa1b 	bl	80009ec <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 80105b6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80105ba:	210f      	movs	r1, #15
 80105bc:	2200      	movs	r2, #0
 80105be:	f7f0 fa15 	bl	80009ec <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80105c2:	bd80      	pop	{r7, pc}

080105c4 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
{
 80105c4:	b480      	push	{r7}
 80105c6:	b083      	sub	sp, #12
 80105c8:	af00      	add	r7, sp, #0
 80105ca:	6078      	str	r0, [r7, #4]

  if(hrtc->Instance==RTC)
 80105cc:	687b      	ldr	r3, [r7, #4]
 80105ce:	681b      	ldr	r3, [r3, #0]
 80105d0:	4a06      	ldr	r2, [pc, #24]	; (80105ec <HAL_RTC_MspInit+0x28>)
 80105d2:	4293      	cmp	r3, r2
 80105d4:	d105      	bne.n	80105e2 <HAL_RTC_MspInit+0x1e>
  {
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RTC_ENABLE();
 80105d6:	4a06      	ldr	r2, [pc, #24]	; (80105f0 <HAL_RTC_MspInit+0x2c>)
 80105d8:	4b05      	ldr	r3, [pc, #20]	; (80105f0 <HAL_RTC_MspInit+0x2c>)
 80105da:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80105dc:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80105e0:	6713      	str	r3, [r2, #112]	; 0x70
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }

}
 80105e2:	370c      	adds	r7, #12
 80105e4:	46bd      	mov	sp, r7
 80105e6:	f85d 7b04 	ldr.w	r7, [sp], #4
 80105ea:	4770      	bx	lr
 80105ec:	40002800 	.word	0x40002800
 80105f0:	40023800 	.word	0x40023800

080105f4 <HAL_RNG_MspInit>:
}

/* USER CODE BEGIN 1 */

void HAL_RNG_MspInit(RNG_HandleTypeDef* hrng)
{
 80105f4:	b480      	push	{r7}
 80105f6:	b085      	sub	sp, #20
 80105f8:	af00      	add	r7, sp, #0
 80105fa:	6078      	str	r0, [r7, #4]
    __HAL_RCC_RNG_CLK_ENABLE();
 80105fc:	4a10      	ldr	r2, [pc, #64]	; (8010640 <HAL_RNG_MspInit+0x4c>)
 80105fe:	4b10      	ldr	r3, [pc, #64]	; (8010640 <HAL_RNG_MspInit+0x4c>)
 8010600:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8010602:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8010606:	6353      	str	r3, [r2, #52]	; 0x34
 8010608:	4b0d      	ldr	r3, [pc, #52]	; (8010640 <HAL_RNG_MspInit+0x4c>)
 801060a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801060c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010610:	60fb      	str	r3, [r7, #12]
 8010612:	68fb      	ldr	r3, [r7, #12]
  if(hrng->Instance==RNG)
 8010614:	687b      	ldr	r3, [r7, #4]
 8010616:	681b      	ldr	r3, [r3, #0]
 8010618:	4a0a      	ldr	r2, [pc, #40]	; (8010644 <HAL_RNG_MspInit+0x50>)
 801061a:	4293      	cmp	r3, r2
 801061c:	d10b      	bne.n	8010636 <HAL_RNG_MspInit+0x42>
  {
  /* USER CODE BEGIN RNG_MspInit 0 */

  /* USER CODE END RNG_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_RNG_CLK_ENABLE();
 801061e:	4a08      	ldr	r2, [pc, #32]	; (8010640 <HAL_RNG_MspInit+0x4c>)
 8010620:	4b07      	ldr	r3, [pc, #28]	; (8010640 <HAL_RNG_MspInit+0x4c>)
 8010622:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8010624:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8010628:	6353      	str	r3, [r2, #52]	; 0x34
 801062a:	4b05      	ldr	r3, [pc, #20]	; (8010640 <HAL_RNG_MspInit+0x4c>)
 801062c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 801062e:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8010632:	60bb      	str	r3, [r7, #8]
 8010634:	68bb      	ldr	r3, [r7, #8]
  /* USER CODE BEGIN RNG_MspInit 1 */

  /* USER CODE END RNG_MspInit 1 */
  }

}
 8010636:	3714      	adds	r7, #20
 8010638:	46bd      	mov	sp, r7
 801063a:	f85d 7b04 	ldr.w	r7, [sp], #4
 801063e:	4770      	bx	lr
 8010640:	40023800 	.word	0x40023800
 8010644:	50060800 	.word	0x50060800

08010648 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priorty.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8010648:	b580      	push	{r7, lr}
 801064a:	b08c      	sub	sp, #48	; 0x30
 801064c:	af00      	add	r7, sp, #0
 801064e:	6078      	str	r0, [r7, #4]
  RCC_ClkInitTypeDef    clkconfig;
  uint32_t              uwTimclock = 0;
 8010650:	2300      	movs	r3, #0
 8010652:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t              uwPrescalerValue = 0;
 8010654:	2300      	movs	r3, #0
 8010656:	62bb      	str	r3, [r7, #40]	; 0x28
  uint32_t              pFLatency;
  
  /*Configure the TIM13 IRQ priority */
  HAL_NVIC_SetPriority(TIM8_UP_TIM13_IRQn, TickPriority ,0); 
 8010658:	202c      	movs	r0, #44	; 0x2c
 801065a:	6879      	ldr	r1, [r7, #4]
 801065c:	2200      	movs	r2, #0
 801065e:	f7f0 f9c5 	bl	80009ec <HAL_NVIC_SetPriority>
  
  /* Enable the TIM13 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM8_UP_TIM13_IRQn); 
 8010662:	202c      	movs	r0, #44	; 0x2c
 8010664:	f7f0 f9de 	bl	8000a24 <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM13 clock */
  __HAL_RCC_TIM13_CLK_ENABLE();
 8010668:	4a1f      	ldr	r2, [pc, #124]	; (80106e8 <HAL_InitTick+0xa0>)
 801066a:	4b1f      	ldr	r3, [pc, #124]	; (80106e8 <HAL_InitTick+0xa0>)
 801066c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 801066e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8010672:	6413      	str	r3, [r2, #64]	; 0x40
 8010674:	4b1c      	ldr	r3, [pc, #112]	; (80106e8 <HAL_InitTick+0xa0>)
 8010676:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8010678:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801067c:	60fb      	str	r3, [r7, #12]
 801067e:	68fb      	ldr	r3, [r7, #12]
  
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8010680:	f107 0214 	add.w	r2, r7, #20
 8010684:	f107 0310 	add.w	r3, r7, #16
 8010688:	4610      	mov	r0, r2
 801068a:	4619      	mov	r1, r3
 801068c:	f7f1 f84a 	bl	8001724 <HAL_RCC_GetClockConfig>
  
  /* Compute TIM13 clock */
  uwTimclock = 2*HAL_RCC_GetPCLK1Freq();
 8010690:	f7f1 f826 	bl	80016e0 <HAL_RCC_GetPCLK1Freq>
 8010694:	4603      	mov	r3, r0
 8010696:	005b      	lsls	r3, r3, #1
 8010698:	62fb      	str	r3, [r7, #44]	; 0x2c
   
  /* Compute the prescaler value to have TIM13 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 801069a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801069c:	4a13      	ldr	r2, [pc, #76]	; (80106ec <HAL_InitTick+0xa4>)
 801069e:	fba2 2303 	umull	r2, r3, r2, r3
 80106a2:	0c9b      	lsrs	r3, r3, #18
 80106a4:	3b01      	subs	r3, #1
 80106a6:	62bb      	str	r3, [r7, #40]	; 0x28
  
  /* Initialize TIM13 */
  htim13.Instance = TIM13;
 80106a8:	4b11      	ldr	r3, [pc, #68]	; (80106f0 <HAL_InitTick+0xa8>)
 80106aa:	4a12      	ldr	r2, [pc, #72]	; (80106f4 <HAL_InitTick+0xac>)
 80106ac:	601a      	str	r2, [r3, #0]
  + Period = [(TIM13CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim13.Init.Period = (1000000 / 1000) - 1;
 80106ae:	4b10      	ldr	r3, [pc, #64]	; (80106f0 <HAL_InitTick+0xa8>)
 80106b0:	f240 32e7 	movw	r2, #999	; 0x3e7
 80106b4:	60da      	str	r2, [r3, #12]
  htim13.Init.Prescaler = uwPrescalerValue;
 80106b6:	4a0e      	ldr	r2, [pc, #56]	; (80106f0 <HAL_InitTick+0xa8>)
 80106b8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80106ba:	6053      	str	r3, [r2, #4]
  htim13.Init.ClockDivision = 0;
 80106bc:	4b0c      	ldr	r3, [pc, #48]	; (80106f0 <HAL_InitTick+0xa8>)
 80106be:	2200      	movs	r2, #0
 80106c0:	611a      	str	r2, [r3, #16]
  htim13.Init.CounterMode = TIM_COUNTERMODE_UP;
 80106c2:	4b0b      	ldr	r3, [pc, #44]	; (80106f0 <HAL_InitTick+0xa8>)
 80106c4:	2200      	movs	r2, #0
 80106c6:	609a      	str	r2, [r3, #8]
  if(HAL_TIM_Base_Init(&htim13) == HAL_OK)
 80106c8:	4809      	ldr	r0, [pc, #36]	; (80106f0 <HAL_InitTick+0xa8>)
 80106ca:	f7f1 ffdd 	bl	8002688 <HAL_TIM_Base_Init>
 80106ce:	4603      	mov	r3, r0
 80106d0:	2b00      	cmp	r3, #0
 80106d2:	d104      	bne.n	80106de <HAL_InitTick+0x96>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim13);
 80106d4:	4806      	ldr	r0, [pc, #24]	; (80106f0 <HAL_InitTick+0xa8>)
 80106d6:	f7f2 f809 	bl	80026ec <HAL_TIM_Base_Start_IT>
 80106da:	4603      	mov	r3, r0
 80106dc:	e000      	b.n	80106e0 <HAL_InitTick+0x98>
  }
  
  /* Return function status */
  return HAL_ERROR;
 80106de:	2301      	movs	r3, #1
}
 80106e0:	4618      	mov	r0, r3
 80106e2:	3730      	adds	r7, #48	; 0x30
 80106e4:	46bd      	mov	sp, r7
 80106e6:	bd80      	pop	{r7, pc}
 80106e8:	40023800 	.word	0x40023800
 80106ec:	431bde83 	.word	0x431bde83
 80106f0:	2000cfcc 	.word	0x2000cfcc
 80106f4:	40001c00 	.word	0x40001c00

080106f8 <NMI_Handler>:
  * @brief  This function handles NMI exception.
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
 80106f8:	b480      	push	{r7}
 80106fa:	af00      	add	r7, sp, #0
}
 80106fc:	46bd      	mov	sp, r7
 80106fe:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010702:	4770      	bx	lr

08010704 <HardFault_Handler>:
  * @brief  This function handles Hard Fault exception.
  * @param  None
  * @retval None
  */
void HardFault_Handler(void)
{
 8010704:	b480      	push	{r7}
 8010706:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Hard Fault exception occurs */
	/* The fault handler implementation calls a function called
	prvGetRegistersFromStack(). */

	    __asm volatile
 8010708:	f01e 0f04 	tst.w	lr, #4
 801070c:	bf0c      	ite	eq
 801070e:	f3ef 8008 	mrseq	r0, MSP
 8010712:	f3ef 8009 	mrsne	r0, PSP
 8010716:	6981      	ldr	r1, [r0, #24]
 8010718:	4a00      	ldr	r2, [pc, #0]	; (801071c <handler2_address_const>)
 801071a:	4710      	bx	r2

0801071c <handler2_address_const>:
 801071c:	08010729 	.word	0x08010729
	        " bx r2                                                     \n"
	        " handler2_address_const: .word prvGetRegistersFromStack    \n"
	    );


}
 8010720:	46bd      	mov	sp, r7
 8010722:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010726:	4770      	bx	lr

08010728 <prvGetRegistersFromStack>:
void prvGetRegistersFromStack( uint32_t *pulFaultStackAddress )
{
 8010728:	b480      	push	{r7}
 801072a:	b08b      	sub	sp, #44	; 0x2c
 801072c:	af00      	add	r7, sp, #0
 801072e:	6078      	str	r0, [r7, #4]
volatile uint32_t r12;
volatile uint32_t lr; /* Link register. */
volatile uint32_t pc; /* Program counter. */
volatile uint32_t psr;/* Program status register. */

    r0 = pulFaultStackAddress[ 0 ];
 8010730:	687b      	ldr	r3, [r7, #4]
 8010732:	681b      	ldr	r3, [r3, #0]
 8010734:	627b      	str	r3, [r7, #36]	; 0x24
    r1 = pulFaultStackAddress[ 1 ];
 8010736:	687b      	ldr	r3, [r7, #4]
 8010738:	685b      	ldr	r3, [r3, #4]
 801073a:	623b      	str	r3, [r7, #32]
    r2 = pulFaultStackAddress[ 2 ];
 801073c:	687b      	ldr	r3, [r7, #4]
 801073e:	689b      	ldr	r3, [r3, #8]
 8010740:	61fb      	str	r3, [r7, #28]
    r3 = pulFaultStackAddress[ 3 ];
 8010742:	687b      	ldr	r3, [r7, #4]
 8010744:	68db      	ldr	r3, [r3, #12]
 8010746:	61bb      	str	r3, [r7, #24]

    r12 = pulFaultStackAddress[ 4 ];
 8010748:	687b      	ldr	r3, [r7, #4]
 801074a:	691b      	ldr	r3, [r3, #16]
 801074c:	617b      	str	r3, [r7, #20]
    lr = pulFaultStackAddress[ 5 ];
 801074e:	687b      	ldr	r3, [r7, #4]
 8010750:	695b      	ldr	r3, [r3, #20]
 8010752:	613b      	str	r3, [r7, #16]
    pc = pulFaultStackAddress[ 6 ];
 8010754:	687b      	ldr	r3, [r7, #4]
 8010756:	699b      	ldr	r3, [r3, #24]
 8010758:	60fb      	str	r3, [r7, #12]
    psr = pulFaultStackAddress[ 7 ];
 801075a:	687b      	ldr	r3, [r7, #4]
 801075c:	69db      	ldr	r3, [r3, #28]
 801075e:	60bb      	str	r3, [r7, #8]

    /* When the following line is hit, the variables contain the register values. */
    for( ;; );
 8010760:	e7fe      	b.n	8010760 <prvGetRegistersFromStack+0x38>
 8010762:	bf00      	nop

08010764 <MemManage_Handler>:
  * @brief  This function handles Memory Manage exception.
  * @param  None
  * @retval None
  */
void MemManage_Handler(void)
{
 8010764:	b480      	push	{r7}
 8010766:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
  {
  }
 8010768:	e7fe      	b.n	8010768 <MemManage_Handler+0x4>
 801076a:	bf00      	nop

0801076c <BusFault_Handler>:
  * @brief  This function handles Bus Fault exception.
  * @param  None
  * @retval None
  */
void BusFault_Handler(void)
{
 801076c:	b480      	push	{r7}
 801076e:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
  {
  }
 8010770:	e7fe      	b.n	8010770 <BusFault_Handler+0x4>
 8010772:	bf00      	nop

08010774 <UsageFault_Handler>:
  * @brief  This function handles Usage Fault exception.
  * @param  None
  * @retval None
  */
void UsageFault_Handler(void)
{
 8010774:	b480      	push	{r7}
 8010776:	af00      	add	r7, sp, #0
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
  {
  }
 8010778:	e7fe      	b.n	8010778 <UsageFault_Handler+0x4>
 801077a:	bf00      	nop

0801077c <DebugMon_Handler>:
  * @brief  This function handles Debug Monitor exception.
  * @param  None
  * @retval None
  */
void DebugMon_Handler(void)
{
 801077c:	b480      	push	{r7}
 801077e:	af00      	add	r7, sp, #0
}
 8010780:	46bd      	mov	sp, r7
 8010782:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010786:	4770      	bx	lr

08010788 <SysTick_Handler>:
  * @brief  This function handles SysTick Handler.
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
 8010788:	b580      	push	{r7, lr}
 801078a:	af00      	add	r7, sp, #0
	HAL_IncTick();
 801078c:	f7f0 f82c 	bl	80007e8 <HAL_IncTick>
	 if(xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 8010790:	f7f5 fb4a 	bl	8005e28 <xTaskGetSchedulerState>
 8010794:	4603      	mov	r3, r0
 8010796:	2b01      	cmp	r3, #1
 8010798:	d001      	beq.n	801079e <SysTick_Handler+0x16>
	  {
	    xPortSysTickHandler();
 801079a:	f7f3 fc03 	bl	8003fa4 <xPortSysTickHandler>
	  }

}
 801079e:	bd80      	pop	{r7, pc}

080107a0 <TIM8_UP_TIM13_IRQHandler>:

/**
* @brief This function handles TIM8 update interrupt and TIM13 global interrupt.
*/
void TIM8_UP_TIM13_IRQHandler(void)
{
 80107a0:	b580      	push	{r7, lr}
 80107a2:	af00      	add	r7, sp, #0
  HAL_TIM_IRQHandler(&htim13);
 80107a4:	4801      	ldr	r0, [pc, #4]	; (80107ac <TIM8_UP_TIM13_IRQHandler+0xc>)
 80107a6:	f7f1 ffbd 	bl	8002724 <HAL_TIM_IRQHandler>
}
 80107aa:	bd80      	pop	{r7, pc}
 80107ac:	2000cfcc 	.word	0x2000cfcc

080107b0 <SystemInit>:
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
void SystemInit(void)
{
 80107b0:	b480      	push	{r7}
 80107b2:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 80107b4:	4a15      	ldr	r2, [pc, #84]	; (801080c <SystemInit+0x5c>)
 80107b6:	4b15      	ldr	r3, [pc, #84]	; (801080c <SystemInit+0x5c>)
 80107b8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80107bc:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80107c0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 80107c4:	4a12      	ldr	r2, [pc, #72]	; (8010810 <SystemInit+0x60>)
 80107c6:	4b12      	ldr	r3, [pc, #72]	; (8010810 <SystemInit+0x60>)
 80107c8:	681b      	ldr	r3, [r3, #0]
 80107ca:	f043 0301 	orr.w	r3, r3, #1
 80107ce:	6013      	str	r3, [r2, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 80107d0:	4b0f      	ldr	r3, [pc, #60]	; (8010810 <SystemInit+0x60>)
 80107d2:	2200      	movs	r2, #0
 80107d4:	609a      	str	r2, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 80107d6:	490e      	ldr	r1, [pc, #56]	; (8010810 <SystemInit+0x60>)
 80107d8:	4b0d      	ldr	r3, [pc, #52]	; (8010810 <SystemInit+0x60>)
 80107da:	681a      	ldr	r2, [r3, #0]
 80107dc:	4b0d      	ldr	r3, [pc, #52]	; (8010814 <SystemInit+0x64>)
 80107de:	4013      	ands	r3, r2
 80107e0:	600b      	str	r3, [r1, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 80107e2:	4b0b      	ldr	r3, [pc, #44]	; (8010810 <SystemInit+0x60>)
 80107e4:	4a0c      	ldr	r2, [pc, #48]	; (8010818 <SystemInit+0x68>)
 80107e6:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 80107e8:	4a09      	ldr	r2, [pc, #36]	; (8010810 <SystemInit+0x60>)
 80107ea:	4b09      	ldr	r3, [pc, #36]	; (8010810 <SystemInit+0x60>)
 80107ec:	681b      	ldr	r3, [r3, #0]
 80107ee:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80107f2:	6013      	str	r3, [r2, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 80107f4:	4b06      	ldr	r3, [pc, #24]	; (8010810 <SystemInit+0x60>)
 80107f6:	2200      	movs	r2, #0
 80107f8:	60da      	str	r2, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = RAMDTCM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80107fa:	4b04      	ldr	r3, [pc, #16]	; (801080c <SystemInit+0x5c>)
 80107fc:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 8010800:	609a      	str	r2, [r3, #8]
#endif
}
 8010802:	46bd      	mov	sp, r7
 8010804:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010808:	4770      	bx	lr
 801080a:	bf00      	nop
 801080c:	e000ed00 	.word	0xe000ed00
 8010810:	40023800 	.word	0x40023800
 8010814:	fef6ffff 	.word	0xfef6ffff
 8010818:	24003010 	.word	0x24003010

0801081c <_cbSendSystemDesc>:
*       _cbSendSystemDesc()
*
*  Function description
*    Sends SystemView description strings.
*/
static void _cbSendSystemDesc(void) {
 801081c:	b580      	push	{r7, lr}
 801081e:	af00      	add	r7, sp, #0
  SEGGER_SYSVIEW_SendSysDesc("N="SYSVIEW_APP_NAME",D="SYSVIEW_DEVICE_NAME",O=FreeRTOS");
 8010820:	4803      	ldr	r0, [pc, #12]	; (8010830 <_cbSendSystemDesc+0x14>)
 8010822:	f001 f879 	bl	8011918 <SEGGER_SYSVIEW_SendSysDesc>
  SEGGER_SYSVIEW_SendSysDesc("I#15=SysTick");
 8010826:	4803      	ldr	r0, [pc, #12]	; (8010834 <_cbSendSystemDesc+0x18>)
 8010828:	f001 f876 	bl	8011918 <SEGGER_SYSVIEW_SendSysDesc>
}
 801082c:	bd80      	pop	{r7, pc}
 801082e:	bf00      	nop
 8010830:	08012940 	.word	0x08012940
 8010834:	08012978 	.word	0x08012978

08010838 <SEGGER_SYSVIEW_Conf>:
*
*       Global functions
*
**********************************************************************
*/
void SEGGER_SYSVIEW_Conf(void) {
 8010838:	b580      	push	{r7, lr}
 801083a:	af00      	add	r7, sp, #0
  SEGGER_SYSVIEW_Init(SYSVIEW_TIMESTAMP_FREQ, SYSVIEW_CPU_FREQ, 
 801083c:	4b07      	ldr	r3, [pc, #28]	; (801085c <SEGGER_SYSVIEW_Conf+0x24>)
 801083e:	681a      	ldr	r2, [r3, #0]
 8010840:	4b06      	ldr	r3, [pc, #24]	; (801085c <SEGGER_SYSVIEW_Conf+0x24>)
 8010842:	681b      	ldr	r3, [r3, #0]
 8010844:	4610      	mov	r0, r2
 8010846:	4619      	mov	r1, r3
 8010848:	4a05      	ldr	r2, [pc, #20]	; (8010860 <SEGGER_SYSVIEW_Conf+0x28>)
 801084a:	4b06      	ldr	r3, [pc, #24]	; (8010864 <SEGGER_SYSVIEW_Conf+0x2c>)
 801084c:	f000 fc84 	bl	8011158 <SEGGER_SYSVIEW_Init>
                      &SYSVIEW_X_OS_TraceAPI, _cbSendSystemDesc);
  SEGGER_SYSVIEW_SetRAMBase(SYSVIEW_RAM_BASE);
 8010850:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 8010854:	f000 fcbc 	bl	80111d0 <SEGGER_SYSVIEW_SetRAMBase>
}
 8010858:	bd80      	pop	{r7, pc}
 801085a:	bf00      	nop
 801085c:	2000bb58 	.word	0x2000bb58
 8010860:	08012a88 	.word	0x08012a88
 8010864:	0801081d 	.word	0x0801081d

08010868 <BSP_LED_Init>:
  *            @arg  LED1
  *            @arg  LED2
  * @retval None
  */
void BSP_LED_Init(Led_TypeDef Led)
{
 8010868:	b580      	push	{r7, lr}
 801086a:	b088      	sub	sp, #32
 801086c:	af00      	add	r7, sp, #0
 801086e:	4603      	mov	r3, r0
 8010870:	71fb      	strb	r3, [r7, #7]
  GPIO_InitTypeDef  gpio_init_structure;
  
  LEDx_GPIO_CLK_ENABLE();
 8010872:	4a12      	ldr	r2, [pc, #72]	; (80108bc <BSP_LED_Init+0x54>)
 8010874:	4b11      	ldr	r3, [pc, #68]	; (80108bc <BSP_LED_Init+0x54>)
 8010876:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010878:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 801087c:	6313      	str	r3, [r2, #48]	; 0x30
 801087e:	4b0f      	ldr	r3, [pc, #60]	; (80108bc <BSP_LED_Init+0x54>)
 8010880:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8010882:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8010886:	60bb      	str	r3, [r7, #8]
 8010888:	68bb      	ldr	r3, [r7, #8]
  /* Configure the GPIO_LED pin */
  gpio_init_structure.Pin   = GPIO_PIN[Led];
 801088a:	79fb      	ldrb	r3, [r7, #7]
 801088c:	4a0c      	ldr	r2, [pc, #48]	; (80108c0 <BSP_LED_Init+0x58>)
 801088e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010892:	60fb      	str	r3, [r7, #12]
  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;
 8010894:	2301      	movs	r3, #1
 8010896:	613b      	str	r3, [r7, #16]
  gpio_init_structure.Pull  = GPIO_PULLUP;
 8010898:	2301      	movs	r3, #1
 801089a:	617b      	str	r3, [r7, #20]
  gpio_init_structure.Speed = GPIO_SPEED_HIGH;
 801089c:	2303      	movs	r3, #3
 801089e:	61bb      	str	r3, [r7, #24]
  
  HAL_GPIO_Init(GPIO_PORT[Led], &gpio_init_structure);
 80108a0:	79fb      	ldrb	r3, [r7, #7]
 80108a2:	4a08      	ldr	r2, [pc, #32]	; (80108c4 <BSP_LED_Init+0x5c>)
 80108a4:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 80108a8:	f107 030c 	add.w	r3, r7, #12
 80108ac:	4610      	mov	r0, r2
 80108ae:	4619      	mov	r1, r3
 80108b0:	f7f0 f8ee 	bl	8000a90 <HAL_GPIO_Init>

}
 80108b4:	3720      	adds	r7, #32
 80108b6:	46bd      	mov	sp, r7
 80108b8:	bd80      	pop	{r7, pc}
 80108ba:	bf00      	nop
 80108bc:	40023800 	.word	0x40023800
 80108c0:	2000bb5c 	.word	0x2000bb5c
 80108c4:	2000bb64 	.word	0x2000bb64

080108c8 <BSP_LED_Toggle>:
  *            @arg  LED1
  *            @arg  LED2
  * @retval None
  */
void BSP_LED_Toggle(Led_TypeDef Led)
{
 80108c8:	b580      	push	{r7, lr}
 80108ca:	b082      	sub	sp, #8
 80108cc:	af00      	add	r7, sp, #0
 80108ce:	4603      	mov	r3, r0
 80108d0:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_TogglePin(GPIO_PORT[Led], GPIO_PIN[Led]);
 80108d2:	79fb      	ldrb	r3, [r7, #7]
 80108d4:	4a07      	ldr	r2, [pc, #28]	; (80108f4 <BSP_LED_Toggle+0x2c>)
 80108d6:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
 80108da:	79fb      	ldrb	r3, [r7, #7]
 80108dc:	4a06      	ldr	r2, [pc, #24]	; (80108f8 <BSP_LED_Toggle+0x30>)
 80108de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80108e2:	b29b      	uxth	r3, r3
 80108e4:	4608      	mov	r0, r1
 80108e6:	4619      	mov	r1, r3
 80108e8:	f7f0 fa78 	bl	8000ddc <HAL_GPIO_TogglePin>
}
 80108ec:	3708      	adds	r7, #8
 80108ee:	46bd      	mov	sp, r7
 80108f0:	bd80      	pop	{r7, pc}
 80108f2:	bf00      	nop
 80108f4:	2000bb64 	.word	0x2000bb64
 80108f8:	2000bb5c 	.word	0x2000bb5c

080108fc <_DoInit>:
*
*/
#define INIT()  do {                                            \
                  if (_SEGGER_RTT.acID[0] == '\0') { _DoInit(); }  \
                } while (0)
static void _DoInit(void) {
 80108fc:	b580      	push	{r7, lr}
 80108fe:	b082      	sub	sp, #8
 8010900:	af00      	add	r7, sp, #0
  SEGGER_RTT_CB* p;
  //
  // Initialize control block
  //
  p = &_SEGGER_RTT;
 8010902:	4b1f      	ldr	r3, [pc, #124]	; (8010980 <_DoInit+0x84>)
 8010904:	607b      	str	r3, [r7, #4]
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
 8010906:	687b      	ldr	r3, [r7, #4]
 8010908:	2203      	movs	r2, #3
 801090a:	611a      	str	r2, [r3, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
 801090c:	687b      	ldr	r3, [r7, #4]
 801090e:	2203      	movs	r2, #3
 8010910:	615a      	str	r2, [r3, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
 8010912:	687b      	ldr	r3, [r7, #4]
 8010914:	4a1b      	ldr	r2, [pc, #108]	; (8010984 <_DoInit+0x88>)
 8010916:	619a      	str	r2, [r3, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
 8010918:	687b      	ldr	r3, [r7, #4]
 801091a:	4a1b      	ldr	r2, [pc, #108]	; (8010988 <_DoInit+0x8c>)
 801091c:	61da      	str	r2, [r3, #28]
  p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
 801091e:	687b      	ldr	r3, [r7, #4]
 8010920:	f44f 6280 	mov.w	r2, #1024	; 0x400
 8010924:	621a      	str	r2, [r3, #32]
  p->aUp[0].RdOff         = 0u;
 8010926:	687b      	ldr	r3, [r7, #4]
 8010928:	2200      	movs	r2, #0
 801092a:	629a      	str	r2, [r3, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
 801092c:	687b      	ldr	r3, [r7, #4]
 801092e:	2200      	movs	r2, #0
 8010930:	625a      	str	r2, [r3, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8010932:	687b      	ldr	r3, [r7, #4]
 8010934:	2200      	movs	r2, #0
 8010936:	62da      	str	r2, [r3, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
 8010938:	687b      	ldr	r3, [r7, #4]
 801093a:	4a12      	ldr	r2, [pc, #72]	; (8010984 <_DoInit+0x88>)
 801093c:	661a      	str	r2, [r3, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
 801093e:	687b      	ldr	r3, [r7, #4]
 8010940:	4a12      	ldr	r2, [pc, #72]	; (801098c <_DoInit+0x90>)
 8010942:	665a      	str	r2, [r3, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
 8010944:	687b      	ldr	r3, [r7, #4]
 8010946:	2210      	movs	r2, #16
 8010948:	669a      	str	r2, [r3, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
 801094a:	687b      	ldr	r3, [r7, #4]
 801094c:	2200      	movs	r2, #0
 801094e:	671a      	str	r2, [r3, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
 8010950:	687b      	ldr	r3, [r7, #4]
 8010952:	2200      	movs	r2, #0
 8010954:	66da      	str	r2, [r3, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
 8010956:	687b      	ldr	r3, [r7, #4]
 8010958:	2200      	movs	r2, #0
 801095a:	675a      	str	r2, [r3, #116]	; 0x74
  //
  // Finish initialization of the control block.
  // Copy Id string in three steps to make sure "SEGGER RTT" is not found
  // in initializer memory (usually flash) by J-Link
  //
  strcpy(&p->acID[7], "RTT");
 801095c:	687b      	ldr	r3, [r7, #4]
 801095e:	3307      	adds	r3, #7
 8010960:	4618      	mov	r0, r3
 8010962:	490b      	ldr	r1, [pc, #44]	; (8010990 <_DoInit+0x94>)
 8010964:	f001 fd28 	bl	80123b8 <strcpy>
  strcpy(&p->acID[0], "SEGGER");
 8010968:	687b      	ldr	r3, [r7, #4]
 801096a:	4618      	mov	r0, r3
 801096c:	4909      	ldr	r1, [pc, #36]	; (8010994 <_DoInit+0x98>)
 801096e:	f001 fd23 	bl	80123b8 <strcpy>
  p->acID[6] = ' ';
 8010972:	687b      	ldr	r3, [r7, #4]
 8010974:	2220      	movs	r2, #32
 8010976:	719a      	strb	r2, [r3, #6]
}
 8010978:	3708      	adds	r7, #8
 801097a:	46bd      	mov	sp, r7
 801097c:	bd80      	pop	{r7, pc}
 801097e:	bf00      	nop
 8010980:	2000d008 	.word	0x2000d008
 8010984:	08012988 	.word	0x08012988
 8010988:	2000c4fc 	.word	0x2000c4fc
 801098c:	2000c8fc 	.word	0x2000c8fc
 8010990:	08012994 	.word	0x08012994
 8010994:	08012998 	.word	0x08012998

08010998 <SEGGER_RTT_ReadNoLock>:
*    BufferSize   Size of the target application buffer.
*
*  Return value
*    Number of bytes that have been read.
*/
unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
 8010998:	b580      	push	{r7, lr}
 801099a:	b08a      	sub	sp, #40	; 0x28
 801099c:	af00      	add	r7, sp, #0
 801099e:	60f8      	str	r0, [r7, #12]
 80109a0:	60b9      	str	r1, [r7, #8]
 80109a2:	607a      	str	r2, [r7, #4]
  unsigned                RdOff;
  unsigned                WrOff;
  unsigned char*          pBuffer;
  SEGGER_RTT_BUFFER_DOWN* pRing;
  //
  INIT();
 80109a4:	4b3c      	ldr	r3, [pc, #240]	; (8010a98 <SEGGER_RTT_ReadNoLock+0x100>)
 80109a6:	781b      	ldrb	r3, [r3, #0]
 80109a8:	2b00      	cmp	r3, #0
 80109aa:	d101      	bne.n	80109b0 <SEGGER_RTT_ReadNoLock+0x18>
 80109ac:	f7ff ffa6 	bl	80108fc <_DoInit>
  pRing = &_SEGGER_RTT.aDown[BufferIndex];
 80109b0:	68fa      	ldr	r2, [r7, #12]
 80109b2:	4613      	mov	r3, r2
 80109b4:	005b      	lsls	r3, r3, #1
 80109b6:	4413      	add	r3, r2
 80109b8:	00db      	lsls	r3, r3, #3
 80109ba:	3360      	adds	r3, #96	; 0x60
 80109bc:	4a36      	ldr	r2, [pc, #216]	; (8010a98 <SEGGER_RTT_ReadNoLock+0x100>)
 80109be:	4413      	add	r3, r2
 80109c0:	61bb      	str	r3, [r7, #24]
  pBuffer = (unsigned char*)pData;
 80109c2:	68bb      	ldr	r3, [r7, #8]
 80109c4:	61fb      	str	r3, [r7, #28]
  RdOff = pRing->RdOff;
 80109c6:	69bb      	ldr	r3, [r7, #24]
 80109c8:	691b      	ldr	r3, [r3, #16]
 80109ca:	623b      	str	r3, [r7, #32]
  WrOff = pRing->WrOff;
 80109cc:	69bb      	ldr	r3, [r7, #24]
 80109ce:	68db      	ldr	r3, [r3, #12]
 80109d0:	617b      	str	r3, [r7, #20]
  NumBytesRead = 0u;
 80109d2:	2300      	movs	r3, #0
 80109d4:	627b      	str	r3, [r7, #36]	; 0x24
  //
  // Read from current read position to wrap-around of buffer, first
  //
  if (RdOff > WrOff) {
 80109d6:	6a3a      	ldr	r2, [r7, #32]
 80109d8:	697b      	ldr	r3, [r7, #20]
 80109da:	429a      	cmp	r2, r3
 80109dc:	d92a      	bls.n	8010a34 <SEGGER_RTT_ReadNoLock+0x9c>
    NumBytesRem = pRing->SizeOfBuffer - RdOff;
 80109de:	69bb      	ldr	r3, [r7, #24]
 80109e0:	689a      	ldr	r2, [r3, #8]
 80109e2:	6a3b      	ldr	r3, [r7, #32]
 80109e4:	1ad3      	subs	r3, r2, r3
 80109e6:	613b      	str	r3, [r7, #16]
    NumBytesRem = MIN(NumBytesRem, BufferSize);
 80109e8:	693a      	ldr	r2, [r7, #16]
 80109ea:	687b      	ldr	r3, [r7, #4]
 80109ec:	4293      	cmp	r3, r2
 80109ee:	bf28      	it	cs
 80109f0:	4613      	movcs	r3, r2
 80109f2:	613b      	str	r3, [r7, #16]
    memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
 80109f4:	69bb      	ldr	r3, [r7, #24]
 80109f6:	685a      	ldr	r2, [r3, #4]
 80109f8:	6a3b      	ldr	r3, [r7, #32]
 80109fa:	4413      	add	r3, r2
 80109fc:	69f8      	ldr	r0, [r7, #28]
 80109fe:	4619      	mov	r1, r3
 8010a00:	693a      	ldr	r2, [r7, #16]
 8010a02:	f7ff fb51 	bl	80100a8 <memcpy>
    NumBytesRead += NumBytesRem;
 8010a06:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010a08:	693b      	ldr	r3, [r7, #16]
 8010a0a:	4413      	add	r3, r2
 8010a0c:	627b      	str	r3, [r7, #36]	; 0x24
    pBuffer      += NumBytesRem;
 8010a0e:	69fa      	ldr	r2, [r7, #28]
 8010a10:	693b      	ldr	r3, [r7, #16]
 8010a12:	4413      	add	r3, r2
 8010a14:	61fb      	str	r3, [r7, #28]
    BufferSize   -= NumBytesRem;
 8010a16:	687a      	ldr	r2, [r7, #4]
 8010a18:	693b      	ldr	r3, [r7, #16]
 8010a1a:	1ad3      	subs	r3, r2, r3
 8010a1c:	607b      	str	r3, [r7, #4]
    RdOff        += NumBytesRem;
 8010a1e:	6a3a      	ldr	r2, [r7, #32]
 8010a20:	693b      	ldr	r3, [r7, #16]
 8010a22:	4413      	add	r3, r2
 8010a24:	623b      	str	r3, [r7, #32]
    //
    // Handle wrap-around of buffer
    //
    if (RdOff == pRing->SizeOfBuffer) {
 8010a26:	69bb      	ldr	r3, [r7, #24]
 8010a28:	689a      	ldr	r2, [r3, #8]
 8010a2a:	6a3b      	ldr	r3, [r7, #32]
 8010a2c:	429a      	cmp	r2, r3
 8010a2e:	d101      	bne.n	8010a34 <SEGGER_RTT_ReadNoLock+0x9c>
      RdOff = 0u;
 8010a30:	2300      	movs	r3, #0
 8010a32:	623b      	str	r3, [r7, #32]
    }
  }
  //
  // Read remaining items of buffer
  //
  NumBytesRem = WrOff - RdOff;
 8010a34:	697a      	ldr	r2, [r7, #20]
 8010a36:	6a3b      	ldr	r3, [r7, #32]
 8010a38:	1ad3      	subs	r3, r2, r3
 8010a3a:	613b      	str	r3, [r7, #16]
  NumBytesRem = MIN(NumBytesRem, BufferSize);
 8010a3c:	693a      	ldr	r2, [r7, #16]
 8010a3e:	687b      	ldr	r3, [r7, #4]
 8010a40:	4293      	cmp	r3, r2
 8010a42:	bf28      	it	cs
 8010a44:	4613      	movcs	r3, r2
 8010a46:	613b      	str	r3, [r7, #16]
  if (NumBytesRem > 0u) {
 8010a48:	693b      	ldr	r3, [r7, #16]
 8010a4a:	2b00      	cmp	r3, #0
 8010a4c:	d018      	beq.n	8010a80 <SEGGER_RTT_ReadNoLock+0xe8>
    memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
 8010a4e:	69bb      	ldr	r3, [r7, #24]
 8010a50:	685a      	ldr	r2, [r3, #4]
 8010a52:	6a3b      	ldr	r3, [r7, #32]
 8010a54:	4413      	add	r3, r2
 8010a56:	69f8      	ldr	r0, [r7, #28]
 8010a58:	4619      	mov	r1, r3
 8010a5a:	693a      	ldr	r2, [r7, #16]
 8010a5c:	f7ff fb24 	bl	80100a8 <memcpy>
    NumBytesRead += NumBytesRem;
 8010a60:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8010a62:	693b      	ldr	r3, [r7, #16]
 8010a64:	4413      	add	r3, r2
 8010a66:	627b      	str	r3, [r7, #36]	; 0x24
    pBuffer      += NumBytesRem;
 8010a68:	69fa      	ldr	r2, [r7, #28]
 8010a6a:	693b      	ldr	r3, [r7, #16]
 8010a6c:	4413      	add	r3, r2
 8010a6e:	61fb      	str	r3, [r7, #28]
    BufferSize   -= NumBytesRem;
 8010a70:	687a      	ldr	r2, [r7, #4]
 8010a72:	693b      	ldr	r3, [r7, #16]
 8010a74:	1ad3      	subs	r3, r2, r3
 8010a76:	607b      	str	r3, [r7, #4]
    RdOff        += NumBytesRem;
 8010a78:	6a3a      	ldr	r2, [r7, #32]
 8010a7a:	693b      	ldr	r3, [r7, #16]
 8010a7c:	4413      	add	r3, r2
 8010a7e:	623b      	str	r3, [r7, #32]
  }
  if (NumBytesRead) {
 8010a80:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010a82:	2b00      	cmp	r3, #0
 8010a84:	d002      	beq.n	8010a8c <SEGGER_RTT_ReadNoLock+0xf4>
    pRing->RdOff = RdOff;
 8010a86:	69bb      	ldr	r3, [r7, #24]
 8010a88:	6a3a      	ldr	r2, [r7, #32]
 8010a8a:	611a      	str	r2, [r3, #16]
  }
  //
  return NumBytesRead;
 8010a8c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
 8010a8e:	4618      	mov	r0, r3
 8010a90:	3728      	adds	r7, #40	; 0x28
 8010a92:	46bd      	mov	sp, r7
 8010a94:	bd80      	pop	{r7, pc}
 8010a96:	bf00      	nop
 8010a98:	2000d008 	.word	0x2000d008

08010a9c <SEGGER_RTT_WriteSkipNoLock>:
*    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
 8010a9c:	b580      	push	{r7, lr}
 8010a9e:	b08c      	sub	sp, #48	; 0x30
 8010aa0:	af00      	add	r7, sp, #0
 8010aa2:	60f8      	str	r0, [r7, #12]
 8010aa4:	60b9      	str	r1, [r7, #8]
 8010aa6:	607a      	str	r2, [r7, #4]
  unsigned              Avail;
  unsigned              RdOff;
  unsigned              WrOff;
  unsigned              Rem;

  pData = (const char *)pBuffer;
 8010aa8:	68bb      	ldr	r3, [r7, #8]
 8010aaa:	62fb      	str	r3, [r7, #44]	; 0x2c
  //
  // Get "to-host" ring buffer and copy some elements into local variables.
  //
  pRing = &_SEGGER_RTT.aUp[BufferIndex];
 8010aac:	68fb      	ldr	r3, [r7, #12]
 8010aae:	1c5a      	adds	r2, r3, #1
 8010ab0:	4613      	mov	r3, r2
 8010ab2:	005b      	lsls	r3, r3, #1
 8010ab4:	4413      	add	r3, r2
 8010ab6:	00db      	lsls	r3, r3, #3
 8010ab8:	4a46      	ldr	r2, [pc, #280]	; (8010bd4 <SEGGER_RTT_WriteSkipNoLock+0x138>)
 8010aba:	4413      	add	r3, r2
 8010abc:	627b      	str	r3, [r7, #36]	; 0x24
  RdOff = pRing->RdOff;
 8010abe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010ac0:	691b      	ldr	r3, [r3, #16]
 8010ac2:	623b      	str	r3, [r7, #32]
  WrOff = pRing->WrOff;
 8010ac4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010ac6:	68db      	ldr	r3, [r3, #12]
 8010ac8:	61fb      	str	r3, [r7, #28]
  //
  //    RdOff > WrOff -> Space until RdOff - 1 is free.
  //  AND
  //    WrOff + NumBytes < RdOff -> Data fits into buffer
  //
  if (RdOff <= WrOff) {
 8010aca:	6a3a      	ldr	r2, [r7, #32]
 8010acc:	69fb      	ldr	r3, [r7, #28]
 8010ace:	429a      	cmp	r2, r3
 8010ad0:	d862      	bhi.n	8010b98 <SEGGER_RTT_WriteSkipNoLock+0xfc>
    //
    // Get space until WrOff will be at wrap around.
    //
    Avail = pRing->SizeOfBuffer - 1u - WrOff ;
 8010ad2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010ad4:	689a      	ldr	r2, [r3, #8]
 8010ad6:	69fb      	ldr	r3, [r7, #28]
 8010ad8:	1ad3      	subs	r3, r2, r3
 8010ada:	3b01      	subs	r3, #1
 8010adc:	61bb      	str	r3, [r7, #24]
    if (Avail >= NumBytes) {
 8010ade:	69ba      	ldr	r2, [r7, #24]
 8010ae0:	687b      	ldr	r3, [r7, #4]
 8010ae2:	429a      	cmp	r2, r3
 8010ae4:	d31d      	bcc.n	8010b22 <SEGGER_RTT_WriteSkipNoLock+0x86>
#if 1 // memcpy() is good for large amounts of data, but the overhead is too big for small amounts. Use a simple byte loop instead.
      char* pDst;
      pDst = pRing->pBuffer + WrOff;
 8010ae6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010ae8:	685a      	ldr	r2, [r3, #4]
 8010aea:	69fb      	ldr	r3, [r7, #28]
 8010aec:	4413      	add	r3, r2
 8010aee:	62bb      	str	r3, [r7, #40]	; 0x28
      WrOff += NumBytes;
 8010af0:	69fa      	ldr	r2, [r7, #28]
 8010af2:	687b      	ldr	r3, [r7, #4]
 8010af4:	4413      	add	r3, r2
 8010af6:	61fb      	str	r3, [r7, #28]
      do {
        *pDst++ = *pData++;
 8010af8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010afa:	1c5a      	adds	r2, r3, #1
 8010afc:	62ba      	str	r2, [r7, #40]	; 0x28
 8010afe:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8010b00:	1c51      	adds	r1, r2, #1
 8010b02:	62f9      	str	r1, [r7, #44]	; 0x2c
 8010b04:	7812      	ldrb	r2, [r2, #0]
 8010b06:	701a      	strb	r2, [r3, #0]
      } while (--NumBytes);
 8010b08:	687b      	ldr	r3, [r7, #4]
 8010b0a:	3b01      	subs	r3, #1
 8010b0c:	607b      	str	r3, [r7, #4]
 8010b0e:	687b      	ldr	r3, [r7, #4]
 8010b10:	2b00      	cmp	r3, #0
 8010b12:	d1f1      	bne.n	8010af8 <SEGGER_RTT_WriteSkipNoLock+0x5c>
      pRing->WrOff = WrOff + NumBytes;
 8010b14:	69fa      	ldr	r2, [r7, #28]
 8010b16:	687b      	ldr	r3, [r7, #4]
 8010b18:	441a      	add	r2, r3
 8010b1a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010b1c:	60da      	str	r2, [r3, #12]
#else
      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
      pRing->WrOff = WrOff + NumBytes;
#endif
      return 1;
 8010b1e:	2301      	movs	r3, #1
 8010b20:	e054      	b.n	8010bcc <SEGGER_RTT_WriteSkipNoLock+0x130>
    }
    //
    // If data did not fit into space until wrap around calculate complete space in buffer.
    //
    Avail += RdOff;
 8010b22:	69ba      	ldr	r2, [r7, #24]
 8010b24:	6a3b      	ldr	r3, [r7, #32]
 8010b26:	4413      	add	r3, r2
 8010b28:	61bb      	str	r3, [r7, #24]
    //
    // If there is still no space for the whole of this output, don't bother.
    //
    if (Avail >= NumBytes) {
 8010b2a:	69ba      	ldr	r2, [r7, #24]
 8010b2c:	687b      	ldr	r3, [r7, #4]
 8010b2e:	429a      	cmp	r2, r3
 8010b30:	d34b      	bcc.n	8010bca <SEGGER_RTT_WriteSkipNoLock+0x12e>
      //
      //  OK, we have enough space in buffer. Copy in one or 2 chunks
      //
      Rem = pRing->SizeOfBuffer - WrOff;      // Space until end of buffer
 8010b32:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010b34:	689a      	ldr	r2, [r3, #8]
 8010b36:	69fb      	ldr	r3, [r7, #28]
 8010b38:	1ad3      	subs	r3, r2, r3
 8010b3a:	617b      	str	r3, [r7, #20]
      if (Rem > NumBytes) {
 8010b3c:	697a      	ldr	r2, [r7, #20]
 8010b3e:	687b      	ldr	r3, [r7, #4]
 8010b40:	429a      	cmp	r2, r3
 8010b42:	d90e      	bls.n	8010b62 <SEGGER_RTT_WriteSkipNoLock+0xc6>
        memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
 8010b44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010b46:	685a      	ldr	r2, [r3, #4]
 8010b48:	69fb      	ldr	r3, [r7, #28]
 8010b4a:	4413      	add	r3, r2
 8010b4c:	4618      	mov	r0, r3
 8010b4e:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8010b50:	687a      	ldr	r2, [r7, #4]
 8010b52:	f7ff faa9 	bl	80100a8 <memcpy>
        pRing->WrOff = WrOff + NumBytes;
 8010b56:	69fa      	ldr	r2, [r7, #28]
 8010b58:	687b      	ldr	r3, [r7, #4]
 8010b5a:	441a      	add	r2, r3
 8010b5c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010b5e:	60da      	str	r2, [r3, #12]
 8010b60:	e018      	b.n	8010b94 <SEGGER_RTT_WriteSkipNoLock+0xf8>
      } else {
        //
        // We reach the end of the buffer, so need to wrap around
        //
        memcpy(pRing->pBuffer + WrOff, pData, Rem);
 8010b62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010b64:	685a      	ldr	r2, [r3, #4]
 8010b66:	69fb      	ldr	r3, [r7, #28]
 8010b68:	4413      	add	r3, r2
 8010b6a:	4618      	mov	r0, r3
 8010b6c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8010b6e:	697a      	ldr	r2, [r7, #20]
 8010b70:	f7ff fa9a 	bl	80100a8 <memcpy>
        memcpy(pRing->pBuffer, pData + Rem, NumBytes - Rem);
 8010b74:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010b76:	6858      	ldr	r0, [r3, #4]
 8010b78:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 8010b7a:	697b      	ldr	r3, [r7, #20]
 8010b7c:	18d1      	adds	r1, r2, r3
 8010b7e:	687a      	ldr	r2, [r7, #4]
 8010b80:	697b      	ldr	r3, [r7, #20]
 8010b82:	1ad3      	subs	r3, r2, r3
 8010b84:	461a      	mov	r2, r3
 8010b86:	f7ff fa8f 	bl	80100a8 <memcpy>
        pRing->WrOff = NumBytes - Rem;
 8010b8a:	687a      	ldr	r2, [r7, #4]
 8010b8c:	697b      	ldr	r3, [r7, #20]
 8010b8e:	1ad2      	subs	r2, r2, r3
 8010b90:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010b92:	60da      	str	r2, [r3, #12]
      }
      return 1;
 8010b94:	2301      	movs	r3, #1
 8010b96:	e019      	b.n	8010bcc <SEGGER_RTT_WriteSkipNoLock+0x130>
    }
  } else {
    Avail = RdOff - WrOff - 1u;
 8010b98:	6a3a      	ldr	r2, [r7, #32]
 8010b9a:	69fb      	ldr	r3, [r7, #28]
 8010b9c:	1ad3      	subs	r3, r2, r3
 8010b9e:	3b01      	subs	r3, #1
 8010ba0:	61bb      	str	r3, [r7, #24]
    if (Avail >= NumBytes) {
 8010ba2:	69ba      	ldr	r2, [r7, #24]
 8010ba4:	687b      	ldr	r3, [r7, #4]
 8010ba6:	429a      	cmp	r2, r3
 8010ba8:	d30f      	bcc.n	8010bca <SEGGER_RTT_WriteSkipNoLock+0x12e>
      memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
 8010baa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010bac:	685a      	ldr	r2, [r3, #4]
 8010bae:	69fb      	ldr	r3, [r7, #28]
 8010bb0:	4413      	add	r3, r2
 8010bb2:	4618      	mov	r0, r3
 8010bb4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
 8010bb6:	687a      	ldr	r2, [r7, #4]
 8010bb8:	f7ff fa76 	bl	80100a8 <memcpy>
      pRing->WrOff = WrOff + NumBytes;
 8010bbc:	69fa      	ldr	r2, [r7, #28]
 8010bbe:	687b      	ldr	r3, [r7, #4]
 8010bc0:	441a      	add	r2, r3
 8010bc2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010bc4:	60da      	str	r2, [r3, #12]
      return 1;
 8010bc6:	2301      	movs	r3, #1
 8010bc8:	e000      	b.n	8010bcc <SEGGER_RTT_WriteSkipNoLock+0x130>
    }
  }
  //
  // If we reach this point no data has been written
  //
  return 0;
 8010bca:	2300      	movs	r3, #0
}
 8010bcc:	4618      	mov	r0, r3
 8010bce:	3730      	adds	r7, #48	; 0x30
 8010bd0:	46bd      	mov	sp, r7
 8010bd2:	bd80      	pop	{r7, pc}
 8010bd4:	2000d008 	.word	0x2000d008

08010bd8 <SEGGER_RTT_ConfigUpBuffer>:
*  Additional information
*    Buffer 0 is configured on compile-time.
*    May only be called once per buffer.
*    Buffer name and flags can be reconfigured using the appropriate functions.
*/
int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
 8010bd8:	b580      	push	{r7, lr}
 8010bda:	b086      	sub	sp, #24
 8010bdc:	af00      	add	r7, sp, #0
 8010bde:	60f8      	str	r0, [r7, #12]
 8010be0:	60b9      	str	r1, [r7, #8]
 8010be2:	607a      	str	r2, [r7, #4]
 8010be4:	603b      	str	r3, [r7, #0]
  int r;

  INIT();
 8010be6:	4b30      	ldr	r3, [pc, #192]	; (8010ca8 <SEGGER_RTT_ConfigUpBuffer+0xd0>)
 8010be8:	781b      	ldrb	r3, [r3, #0]
 8010bea:	2b00      	cmp	r3, #0
 8010bec:	d101      	bne.n	8010bf2 <SEGGER_RTT_ConfigUpBuffer+0x1a>
 8010bee:	f7ff fe85 	bl	80108fc <_DoInit>
  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
 8010bf2:	4b2d      	ldr	r3, [pc, #180]	; (8010ca8 <SEGGER_RTT_ConfigUpBuffer+0xd0>)
 8010bf4:	691b      	ldr	r3, [r3, #16]
 8010bf6:	461a      	mov	r2, r3
 8010bf8:	68fb      	ldr	r3, [r7, #12]
 8010bfa:	429a      	cmp	r2, r3
 8010bfc:	d94b      	bls.n	8010c96 <SEGGER_RTT_ConfigUpBuffer+0xbe>
    SEGGER_RTT_LOCK();
 8010bfe:	f3ef 8311 	mrs	r3, BASEPRI
 8010c02:	f04f 0120 	mov.w	r1, #32
 8010c06:	f381 8811 	msr	BASEPRI, r1
 8010c0a:	613b      	str	r3, [r7, #16]
    if (BufferIndex > 0u) {
 8010c0c:	68fb      	ldr	r3, [r7, #12]
 8010c0e:	2b00      	cmp	r3, #0
 8010c10:	d031      	beq.n	8010c76 <SEGGER_RTT_ConfigUpBuffer+0x9e>
      _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
 8010c12:	4925      	ldr	r1, [pc, #148]	; (8010ca8 <SEGGER_RTT_ConfigUpBuffer+0xd0>)
 8010c14:	68fb      	ldr	r3, [r7, #12]
 8010c16:	1c5a      	adds	r2, r3, #1
 8010c18:	4613      	mov	r3, r2
 8010c1a:	005b      	lsls	r3, r3, #1
 8010c1c:	4413      	add	r3, r2
 8010c1e:	00db      	lsls	r3, r3, #3
 8010c20:	440b      	add	r3, r1
 8010c22:	68ba      	ldr	r2, [r7, #8]
 8010c24:	601a      	str	r2, [r3, #0]
      _SEGGER_RTT.aUp[BufferIndex].pBuffer      = (char*)pBuffer;
 8010c26:	4920      	ldr	r1, [pc, #128]	; (8010ca8 <SEGGER_RTT_ConfigUpBuffer+0xd0>)
 8010c28:	68fb      	ldr	r3, [r7, #12]
 8010c2a:	1c5a      	adds	r2, r3, #1
 8010c2c:	4613      	mov	r3, r2
 8010c2e:	005b      	lsls	r3, r3, #1
 8010c30:	4413      	add	r3, r2
 8010c32:	00db      	lsls	r3, r3, #3
 8010c34:	440b      	add	r3, r1
 8010c36:	687a      	ldr	r2, [r7, #4]
 8010c38:	605a      	str	r2, [r3, #4]
      _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
 8010c3a:	491b      	ldr	r1, [pc, #108]	; (8010ca8 <SEGGER_RTT_ConfigUpBuffer+0xd0>)
 8010c3c:	68fa      	ldr	r2, [r7, #12]
 8010c3e:	4613      	mov	r3, r2
 8010c40:	005b      	lsls	r3, r3, #1
 8010c42:	4413      	add	r3, r2
 8010c44:	00db      	lsls	r3, r3, #3
 8010c46:	440b      	add	r3, r1
 8010c48:	3320      	adds	r3, #32
 8010c4a:	683a      	ldr	r2, [r7, #0]
 8010c4c:	601a      	str	r2, [r3, #0]
      _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
 8010c4e:	4916      	ldr	r1, [pc, #88]	; (8010ca8 <SEGGER_RTT_ConfigUpBuffer+0xd0>)
 8010c50:	68fa      	ldr	r2, [r7, #12]
 8010c52:	4613      	mov	r3, r2
 8010c54:	005b      	lsls	r3, r3, #1
 8010c56:	4413      	add	r3, r2
 8010c58:	00db      	lsls	r3, r3, #3
 8010c5a:	440b      	add	r3, r1
 8010c5c:	3328      	adds	r3, #40	; 0x28
 8010c5e:	2200      	movs	r2, #0
 8010c60:	601a      	str	r2, [r3, #0]
      _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
 8010c62:	4911      	ldr	r1, [pc, #68]	; (8010ca8 <SEGGER_RTT_ConfigUpBuffer+0xd0>)
 8010c64:	68fa      	ldr	r2, [r7, #12]
 8010c66:	4613      	mov	r3, r2
 8010c68:	005b      	lsls	r3, r3, #1
 8010c6a:	4413      	add	r3, r2
 8010c6c:	00db      	lsls	r3, r3, #3
 8010c6e:	440b      	add	r3, r1
 8010c70:	3320      	adds	r3, #32
 8010c72:	2200      	movs	r2, #0
 8010c74:	605a      	str	r2, [r3, #4]
    }
    _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
 8010c76:	490c      	ldr	r1, [pc, #48]	; (8010ca8 <SEGGER_RTT_ConfigUpBuffer+0xd0>)
 8010c78:	68fa      	ldr	r2, [r7, #12]
 8010c7a:	4613      	mov	r3, r2
 8010c7c:	005b      	lsls	r3, r3, #1
 8010c7e:	4413      	add	r3, r2
 8010c80:	00db      	lsls	r3, r3, #3
 8010c82:	440b      	add	r3, r1
 8010c84:	3328      	adds	r3, #40	; 0x28
 8010c86:	6a3a      	ldr	r2, [r7, #32]
 8010c88:	605a      	str	r2, [r3, #4]
    SEGGER_RTT_UNLOCK();
 8010c8a:	693b      	ldr	r3, [r7, #16]
 8010c8c:	f383 8811 	msr	BASEPRI, r3
    r =  0;
 8010c90:	2300      	movs	r3, #0
 8010c92:	617b      	str	r3, [r7, #20]
 8010c94:	e002      	b.n	8010c9c <SEGGER_RTT_ConfigUpBuffer+0xc4>
  } else {
    r = -1;
 8010c96:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8010c9a:	617b      	str	r3, [r7, #20]
  }
  return r;
 8010c9c:	697b      	ldr	r3, [r7, #20]
}
 8010c9e:	4618      	mov	r0, r3
 8010ca0:	3718      	adds	r7, #24
 8010ca2:	46bd      	mov	sp, r7
 8010ca4:	bd80      	pop	{r7, pc}
 8010ca6:	bf00      	nop
 8010ca8:	2000d008 	.word	0x2000d008

08010cac <SEGGER_RTT_ConfigDownBuffer>:
*  Additional information
*    Buffer 0 is configured on compile-time.
*    May only be called once per buffer.
*    Buffer name and flags can be reconfigured using the appropriate functions.
*/
int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
 8010cac:	b580      	push	{r7, lr}
 8010cae:	b086      	sub	sp, #24
 8010cb0:	af00      	add	r7, sp, #0
 8010cb2:	60f8      	str	r0, [r7, #12]
 8010cb4:	60b9      	str	r1, [r7, #8]
 8010cb6:	607a      	str	r2, [r7, #4]
 8010cb8:	603b      	str	r3, [r7, #0]
  int r;

  INIT();
 8010cba:	4b30      	ldr	r3, [pc, #192]	; (8010d7c <SEGGER_RTT_ConfigDownBuffer+0xd0>)
 8010cbc:	781b      	ldrb	r3, [r3, #0]
 8010cbe:	2b00      	cmp	r3, #0
 8010cc0:	d101      	bne.n	8010cc6 <SEGGER_RTT_ConfigDownBuffer+0x1a>
 8010cc2:	f7ff fe1b 	bl	80108fc <_DoInit>
  if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
 8010cc6:	4b2d      	ldr	r3, [pc, #180]	; (8010d7c <SEGGER_RTT_ConfigDownBuffer+0xd0>)
 8010cc8:	695b      	ldr	r3, [r3, #20]
 8010cca:	461a      	mov	r2, r3
 8010ccc:	68fb      	ldr	r3, [r7, #12]
 8010cce:	429a      	cmp	r2, r3
 8010cd0:	d94b      	bls.n	8010d6a <SEGGER_RTT_ConfigDownBuffer+0xbe>
    SEGGER_RTT_LOCK();
 8010cd2:	f3ef 8311 	mrs	r3, BASEPRI
 8010cd6:	f04f 0120 	mov.w	r1, #32
 8010cda:	f381 8811 	msr	BASEPRI, r1
 8010cde:	613b      	str	r3, [r7, #16]
    if (BufferIndex > 0u) {
 8010ce0:	68fb      	ldr	r3, [r7, #12]
 8010ce2:	2b00      	cmp	r3, #0
 8010ce4:	d031      	beq.n	8010d4a <SEGGER_RTT_ConfigDownBuffer+0x9e>
      _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
 8010ce6:	4925      	ldr	r1, [pc, #148]	; (8010d7c <SEGGER_RTT_ConfigDownBuffer+0xd0>)
 8010ce8:	68fa      	ldr	r2, [r7, #12]
 8010cea:	4613      	mov	r3, r2
 8010cec:	005b      	lsls	r3, r3, #1
 8010cee:	4413      	add	r3, r2
 8010cf0:	00db      	lsls	r3, r3, #3
 8010cf2:	440b      	add	r3, r1
 8010cf4:	3360      	adds	r3, #96	; 0x60
 8010cf6:	68ba      	ldr	r2, [r7, #8]
 8010cf8:	601a      	str	r2, [r3, #0]
      _SEGGER_RTT.aDown[BufferIndex].pBuffer      = (char*)pBuffer;
 8010cfa:	4920      	ldr	r1, [pc, #128]	; (8010d7c <SEGGER_RTT_ConfigDownBuffer+0xd0>)
 8010cfc:	68fa      	ldr	r2, [r7, #12]
 8010cfe:	4613      	mov	r3, r2
 8010d00:	005b      	lsls	r3, r3, #1
 8010d02:	4413      	add	r3, r2
 8010d04:	00db      	lsls	r3, r3, #3
 8010d06:	440b      	add	r3, r1
 8010d08:	3360      	adds	r3, #96	; 0x60
 8010d0a:	687a      	ldr	r2, [r7, #4]
 8010d0c:	605a      	str	r2, [r3, #4]
      _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
 8010d0e:	491b      	ldr	r1, [pc, #108]	; (8010d7c <SEGGER_RTT_ConfigDownBuffer+0xd0>)
 8010d10:	68fa      	ldr	r2, [r7, #12]
 8010d12:	4613      	mov	r3, r2
 8010d14:	005b      	lsls	r3, r3, #1
 8010d16:	4413      	add	r3, r2
 8010d18:	00db      	lsls	r3, r3, #3
 8010d1a:	440b      	add	r3, r1
 8010d1c:	3368      	adds	r3, #104	; 0x68
 8010d1e:	683a      	ldr	r2, [r7, #0]
 8010d20:	601a      	str	r2, [r3, #0]
      _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
 8010d22:	4916      	ldr	r1, [pc, #88]	; (8010d7c <SEGGER_RTT_ConfigDownBuffer+0xd0>)
 8010d24:	68fa      	ldr	r2, [r7, #12]
 8010d26:	4613      	mov	r3, r2
 8010d28:	005b      	lsls	r3, r3, #1
 8010d2a:	4413      	add	r3, r2
 8010d2c:	00db      	lsls	r3, r3, #3
 8010d2e:	440b      	add	r3, r1
 8010d30:	3370      	adds	r3, #112	; 0x70
 8010d32:	2200      	movs	r2, #0
 8010d34:	601a      	str	r2, [r3, #0]
      _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
 8010d36:	4911      	ldr	r1, [pc, #68]	; (8010d7c <SEGGER_RTT_ConfigDownBuffer+0xd0>)
 8010d38:	68fa      	ldr	r2, [r7, #12]
 8010d3a:	4613      	mov	r3, r2
 8010d3c:	005b      	lsls	r3, r3, #1
 8010d3e:	4413      	add	r3, r2
 8010d40:	00db      	lsls	r3, r3, #3
 8010d42:	440b      	add	r3, r1
 8010d44:	3368      	adds	r3, #104	; 0x68
 8010d46:	2200      	movs	r2, #0
 8010d48:	605a      	str	r2, [r3, #4]
    }
    _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
 8010d4a:	490c      	ldr	r1, [pc, #48]	; (8010d7c <SEGGER_RTT_ConfigDownBuffer+0xd0>)
 8010d4c:	68fa      	ldr	r2, [r7, #12]
 8010d4e:	4613      	mov	r3, r2
 8010d50:	005b      	lsls	r3, r3, #1
 8010d52:	4413      	add	r3, r2
 8010d54:	00db      	lsls	r3, r3, #3
 8010d56:	440b      	add	r3, r1
 8010d58:	3370      	adds	r3, #112	; 0x70
 8010d5a:	6a3a      	ldr	r2, [r7, #32]
 8010d5c:	605a      	str	r2, [r3, #4]
    SEGGER_RTT_UNLOCK();
 8010d5e:	693b      	ldr	r3, [r7, #16]
 8010d60:	f383 8811 	msr	BASEPRI, r3
    r =  0;
 8010d64:	2300      	movs	r3, #0
 8010d66:	617b      	str	r3, [r7, #20]
 8010d68:	e002      	b.n	8010d70 <SEGGER_RTT_ConfigDownBuffer+0xc4>
  } else {
    r = -1;
 8010d6a:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8010d6e:	617b      	str	r3, [r7, #20]
  }
  return r;
 8010d70:	697b      	ldr	r3, [r7, #20]
}
 8010d72:	4618      	mov	r0, r3
 8010d74:	3718      	adds	r7, #24
 8010d76:	46bd      	mov	sp, r7
 8010d78:	bd80      	pop	{r7, pc}
 8010d7a:	bf00      	nop
 8010d7c:	2000d008 	.word	0x2000d008

08010d80 <_EncodeStr>:
*  Additional information
*    The string is encoded as a count byte followed by the contents
*    of the string.
*    No more than 1 + Limit bytes will be encoded to the payload.
*/
static U8 *_EncodeStr(U8 *pPayload, const char *pText, unsigned int Limit) {
 8010d80:	b480      	push	{r7}
 8010d82:	b087      	sub	sp, #28
 8010d84:	af00      	add	r7, sp, #0
 8010d86:	60f8      	str	r0, [r7, #12]
 8010d88:	60b9      	str	r1, [r7, #8]
 8010d8a:	607a      	str	r2, [r7, #4]
  unsigned int n;
  unsigned int Len;
  //
  // Compute string len
  //
  Len = 0;
 8010d8c:	2300      	movs	r3, #0
 8010d8e:	613b      	str	r3, [r7, #16]
  while(*(pText + Len) != 0) {
 8010d90:	e002      	b.n	8010d98 <_EncodeStr+0x18>
    Len++;
 8010d92:	693b      	ldr	r3, [r7, #16]
 8010d94:	3301      	adds	r3, #1
 8010d96:	613b      	str	r3, [r7, #16]
  unsigned int Len;
  //
  // Compute string len
  //
  Len = 0;
  while(*(pText + Len) != 0) {
 8010d98:	68ba      	ldr	r2, [r7, #8]
 8010d9a:	693b      	ldr	r3, [r7, #16]
 8010d9c:	4413      	add	r3, r2
 8010d9e:	781b      	ldrb	r3, [r3, #0]
 8010da0:	2b00      	cmp	r3, #0
 8010da2:	d1f6      	bne.n	8010d92 <_EncodeStr+0x12>
    Len++;
  }
  if (Len > Limit) {
 8010da4:	693a      	ldr	r2, [r7, #16]
 8010da6:	687b      	ldr	r3, [r7, #4]
 8010da8:	429a      	cmp	r2, r3
 8010daa:	d901      	bls.n	8010db0 <_EncodeStr+0x30>
    Len = Limit;
 8010dac:	687b      	ldr	r3, [r7, #4]
 8010dae:	613b      	str	r3, [r7, #16]
  }
  //
  // Write Len
  //
  if (Len < 255)  {
 8010db0:	693b      	ldr	r3, [r7, #16]
 8010db2:	2bfe      	cmp	r3, #254	; 0xfe
 8010db4:	d806      	bhi.n	8010dc4 <_EncodeStr+0x44>
    *pPayload++ = Len; 
 8010db6:	68fb      	ldr	r3, [r7, #12]
 8010db8:	1c5a      	adds	r2, r3, #1
 8010dba:	60fa      	str	r2, [r7, #12]
 8010dbc:	693a      	ldr	r2, [r7, #16]
 8010dbe:	b2d2      	uxtb	r2, r2
 8010dc0:	701a      	strb	r2, [r3, #0]
 8010dc2:	e011      	b.n	8010de8 <_EncodeStr+0x68>
  } else {
    *pPayload++ = 255;
 8010dc4:	68fb      	ldr	r3, [r7, #12]
 8010dc6:	1c5a      	adds	r2, r3, #1
 8010dc8:	60fa      	str	r2, [r7, #12]
 8010dca:	22ff      	movs	r2, #255	; 0xff
 8010dcc:	701a      	strb	r2, [r3, #0]
    *pPayload++ = (Len & 255);
 8010dce:	68fb      	ldr	r3, [r7, #12]
 8010dd0:	1c5a      	adds	r2, r3, #1
 8010dd2:	60fa      	str	r2, [r7, #12]
 8010dd4:	693a      	ldr	r2, [r7, #16]
 8010dd6:	b2d2      	uxtb	r2, r2
 8010dd8:	701a      	strb	r2, [r3, #0]
    *pPayload++ = ((Len >> 8) & 255);
 8010dda:	68fb      	ldr	r3, [r7, #12]
 8010ddc:	1c5a      	adds	r2, r3, #1
 8010dde:	60fa      	str	r2, [r7, #12]
 8010de0:	693a      	ldr	r2, [r7, #16]
 8010de2:	0a12      	lsrs	r2, r2, #8
 8010de4:	b2d2      	uxtb	r2, r2
 8010de6:	701a      	strb	r2, [r3, #0]
  }
  //
  // copy string
  //
  n = 0;
 8010de8:	2300      	movs	r3, #0
 8010dea:	617b      	str	r3, [r7, #20]
  while (n < Len) {
 8010dec:	e00a      	b.n	8010e04 <_EncodeStr+0x84>
    *pPayload++ = *pText++;
 8010dee:	68fb      	ldr	r3, [r7, #12]
 8010df0:	1c5a      	adds	r2, r3, #1
 8010df2:	60fa      	str	r2, [r7, #12]
 8010df4:	68ba      	ldr	r2, [r7, #8]
 8010df6:	1c51      	adds	r1, r2, #1
 8010df8:	60b9      	str	r1, [r7, #8]
 8010dfa:	7812      	ldrb	r2, [r2, #0]
 8010dfc:	701a      	strb	r2, [r3, #0]
    n++;
 8010dfe:	697b      	ldr	r3, [r7, #20]
 8010e00:	3301      	adds	r3, #1
 8010e02:	617b      	str	r3, [r7, #20]
  }
  //
  // copy string
  //
  n = 0;
  while (n < Len) {
 8010e04:	697a      	ldr	r2, [r7, #20]
 8010e06:	693b      	ldr	r3, [r7, #16]
 8010e08:	429a      	cmp	r2, r3
 8010e0a:	d3f0      	bcc.n	8010dee <_EncodeStr+0x6e>
    *pPayload++ = *pText++;
    n++;
  }
  return pPayload;
 8010e0c:	68fb      	ldr	r3, [r7, #12]
}
 8010e0e:	4618      	mov	r0, r3
 8010e10:	371c      	adds	r7, #28
 8010e12:	46bd      	mov	sp, r7
 8010e14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e18:	4770      	bx	lr
 8010e1a:	bf00      	nop

08010e1c <_PreparePacket>:
*  Additional information
*    The payload length and evnetId are not initialized.
*    PreparePacket only reserves space for them and they are
*    computed and filled in by the sending function.
*/
static U8* _PreparePacket(U8* pPacket) {
 8010e1c:	b480      	push	{r7}
 8010e1e:	b083      	sub	sp, #12
 8010e20:	af00      	add	r7, sp, #0
 8010e22:	6078      	str	r0, [r7, #4]
  return pPacket + 4;
 8010e24:	687b      	ldr	r3, [r7, #4]
 8010e26:	3304      	adds	r3, #4
}
 8010e28:	4618      	mov	r0, r3
 8010e2a:	370c      	adds	r7, #12
 8010e2c:	46bd      	mov	sp, r7
 8010e2e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8010e32:	4770      	bx	lr

08010e34 <_HandleIncomingPacket>:
*    This function is called each time after sending a packet.
*    Processing incoming packets is done asynchronous. SystemView might
*    already have sent event packets after the host has sent a command.
*/
#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
static void _HandleIncomingPacket(void) {
 8010e34:	b580      	push	{r7, lr}
 8010e36:	b082      	sub	sp, #8
 8010e38:	af00      	add	r7, sp, #0
  U8  Cmd;
  int Status;
  //
  Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
 8010e3a:	1cfb      	adds	r3, r7, #3
 8010e3c:	2001      	movs	r0, #1
 8010e3e:	4619      	mov	r1, r3
 8010e40:	2201      	movs	r2, #1
 8010e42:	f7ff fda9 	bl	8010998 <SEGGER_RTT_ReadNoLock>
 8010e46:	4603      	mov	r3, r0
 8010e48:	607b      	str	r3, [r7, #4]
  if (Status > 0) {
 8010e4a:	687b      	ldr	r3, [r7, #4]
 8010e4c:	2b00      	cmp	r3, #0
 8010e4e:	dd46      	ble.n	8010ede <_HandleIncomingPacket+0xaa>
    switch (Cmd) {
 8010e50:	78fb      	ldrb	r3, [r7, #3]
 8010e52:	2b04      	cmp	r3, #4
 8010e54:	d01a      	beq.n	8010e8c <_HandleIncomingPacket+0x58>
 8010e56:	2b04      	cmp	r3, #4
 8010e58:	dc06      	bgt.n	8010e68 <_HandleIncomingPacket+0x34>
 8010e5a:	2b02      	cmp	r3, #2
 8010e5c:	d010      	beq.n	8010e80 <_HandleIncomingPacket+0x4c>
 8010e5e:	2b02      	cmp	r3, #2
 8010e60:	dc11      	bgt.n	8010e86 <_HandleIncomingPacket+0x52>
 8010e62:	2b01      	cmp	r3, #1
 8010e64:	d009      	beq.n	8010e7a <_HandleIncomingPacket+0x46>
 8010e66:	e02e      	b.n	8010ec6 <_HandleIncomingPacket+0x92>
 8010e68:	2b06      	cmp	r3, #6
 8010e6a:	d015      	beq.n	8010e98 <_HandleIncomingPacket+0x64>
 8010e6c:	2b06      	cmp	r3, #6
 8010e6e:	db10      	blt.n	8010e92 <_HandleIncomingPacket+0x5e>
 8010e70:	2b07      	cmp	r3, #7
 8010e72:	d014      	beq.n	8010e9e <_HandleIncomingPacket+0x6a>
 8010e74:	2b80      	cmp	r3, #128	; 0x80
 8010e76:	d015      	beq.n	8010ea4 <_HandleIncomingPacket+0x70>
 8010e78:	e025      	b.n	8010ec6 <_HandleIncomingPacket+0x92>
    case SEGGER_SYSVIEW_COMMAND_ID_START:
      SEGGER_SYSVIEW_Start();
 8010e7a:	f000 fadd 	bl	8011438 <SEGGER_SYSVIEW_Start>
      break;
 8010e7e:	e02e      	b.n	8010ede <_HandleIncomingPacket+0xaa>
    case SEGGER_SYSVIEW_COMMAND_ID_STOP:
      SEGGER_SYSVIEW_Stop();
 8010e80:	f000 fb96 	bl	80115b0 <SEGGER_SYSVIEW_Stop>
      break;
 8010e84:	e02b      	b.n	8010ede <_HandleIncomingPacket+0xaa>
    case SEGGER_SYSVIEW_COMMAND_ID_GET_SYSTIME:
      SEGGER_SYSVIEW_RecordSystime();
 8010e86:	f000 fd69 	bl	801195c <SEGGER_SYSVIEW_RecordSystime>
      break;
 8010e8a:	e028      	b.n	8010ede <_HandleIncomingPacket+0xaa>
    case SEGGER_SYSVIEW_COMMAND_ID_GET_TASKLIST:
      SEGGER_SYSVIEW_SendTaskList();
 8010e8c:	f000 fd32 	bl	80118f4 <SEGGER_SYSVIEW_SendTaskList>
      break;
 8010e90:	e025      	b.n	8010ede <_HandleIncomingPacket+0xaa>
    case SEGGER_SYSVIEW_COMMAND_ID_GET_SYSDESC:
      SEGGER_SYSVIEW_GetSysDesc();
 8010e92:	f000 fbb1 	bl	80115f8 <SEGGER_SYSVIEW_GetSysDesc>
      break;
 8010e96:	e022      	b.n	8010ede <_HandleIncomingPacket+0xaa>
    case SEGGER_SYSVIEW_COMMAND_ID_GET_NUMMODULES:
      SEGGER_SYSVIEW_SendNumModules();
 8010e98:	f001 f834 	bl	8011f04 <SEGGER_SYSVIEW_SendNumModules>
      break;
 8010e9c:	e01f      	b.n	8010ede <_HandleIncomingPacket+0xaa>
    case SEGGER_SYSVIEW_COMMAND_ID_GET_MODULEDESC:
      SEGGER_SYSVIEW_SendModuleDescription();
 8010e9e:	f001 f815 	bl	8011ecc <SEGGER_SYSVIEW_SendModuleDescription>
      break;
 8010ea2:	e01c      	b.n	8010ede <_HandleIncomingPacket+0xaa>
    case SEGGER_SYSVIEW_COMMAND_ID_GET_MODULE:
      Status = SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
 8010ea4:	1cfb      	adds	r3, r7, #3
 8010ea6:	2001      	movs	r0, #1
 8010ea8:	4619      	mov	r1, r3
 8010eaa:	2201      	movs	r2, #1
 8010eac:	f7ff fd74 	bl	8010998 <SEGGER_RTT_ReadNoLock>
 8010eb0:	4603      	mov	r3, r0
 8010eb2:	607b      	str	r3, [r7, #4]
      if (Status > 0) {
 8010eb4:	687b      	ldr	r3, [r7, #4]
 8010eb6:	2b00      	cmp	r3, #0
 8010eb8:	dd04      	ble.n	8010ec4 <_HandleIncomingPacket+0x90>
        SEGGER_SYSVIEW_SendModule(Cmd);
 8010eba:	78fb      	ldrb	r3, [r7, #3]
 8010ebc:	4618      	mov	r0, r3
 8010ebe:	f000 ff87 	bl	8011dd0 <SEGGER_SYSVIEW_SendModule>
      }
      break;
 8010ec2:	e00c      	b.n	8010ede <_HandleIncomingPacket+0xaa>
 8010ec4:	e00b      	b.n	8010ede <_HandleIncomingPacket+0xaa>
    default:
      if (Cmd >= 128) { // Unknown extended command. Dummy read its parameter.
 8010ec6:	78fb      	ldrb	r3, [r7, #3]
 8010ec8:	b2db      	uxtb	r3, r3
 8010eca:	b25b      	sxtb	r3, r3
 8010ecc:	2b00      	cmp	r3, #0
 8010ece:	da05      	bge.n	8010edc <_HandleIncomingPacket+0xa8>
        SEGGER_RTT_ReadNoLock(CHANNEL_ID_DOWN, &Cmd, 1);
 8010ed0:	1cfb      	adds	r3, r7, #3
 8010ed2:	2001      	movs	r0, #1
 8010ed4:	4619      	mov	r1, r3
 8010ed6:	2201      	movs	r2, #1
 8010ed8:	f7ff fd5e 	bl	8010998 <SEGGER_RTT_ReadNoLock>
      }
      break;
 8010edc:	bf00      	nop
    }
  }
}
 8010ede:	3708      	adds	r7, #8
 8010ee0:	46bd      	mov	sp, r7
 8010ee2:	bd80      	pop	{r7, pc}

08010ee4 <_TrySendOverflowPacket>:
*    !=0:  Success, Message sent (stored in RTT-Buffer)
*    ==0:  Buffer full, Message *NOT* stored
*
*/
#if (SEGGER_SYSVIEW_POST_MORTEM_MODE != 1)
static int _TrySendOverflowPacket(void) {
 8010ee4:	b580      	push	{r7, lr}
 8010ee6:	b08c      	sub	sp, #48	; 0x30
 8010ee8:	af00      	add	r7, sp, #0
  I32 Delta;
  int Status;
  U8  aPacket[11];
  U8* pPayload;

  aPacket[0] = SYSVIEW_EVTID_OVERFLOW;      // 1
 8010eea:	2301      	movs	r3, #1
 8010eec:	713b      	strb	r3, [r7, #4]
  pPayload   = &aPacket[1];
 8010eee:	1d3b      	adds	r3, r7, #4
 8010ef0:	3301      	adds	r3, #1
 8010ef2:	61fb      	str	r3, [r7, #28]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.DropCount);
 8010ef4:	69fb      	ldr	r3, [r7, #28]
 8010ef6:	62fb      	str	r3, [r7, #44]	; 0x2c
 8010ef8:	4b30      	ldr	r3, [pc, #192]	; (8010fbc <_TrySendOverflowPacket+0xd8>)
 8010efa:	695b      	ldr	r3, [r3, #20]
 8010efc:	62bb      	str	r3, [r7, #40]	; 0x28
 8010efe:	e00b      	b.n	8010f18 <_TrySendOverflowPacket+0x34>
 8010f00:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010f02:	1c5a      	adds	r2, r3, #1
 8010f04:	62fa      	str	r2, [r7, #44]	; 0x2c
 8010f06:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8010f08:	b2d2      	uxtb	r2, r2
 8010f0a:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8010f0e:	b2d2      	uxtb	r2, r2
 8010f10:	701a      	strb	r2, [r3, #0]
 8010f12:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010f14:	09db      	lsrs	r3, r3, #7
 8010f16:	62bb      	str	r3, [r7, #40]	; 0x28
 8010f18:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8010f1a:	2b7f      	cmp	r3, #127	; 0x7f
 8010f1c:	d8f0      	bhi.n	8010f00 <_TrySendOverflowPacket+0x1c>
 8010f1e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010f20:	1c5a      	adds	r2, r3, #1
 8010f22:	62fa      	str	r2, [r7, #44]	; 0x2c
 8010f24:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8010f26:	b2d2      	uxtb	r2, r2
 8010f28:	701a      	strb	r2, [r3, #0]
 8010f2a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8010f2c:	61fb      	str	r3, [r7, #28]
  //
  // Compute time stamp delta and append it to packet.
  //
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8010f2e:	4b24      	ldr	r3, [pc, #144]	; (8010fc0 <_TrySendOverflowPacket+0xdc>)
 8010f30:	681b      	ldr	r3, [r3, #0]
 8010f32:	61bb      	str	r3, [r7, #24]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
 8010f34:	4b21      	ldr	r3, [pc, #132]	; (8010fbc <_TrySendOverflowPacket+0xd8>)
 8010f36:	68db      	ldr	r3, [r3, #12]
 8010f38:	69ba      	ldr	r2, [r7, #24]
 8010f3a:	1ad3      	subs	r3, r2, r3
 8010f3c:	617b      	str	r3, [r7, #20]
  MAKE_DELTA_32BIT(Delta);
  ENCODE_U32(pPayload, Delta);
 8010f3e:	69fb      	ldr	r3, [r7, #28]
 8010f40:	627b      	str	r3, [r7, #36]	; 0x24
 8010f42:	697b      	ldr	r3, [r7, #20]
 8010f44:	623b      	str	r3, [r7, #32]
 8010f46:	e00b      	b.n	8010f60 <_TrySendOverflowPacket+0x7c>
 8010f48:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010f4a:	1c5a      	adds	r2, r3, #1
 8010f4c:	627a      	str	r2, [r7, #36]	; 0x24
 8010f4e:	6a3a      	ldr	r2, [r7, #32]
 8010f50:	b2d2      	uxtb	r2, r2
 8010f52:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8010f56:	b2d2      	uxtb	r2, r2
 8010f58:	701a      	strb	r2, [r3, #0]
 8010f5a:	6a3b      	ldr	r3, [r7, #32]
 8010f5c:	09db      	lsrs	r3, r3, #7
 8010f5e:	623b      	str	r3, [r7, #32]
 8010f60:	6a3b      	ldr	r3, [r7, #32]
 8010f62:	2b7f      	cmp	r3, #127	; 0x7f
 8010f64:	d8f0      	bhi.n	8010f48 <_TrySendOverflowPacket+0x64>
 8010f66:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010f68:	1c5a      	adds	r2, r3, #1
 8010f6a:	627a      	str	r2, [r7, #36]	; 0x24
 8010f6c:	6a3a      	ldr	r2, [r7, #32]
 8010f6e:	b2d2      	uxtb	r2, r2
 8010f70:	701a      	strb	r2, [r3, #0]
 8010f72:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8010f74:	61fb      	str	r3, [r7, #28]
  //
  // Try to store packet in RTT buffer and update time stamp when this was successful
  //
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, aPacket, pPayload - aPacket);
 8010f76:	69fa      	ldr	r2, [r7, #28]
 8010f78:	1d3b      	adds	r3, r7, #4
 8010f7a:	1ad3      	subs	r3, r2, r3
 8010f7c:	461a      	mov	r2, r3
 8010f7e:	1d3b      	adds	r3, r7, #4
 8010f80:	2001      	movs	r0, #1
 8010f82:	4619      	mov	r1, r3
 8010f84:	f7ff fd8a 	bl	8010a9c <SEGGER_RTT_WriteSkipNoLock>
 8010f88:	4603      	mov	r3, r0
 8010f8a:	613b      	str	r3, [r7, #16]
  if (Status) {
 8010f8c:	693b      	ldr	r3, [r7, #16]
 8010f8e:	2b00      	cmp	r3, #0
 8010f90:	d009      	beq.n	8010fa6 <_TrySendOverflowPacket+0xc2>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
 8010f92:	4a0a      	ldr	r2, [pc, #40]	; (8010fbc <_TrySendOverflowPacket+0xd8>)
 8010f94:	69bb      	ldr	r3, [r7, #24]
 8010f96:	60d3      	str	r3, [r2, #12]
    _SYSVIEW_Globals.EnableState--; // EnableState has been 2, will be 1. Always.
 8010f98:	4b08      	ldr	r3, [pc, #32]	; (8010fbc <_TrySendOverflowPacket+0xd8>)
 8010f9a:	781b      	ldrb	r3, [r3, #0]
 8010f9c:	3b01      	subs	r3, #1
 8010f9e:	b2da      	uxtb	r2, r3
 8010fa0:	4b06      	ldr	r3, [pc, #24]	; (8010fbc <_TrySendOverflowPacket+0xd8>)
 8010fa2:	701a      	strb	r2, [r3, #0]
 8010fa4:	e004      	b.n	8010fb0 <_TrySendOverflowPacket+0xcc>
  } else {
    _SYSVIEW_Globals.DropCount++;
 8010fa6:	4b05      	ldr	r3, [pc, #20]	; (8010fbc <_TrySendOverflowPacket+0xd8>)
 8010fa8:	695b      	ldr	r3, [r3, #20]
 8010faa:	3301      	adds	r3, #1
 8010fac:	4a03      	ldr	r2, [pc, #12]	; (8010fbc <_TrySendOverflowPacket+0xd8>)
 8010fae:	6153      	str	r3, [r2, #20]
  }
  //
  return Status;
 8010fb0:	693b      	ldr	r3, [r7, #16]
}
 8010fb2:	4618      	mov	r0, r3
 8010fb4:	3730      	adds	r7, #48	; 0x30
 8010fb6:	46bd      	mov	sp, r7
 8010fb8:	bd80      	pop	{r7, pc}
 8010fba:	bf00      	nop
 8010fbc:	2000cd14 	.word	0x2000cd14
 8010fc0:	e0001004 	.word	0xe0001004

08010fc4 <_SendPacket>:
*                   There must be at least 4 bytes free to prepend Id and Length.
*    pEndPacket   - Pointer to end of packet payload.
*    EventId      - Id of the event to send.
*
*/
static void _SendPacket(U8* pStartPacket, U8* pEndPacket, unsigned int EventId) {
 8010fc4:	b580      	push	{r7, lr}
 8010fc6:	b08a      	sub	sp, #40	; 0x28
 8010fc8:	af00      	add	r7, sp, #0
 8010fca:	60f8      	str	r0, [r7, #12]
 8010fcc:	60b9      	str	r1, [r7, #8]
 8010fce:	607a      	str	r2, [r7, #4]
#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
  if (_SYSVIEW_Globals.EnableState == 0) {
    goto SendDone;
  }
#else
  if (_SYSVIEW_Globals.EnableState == 1) {  // Enabled, no dropped packets remaining
 8010fd0:	4b5e      	ldr	r3, [pc, #376]	; (801114c <_SendPacket+0x188>)
 8010fd2:	781b      	ldrb	r3, [r3, #0]
 8010fd4:	2b01      	cmp	r3, #1
 8010fd6:	d100      	bne.n	8010fda <_SendPacket+0x16>
    goto Send;
 8010fd8:	e00f      	b.n	8010ffa <_SendPacket+0x36>
  }
  if (_SYSVIEW_Globals.EnableState == 0) {
 8010fda:	4b5c      	ldr	r3, [pc, #368]	; (801114c <_SendPacket+0x188>)
 8010fdc:	781b      	ldrb	r3, [r3, #0]
 8010fde:	2b00      	cmp	r3, #0
 8010fe0:	d100      	bne.n	8010fe4 <_SendPacket+0x20>
    goto SendDone;
 8010fe2:	e09b      	b.n	801111c <_SendPacket+0x158>
  //
  // Handle buffer full situations:
  // Have packets been dropped before because buffer was full?
  // In this case try to send and overflow packet.
  //
  if (_SYSVIEW_Globals.EnableState == 2) {
 8010fe4:	4b59      	ldr	r3, [pc, #356]	; (801114c <_SendPacket+0x188>)
 8010fe6:	781b      	ldrb	r3, [r3, #0]
 8010fe8:	2b02      	cmp	r3, #2
 8010fea:	d106      	bne.n	8010ffa <_SendPacket+0x36>
    _TrySendOverflowPacket();
 8010fec:	f7ff ff7a 	bl	8010ee4 <_TrySendOverflowPacket>
    if (_SYSVIEW_Globals.EnableState != 1) {
 8010ff0:	4b56      	ldr	r3, [pc, #344]	; (801114c <_SendPacket+0x188>)
 8010ff2:	781b      	ldrb	r3, [r3, #0]
 8010ff4:	2b01      	cmp	r3, #1
 8010ff6:	d000      	beq.n	8010ffa <_SendPacket+0x36>
      goto SendDone;
 8010ff8:	e090      	b.n	801111c <_SendPacket+0x158>
Send:
#endif
  //
  // Check if event is disabled from being recorded.
  //
  if (EventId < 32) {
 8010ffa:	687b      	ldr	r3, [r7, #4]
 8010ffc:	2b1f      	cmp	r3, #31
 8010ffe:	d809      	bhi.n	8011014 <_SendPacket+0x50>
    if (_SYSVIEW_Globals.DisabledEvents & ((U32)1u << EventId)) {
 8011000:	4b52      	ldr	r3, [pc, #328]	; (801114c <_SendPacket+0x188>)
 8011002:	69da      	ldr	r2, [r3, #28]
 8011004:	687b      	ldr	r3, [r7, #4]
 8011006:	fa22 f303 	lsr.w	r3, r2, r3
 801100a:	f003 0301 	and.w	r3, r3, #1
 801100e:	2b00      	cmp	r3, #0
 8011010:	d000      	beq.n	8011014 <_SendPacket+0x50>
      goto SendDone;
 8011012:	e083      	b.n	801111c <_SendPacket+0x158>
  //
  // Prepare actual packet.
  // If it is a known packet, prepend eventId only,
  // otherwise prepend packet length and eventId.
  //
  if (EventId < 24) {
 8011014:	687b      	ldr	r3, [r7, #4]
 8011016:	2b17      	cmp	r3, #23
 8011018:	d807      	bhi.n	801102a <_SendPacket+0x66>
    *--pStartPacket = EventId;
 801101a:	68fb      	ldr	r3, [r7, #12]
 801101c:	3b01      	subs	r3, #1
 801101e:	60fb      	str	r3, [r7, #12]
 8011020:	687b      	ldr	r3, [r7, #4]
 8011022:	b2da      	uxtb	r2, r3
 8011024:	68fb      	ldr	r3, [r7, #12]
 8011026:	701a      	strb	r2, [r3, #0]
 8011028:	e03d      	b.n	80110a6 <_SendPacket+0xe2>
  } else {
    NumBytes = pEndPacket - pStartPacket;
 801102a:	68ba      	ldr	r2, [r7, #8]
 801102c:	68fb      	ldr	r3, [r7, #12]
 801102e:	1ad3      	subs	r3, r2, r3
 8011030:	61fb      	str	r3, [r7, #28]
    if (NumBytes > 127) {
 8011032:	69fb      	ldr	r3, [r7, #28]
 8011034:	2b7f      	cmp	r3, #127	; 0x7f
 8011036:	d912      	bls.n	801105e <_SendPacket+0x9a>
      *--pStartPacket = (NumBytes >> 7);
 8011038:	68fb      	ldr	r3, [r7, #12]
 801103a:	3b01      	subs	r3, #1
 801103c:	60fb      	str	r3, [r7, #12]
 801103e:	69fb      	ldr	r3, [r7, #28]
 8011040:	09db      	lsrs	r3, r3, #7
 8011042:	b2da      	uxtb	r2, r3
 8011044:	68fb      	ldr	r3, [r7, #12]
 8011046:	701a      	strb	r2, [r3, #0]
      *--pStartPacket = NumBytes | 0x80;
 8011048:	68fb      	ldr	r3, [r7, #12]
 801104a:	3b01      	subs	r3, #1
 801104c:	60fb      	str	r3, [r7, #12]
 801104e:	69fb      	ldr	r3, [r7, #28]
 8011050:	b2db      	uxtb	r3, r3
 8011052:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8011056:	b2da      	uxtb	r2, r3
 8011058:	68fb      	ldr	r3, [r7, #12]
 801105a:	701a      	strb	r2, [r3, #0]
 801105c:	e006      	b.n	801106c <_SendPacket+0xa8>
    } else {
      *--pStartPacket = NumBytes;
 801105e:	68fb      	ldr	r3, [r7, #12]
 8011060:	3b01      	subs	r3, #1
 8011062:	60fb      	str	r3, [r7, #12]
 8011064:	69fb      	ldr	r3, [r7, #28]
 8011066:	b2da      	uxtb	r2, r3
 8011068:	68fb      	ldr	r3, [r7, #12]
 801106a:	701a      	strb	r2, [r3, #0]
    }
    if (EventId > 127) {
 801106c:	687b      	ldr	r3, [r7, #4]
 801106e:	2b7f      	cmp	r3, #127	; 0x7f
 8011070:	d912      	bls.n	8011098 <_SendPacket+0xd4>
      *--pStartPacket = (EventId >> 7);
 8011072:	68fb      	ldr	r3, [r7, #12]
 8011074:	3b01      	subs	r3, #1
 8011076:	60fb      	str	r3, [r7, #12]
 8011078:	687b      	ldr	r3, [r7, #4]
 801107a:	09db      	lsrs	r3, r3, #7
 801107c:	b2da      	uxtb	r2, r3
 801107e:	68fb      	ldr	r3, [r7, #12]
 8011080:	701a      	strb	r2, [r3, #0]
      *--pStartPacket = EventId | 0x80;
 8011082:	68fb      	ldr	r3, [r7, #12]
 8011084:	3b01      	subs	r3, #1
 8011086:	60fb      	str	r3, [r7, #12]
 8011088:	687b      	ldr	r3, [r7, #4]
 801108a:	b2db      	uxtb	r3, r3
 801108c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8011090:	b2da      	uxtb	r2, r3
 8011092:	68fb      	ldr	r3, [r7, #12]
 8011094:	701a      	strb	r2, [r3, #0]
 8011096:	e006      	b.n	80110a6 <_SendPacket+0xe2>
    } else {
      *--pStartPacket = EventId;
 8011098:	68fb      	ldr	r3, [r7, #12]
 801109a:	3b01      	subs	r3, #1
 801109c:	60fb      	str	r3, [r7, #12]
 801109e:	687b      	ldr	r3, [r7, #4]
 80110a0:	b2da      	uxtb	r2, r3
 80110a2:	68fb      	ldr	r3, [r7, #12]
 80110a4:	701a      	strb	r2, [r3, #0]
    }
  }
  //
  // Compute time stamp delta and append it to packet.
  //
  TimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 80110a6:	4b2a      	ldr	r3, [pc, #168]	; (8011150 <_SendPacket+0x18c>)
 80110a8:	681b      	ldr	r3, [r3, #0]
 80110aa:	61bb      	str	r3, [r7, #24]
  Delta = TimeStamp - _SYSVIEW_Globals.LastTxTimeStamp;
 80110ac:	4b27      	ldr	r3, [pc, #156]	; (801114c <_SendPacket+0x188>)
 80110ae:	68db      	ldr	r3, [r3, #12]
 80110b0:	69ba      	ldr	r2, [r7, #24]
 80110b2:	1ad3      	subs	r3, r2, r3
 80110b4:	617b      	str	r3, [r7, #20]
  MAKE_DELTA_32BIT(Delta);
  ENCODE_U32(pEndPacket, Delta);
 80110b6:	68bb      	ldr	r3, [r7, #8]
 80110b8:	627b      	str	r3, [r7, #36]	; 0x24
 80110ba:	697b      	ldr	r3, [r7, #20]
 80110bc:	623b      	str	r3, [r7, #32]
 80110be:	e00b      	b.n	80110d8 <_SendPacket+0x114>
 80110c0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80110c2:	1c5a      	adds	r2, r3, #1
 80110c4:	627a      	str	r2, [r7, #36]	; 0x24
 80110c6:	6a3a      	ldr	r2, [r7, #32]
 80110c8:	b2d2      	uxtb	r2, r2
 80110ca:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80110ce:	b2d2      	uxtb	r2, r2
 80110d0:	701a      	strb	r2, [r3, #0]
 80110d2:	6a3b      	ldr	r3, [r7, #32]
 80110d4:	09db      	lsrs	r3, r3, #7
 80110d6:	623b      	str	r3, [r7, #32]
 80110d8:	6a3b      	ldr	r3, [r7, #32]
 80110da:	2b7f      	cmp	r3, #127	; 0x7f
 80110dc:	d8f0      	bhi.n	80110c0 <_SendPacket+0xfc>
 80110de:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80110e0:	1c5a      	adds	r2, r3, #1
 80110e2:	627a      	str	r2, [r7, #36]	; 0x24
 80110e4:	6a3a      	ldr	r2, [r7, #32]
 80110e6:	b2d2      	uxtb	r2, r2
 80110e8:	701a      	strb	r2, [r3, #0]
 80110ea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80110ec:	60bb      	str	r3, [r7, #8]
  _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
#else
  //
  // Try to store packet in RTT buffer and update time stamp when this was successful
  //
  Status = SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, pStartPacket, pEndPacket - pStartPacket);
 80110ee:	68ba      	ldr	r2, [r7, #8]
 80110f0:	68fb      	ldr	r3, [r7, #12]
 80110f2:	1ad3      	subs	r3, r2, r3
 80110f4:	2001      	movs	r0, #1
 80110f6:	68f9      	ldr	r1, [r7, #12]
 80110f8:	461a      	mov	r2, r3
 80110fa:	f7ff fccf 	bl	8010a9c <SEGGER_RTT_WriteSkipNoLock>
 80110fe:	4603      	mov	r3, r0
 8011100:	613b      	str	r3, [r7, #16]
  if (Status) {
 8011102:	693b      	ldr	r3, [r7, #16]
 8011104:	2b00      	cmp	r3, #0
 8011106:	d003      	beq.n	8011110 <_SendPacket+0x14c>
    _SYSVIEW_Globals.LastTxTimeStamp = TimeStamp;
 8011108:	4a10      	ldr	r2, [pc, #64]	; (801114c <_SendPacket+0x188>)
 801110a:	69bb      	ldr	r3, [r7, #24]
 801110c:	60d3      	str	r3, [r2, #12]
 801110e:	e005      	b.n	801111c <_SendPacket+0x158>
  } else {
    _SYSVIEW_Globals.EnableState++; // EnableState has been 1, will be 2. Always.
 8011110:	4b0e      	ldr	r3, [pc, #56]	; (801114c <_SendPacket+0x188>)
 8011112:	781b      	ldrb	r3, [r3, #0]
 8011114:	3301      	adds	r3, #1
 8011116:	b2da      	uxtb	r2, r3
 8011118:	4b0c      	ldr	r3, [pc, #48]	; (801114c <_SendPacket+0x188>)
 801111a:	701a      	strb	r2, [r3, #0]
  //
  // Check if host is sending data which needs to be processed.
  // Note that since this code is called for every packet, it is very time critical, so we do
  // only what is really needed here, which is checking if there is any data
  //
  if (SEGGER_RTT_HASDATA(CHANNEL_ID_DOWN)) {
 801111c:	4b0d      	ldr	r3, [pc, #52]	; (8011154 <_SendPacket+0x190>)
 801111e:	f8d3 2084 	ldr.w	r2, [r3, #132]	; 0x84
 8011122:	4b0c      	ldr	r3, [pc, #48]	; (8011154 <_SendPacket+0x190>)
 8011124:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8011128:	429a      	cmp	r2, r3
 801112a:	d00b      	beq.n	8011144 <_SendPacket+0x180>
    if (_SYSVIEW_Globals.RecursionCnt == 0) {   // Avoid uncontrolled nesting. This way, this routine can call itself once, but no more often than that.
 801112c:	4b07      	ldr	r3, [pc, #28]	; (801114c <_SendPacket+0x188>)
 801112e:	789b      	ldrb	r3, [r3, #2]
 8011130:	2b00      	cmp	r3, #0
 8011132:	d107      	bne.n	8011144 <_SendPacket+0x180>
      _SYSVIEW_Globals.RecursionCnt = 1;
 8011134:	4b05      	ldr	r3, [pc, #20]	; (801114c <_SendPacket+0x188>)
 8011136:	2201      	movs	r2, #1
 8011138:	709a      	strb	r2, [r3, #2]
      _HandleIncomingPacket();
 801113a:	f7ff fe7b 	bl	8010e34 <_HandleIncomingPacket>
      _SYSVIEW_Globals.RecursionCnt = 0;
 801113e:	4b03      	ldr	r3, [pc, #12]	; (801114c <_SendPacket+0x188>)
 8011140:	2200      	movs	r2, #0
 8011142:	709a      	strb	r2, [r3, #2]
#endif
  //
#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 0)
  SEGGER_SYSVIEW_UNLOCK();  // We are done. Unlock and return
#endif
}
 8011144:	3728      	adds	r7, #40	; 0x28
 8011146:	46bd      	mov	sp, r7
 8011148:	bd80      	pop	{r7, pc}
 801114a:	bf00      	nop
 801114c:	2000cd14 	.word	0x2000cd14
 8011150:	e0001004 	.word	0xe0001004
 8011154:	2000d008 	.word	0x2000d008

08011158 <SEGGER_SYSVIEW_Init>:
*    to identify the SystemView channel.
*
*  Notes
*    The channel is configured by the macro SEGGER_SYSVIEW_RTT_CHANNEL.
*/
void SEGGER_SYSVIEW_Init(U32 SysFreq, U32 CPUFreq, const SEGGER_SYSVIEW_OS_API *pOSAPI, SEGGER_SYSVIEW_SEND_SYS_DESC_FUNC pfSendSysDesc) {
 8011158:	b580      	push	{r7, lr}
 801115a:	b086      	sub	sp, #24
 801115c:	af02      	add	r7, sp, #8
 801115e:	60f8      	str	r0, [r7, #12]
 8011160:	60b9      	str	r1, [r7, #8]
 8011162:	607a      	str	r2, [r7, #4]
 8011164:	603b      	str	r3, [r7, #0]
  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
  _SYSVIEW_Globals.EnableState      = 0;
  _SYSVIEW_Globals.PacketCount      = 0;
#else // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
#if SEGGER_SYSVIEW_RTT_CHANNEL > 0
  SEGGER_RTT_ConfigUpBuffer   (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_UpBuffer[0],   sizeof(_UpBuffer),   SEGGER_RTT_MODE_NO_BLOCK_SKIP);
 8011166:	2300      	movs	r3, #0
 8011168:	9300      	str	r3, [sp, #0]
 801116a:	2001      	movs	r0, #1
 801116c:	4913      	ldr	r1, [pc, #76]	; (80111bc <SEGGER_SYSVIEW_Init+0x64>)
 801116e:	4a14      	ldr	r2, [pc, #80]	; (80111c0 <SEGGER_SYSVIEW_Init+0x68>)
 8011170:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8011174:	f7ff fd30 	bl	8010bd8 <SEGGER_RTT_ConfigUpBuffer>
  SEGGER_RTT_ConfigDownBuffer (SEGGER_SYSVIEW_RTT_CHANNEL, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
 8011178:	2300      	movs	r3, #0
 801117a:	9300      	str	r3, [sp, #0]
 801117c:	2001      	movs	r0, #1
 801117e:	490f      	ldr	r1, [pc, #60]	; (80111bc <SEGGER_SYSVIEW_Init+0x64>)
 8011180:	4a10      	ldr	r2, [pc, #64]	; (80111c4 <SEGGER_SYSVIEW_Init+0x6c>)
 8011182:	2308      	movs	r3, #8
 8011184:	f7ff fd92 	bl	8010cac <SEGGER_RTT_ConfigDownBuffer>
  // TODO: Use SEGGER_RTT_AllocDownBuffer when SystemViewer is able to handle another Down Channel than Up Channel.
  //
  _SYSVIEW_Globals.DownChannel = _SYSVIEW_Globals.UpChannel;
  SEGGER_RTT_ConfigDownBuffer (_SYSVIEW_Globals.DownChannel, "SysView", &_DownBuffer[0], sizeof(_DownBuffer), SEGGER_RTT_MODE_NO_BLOCK_SKIP);
#endif
  _SYSVIEW_Globals.RAMBaseAddress   = SEGGER_SYSVIEW_ID_BASE;
 8011188:	4b0f      	ldr	r3, [pc, #60]	; (80111c8 <SEGGER_SYSVIEW_Init+0x70>)
 801118a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 801118e:	611a      	str	r2, [r3, #16]
  _SYSVIEW_Globals.LastTxTimeStamp  = SEGGER_SYSVIEW_GET_TIMESTAMP();
 8011190:	4b0e      	ldr	r3, [pc, #56]	; (80111cc <SEGGER_SYSVIEW_Init+0x74>)
 8011192:	681b      	ldr	r3, [r3, #0]
 8011194:	4a0c      	ldr	r2, [pc, #48]	; (80111c8 <SEGGER_SYSVIEW_Init+0x70>)
 8011196:	60d3      	str	r3, [r2, #12]
  _SYSVIEW_Globals.pOSAPI           = pOSAPI;
 8011198:	4a0b      	ldr	r2, [pc, #44]	; (80111c8 <SEGGER_SYSVIEW_Init+0x70>)
 801119a:	687b      	ldr	r3, [r7, #4]
 801119c:	6213      	str	r3, [r2, #32]
  _SYSVIEW_Globals.SysFreq          = SysFreq;
 801119e:	4a0a      	ldr	r2, [pc, #40]	; (80111c8 <SEGGER_SYSVIEW_Init+0x70>)
 80111a0:	68fb      	ldr	r3, [r7, #12]
 80111a2:	6053      	str	r3, [r2, #4]
  _SYSVIEW_Globals.CPUFreq          = CPUFreq;
 80111a4:	4a08      	ldr	r2, [pc, #32]	; (80111c8 <SEGGER_SYSVIEW_Init+0x70>)
 80111a6:	68bb      	ldr	r3, [r7, #8]
 80111a8:	6093      	str	r3, [r2, #8]
  _SYSVIEW_Globals.pfSendSysDesc    = pfSendSysDesc;
 80111aa:	4a07      	ldr	r2, [pc, #28]	; (80111c8 <SEGGER_SYSVIEW_Init+0x70>)
 80111ac:	683b      	ldr	r3, [r7, #0]
 80111ae:	6253      	str	r3, [r2, #36]	; 0x24
  _SYSVIEW_Globals.EnableState      = 0;
 80111b0:	4b05      	ldr	r3, [pc, #20]	; (80111c8 <SEGGER_SYSVIEW_Init+0x70>)
 80111b2:	2200      	movs	r2, #0
 80111b4:	701a      	strb	r2, [r3, #0]
#endif  // (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
}
 80111b6:	3710      	adds	r7, #16
 80111b8:	46bd      	mov	sp, r7
 80111ba:	bd80      	pop	{r7, pc}
 80111bc:	080129a0 	.word	0x080129a0
 80111c0:	2000c90c 	.word	0x2000c90c
 80111c4:	2000cd0c 	.word	0x2000cd0c
 80111c8:	2000cd14 	.word	0x2000cd14
 80111cc:	e0001004 	.word	0xe0001004

080111d0 <SEGGER_SYSVIEW_SetRAMBase>:
*     to save bandwidth.
*
*  Parameters
*    RAMBaseAddress - Lowest RAM Address. (i.e. 0x20000000 on most Cortex-M)
*/
void SEGGER_SYSVIEW_SetRAMBase(U32 RAMBaseAddress) {
 80111d0:	b480      	push	{r7}
 80111d2:	b083      	sub	sp, #12
 80111d4:	af00      	add	r7, sp, #0
 80111d6:	6078      	str	r0, [r7, #4]
  _SYSVIEW_Globals.RAMBaseAddress = RAMBaseAddress;
 80111d8:	4a03      	ldr	r2, [pc, #12]	; (80111e8 <SEGGER_SYSVIEW_SetRAMBase+0x18>)
 80111da:	687b      	ldr	r3, [r7, #4]
 80111dc:	6113      	str	r3, [r2, #16]
}
 80111de:	370c      	adds	r7, #12
 80111e0:	46bd      	mov	sp, r7
 80111e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 80111e6:	4770      	bx	lr
 80111e8:	2000cd14 	.word	0x2000cd14

080111ec <SEGGER_SYSVIEW_RecordVoid>:
*    Formats and sends a SystemView packet with an empty payload.
*
*  Parameters
*    EventID - SystemView event ID.
*/
void SEGGER_SYSVIEW_RecordVoid(unsigned int EventID) {
 80111ec:	b580      	push	{r7, lr}
 80111ee:	b084      	sub	sp, #16
 80111f0:	af00      	add	r7, sp, #0
 80111f2:	6078      	str	r0, [r7, #4]
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
 80111f4:	f3ef 8311 	mrs	r3, BASEPRI
 80111f8:	f04f 0120 	mov.w	r1, #32
 80111fc:	f381 8811 	msr	BASEPRI, r1
 8011200:	60fb      	str	r3, [r7, #12]
 8011202:	4807      	ldr	r0, [pc, #28]	; (8011220 <SEGGER_SYSVIEW_RecordVoid+0x34>)
 8011204:	f7ff fe0a 	bl	8010e1c <_PreparePacket>
 8011208:	60b8      	str	r0, [r7, #8]
  //
  _SendPacket(pPayloadStart, pPayloadStart, EventID);
 801120a:	68b8      	ldr	r0, [r7, #8]
 801120c:	68b9      	ldr	r1, [r7, #8]
 801120e:	687a      	ldr	r2, [r7, #4]
 8011210:	f7ff fed8 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8011214:	68fb      	ldr	r3, [r7, #12]
 8011216:	f383 8811 	msr	BASEPRI, r3
}
 801121a:	3710      	adds	r7, #16
 801121c:	46bd      	mov	sp, r7
 801121e:	bd80      	pop	{r7, pc}
 8011220:	2000cd44 	.word	0x2000cd44

08011224 <SEGGER_SYSVIEW_RecordU32>:
*
*  Parameters
*    EventID - SystemView event ID.
*    Value   - The 32-bit parameter encoded to SystemView packet payload.
*/
void SEGGER_SYSVIEW_RecordU32(unsigned int EventID, U32 Value) {
 8011224:	b580      	push	{r7, lr}
 8011226:	b088      	sub	sp, #32
 8011228:	af00      	add	r7, sp, #0
 801122a:	6078      	str	r0, [r7, #4]
 801122c:	6039      	str	r1, [r7, #0]
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
 801122e:	f3ef 8311 	mrs	r3, BASEPRI
 8011232:	f04f 0120 	mov.w	r1, #32
 8011236:	f381 8811 	msr	BASEPRI, r1
 801123a:	617b      	str	r3, [r7, #20]
 801123c:	4816      	ldr	r0, [pc, #88]	; (8011298 <SEGGER_SYSVIEW_RecordU32+0x74>)
 801123e:	f7ff fded 	bl	8010e1c <_PreparePacket>
 8011242:	6138      	str	r0, [r7, #16]
  //
  pPayload = pPayloadStart;
 8011244:	693b      	ldr	r3, [r7, #16]
 8011246:	60fb      	str	r3, [r7, #12]
  ENCODE_U32(pPayload, Value);
 8011248:	68fb      	ldr	r3, [r7, #12]
 801124a:	61fb      	str	r3, [r7, #28]
 801124c:	683b      	ldr	r3, [r7, #0]
 801124e:	61bb      	str	r3, [r7, #24]
 8011250:	e00b      	b.n	801126a <SEGGER_SYSVIEW_RecordU32+0x46>
 8011252:	69fb      	ldr	r3, [r7, #28]
 8011254:	1c5a      	adds	r2, r3, #1
 8011256:	61fa      	str	r2, [r7, #28]
 8011258:	69ba      	ldr	r2, [r7, #24]
 801125a:	b2d2      	uxtb	r2, r2
 801125c:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011260:	b2d2      	uxtb	r2, r2
 8011262:	701a      	strb	r2, [r3, #0]
 8011264:	69bb      	ldr	r3, [r7, #24]
 8011266:	09db      	lsrs	r3, r3, #7
 8011268:	61bb      	str	r3, [r7, #24]
 801126a:	69bb      	ldr	r3, [r7, #24]
 801126c:	2b7f      	cmp	r3, #127	; 0x7f
 801126e:	d8f0      	bhi.n	8011252 <SEGGER_SYSVIEW_RecordU32+0x2e>
 8011270:	69fb      	ldr	r3, [r7, #28]
 8011272:	1c5a      	adds	r2, r3, #1
 8011274:	61fa      	str	r2, [r7, #28]
 8011276:	69ba      	ldr	r2, [r7, #24]
 8011278:	b2d2      	uxtb	r2, r2
 801127a:	701a      	strb	r2, [r3, #0]
 801127c:	69fb      	ldr	r3, [r7, #28]
 801127e:	60fb      	str	r3, [r7, #12]
  _SendPacket(pPayloadStart, pPayload, EventID);
 8011280:	6938      	ldr	r0, [r7, #16]
 8011282:	68f9      	ldr	r1, [r7, #12]
 8011284:	687a      	ldr	r2, [r7, #4]
 8011286:	f7ff fe9d 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 801128a:	697b      	ldr	r3, [r7, #20]
 801128c:	f383 8811 	msr	BASEPRI, r3
}
 8011290:	3720      	adds	r7, #32
 8011292:	46bd      	mov	sp, r7
 8011294:	bd80      	pop	{r7, pc}
 8011296:	bf00      	nop
 8011298:	2000cd44 	.word	0x2000cd44

0801129c <SEGGER_SYSVIEW_RecordU32x2>:
*  Parameters
*    EventID - SystemView event ID.
*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
*/
void SEGGER_SYSVIEW_RecordU32x2(unsigned int EventID, U32 Para0, U32 Para1) {
 801129c:	b580      	push	{r7, lr}
 801129e:	b08c      	sub	sp, #48	; 0x30
 80112a0:	af00      	add	r7, sp, #0
 80112a2:	60f8      	str	r0, [r7, #12]
 80112a4:	60b9      	str	r1, [r7, #8]
 80112a6:	607a      	str	r2, [r7, #4]
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
 80112a8:	f3ef 8311 	mrs	r3, BASEPRI
 80112ac:	f04f 0120 	mov.w	r1, #32
 80112b0:	f381 8811 	msr	BASEPRI, r1
 80112b4:	61fb      	str	r3, [r7, #28]
 80112b6:	4824      	ldr	r0, [pc, #144]	; (8011348 <SEGGER_SYSVIEW_RecordU32x2+0xac>)
 80112b8:	f7ff fdb0 	bl	8010e1c <_PreparePacket>
 80112bc:	61b8      	str	r0, [r7, #24]
  //
  pPayload = pPayloadStart;
 80112be:	69bb      	ldr	r3, [r7, #24]
 80112c0:	617b      	str	r3, [r7, #20]
  ENCODE_U32(pPayload, Para0);
 80112c2:	697b      	ldr	r3, [r7, #20]
 80112c4:	62fb      	str	r3, [r7, #44]	; 0x2c
 80112c6:	68bb      	ldr	r3, [r7, #8]
 80112c8:	62bb      	str	r3, [r7, #40]	; 0x28
 80112ca:	e00b      	b.n	80112e4 <SEGGER_SYSVIEW_RecordU32x2+0x48>
 80112cc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80112ce:	1c5a      	adds	r2, r3, #1
 80112d0:	62fa      	str	r2, [r7, #44]	; 0x2c
 80112d2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80112d4:	b2d2      	uxtb	r2, r2
 80112d6:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80112da:	b2d2      	uxtb	r2, r2
 80112dc:	701a      	strb	r2, [r3, #0]
 80112de:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80112e0:	09db      	lsrs	r3, r3, #7
 80112e2:	62bb      	str	r3, [r7, #40]	; 0x28
 80112e4:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80112e6:	2b7f      	cmp	r3, #127	; 0x7f
 80112e8:	d8f0      	bhi.n	80112cc <SEGGER_SYSVIEW_RecordU32x2+0x30>
 80112ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80112ec:	1c5a      	adds	r2, r3, #1
 80112ee:	62fa      	str	r2, [r7, #44]	; 0x2c
 80112f0:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80112f2:	b2d2      	uxtb	r2, r2
 80112f4:	701a      	strb	r2, [r3, #0]
 80112f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80112f8:	617b      	str	r3, [r7, #20]
  ENCODE_U32(pPayload, Para1);
 80112fa:	697b      	ldr	r3, [r7, #20]
 80112fc:	627b      	str	r3, [r7, #36]	; 0x24
 80112fe:	687b      	ldr	r3, [r7, #4]
 8011300:	623b      	str	r3, [r7, #32]
 8011302:	e00b      	b.n	801131c <SEGGER_SYSVIEW_RecordU32x2+0x80>
 8011304:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011306:	1c5a      	adds	r2, r3, #1
 8011308:	627a      	str	r2, [r7, #36]	; 0x24
 801130a:	6a3a      	ldr	r2, [r7, #32]
 801130c:	b2d2      	uxtb	r2, r2
 801130e:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011312:	b2d2      	uxtb	r2, r2
 8011314:	701a      	strb	r2, [r3, #0]
 8011316:	6a3b      	ldr	r3, [r7, #32]
 8011318:	09db      	lsrs	r3, r3, #7
 801131a:	623b      	str	r3, [r7, #32]
 801131c:	6a3b      	ldr	r3, [r7, #32]
 801131e:	2b7f      	cmp	r3, #127	; 0x7f
 8011320:	d8f0      	bhi.n	8011304 <SEGGER_SYSVIEW_RecordU32x2+0x68>
 8011322:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011324:	1c5a      	adds	r2, r3, #1
 8011326:	627a      	str	r2, [r7, #36]	; 0x24
 8011328:	6a3a      	ldr	r2, [r7, #32]
 801132a:	b2d2      	uxtb	r2, r2
 801132c:	701a      	strb	r2, [r3, #0]
 801132e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011330:	617b      	str	r3, [r7, #20]
  _SendPacket(pPayloadStart, pPayload, EventID);
 8011332:	69b8      	ldr	r0, [r7, #24]
 8011334:	6979      	ldr	r1, [r7, #20]
 8011336:	68fa      	ldr	r2, [r7, #12]
 8011338:	f7ff fe44 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 801133c:	69fb      	ldr	r3, [r7, #28]
 801133e:	f383 8811 	msr	BASEPRI, r3
}
 8011342:	3730      	adds	r7, #48	; 0x30
 8011344:	46bd      	mov	sp, r7
 8011346:	bd80      	pop	{r7, pc}
 8011348:	2000cd44 	.word	0x2000cd44

0801134c <SEGGER_SYSVIEW_RecordU32x3>:
*    EventID - SystemView event ID.
*    Para0   - The 32-bit parameter encoded to SystemView packet payload.
*    Para1   - The 32-bit parameter encoded to SystemView packet payload.
*    Para2   - The 32-bit parameter encoded to SystemView packet payload.
*/
void SEGGER_SYSVIEW_RecordU32x3(unsigned int EventID, U32 Para0, U32 Para1, U32 Para2) {
 801134c:	b580      	push	{r7, lr}
 801134e:	b08e      	sub	sp, #56	; 0x38
 8011350:	af00      	add	r7, sp, #0
 8011352:	60f8      	str	r0, [r7, #12]
 8011354:	60b9      	str	r1, [r7, #8]
 8011356:	607a      	str	r2, [r7, #4]
 8011358:	603b      	str	r3, [r7, #0]
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 3 * SEGGER_SYSVIEW_QUANTA_U32);
 801135a:	f3ef 8311 	mrs	r3, BASEPRI
 801135e:	f04f 0120 	mov.w	r1, #32
 8011362:	f381 8811 	msr	BASEPRI, r1
 8011366:	61fb      	str	r3, [r7, #28]
 8011368:	4832      	ldr	r0, [pc, #200]	; (8011434 <SEGGER_SYSVIEW_RecordU32x3+0xe8>)
 801136a:	f7ff fd57 	bl	8010e1c <_PreparePacket>
 801136e:	61b8      	str	r0, [r7, #24]
  //
  pPayload = pPayloadStart;
 8011370:	69bb      	ldr	r3, [r7, #24]
 8011372:	617b      	str	r3, [r7, #20]
  ENCODE_U32(pPayload, Para0);
 8011374:	697b      	ldr	r3, [r7, #20]
 8011376:	637b      	str	r3, [r7, #52]	; 0x34
 8011378:	68bb      	ldr	r3, [r7, #8]
 801137a:	633b      	str	r3, [r7, #48]	; 0x30
 801137c:	e00b      	b.n	8011396 <SEGGER_SYSVIEW_RecordU32x3+0x4a>
 801137e:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011380:	1c5a      	adds	r2, r3, #1
 8011382:	637a      	str	r2, [r7, #52]	; 0x34
 8011384:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011386:	b2d2      	uxtb	r2, r2
 8011388:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801138c:	b2d2      	uxtb	r2, r2
 801138e:	701a      	strb	r2, [r3, #0]
 8011390:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011392:	09db      	lsrs	r3, r3, #7
 8011394:	633b      	str	r3, [r7, #48]	; 0x30
 8011396:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011398:	2b7f      	cmp	r3, #127	; 0x7f
 801139a:	d8f0      	bhi.n	801137e <SEGGER_SYSVIEW_RecordU32x3+0x32>
 801139c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801139e:	1c5a      	adds	r2, r3, #1
 80113a0:	637a      	str	r2, [r7, #52]	; 0x34
 80113a2:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80113a4:	b2d2      	uxtb	r2, r2
 80113a6:	701a      	strb	r2, [r3, #0]
 80113a8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80113aa:	617b      	str	r3, [r7, #20]
  ENCODE_U32(pPayload, Para1);
 80113ac:	697b      	ldr	r3, [r7, #20]
 80113ae:	62fb      	str	r3, [r7, #44]	; 0x2c
 80113b0:	687b      	ldr	r3, [r7, #4]
 80113b2:	62bb      	str	r3, [r7, #40]	; 0x28
 80113b4:	e00b      	b.n	80113ce <SEGGER_SYSVIEW_RecordU32x3+0x82>
 80113b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80113b8:	1c5a      	adds	r2, r3, #1
 80113ba:	62fa      	str	r2, [r7, #44]	; 0x2c
 80113bc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80113be:	b2d2      	uxtb	r2, r2
 80113c0:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80113c4:	b2d2      	uxtb	r2, r2
 80113c6:	701a      	strb	r2, [r3, #0]
 80113c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80113ca:	09db      	lsrs	r3, r3, #7
 80113cc:	62bb      	str	r3, [r7, #40]	; 0x28
 80113ce:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80113d0:	2b7f      	cmp	r3, #127	; 0x7f
 80113d2:	d8f0      	bhi.n	80113b6 <SEGGER_SYSVIEW_RecordU32x3+0x6a>
 80113d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80113d6:	1c5a      	adds	r2, r3, #1
 80113d8:	62fa      	str	r2, [r7, #44]	; 0x2c
 80113da:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80113dc:	b2d2      	uxtb	r2, r2
 80113de:	701a      	strb	r2, [r3, #0]
 80113e0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80113e2:	617b      	str	r3, [r7, #20]
  ENCODE_U32(pPayload, Para2);
 80113e4:	697b      	ldr	r3, [r7, #20]
 80113e6:	627b      	str	r3, [r7, #36]	; 0x24
 80113e8:	683b      	ldr	r3, [r7, #0]
 80113ea:	623b      	str	r3, [r7, #32]
 80113ec:	e00b      	b.n	8011406 <SEGGER_SYSVIEW_RecordU32x3+0xba>
 80113ee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80113f0:	1c5a      	adds	r2, r3, #1
 80113f2:	627a      	str	r2, [r7, #36]	; 0x24
 80113f4:	6a3a      	ldr	r2, [r7, #32]
 80113f6:	b2d2      	uxtb	r2, r2
 80113f8:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80113fc:	b2d2      	uxtb	r2, r2
 80113fe:	701a      	strb	r2, [r3, #0]
 8011400:	6a3b      	ldr	r3, [r7, #32]
 8011402:	09db      	lsrs	r3, r3, #7
 8011404:	623b      	str	r3, [r7, #32]
 8011406:	6a3b      	ldr	r3, [r7, #32]
 8011408:	2b7f      	cmp	r3, #127	; 0x7f
 801140a:	d8f0      	bhi.n	80113ee <SEGGER_SYSVIEW_RecordU32x3+0xa2>
 801140c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801140e:	1c5a      	adds	r2, r3, #1
 8011410:	627a      	str	r2, [r7, #36]	; 0x24
 8011412:	6a3a      	ldr	r2, [r7, #32]
 8011414:	b2d2      	uxtb	r2, r2
 8011416:	701a      	strb	r2, [r3, #0]
 8011418:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801141a:	617b      	str	r3, [r7, #20]
  _SendPacket(pPayloadStart, pPayload, EventID);
 801141c:	69b8      	ldr	r0, [r7, #24]
 801141e:	6979      	ldr	r1, [r7, #20]
 8011420:	68fa      	ldr	r2, [r7, #12]
 8011422:	f7ff fdcf 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8011426:	69fb      	ldr	r3, [r7, #28]
 8011428:	f383 8811 	msr	BASEPRI, r3
}
 801142c:	3738      	adds	r7, #56	; 0x38
 801142e:	46bd      	mov	sp, r7
 8011430:	bd80      	pop	{r7, pc}
 8011432:	bf00      	nop
 8011434:	2000cd44 	.word	0x2000cd44

08011438 <SEGGER_SYSVIEW_Start>:
*    system description string is sent, too.
*
*  Notes
*    SEGGER_SYSVIEW_Start and SEGGER_SYSVIEW_Stop do not nest.
*/
void SEGGER_SYSVIEW_Start(void) {
 8011438:	b580      	push	{r7, lr}
 801143a:	b08c      	sub	sp, #48	; 0x30
 801143c:	af00      	add	r7, sp, #0
  if (_SYSVIEW_Globals.EnableState == 0) {
 801143e:	4b59      	ldr	r3, [pc, #356]	; (80115a4 <SEGGER_SYSVIEW_Start+0x16c>)
 8011440:	781b      	ldrb	r3, [r3, #0]
 8011442:	2b00      	cmp	r3, #0
 8011444:	f040 80aa 	bne.w	801159c <SEGGER_SYSVIEW_Start+0x164>
    _SYSVIEW_Globals.EnableState = 1;
 8011448:	4b56      	ldr	r3, [pc, #344]	; (80115a4 <SEGGER_SYSVIEW_Start+0x16c>)
 801144a:	2201      	movs	r2, #1
 801144c:	701a      	strb	r2, [r3, #0]
#if (SEGGER_SYSVIEW_POST_MORTEM_MODE == 1)
    _SendSyncInfo();
#else
    SEGGER_SYSVIEW_LOCK();
 801144e:	f3ef 8311 	mrs	r3, BASEPRI
 8011452:	f04f 0120 	mov.w	r1, #32
 8011456:	f381 8811 	msr	BASEPRI, r1
 801145a:	60fb      	str	r3, [r7, #12]
    SEGGER_RTT_WriteSkipNoLock(CHANNEL_ID_UP, _abSync, 10);
 801145c:	2001      	movs	r0, #1
 801145e:	4952      	ldr	r1, [pc, #328]	; (80115a8 <SEGGER_SYSVIEW_Start+0x170>)
 8011460:	220a      	movs	r2, #10
 8011462:	f7ff fb1b 	bl	8010a9c <SEGGER_RTT_WriteSkipNoLock>
    SEGGER_SYSVIEW_UNLOCK();
 8011466:	68fb      	ldr	r3, [r7, #12]
 8011468:	f383 8811 	msr	BASEPRI, r3
    SEGGER_SYSVIEW_RecordVoid(SYSVIEW_EVTID_TRACE_START);
 801146c:	200a      	movs	r0, #10
 801146e:	f7ff febd 	bl	80111ec <SEGGER_SYSVIEW_RecordVoid>
    {
      U8* pPayload;
      U8* pPayloadStart;
      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
 8011472:	f3ef 8311 	mrs	r3, BASEPRI
 8011476:	f04f 0120 	mov.w	r1, #32
 801147a:	f381 8811 	msr	BASEPRI, r1
 801147e:	60bb      	str	r3, [r7, #8]
 8011480:	484a      	ldr	r0, [pc, #296]	; (80115ac <SEGGER_SYSVIEW_Start+0x174>)
 8011482:	f7ff fccb 	bl	8010e1c <_PreparePacket>
 8011486:	6078      	str	r0, [r7, #4]
      //
      pPayload = pPayloadStart;
 8011488:	687b      	ldr	r3, [r7, #4]
 801148a:	603b      	str	r3, [r7, #0]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
 801148c:	683b      	ldr	r3, [r7, #0]
 801148e:	62fb      	str	r3, [r7, #44]	; 0x2c
 8011490:	4b44      	ldr	r3, [pc, #272]	; (80115a4 <SEGGER_SYSVIEW_Start+0x16c>)
 8011492:	685b      	ldr	r3, [r3, #4]
 8011494:	62bb      	str	r3, [r7, #40]	; 0x28
 8011496:	e00b      	b.n	80114b0 <SEGGER_SYSVIEW_Start+0x78>
 8011498:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 801149a:	1c5a      	adds	r2, r3, #1
 801149c:	62fa      	str	r2, [r7, #44]	; 0x2c
 801149e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80114a0:	b2d2      	uxtb	r2, r2
 80114a2:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80114a6:	b2d2      	uxtb	r2, r2
 80114a8:	701a      	strb	r2, [r3, #0]
 80114aa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80114ac:	09db      	lsrs	r3, r3, #7
 80114ae:	62bb      	str	r3, [r7, #40]	; 0x28
 80114b0:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80114b2:	2b7f      	cmp	r3, #127	; 0x7f
 80114b4:	d8f0      	bhi.n	8011498 <SEGGER_SYSVIEW_Start+0x60>
 80114b6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80114b8:	1c5a      	adds	r2, r3, #1
 80114ba:	62fa      	str	r2, [r7, #44]	; 0x2c
 80114bc:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80114be:	b2d2      	uxtb	r2, r2
 80114c0:	701a      	strb	r2, [r3, #0]
 80114c2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80114c4:	603b      	str	r3, [r7, #0]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
 80114c6:	683b      	ldr	r3, [r7, #0]
 80114c8:	627b      	str	r3, [r7, #36]	; 0x24
 80114ca:	4b36      	ldr	r3, [pc, #216]	; (80115a4 <SEGGER_SYSVIEW_Start+0x16c>)
 80114cc:	689b      	ldr	r3, [r3, #8]
 80114ce:	623b      	str	r3, [r7, #32]
 80114d0:	e00b      	b.n	80114ea <SEGGER_SYSVIEW_Start+0xb2>
 80114d2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80114d4:	1c5a      	adds	r2, r3, #1
 80114d6:	627a      	str	r2, [r7, #36]	; 0x24
 80114d8:	6a3a      	ldr	r2, [r7, #32]
 80114da:	b2d2      	uxtb	r2, r2
 80114dc:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80114e0:	b2d2      	uxtb	r2, r2
 80114e2:	701a      	strb	r2, [r3, #0]
 80114e4:	6a3b      	ldr	r3, [r7, #32]
 80114e6:	09db      	lsrs	r3, r3, #7
 80114e8:	623b      	str	r3, [r7, #32]
 80114ea:	6a3b      	ldr	r3, [r7, #32]
 80114ec:	2b7f      	cmp	r3, #127	; 0x7f
 80114ee:	d8f0      	bhi.n	80114d2 <SEGGER_SYSVIEW_Start+0x9a>
 80114f0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80114f2:	1c5a      	adds	r2, r3, #1
 80114f4:	627a      	str	r2, [r7, #36]	; 0x24
 80114f6:	6a3a      	ldr	r2, [r7, #32]
 80114f8:	b2d2      	uxtb	r2, r2
 80114fa:	701a      	strb	r2, [r3, #0]
 80114fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80114fe:	603b      	str	r3, [r7, #0]
      ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
 8011500:	683b      	ldr	r3, [r7, #0]
 8011502:	61fb      	str	r3, [r7, #28]
 8011504:	4b27      	ldr	r3, [pc, #156]	; (80115a4 <SEGGER_SYSVIEW_Start+0x16c>)
 8011506:	691b      	ldr	r3, [r3, #16]
 8011508:	61bb      	str	r3, [r7, #24]
 801150a:	e00b      	b.n	8011524 <SEGGER_SYSVIEW_Start+0xec>
 801150c:	69fb      	ldr	r3, [r7, #28]
 801150e:	1c5a      	adds	r2, r3, #1
 8011510:	61fa      	str	r2, [r7, #28]
 8011512:	69ba      	ldr	r2, [r7, #24]
 8011514:	b2d2      	uxtb	r2, r2
 8011516:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801151a:	b2d2      	uxtb	r2, r2
 801151c:	701a      	strb	r2, [r3, #0]
 801151e:	69bb      	ldr	r3, [r7, #24]
 8011520:	09db      	lsrs	r3, r3, #7
 8011522:	61bb      	str	r3, [r7, #24]
 8011524:	69bb      	ldr	r3, [r7, #24]
 8011526:	2b7f      	cmp	r3, #127	; 0x7f
 8011528:	d8f0      	bhi.n	801150c <SEGGER_SYSVIEW_Start+0xd4>
 801152a:	69fb      	ldr	r3, [r7, #28]
 801152c:	1c5a      	adds	r2, r3, #1
 801152e:	61fa      	str	r2, [r7, #28]
 8011530:	69ba      	ldr	r2, [r7, #24]
 8011532:	b2d2      	uxtb	r2, r2
 8011534:	701a      	strb	r2, [r3, #0]
 8011536:	69fb      	ldr	r3, [r7, #28]
 8011538:	603b      	str	r3, [r7, #0]
      ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
 801153a:	683b      	ldr	r3, [r7, #0]
 801153c:	617b      	str	r3, [r7, #20]
 801153e:	2302      	movs	r3, #2
 8011540:	613b      	str	r3, [r7, #16]
 8011542:	e00b      	b.n	801155c <SEGGER_SYSVIEW_Start+0x124>
 8011544:	697b      	ldr	r3, [r7, #20]
 8011546:	1c5a      	adds	r2, r3, #1
 8011548:	617a      	str	r2, [r7, #20]
 801154a:	693a      	ldr	r2, [r7, #16]
 801154c:	b2d2      	uxtb	r2, r2
 801154e:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011552:	b2d2      	uxtb	r2, r2
 8011554:	701a      	strb	r2, [r3, #0]
 8011556:	693b      	ldr	r3, [r7, #16]
 8011558:	09db      	lsrs	r3, r3, #7
 801155a:	613b      	str	r3, [r7, #16]
 801155c:	693b      	ldr	r3, [r7, #16]
 801155e:	2b7f      	cmp	r3, #127	; 0x7f
 8011560:	d8f0      	bhi.n	8011544 <SEGGER_SYSVIEW_Start+0x10c>
 8011562:	697b      	ldr	r3, [r7, #20]
 8011564:	1c5a      	adds	r2, r3, #1
 8011566:	617a      	str	r2, [r7, #20]
 8011568:	693a      	ldr	r2, [r7, #16]
 801156a:	b2d2      	uxtb	r2, r2
 801156c:	701a      	strb	r2, [r3, #0]
 801156e:	697b      	ldr	r3, [r7, #20]
 8011570:	603b      	str	r3, [r7, #0]
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
 8011572:	6878      	ldr	r0, [r7, #4]
 8011574:	6839      	ldr	r1, [r7, #0]
 8011576:	2218      	movs	r2, #24
 8011578:	f7ff fd24 	bl	8010fc4 <_SendPacket>
      RECORD_END();
 801157c:	68bb      	ldr	r3, [r7, #8]
 801157e:	f383 8811 	msr	BASEPRI, r3
    }
    if (_SYSVIEW_Globals.pfSendSysDesc) {
 8011582:	4b08      	ldr	r3, [pc, #32]	; (80115a4 <SEGGER_SYSVIEW_Start+0x16c>)
 8011584:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011586:	2b00      	cmp	r3, #0
 8011588:	d002      	beq.n	8011590 <SEGGER_SYSVIEW_Start+0x158>
      _SYSVIEW_Globals.pfSendSysDesc();
 801158a:	4b06      	ldr	r3, [pc, #24]	; (80115a4 <SEGGER_SYSVIEW_Start+0x16c>)
 801158c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801158e:	4798      	blx	r3
    }
    SEGGER_SYSVIEW_RecordSystime();
 8011590:	f000 f9e4 	bl	801195c <SEGGER_SYSVIEW_RecordSystime>
    SEGGER_SYSVIEW_SendTaskList();
 8011594:	f000 f9ae 	bl	80118f4 <SEGGER_SYSVIEW_SendTaskList>
    SEGGER_SYSVIEW_SendNumModules();
 8011598:	f000 fcb4 	bl	8011f04 <SEGGER_SYSVIEW_SendNumModules>
#endif
  }
}
 801159c:	3730      	adds	r7, #48	; 0x30
 801159e:	46bd      	mov	sp, r7
 80115a0:	bd80      	pop	{r7, pc}
 80115a2:	bf00      	nop
 80115a4:	2000cd14 	.word	0x2000cd14
 80115a8:	08012a7c 	.word	0x08012a7c
 80115ac:	2000cd44 	.word	0x2000cd44

080115b0 <SEGGER_SYSVIEW_Stop>:
*    This function disables transmission of SystemView packets recorded
*    by subsequent trace calls.  If transmission is enabled when
*    this function is called, a single SystemView Stop event is recorded
*    to the trace, send, and then trace transmission is halted.
*/
void SEGGER_SYSVIEW_Stop(void) {
 80115b0:	b580      	push	{r7, lr}
 80115b2:	b082      	sub	sp, #8
 80115b4:	af00      	add	r7, sp, #0
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
 80115b6:	f3ef 8311 	mrs	r3, BASEPRI
 80115ba:	f04f 0120 	mov.w	r1, #32
 80115be:	f381 8811 	msr	BASEPRI, r1
 80115c2:	607b      	str	r3, [r7, #4]
 80115c4:	480a      	ldr	r0, [pc, #40]	; (80115f0 <SEGGER_SYSVIEW_Stop+0x40>)
 80115c6:	f7ff fc29 	bl	8010e1c <_PreparePacket>
 80115ca:	6038      	str	r0, [r7, #0]
  //
  if (_SYSVIEW_Globals.EnableState) {
 80115cc:	4b09      	ldr	r3, [pc, #36]	; (80115f4 <SEGGER_SYSVIEW_Stop+0x44>)
 80115ce:	781b      	ldrb	r3, [r3, #0]
 80115d0:	2b00      	cmp	r3, #0
 80115d2:	d007      	beq.n	80115e4 <SEGGER_SYSVIEW_Stop+0x34>
    _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_TRACE_STOP);
 80115d4:	6838      	ldr	r0, [r7, #0]
 80115d6:	6839      	ldr	r1, [r7, #0]
 80115d8:	220b      	movs	r2, #11
 80115da:	f7ff fcf3 	bl	8010fc4 <_SendPacket>
    _SYSVIEW_Globals.EnableState = 0;
 80115de:	4b05      	ldr	r3, [pc, #20]	; (80115f4 <SEGGER_SYSVIEW_Stop+0x44>)
 80115e0:	2200      	movs	r2, #0
 80115e2:	701a      	strb	r2, [r3, #0]
  }
  RECORD_END();
 80115e4:	687b      	ldr	r3, [r7, #4]
 80115e6:	f383 8811 	msr	BASEPRI, r3
}
 80115ea:	3708      	adds	r7, #8
 80115ec:	46bd      	mov	sp, r7
 80115ee:	bd80      	pop	{r7, pc}
 80115f0:	2000cd44 	.word	0x2000cd44
 80115f4:	2000cd14 	.word	0x2000cd14

080115f8 <SEGGER_SYSVIEW_GetSysDesc>:
*
*  Function description
*    Triggers a send of the system information and description.
*
*/
void SEGGER_SYSVIEW_GetSysDesc(void) {
 80115f8:	b580      	push	{r7, lr}
 80115fa:	b08c      	sub	sp, #48	; 0x30
 80115fc:	af00      	add	r7, sp, #0
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32);
 80115fe:	f3ef 8311 	mrs	r3, BASEPRI
 8011602:	f04f 0120 	mov.w	r1, #32
 8011606:	f381 8811 	msr	BASEPRI, r1
 801160a:	60fb      	str	r3, [r7, #12]
 801160c:	4845      	ldr	r0, [pc, #276]	; (8011724 <SEGGER_SYSVIEW_GetSysDesc+0x12c>)
 801160e:	f7ff fc05 	bl	8010e1c <_PreparePacket>
 8011612:	60b8      	str	r0, [r7, #8]
  //
  pPayload = pPayloadStart;
 8011614:	68bb      	ldr	r3, [r7, #8]
 8011616:	607b      	str	r3, [r7, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.SysFreq);
 8011618:	687b      	ldr	r3, [r7, #4]
 801161a:	62fb      	str	r3, [r7, #44]	; 0x2c
 801161c:	4b42      	ldr	r3, [pc, #264]	; (8011728 <SEGGER_SYSVIEW_GetSysDesc+0x130>)
 801161e:	685b      	ldr	r3, [r3, #4]
 8011620:	62bb      	str	r3, [r7, #40]	; 0x28
 8011622:	e00b      	b.n	801163c <SEGGER_SYSVIEW_GetSysDesc+0x44>
 8011624:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011626:	1c5a      	adds	r2, r3, #1
 8011628:	62fa      	str	r2, [r7, #44]	; 0x2c
 801162a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801162c:	b2d2      	uxtb	r2, r2
 801162e:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011632:	b2d2      	uxtb	r2, r2
 8011634:	701a      	strb	r2, [r3, #0]
 8011636:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011638:	09db      	lsrs	r3, r3, #7
 801163a:	62bb      	str	r3, [r7, #40]	; 0x28
 801163c:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801163e:	2b7f      	cmp	r3, #127	; 0x7f
 8011640:	d8f0      	bhi.n	8011624 <SEGGER_SYSVIEW_GetSysDesc+0x2c>
 8011642:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011644:	1c5a      	adds	r2, r3, #1
 8011646:	62fa      	str	r2, [r7, #44]	; 0x2c
 8011648:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801164a:	b2d2      	uxtb	r2, r2
 801164c:	701a      	strb	r2, [r3, #0]
 801164e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011650:	607b      	str	r3, [r7, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.CPUFreq);
 8011652:	687b      	ldr	r3, [r7, #4]
 8011654:	627b      	str	r3, [r7, #36]	; 0x24
 8011656:	4b34      	ldr	r3, [pc, #208]	; (8011728 <SEGGER_SYSVIEW_GetSysDesc+0x130>)
 8011658:	689b      	ldr	r3, [r3, #8]
 801165a:	623b      	str	r3, [r7, #32]
 801165c:	e00b      	b.n	8011676 <SEGGER_SYSVIEW_GetSysDesc+0x7e>
 801165e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011660:	1c5a      	adds	r2, r3, #1
 8011662:	627a      	str	r2, [r7, #36]	; 0x24
 8011664:	6a3a      	ldr	r2, [r7, #32]
 8011666:	b2d2      	uxtb	r2, r2
 8011668:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801166c:	b2d2      	uxtb	r2, r2
 801166e:	701a      	strb	r2, [r3, #0]
 8011670:	6a3b      	ldr	r3, [r7, #32]
 8011672:	09db      	lsrs	r3, r3, #7
 8011674:	623b      	str	r3, [r7, #32]
 8011676:	6a3b      	ldr	r3, [r7, #32]
 8011678:	2b7f      	cmp	r3, #127	; 0x7f
 801167a:	d8f0      	bhi.n	801165e <SEGGER_SYSVIEW_GetSysDesc+0x66>
 801167c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801167e:	1c5a      	adds	r2, r3, #1
 8011680:	627a      	str	r2, [r7, #36]	; 0x24
 8011682:	6a3a      	ldr	r2, [r7, #32]
 8011684:	b2d2      	uxtb	r2, r2
 8011686:	701a      	strb	r2, [r3, #0]
 8011688:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801168a:	607b      	str	r3, [r7, #4]
  ENCODE_U32(pPayload, _SYSVIEW_Globals.RAMBaseAddress);
 801168c:	687b      	ldr	r3, [r7, #4]
 801168e:	61fb      	str	r3, [r7, #28]
 8011690:	4b25      	ldr	r3, [pc, #148]	; (8011728 <SEGGER_SYSVIEW_GetSysDesc+0x130>)
 8011692:	691b      	ldr	r3, [r3, #16]
 8011694:	61bb      	str	r3, [r7, #24]
 8011696:	e00b      	b.n	80116b0 <SEGGER_SYSVIEW_GetSysDesc+0xb8>
 8011698:	69fb      	ldr	r3, [r7, #28]
 801169a:	1c5a      	adds	r2, r3, #1
 801169c:	61fa      	str	r2, [r7, #28]
 801169e:	69ba      	ldr	r2, [r7, #24]
 80116a0:	b2d2      	uxtb	r2, r2
 80116a2:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80116a6:	b2d2      	uxtb	r2, r2
 80116a8:	701a      	strb	r2, [r3, #0]
 80116aa:	69bb      	ldr	r3, [r7, #24]
 80116ac:	09db      	lsrs	r3, r3, #7
 80116ae:	61bb      	str	r3, [r7, #24]
 80116b0:	69bb      	ldr	r3, [r7, #24]
 80116b2:	2b7f      	cmp	r3, #127	; 0x7f
 80116b4:	d8f0      	bhi.n	8011698 <SEGGER_SYSVIEW_GetSysDesc+0xa0>
 80116b6:	69fb      	ldr	r3, [r7, #28]
 80116b8:	1c5a      	adds	r2, r3, #1
 80116ba:	61fa      	str	r2, [r7, #28]
 80116bc:	69ba      	ldr	r2, [r7, #24]
 80116be:	b2d2      	uxtb	r2, r2
 80116c0:	701a      	strb	r2, [r3, #0]
 80116c2:	69fb      	ldr	r3, [r7, #28]
 80116c4:	607b      	str	r3, [r7, #4]
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_ID_SHIFT);
 80116c6:	687b      	ldr	r3, [r7, #4]
 80116c8:	617b      	str	r3, [r7, #20]
 80116ca:	2302      	movs	r3, #2
 80116cc:	613b      	str	r3, [r7, #16]
 80116ce:	e00b      	b.n	80116e8 <SEGGER_SYSVIEW_GetSysDesc+0xf0>
 80116d0:	697b      	ldr	r3, [r7, #20]
 80116d2:	1c5a      	adds	r2, r3, #1
 80116d4:	617a      	str	r2, [r7, #20]
 80116d6:	693a      	ldr	r2, [r7, #16]
 80116d8:	b2d2      	uxtb	r2, r2
 80116da:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80116de:	b2d2      	uxtb	r2, r2
 80116e0:	701a      	strb	r2, [r3, #0]
 80116e2:	693b      	ldr	r3, [r7, #16]
 80116e4:	09db      	lsrs	r3, r3, #7
 80116e6:	613b      	str	r3, [r7, #16]
 80116e8:	693b      	ldr	r3, [r7, #16]
 80116ea:	2b7f      	cmp	r3, #127	; 0x7f
 80116ec:	d8f0      	bhi.n	80116d0 <SEGGER_SYSVIEW_GetSysDesc+0xd8>
 80116ee:	697b      	ldr	r3, [r7, #20]
 80116f0:	1c5a      	adds	r2, r3, #1
 80116f2:	617a      	str	r2, [r7, #20]
 80116f4:	693a      	ldr	r2, [r7, #16]
 80116f6:	b2d2      	uxtb	r2, r2
 80116f8:	701a      	strb	r2, [r3, #0]
 80116fa:	697b      	ldr	r3, [r7, #20]
 80116fc:	607b      	str	r3, [r7, #4]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_INIT);
 80116fe:	68b8      	ldr	r0, [r7, #8]
 8011700:	6879      	ldr	r1, [r7, #4]
 8011702:	2218      	movs	r2, #24
 8011704:	f7ff fc5e 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8011708:	68fb      	ldr	r3, [r7, #12]
 801170a:	f383 8811 	msr	BASEPRI, r3
  if (_SYSVIEW_Globals.pfSendSysDesc) {
 801170e:	4b06      	ldr	r3, [pc, #24]	; (8011728 <SEGGER_SYSVIEW_GetSysDesc+0x130>)
 8011710:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8011712:	2b00      	cmp	r3, #0
 8011714:	d002      	beq.n	801171c <SEGGER_SYSVIEW_GetSysDesc+0x124>
    _SYSVIEW_Globals.pfSendSysDesc();
 8011716:	4b04      	ldr	r3, [pc, #16]	; (8011728 <SEGGER_SYSVIEW_GetSysDesc+0x130>)
 8011718:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801171a:	4798      	blx	r3
  }
}
 801171c:	3730      	adds	r7, #48	; 0x30
 801171e:	46bd      	mov	sp, r7
 8011720:	bd80      	pop	{r7, pc}
 8011722:	bf00      	nop
 8011724:	2000cd44 	.word	0x2000cd44
 8011728:	2000cd14 	.word	0x2000cd14

0801172c <SEGGER_SYSVIEW_SendTaskInfo>:
*    task priority and task name.
*
*  Parameters
*    pInfo - Pointer to task information to send.
*/
void SEGGER_SYSVIEW_SendTaskInfo(const SEGGER_SYSVIEW_TASKINFO *pInfo) {
 801172c:	b580      	push	{r7, lr}
 801172e:	b092      	sub	sp, #72	; 0x48
 8011730:	af00      	add	r7, sp, #0
 8011732:	6078      	str	r0, [r7, #4]
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32 + 1 + 32);
 8011734:	f3ef 8311 	mrs	r3, BASEPRI
 8011738:	f04f 0120 	mov.w	r1, #32
 801173c:	f381 8811 	msr	BASEPRI, r1
 8011740:	617b      	str	r3, [r7, #20]
 8011742:	486a      	ldr	r0, [pc, #424]	; (80118ec <SEGGER_SYSVIEW_SendTaskInfo+0x1c0>)
 8011744:	f7ff fb6a 	bl	8010e1c <_PreparePacket>
 8011748:	6138      	str	r0, [r7, #16]
  //
  pPayload = pPayloadStart;
 801174a:	693b      	ldr	r3, [r7, #16]
 801174c:	60fb      	str	r3, [r7, #12]
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
 801174e:	68fb      	ldr	r3, [r7, #12]
 8011750:	647b      	str	r3, [r7, #68]	; 0x44
 8011752:	687b      	ldr	r3, [r7, #4]
 8011754:	681a      	ldr	r2, [r3, #0]
 8011756:	4b66      	ldr	r3, [pc, #408]	; (80118f0 <SEGGER_SYSVIEW_SendTaskInfo+0x1c4>)
 8011758:	691b      	ldr	r3, [r3, #16]
 801175a:	1ad3      	subs	r3, r2, r3
 801175c:	089b      	lsrs	r3, r3, #2
 801175e:	643b      	str	r3, [r7, #64]	; 0x40
 8011760:	e00b      	b.n	801177a <SEGGER_SYSVIEW_SendTaskInfo+0x4e>
 8011762:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011764:	1c5a      	adds	r2, r3, #1
 8011766:	647a      	str	r2, [r7, #68]	; 0x44
 8011768:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 801176a:	b2d2      	uxtb	r2, r2
 801176c:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011770:	b2d2      	uxtb	r2, r2
 8011772:	701a      	strb	r2, [r3, #0]
 8011774:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 8011776:	09db      	lsrs	r3, r3, #7
 8011778:	643b      	str	r3, [r7, #64]	; 0x40
 801177a:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 801177c:	2b7f      	cmp	r3, #127	; 0x7f
 801177e:	d8f0      	bhi.n	8011762 <SEGGER_SYSVIEW_SendTaskInfo+0x36>
 8011780:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8011782:	1c5a      	adds	r2, r3, #1
 8011784:	647a      	str	r2, [r7, #68]	; 0x44
 8011786:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8011788:	b2d2      	uxtb	r2, r2
 801178a:	701a      	strb	r2, [r3, #0]
 801178c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 801178e:	60fb      	str	r3, [r7, #12]
  ENCODE_U32(pPayload, pInfo->Prio);
 8011790:	68fb      	ldr	r3, [r7, #12]
 8011792:	63fb      	str	r3, [r7, #60]	; 0x3c
 8011794:	687b      	ldr	r3, [r7, #4]
 8011796:	689b      	ldr	r3, [r3, #8]
 8011798:	63bb      	str	r3, [r7, #56]	; 0x38
 801179a:	e00b      	b.n	80117b4 <SEGGER_SYSVIEW_SendTaskInfo+0x88>
 801179c:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 801179e:	1c5a      	adds	r2, r3, #1
 80117a0:	63fa      	str	r2, [r7, #60]	; 0x3c
 80117a2:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80117a4:	b2d2      	uxtb	r2, r2
 80117a6:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80117aa:	b2d2      	uxtb	r2, r2
 80117ac:	701a      	strb	r2, [r3, #0]
 80117ae:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80117b0:	09db      	lsrs	r3, r3, #7
 80117b2:	63bb      	str	r3, [r7, #56]	; 0x38
 80117b4:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 80117b6:	2b7f      	cmp	r3, #127	; 0x7f
 80117b8:	d8f0      	bhi.n	801179c <SEGGER_SYSVIEW_SendTaskInfo+0x70>
 80117ba:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80117bc:	1c5a      	adds	r2, r3, #1
 80117be:	63fa      	str	r2, [r7, #60]	; 0x3c
 80117c0:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80117c2:	b2d2      	uxtb	r2, r2
 80117c4:	701a      	strb	r2, [r3, #0]
 80117c6:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 80117c8:	60fb      	str	r3, [r7, #12]
  pPayload = _EncodeStr(pPayload, pInfo->sName, 32);
 80117ca:	687b      	ldr	r3, [r7, #4]
 80117cc:	685b      	ldr	r3, [r3, #4]
 80117ce:	68f8      	ldr	r0, [r7, #12]
 80117d0:	4619      	mov	r1, r3
 80117d2:	2220      	movs	r2, #32
 80117d4:	f7ff fad4 	bl	8010d80 <_EncodeStr>
 80117d8:	60f8      	str	r0, [r7, #12]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_INFO);
 80117da:	6938      	ldr	r0, [r7, #16]
 80117dc:	68f9      	ldr	r1, [r7, #12]
 80117de:	2209      	movs	r2, #9
 80117e0:	f7ff fbf0 	bl	8010fc4 <_SendPacket>
  //
  pPayload = pPayloadStart;
 80117e4:	693b      	ldr	r3, [r7, #16]
 80117e6:	60fb      	str	r3, [r7, #12]
  ENCODE_U32(pPayload, SHRINK_ID(pInfo->TaskID));
 80117e8:	68fb      	ldr	r3, [r7, #12]
 80117ea:	637b      	str	r3, [r7, #52]	; 0x34
 80117ec:	687b      	ldr	r3, [r7, #4]
 80117ee:	681a      	ldr	r2, [r3, #0]
 80117f0:	4b3f      	ldr	r3, [pc, #252]	; (80118f0 <SEGGER_SYSVIEW_SendTaskInfo+0x1c4>)
 80117f2:	691b      	ldr	r3, [r3, #16]
 80117f4:	1ad3      	subs	r3, r2, r3
 80117f6:	089b      	lsrs	r3, r3, #2
 80117f8:	633b      	str	r3, [r7, #48]	; 0x30
 80117fa:	e00b      	b.n	8011814 <SEGGER_SYSVIEW_SendTaskInfo+0xe8>
 80117fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80117fe:	1c5a      	adds	r2, r3, #1
 8011800:	637a      	str	r2, [r7, #52]	; 0x34
 8011802:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011804:	b2d2      	uxtb	r2, r2
 8011806:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801180a:	b2d2      	uxtb	r2, r2
 801180c:	701a      	strb	r2, [r3, #0]
 801180e:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011810:	09db      	lsrs	r3, r3, #7
 8011812:	633b      	str	r3, [r7, #48]	; 0x30
 8011814:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 8011816:	2b7f      	cmp	r3, #127	; 0x7f
 8011818:	d8f0      	bhi.n	80117fc <SEGGER_SYSVIEW_SendTaskInfo+0xd0>
 801181a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 801181c:	1c5a      	adds	r2, r3, #1
 801181e:	637a      	str	r2, [r7, #52]	; 0x34
 8011820:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8011822:	b2d2      	uxtb	r2, r2
 8011824:	701a      	strb	r2, [r3, #0]
 8011826:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8011828:	60fb      	str	r3, [r7, #12]
  ENCODE_U32(pPayload, pInfo->StackBase);
 801182a:	68fb      	ldr	r3, [r7, #12]
 801182c:	62fb      	str	r3, [r7, #44]	; 0x2c
 801182e:	687b      	ldr	r3, [r7, #4]
 8011830:	68db      	ldr	r3, [r3, #12]
 8011832:	62bb      	str	r3, [r7, #40]	; 0x28
 8011834:	e00b      	b.n	801184e <SEGGER_SYSVIEW_SendTaskInfo+0x122>
 8011836:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011838:	1c5a      	adds	r2, r3, #1
 801183a:	62fa      	str	r2, [r7, #44]	; 0x2c
 801183c:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801183e:	b2d2      	uxtb	r2, r2
 8011840:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011844:	b2d2      	uxtb	r2, r2
 8011846:	701a      	strb	r2, [r3, #0]
 8011848:	6abb      	ldr	r3, [r7, #40]	; 0x28
 801184a:	09db      	lsrs	r3, r3, #7
 801184c:	62bb      	str	r3, [r7, #40]	; 0x28
 801184e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011850:	2b7f      	cmp	r3, #127	; 0x7f
 8011852:	d8f0      	bhi.n	8011836 <SEGGER_SYSVIEW_SendTaskInfo+0x10a>
 8011854:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011856:	1c5a      	adds	r2, r3, #1
 8011858:	62fa      	str	r2, [r7, #44]	; 0x2c
 801185a:	6aba      	ldr	r2, [r7, #40]	; 0x28
 801185c:	b2d2      	uxtb	r2, r2
 801185e:	701a      	strb	r2, [r3, #0]
 8011860:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011862:	60fb      	str	r3, [r7, #12]
  ENCODE_U32(pPayload, pInfo->StackSize);
 8011864:	68fb      	ldr	r3, [r7, #12]
 8011866:	627b      	str	r3, [r7, #36]	; 0x24
 8011868:	687b      	ldr	r3, [r7, #4]
 801186a:	691b      	ldr	r3, [r3, #16]
 801186c:	623b      	str	r3, [r7, #32]
 801186e:	e00b      	b.n	8011888 <SEGGER_SYSVIEW_SendTaskInfo+0x15c>
 8011870:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011872:	1c5a      	adds	r2, r3, #1
 8011874:	627a      	str	r2, [r7, #36]	; 0x24
 8011876:	6a3a      	ldr	r2, [r7, #32]
 8011878:	b2d2      	uxtb	r2, r2
 801187a:	f062 027f 	orn	r2, r2, #127	; 0x7f
 801187e:	b2d2      	uxtb	r2, r2
 8011880:	701a      	strb	r2, [r3, #0]
 8011882:	6a3b      	ldr	r3, [r7, #32]
 8011884:	09db      	lsrs	r3, r3, #7
 8011886:	623b      	str	r3, [r7, #32]
 8011888:	6a3b      	ldr	r3, [r7, #32]
 801188a:	2b7f      	cmp	r3, #127	; 0x7f
 801188c:	d8f0      	bhi.n	8011870 <SEGGER_SYSVIEW_SendTaskInfo+0x144>
 801188e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011890:	1c5a      	adds	r2, r3, #1
 8011892:	627a      	str	r2, [r7, #36]	; 0x24
 8011894:	6a3a      	ldr	r2, [r7, #32]
 8011896:	b2d2      	uxtb	r2, r2
 8011898:	701a      	strb	r2, [r3, #0]
 801189a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 801189c:	60fb      	str	r3, [r7, #12]
  ENCODE_U32(pPayload, 0); // Stack End, future use
 801189e:	68fb      	ldr	r3, [r7, #12]
 80118a0:	61fb      	str	r3, [r7, #28]
 80118a2:	2300      	movs	r3, #0
 80118a4:	61bb      	str	r3, [r7, #24]
 80118a6:	e00b      	b.n	80118c0 <SEGGER_SYSVIEW_SendTaskInfo+0x194>
 80118a8:	69fb      	ldr	r3, [r7, #28]
 80118aa:	1c5a      	adds	r2, r3, #1
 80118ac:	61fa      	str	r2, [r7, #28]
 80118ae:	69ba      	ldr	r2, [r7, #24]
 80118b0:	b2d2      	uxtb	r2, r2
 80118b2:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80118b6:	b2d2      	uxtb	r2, r2
 80118b8:	701a      	strb	r2, [r3, #0]
 80118ba:	69bb      	ldr	r3, [r7, #24]
 80118bc:	09db      	lsrs	r3, r3, #7
 80118be:	61bb      	str	r3, [r7, #24]
 80118c0:	69bb      	ldr	r3, [r7, #24]
 80118c2:	2b7f      	cmp	r3, #127	; 0x7f
 80118c4:	d8f0      	bhi.n	80118a8 <SEGGER_SYSVIEW_SendTaskInfo+0x17c>
 80118c6:	69fb      	ldr	r3, [r7, #28]
 80118c8:	1c5a      	adds	r2, r3, #1
 80118ca:	61fa      	str	r2, [r7, #28]
 80118cc:	69ba      	ldr	r2, [r7, #24]
 80118ce:	b2d2      	uxtb	r2, r2
 80118d0:	701a      	strb	r2, [r3, #0]
 80118d2:	69fb      	ldr	r3, [r7, #28]
 80118d4:	60fb      	str	r3, [r7, #12]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_STACK_INFO);
 80118d6:	6938      	ldr	r0, [r7, #16]
 80118d8:	68f9      	ldr	r1, [r7, #12]
 80118da:	2215      	movs	r2, #21
 80118dc:	f7ff fb72 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 80118e0:	697b      	ldr	r3, [r7, #20]
 80118e2:	f383 8811 	msr	BASEPRI, r3
}
 80118e6:	3748      	adds	r7, #72	; 0x48
 80118e8:	46bd      	mov	sp, r7
 80118ea:	bd80      	pop	{r7, pc}
 80118ec:	2000cd44 	.word	0x2000cd44
 80118f0:	2000cd14 	.word	0x2000cd14

080118f4 <SEGGER_SYSVIEW_SendTaskList>:
*       SEGGER_SYSVIEW_SendTaskList()
*
*  Function description
*    Send all tasks descriptors to the host.
*/
void SEGGER_SYSVIEW_SendTaskList(void) {
 80118f4:	b580      	push	{r7, lr}
 80118f6:	af00      	add	r7, sp, #0
  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfSendTaskList) {
 80118f8:	4b06      	ldr	r3, [pc, #24]	; (8011914 <SEGGER_SYSVIEW_SendTaskList+0x20>)
 80118fa:	6a1b      	ldr	r3, [r3, #32]
 80118fc:	2b00      	cmp	r3, #0
 80118fe:	d008      	beq.n	8011912 <SEGGER_SYSVIEW_SendTaskList+0x1e>
 8011900:	4b04      	ldr	r3, [pc, #16]	; (8011914 <SEGGER_SYSVIEW_SendTaskList+0x20>)
 8011902:	6a1b      	ldr	r3, [r3, #32]
 8011904:	685b      	ldr	r3, [r3, #4]
 8011906:	2b00      	cmp	r3, #0
 8011908:	d003      	beq.n	8011912 <SEGGER_SYSVIEW_SendTaskList+0x1e>
    _SYSVIEW_Globals.pOSAPI->pfSendTaskList();
 801190a:	4b02      	ldr	r3, [pc, #8]	; (8011914 <SEGGER_SYSVIEW_SendTaskList+0x20>)
 801190c:	6a1b      	ldr	r3, [r3, #32]
 801190e:	685b      	ldr	r3, [r3, #4]
 8011910:	4798      	blx	r3
  }
}
 8011912:	bd80      	pop	{r7, pc}
 8011914:	2000cd14 	.word	0x2000cd14

08011918 <SEGGER_SYSVIEW_SendSysDesc>:
*
*    The Following items can be described in a system description string.
*    Each item is identified by its identifier, followed by '=' and the value.
*    Items are separated by ','.
*/
void SEGGER_SYSVIEW_SendSysDesc(const char *sSysDesc) {
 8011918:	b580      	push	{r7, lr}
 801191a:	b086      	sub	sp, #24
 801191c:	af00      	add	r7, sp, #0
 801191e:	6078      	str	r0, [r7, #4]
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
 8011920:	f3ef 8311 	mrs	r3, BASEPRI
 8011924:	f04f 0120 	mov.w	r1, #32
 8011928:	f381 8811 	msr	BASEPRI, r1
 801192c:	617b      	str	r3, [r7, #20]
 801192e:	480a      	ldr	r0, [pc, #40]	; (8011958 <SEGGER_SYSVIEW_SendSysDesc+0x40>)
 8011930:	f7ff fa74 	bl	8010e1c <_PreparePacket>
 8011934:	6138      	str	r0, [r7, #16]
  //
  pPayload = _EncodeStr(pPayloadStart, sSysDesc, SEGGER_SYSVIEW_MAX_STRING_LEN);
 8011936:	6938      	ldr	r0, [r7, #16]
 8011938:	6879      	ldr	r1, [r7, #4]
 801193a:	2280      	movs	r2, #128	; 0x80
 801193c:	f7ff fa20 	bl	8010d80 <_EncodeStr>
 8011940:	60f8      	str	r0, [r7, #12]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_SYSDESC);
 8011942:	6938      	ldr	r0, [r7, #16]
 8011944:	68f9      	ldr	r1, [r7, #12]
 8011946:	220e      	movs	r2, #14
 8011948:	f7ff fb3c 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 801194c:	697b      	ldr	r3, [r7, #20]
 801194e:	f383 8811 	msr	BASEPRI, r3
}
 8011952:	3718      	adds	r7, #24
 8011954:	46bd      	mov	sp, r7
 8011956:	bd80      	pop	{r7, pc}
 8011958:	2000cd44 	.word	0x2000cd44

0801195c <SEGGER_SYSVIEW_RecordSystime>:
*
*  Function description
*    Formats and sends a SystemView Systime containing a single U64 or U32
*    parameter payload.
*/
void SEGGER_SYSVIEW_RecordSystime(void) {
 801195c:	b5b0      	push	{r4, r5, r7, lr}
 801195e:	b082      	sub	sp, #8
 8011960:	af00      	add	r7, sp, #0
  U64 Systime;

  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
 8011962:	4b11      	ldr	r3, [pc, #68]	; (80119a8 <SEGGER_SYSVIEW_RecordSystime+0x4c>)
 8011964:	6a1b      	ldr	r3, [r3, #32]
 8011966:	2b00      	cmp	r3, #0
 8011968:	d015      	beq.n	8011996 <SEGGER_SYSVIEW_RecordSystime+0x3a>
 801196a:	4b0f      	ldr	r3, [pc, #60]	; (80119a8 <SEGGER_SYSVIEW_RecordSystime+0x4c>)
 801196c:	6a1b      	ldr	r3, [r3, #32]
 801196e:	681b      	ldr	r3, [r3, #0]
 8011970:	2b00      	cmp	r3, #0
 8011972:	d010      	beq.n	8011996 <SEGGER_SYSVIEW_RecordSystime+0x3a>
    Systime = _SYSVIEW_Globals.pOSAPI->pfGetTime();
 8011974:	4b0c      	ldr	r3, [pc, #48]	; (80119a8 <SEGGER_SYSVIEW_RecordSystime+0x4c>)
 8011976:	6a1b      	ldr	r3, [r3, #32]
 8011978:	681b      	ldr	r3, [r3, #0]
 801197a:	4798      	blx	r3
 801197c:	e9c7 0100 	strd	r0, r1, [r7]
    SEGGER_SYSVIEW_RecordU32x2(SYSVIEW_EVTID_SYSTIME_US,
 8011980:	6839      	ldr	r1, [r7, #0]
                               (U32)(Systime),
                               (U32)(Systime >> 32));
 8011982:	e9d7 2300 	ldrd	r2, r3, [r7]
 8011986:	001c      	movs	r4, r3
 8011988:	2500      	movs	r5, #0
void SEGGER_SYSVIEW_RecordSystime(void) {
  U64 Systime;

  if (_SYSVIEW_Globals.pOSAPI && _SYSVIEW_Globals.pOSAPI->pfGetTime) {
    Systime = _SYSVIEW_Globals.pOSAPI->pfGetTime();
    SEGGER_SYSVIEW_RecordU32x2(SYSVIEW_EVTID_SYSTIME_US,
 801198a:	4623      	mov	r3, r4
 801198c:	200d      	movs	r0, #13
 801198e:	461a      	mov	r2, r3
 8011990:	f7ff fc84 	bl	801129c <SEGGER_SYSVIEW_RecordU32x2>
 8011994:	e005      	b.n	80119a2 <SEGGER_SYSVIEW_RecordSystime+0x46>
                               (U32)(Systime),
                               (U32)(Systime >> 32));
  } else {
    SEGGER_SYSVIEW_RecordU32(SYSVIEW_EVTID_SYSTIME_CYCLES, SEGGER_SYSVIEW_GET_TIMESTAMP());
 8011996:	4b05      	ldr	r3, [pc, #20]	; (80119ac <SEGGER_SYSVIEW_RecordSystime+0x50>)
 8011998:	681b      	ldr	r3, [r3, #0]
 801199a:	200c      	movs	r0, #12
 801199c:	4619      	mov	r1, r3
 801199e:	f7ff fc41 	bl	8011224 <SEGGER_SYSVIEW_RecordU32>
  }
}
 80119a2:	3708      	adds	r7, #8
 80119a4:	46bd      	mov	sp, r7
 80119a6:	bdb0      	pop	{r4, r5, r7, pc}
 80119a8:	2000cd14 	.word	0x2000cd14
 80119ac:	e0001004 	.word	0xe0001004

080119b0 <SEGGER_SYSVIEW_RecordEnterISR>:
*
*  Additional information
*    Example packets sent
*      02 0F 50              // ISR(15) Enter. Timestamp is 80 (0x50)
*/
void SEGGER_SYSVIEW_RecordEnterISR(void) {
 80119b0:	b580      	push	{r7, lr}
 80119b2:	b086      	sub	sp, #24
 80119b4:	af00      	add	r7, sp, #0
  unsigned v;
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
 80119b6:	f3ef 8311 	mrs	r3, BASEPRI
 80119ba:	f04f 0120 	mov.w	r1, #32
 80119be:	f381 8811 	msr	BASEPRI, r1
 80119c2:	60fb      	str	r3, [r7, #12]
 80119c4:	4818      	ldr	r0, [pc, #96]	; (8011a28 <SEGGER_SYSVIEW_RecordEnterISR+0x78>)
 80119c6:	f7ff fa29 	bl	8010e1c <_PreparePacket>
 80119ca:	60b8      	str	r0, [r7, #8]
  //
  pPayload = pPayloadStart;
 80119cc:	68bb      	ldr	r3, [r7, #8]
 80119ce:	607b      	str	r3, [r7, #4]
  v = SEGGER_SYSVIEW_GET_INTERRUPT_ID();
 80119d0:	4b16      	ldr	r3, [pc, #88]	; (8011a2c <SEGGER_SYSVIEW_RecordEnterISR+0x7c>)
 80119d2:	681b      	ldr	r3, [r3, #0]
 80119d4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80119d8:	603b      	str	r3, [r7, #0]
  ENCODE_U32(pPayload, v);
 80119da:	687b      	ldr	r3, [r7, #4]
 80119dc:	617b      	str	r3, [r7, #20]
 80119de:	683b      	ldr	r3, [r7, #0]
 80119e0:	613b      	str	r3, [r7, #16]
 80119e2:	e00b      	b.n	80119fc <SEGGER_SYSVIEW_RecordEnterISR+0x4c>
 80119e4:	697b      	ldr	r3, [r7, #20]
 80119e6:	1c5a      	adds	r2, r3, #1
 80119e8:	617a      	str	r2, [r7, #20]
 80119ea:	693a      	ldr	r2, [r7, #16]
 80119ec:	b2d2      	uxtb	r2, r2
 80119ee:	f062 027f 	orn	r2, r2, #127	; 0x7f
 80119f2:	b2d2      	uxtb	r2, r2
 80119f4:	701a      	strb	r2, [r3, #0]
 80119f6:	693b      	ldr	r3, [r7, #16]
 80119f8:	09db      	lsrs	r3, r3, #7
 80119fa:	613b      	str	r3, [r7, #16]
 80119fc:	693b      	ldr	r3, [r7, #16]
 80119fe:	2b7f      	cmp	r3, #127	; 0x7f
 8011a00:	d8f0      	bhi.n	80119e4 <SEGGER_SYSVIEW_RecordEnterISR+0x34>
 8011a02:	697b      	ldr	r3, [r7, #20]
 8011a04:	1c5a      	adds	r2, r3, #1
 8011a06:	617a      	str	r2, [r7, #20]
 8011a08:	693a      	ldr	r2, [r7, #16]
 8011a0a:	b2d2      	uxtb	r2, r2
 8011a0c:	701a      	strb	r2, [r3, #0]
 8011a0e:	697b      	ldr	r3, [r7, #20]
 8011a10:	607b      	str	r3, [r7, #4]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_ISR_ENTER);
 8011a12:	68b8      	ldr	r0, [r7, #8]
 8011a14:	6879      	ldr	r1, [r7, #4]
 8011a16:	2202      	movs	r2, #2
 8011a18:	f7ff fad4 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8011a1c:	68fb      	ldr	r3, [r7, #12]
 8011a1e:	f383 8811 	msr	BASEPRI, r3
}
 8011a22:	3718      	adds	r7, #24
 8011a24:	46bd      	mov	sp, r7
 8011a26:	bd80      	pop	{r7, pc}
 8011a28:	2000cd44 	.word	0x2000cd44
 8011a2c:	e000ed04 	.word	0xe000ed04

08011a30 <SEGGER_SYSVIEW_RecordExitISR>:
*      03 <TimeStamp>        // Max. packet len is 6
*
*    Example packets sent
*      03 20                // ISR Exit. Timestamp is 32 (0x20)
*/
void SEGGER_SYSVIEW_RecordExitISR(void) {
 8011a30:	b580      	push	{r7, lr}
 8011a32:	b082      	sub	sp, #8
 8011a34:	af00      	add	r7, sp, #0
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
 8011a36:	f3ef 8311 	mrs	r3, BASEPRI
 8011a3a:	f04f 0120 	mov.w	r1, #32
 8011a3e:	f381 8811 	msr	BASEPRI, r1
 8011a42:	607b      	str	r3, [r7, #4]
 8011a44:	4807      	ldr	r0, [pc, #28]	; (8011a64 <SEGGER_SYSVIEW_RecordExitISR+0x34>)
 8011a46:	f7ff f9e9 	bl	8010e1c <_PreparePacket>
 8011a4a:	6038      	str	r0, [r7, #0]
  //
  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_EXIT);
 8011a4c:	6838      	ldr	r0, [r7, #0]
 8011a4e:	6839      	ldr	r1, [r7, #0]
 8011a50:	2203      	movs	r2, #3
 8011a52:	f7ff fab7 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8011a56:	687b      	ldr	r3, [r7, #4]
 8011a58:	f383 8811 	msr	BASEPRI, r3
}
 8011a5c:	3708      	adds	r7, #8
 8011a5e:	46bd      	mov	sp, r7
 8011a60:	bd80      	pop	{r7, pc}
 8011a62:	bf00      	nop
 8011a64:	2000cd44 	.word	0x2000cd44

08011a68 <SEGGER_SYSVIEW_RecordExitISRToScheduler>:
*      18 <TimeStamp>        // Max. packet len is 6
*
*    Example packets sent
*      18 20                // ISR Exit to Scheduler. Timestamp is 32 (0x20)
*/
void SEGGER_SYSVIEW_RecordExitISRToScheduler(void) {
 8011a68:	b580      	push	{r7, lr}
 8011a6a:	b082      	sub	sp, #8
 8011a6c:	af00      	add	r7, sp, #0
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
 8011a6e:	f3ef 8311 	mrs	r3, BASEPRI
 8011a72:	f04f 0120 	mov.w	r1, #32
 8011a76:	f381 8811 	msr	BASEPRI, r1
 8011a7a:	607b      	str	r3, [r7, #4]
 8011a7c:	4807      	ldr	r0, [pc, #28]	; (8011a9c <SEGGER_SYSVIEW_RecordExitISRToScheduler+0x34>)
 8011a7e:	f7ff f9cd 	bl	8010e1c <_PreparePacket>
 8011a82:	6038      	str	r0, [r7, #0]
  //
  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_ISR_TO_SCHEDULER);
 8011a84:	6838      	ldr	r0, [r7, #0]
 8011a86:	6839      	ldr	r1, [r7, #0]
 8011a88:	2212      	movs	r2, #18
 8011a8a:	f7ff fa9b 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8011a8e:	687b      	ldr	r3, [r7, #4]
 8011a90:	f383 8811 	msr	BASEPRI, r3
}
 8011a94:	3708      	adds	r7, #8
 8011a96:	46bd      	mov	sp, r7
 8011a98:	bd80      	pop	{r7, pc}
 8011a9a:	bf00      	nop
 8011a9c:	2000cd44 	.word	0x2000cd44

08011aa0 <SEGGER_SYSVIEW_OnIdle>:
*       SEGGER_SYSVIEW_OnIdle()
*
*  Function description
*    Record an Idle event.
*/
void SEGGER_SYSVIEW_OnIdle(void) {
 8011aa0:	b580      	push	{r7, lr}
 8011aa2:	b082      	sub	sp, #8
 8011aa4:	af00      	add	r7, sp, #0
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE);
 8011aa6:	f3ef 8311 	mrs	r3, BASEPRI
 8011aaa:	f04f 0120 	mov.w	r1, #32
 8011aae:	f381 8811 	msr	BASEPRI, r1
 8011ab2:	607b      	str	r3, [r7, #4]
 8011ab4:	4807      	ldr	r0, [pc, #28]	; (8011ad4 <SEGGER_SYSVIEW_OnIdle+0x34>)
 8011ab6:	f7ff f9b1 	bl	8010e1c <_PreparePacket>
 8011aba:	6038      	str	r0, [r7, #0]
  //
  _SendPacket(pPayloadStart, pPayloadStart, SYSVIEW_EVTID_IDLE);
 8011abc:	6838      	ldr	r0, [r7, #0]
 8011abe:	6839      	ldr	r1, [r7, #0]
 8011ac0:	2211      	movs	r2, #17
 8011ac2:	f7ff fa7f 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8011ac6:	687b      	ldr	r3, [r7, #4]
 8011ac8:	f383 8811 	msr	BASEPRI, r3
}
 8011acc:	3708      	adds	r7, #8
 8011ace:	46bd      	mov	sp, r7
 8011ad0:	bd80      	pop	{r7, pc}
 8011ad2:	bf00      	nop
 8011ad4:	2000cd44 	.word	0x2000cd44

08011ad8 <SEGGER_SYSVIEW_OnTaskCreate>:
*    to creating a task in the OS.
*
*  Parameters
*    TaskId        - Task ID of created task.
*/
void SEGGER_SYSVIEW_OnTaskCreate(U32 TaskId) {
 8011ad8:	b580      	push	{r7, lr}
 8011ada:	b088      	sub	sp, #32
 8011adc:	af00      	add	r7, sp, #0
 8011ade:	6078      	str	r0, [r7, #4]
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
 8011ae0:	f3ef 8311 	mrs	r3, BASEPRI
 8011ae4:	f04f 0120 	mov.w	r1, #32
 8011ae8:	f381 8811 	msr	BASEPRI, r1
 8011aec:	617b      	str	r3, [r7, #20]
 8011aee:	4819      	ldr	r0, [pc, #100]	; (8011b54 <SEGGER_SYSVIEW_OnTaskCreate+0x7c>)
 8011af0:	f7ff f994 	bl	8010e1c <_PreparePacket>
 8011af4:	6138      	str	r0, [r7, #16]
  //
  pPayload = pPayloadStart;
 8011af6:	693b      	ldr	r3, [r7, #16]
 8011af8:	60fb      	str	r3, [r7, #12]
  TaskId = SHRINK_ID(TaskId);
 8011afa:	4b17      	ldr	r3, [pc, #92]	; (8011b58 <SEGGER_SYSVIEW_OnTaskCreate+0x80>)
 8011afc:	691b      	ldr	r3, [r3, #16]
 8011afe:	687a      	ldr	r2, [r7, #4]
 8011b00:	1ad3      	subs	r3, r2, r3
 8011b02:	089b      	lsrs	r3, r3, #2
 8011b04:	607b      	str	r3, [r7, #4]
  ENCODE_U32(pPayload, TaskId);
 8011b06:	68fb      	ldr	r3, [r7, #12]
 8011b08:	61fb      	str	r3, [r7, #28]
 8011b0a:	687b      	ldr	r3, [r7, #4]
 8011b0c:	61bb      	str	r3, [r7, #24]
 8011b0e:	e00b      	b.n	8011b28 <SEGGER_SYSVIEW_OnTaskCreate+0x50>
 8011b10:	69fb      	ldr	r3, [r7, #28]
 8011b12:	1c5a      	adds	r2, r3, #1
 8011b14:	61fa      	str	r2, [r7, #28]
 8011b16:	69ba      	ldr	r2, [r7, #24]
 8011b18:	b2d2      	uxtb	r2, r2
 8011b1a:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011b1e:	b2d2      	uxtb	r2, r2
 8011b20:	701a      	strb	r2, [r3, #0]
 8011b22:	69bb      	ldr	r3, [r7, #24]
 8011b24:	09db      	lsrs	r3, r3, #7
 8011b26:	61bb      	str	r3, [r7, #24]
 8011b28:	69bb      	ldr	r3, [r7, #24]
 8011b2a:	2b7f      	cmp	r3, #127	; 0x7f
 8011b2c:	d8f0      	bhi.n	8011b10 <SEGGER_SYSVIEW_OnTaskCreate+0x38>
 8011b2e:	69fb      	ldr	r3, [r7, #28]
 8011b30:	1c5a      	adds	r2, r3, #1
 8011b32:	61fa      	str	r2, [r7, #28]
 8011b34:	69ba      	ldr	r2, [r7, #24]
 8011b36:	b2d2      	uxtb	r2, r2
 8011b38:	701a      	strb	r2, [r3, #0]
 8011b3a:	69fb      	ldr	r3, [r7, #28]
 8011b3c:	60fb      	str	r3, [r7, #12]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_CREATE);
 8011b3e:	6938      	ldr	r0, [r7, #16]
 8011b40:	68f9      	ldr	r1, [r7, #12]
 8011b42:	2208      	movs	r2, #8
 8011b44:	f7ff fa3e 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8011b48:	697b      	ldr	r3, [r7, #20]
 8011b4a:	f383 8811 	msr	BASEPRI, r3
}
 8011b4e:	3720      	adds	r7, #32
 8011b50:	46bd      	mov	sp, r7
 8011b52:	bd80      	pop	{r7, pc}
 8011b54:	2000cd44 	.word	0x2000cd44
 8011b58:	2000cd14 	.word	0x2000cd14

08011b5c <SEGGER_SYSVIEW_OnTaskStartExec>:
*    when it is ready to execute.
*
*  Parameters
*    TaskId - Task ID of task that started to execute.
*/
void SEGGER_SYSVIEW_OnTaskStartExec(U32 TaskId) {
 8011b5c:	b580      	push	{r7, lr}
 8011b5e:	b088      	sub	sp, #32
 8011b60:	af00      	add	r7, sp, #0
 8011b62:	6078      	str	r0, [r7, #4]
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
 8011b64:	f3ef 8311 	mrs	r3, BASEPRI
 8011b68:	f04f 0120 	mov.w	r1, #32
 8011b6c:	f381 8811 	msr	BASEPRI, r1
 8011b70:	617b      	str	r3, [r7, #20]
 8011b72:	4819      	ldr	r0, [pc, #100]	; (8011bd8 <SEGGER_SYSVIEW_OnTaskStartExec+0x7c>)
 8011b74:	f7ff f952 	bl	8010e1c <_PreparePacket>
 8011b78:	6138      	str	r0, [r7, #16]
  //
  pPayload = pPayloadStart;
 8011b7a:	693b      	ldr	r3, [r7, #16]
 8011b7c:	60fb      	str	r3, [r7, #12]
  TaskId = SHRINK_ID(TaskId);
 8011b7e:	4b17      	ldr	r3, [pc, #92]	; (8011bdc <SEGGER_SYSVIEW_OnTaskStartExec+0x80>)
 8011b80:	691b      	ldr	r3, [r3, #16]
 8011b82:	687a      	ldr	r2, [r7, #4]
 8011b84:	1ad3      	subs	r3, r2, r3
 8011b86:	089b      	lsrs	r3, r3, #2
 8011b88:	607b      	str	r3, [r7, #4]
  ENCODE_U32(pPayload, TaskId);
 8011b8a:	68fb      	ldr	r3, [r7, #12]
 8011b8c:	61fb      	str	r3, [r7, #28]
 8011b8e:	687b      	ldr	r3, [r7, #4]
 8011b90:	61bb      	str	r3, [r7, #24]
 8011b92:	e00b      	b.n	8011bac <SEGGER_SYSVIEW_OnTaskStartExec+0x50>
 8011b94:	69fb      	ldr	r3, [r7, #28]
 8011b96:	1c5a      	adds	r2, r3, #1
 8011b98:	61fa      	str	r2, [r7, #28]
 8011b9a:	69ba      	ldr	r2, [r7, #24]
 8011b9c:	b2d2      	uxtb	r2, r2
 8011b9e:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011ba2:	b2d2      	uxtb	r2, r2
 8011ba4:	701a      	strb	r2, [r3, #0]
 8011ba6:	69bb      	ldr	r3, [r7, #24]
 8011ba8:	09db      	lsrs	r3, r3, #7
 8011baa:	61bb      	str	r3, [r7, #24]
 8011bac:	69bb      	ldr	r3, [r7, #24]
 8011bae:	2b7f      	cmp	r3, #127	; 0x7f
 8011bb0:	d8f0      	bhi.n	8011b94 <SEGGER_SYSVIEW_OnTaskStartExec+0x38>
 8011bb2:	69fb      	ldr	r3, [r7, #28]
 8011bb4:	1c5a      	adds	r2, r3, #1
 8011bb6:	61fa      	str	r2, [r7, #28]
 8011bb8:	69ba      	ldr	r2, [r7, #24]
 8011bba:	b2d2      	uxtb	r2, r2
 8011bbc:	701a      	strb	r2, [r3, #0]
 8011bbe:	69fb      	ldr	r3, [r7, #28]
 8011bc0:	60fb      	str	r3, [r7, #12]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_EXEC);
 8011bc2:	6938      	ldr	r0, [r7, #16]
 8011bc4:	68f9      	ldr	r1, [r7, #12]
 8011bc6:	2204      	movs	r2, #4
 8011bc8:	f7ff f9fc 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8011bcc:	697b      	ldr	r3, [r7, #20]
 8011bce:	f383 8811 	msr	BASEPRI, r3
}
 8011bd2:	3720      	adds	r7, #32
 8011bd4:	46bd      	mov	sp, r7
 8011bd6:	bd80      	pop	{r7, pc}
 8011bd8:	2000cd44 	.word	0x2000cd44
 8011bdc:	2000cd14 	.word	0x2000cd14

08011be0 <SEGGER_SYSVIEW_OnTaskStartReady>:
*    Record a Task Start Ready event.
*
*  Parameters
*    TaskId - Task ID of task that started to execute.
*/
void SEGGER_SYSVIEW_OnTaskStartReady(U32 TaskId) {
 8011be0:	b580      	push	{r7, lr}
 8011be2:	b088      	sub	sp, #32
 8011be4:	af00      	add	r7, sp, #0
 8011be6:	6078      	str	r0, [r7, #4]
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + SEGGER_SYSVIEW_QUANTA_U32);
 8011be8:	f3ef 8311 	mrs	r3, BASEPRI
 8011bec:	f04f 0120 	mov.w	r1, #32
 8011bf0:	f381 8811 	msr	BASEPRI, r1
 8011bf4:	617b      	str	r3, [r7, #20]
 8011bf6:	4819      	ldr	r0, [pc, #100]	; (8011c5c <SEGGER_SYSVIEW_OnTaskStartReady+0x7c>)
 8011bf8:	f7ff f910 	bl	8010e1c <_PreparePacket>
 8011bfc:	6138      	str	r0, [r7, #16]
  //
  pPayload = pPayloadStart;
 8011bfe:	693b      	ldr	r3, [r7, #16]
 8011c00:	60fb      	str	r3, [r7, #12]
  TaskId = SHRINK_ID(TaskId);
 8011c02:	4b17      	ldr	r3, [pc, #92]	; (8011c60 <SEGGER_SYSVIEW_OnTaskStartReady+0x80>)
 8011c04:	691b      	ldr	r3, [r3, #16]
 8011c06:	687a      	ldr	r2, [r7, #4]
 8011c08:	1ad3      	subs	r3, r2, r3
 8011c0a:	089b      	lsrs	r3, r3, #2
 8011c0c:	607b      	str	r3, [r7, #4]
  ENCODE_U32(pPayload, TaskId);
 8011c0e:	68fb      	ldr	r3, [r7, #12]
 8011c10:	61fb      	str	r3, [r7, #28]
 8011c12:	687b      	ldr	r3, [r7, #4]
 8011c14:	61bb      	str	r3, [r7, #24]
 8011c16:	e00b      	b.n	8011c30 <SEGGER_SYSVIEW_OnTaskStartReady+0x50>
 8011c18:	69fb      	ldr	r3, [r7, #28]
 8011c1a:	1c5a      	adds	r2, r3, #1
 8011c1c:	61fa      	str	r2, [r7, #28]
 8011c1e:	69ba      	ldr	r2, [r7, #24]
 8011c20:	b2d2      	uxtb	r2, r2
 8011c22:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011c26:	b2d2      	uxtb	r2, r2
 8011c28:	701a      	strb	r2, [r3, #0]
 8011c2a:	69bb      	ldr	r3, [r7, #24]
 8011c2c:	09db      	lsrs	r3, r3, #7
 8011c2e:	61bb      	str	r3, [r7, #24]
 8011c30:	69bb      	ldr	r3, [r7, #24]
 8011c32:	2b7f      	cmp	r3, #127	; 0x7f
 8011c34:	d8f0      	bhi.n	8011c18 <SEGGER_SYSVIEW_OnTaskStartReady+0x38>
 8011c36:	69fb      	ldr	r3, [r7, #28]
 8011c38:	1c5a      	adds	r2, r3, #1
 8011c3a:	61fa      	str	r2, [r7, #28]
 8011c3c:	69ba      	ldr	r2, [r7, #24]
 8011c3e:	b2d2      	uxtb	r2, r2
 8011c40:	701a      	strb	r2, [r3, #0]
 8011c42:	69fb      	ldr	r3, [r7, #28]
 8011c44:	60fb      	str	r3, [r7, #12]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_START_READY);
 8011c46:	6938      	ldr	r0, [r7, #16]
 8011c48:	68f9      	ldr	r1, [r7, #12]
 8011c4a:	2206      	movs	r2, #6
 8011c4c:	f7ff f9ba 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8011c50:	697b      	ldr	r3, [r7, #20]
 8011c52:	f383 8811 	msr	BASEPRI, r3
}
 8011c56:	3720      	adds	r7, #32
 8011c58:	46bd      	mov	sp, r7
 8011c5a:	bd80      	pop	{r7, pc}
 8011c5c:	2000cd44 	.word	0x2000cd44
 8011c60:	2000cd14 	.word	0x2000cd14

08011c64 <SEGGER_SYSVIEW_OnTaskStopReady>:
*
*  Parameters
*    TaskId - Task ID of task that completed execution.
*    Cause  - Reason for task to stop (i.e. Idle/Sleep)
*/
void SEGGER_SYSVIEW_OnTaskStopReady(U32 TaskId, unsigned int Cause) {
 8011c64:	b580      	push	{r7, lr}
 8011c66:	b08a      	sub	sp, #40	; 0x28
 8011c68:	af00      	add	r7, sp, #0
 8011c6a:	6078      	str	r0, [r7, #4]
 8011c6c:	6039      	str	r1, [r7, #0]
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32);
 8011c6e:	f3ef 8311 	mrs	r3, BASEPRI
 8011c72:	f04f 0120 	mov.w	r1, #32
 8011c76:	f381 8811 	msr	BASEPRI, r1
 8011c7a:	617b      	str	r3, [r7, #20]
 8011c7c:	4827      	ldr	r0, [pc, #156]	; (8011d1c <SEGGER_SYSVIEW_OnTaskStopReady+0xb8>)
 8011c7e:	f7ff f8cd 	bl	8010e1c <_PreparePacket>
 8011c82:	6138      	str	r0, [r7, #16]
  //
  pPayload = pPayloadStart;
 8011c84:	693b      	ldr	r3, [r7, #16]
 8011c86:	60fb      	str	r3, [r7, #12]
  TaskId = SHRINK_ID(TaskId);
 8011c88:	4b25      	ldr	r3, [pc, #148]	; (8011d20 <SEGGER_SYSVIEW_OnTaskStopReady+0xbc>)
 8011c8a:	691b      	ldr	r3, [r3, #16]
 8011c8c:	687a      	ldr	r2, [r7, #4]
 8011c8e:	1ad3      	subs	r3, r2, r3
 8011c90:	089b      	lsrs	r3, r3, #2
 8011c92:	607b      	str	r3, [r7, #4]
  ENCODE_U32(pPayload, TaskId);
 8011c94:	68fb      	ldr	r3, [r7, #12]
 8011c96:	627b      	str	r3, [r7, #36]	; 0x24
 8011c98:	687b      	ldr	r3, [r7, #4]
 8011c9a:	623b      	str	r3, [r7, #32]
 8011c9c:	e00b      	b.n	8011cb6 <SEGGER_SYSVIEW_OnTaskStopReady+0x52>
 8011c9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011ca0:	1c5a      	adds	r2, r3, #1
 8011ca2:	627a      	str	r2, [r7, #36]	; 0x24
 8011ca4:	6a3a      	ldr	r2, [r7, #32]
 8011ca6:	b2d2      	uxtb	r2, r2
 8011ca8:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011cac:	b2d2      	uxtb	r2, r2
 8011cae:	701a      	strb	r2, [r3, #0]
 8011cb0:	6a3b      	ldr	r3, [r7, #32]
 8011cb2:	09db      	lsrs	r3, r3, #7
 8011cb4:	623b      	str	r3, [r7, #32]
 8011cb6:	6a3b      	ldr	r3, [r7, #32]
 8011cb8:	2b7f      	cmp	r3, #127	; 0x7f
 8011cba:	d8f0      	bhi.n	8011c9e <SEGGER_SYSVIEW_OnTaskStopReady+0x3a>
 8011cbc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011cbe:	1c5a      	adds	r2, r3, #1
 8011cc0:	627a      	str	r2, [r7, #36]	; 0x24
 8011cc2:	6a3a      	ldr	r2, [r7, #32]
 8011cc4:	b2d2      	uxtb	r2, r2
 8011cc6:	701a      	strb	r2, [r3, #0]
 8011cc8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011cca:	60fb      	str	r3, [r7, #12]
  ENCODE_U32(pPayload, Cause);
 8011ccc:	68fb      	ldr	r3, [r7, #12]
 8011cce:	61fb      	str	r3, [r7, #28]
 8011cd0:	683b      	ldr	r3, [r7, #0]
 8011cd2:	61bb      	str	r3, [r7, #24]
 8011cd4:	e00b      	b.n	8011cee <SEGGER_SYSVIEW_OnTaskStopReady+0x8a>
 8011cd6:	69fb      	ldr	r3, [r7, #28]
 8011cd8:	1c5a      	adds	r2, r3, #1
 8011cda:	61fa      	str	r2, [r7, #28]
 8011cdc:	69ba      	ldr	r2, [r7, #24]
 8011cde:	b2d2      	uxtb	r2, r2
 8011ce0:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011ce4:	b2d2      	uxtb	r2, r2
 8011ce6:	701a      	strb	r2, [r3, #0]
 8011ce8:	69bb      	ldr	r3, [r7, #24]
 8011cea:	09db      	lsrs	r3, r3, #7
 8011cec:	61bb      	str	r3, [r7, #24]
 8011cee:	69bb      	ldr	r3, [r7, #24]
 8011cf0:	2b7f      	cmp	r3, #127	; 0x7f
 8011cf2:	d8f0      	bhi.n	8011cd6 <SEGGER_SYSVIEW_OnTaskStopReady+0x72>
 8011cf4:	69fb      	ldr	r3, [r7, #28]
 8011cf6:	1c5a      	adds	r2, r3, #1
 8011cf8:	61fa      	str	r2, [r7, #28]
 8011cfa:	69ba      	ldr	r2, [r7, #24]
 8011cfc:	b2d2      	uxtb	r2, r2
 8011cfe:	701a      	strb	r2, [r3, #0]
 8011d00:	69fb      	ldr	r3, [r7, #28]
 8011d02:	60fb      	str	r3, [r7, #12]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_TASK_STOP_READY);
 8011d04:	6938      	ldr	r0, [r7, #16]
 8011d06:	68f9      	ldr	r1, [r7, #12]
 8011d08:	2207      	movs	r2, #7
 8011d0a:	f7ff f95b 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8011d0e:	697b      	ldr	r3, [r7, #20]
 8011d10:	f383 8811 	msr	BASEPRI, r3
}
 8011d14:	3728      	adds	r7, #40	; 0x28
 8011d16:	46bd      	mov	sp, r7
 8011d18:	bd80      	pop	{r7, pc}
 8011d1a:	bf00      	nop
 8011d1c:	2000cd44 	.word	0x2000cd44
 8011d20:	2000cd14 	.word	0x2000cd14

08011d24 <SEGGER_SYSVIEW_SendPacket>:
*
*  Return value
*    !=0:  Success, Message sent.
*    ==0:  Buffer full, Message *NOT* sent.
*/
int SEGGER_SYSVIEW_SendPacket(U8* pPacket, U8* pPayloadEnd, unsigned int EventId) {
 8011d24:	b580      	push	{r7, lr}
 8011d26:	b086      	sub	sp, #24
 8011d28:	af00      	add	r7, sp, #0
 8011d2a:	60f8      	str	r0, [r7, #12]
 8011d2c:	60b9      	str	r1, [r7, #8]
 8011d2e:	607a      	str	r2, [r7, #4]
#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
  SEGGER_SYSVIEW_LOCK();
 8011d30:	f3ef 8311 	mrs	r3, BASEPRI
 8011d34:	f04f 0120 	mov.w	r1, #32
 8011d38:	f381 8811 	msr	BASEPRI, r1
 8011d3c:	617b      	str	r3, [r7, #20]
#endif
  _SendPacket(pPacket + 4, pPayloadEnd, EventId);
 8011d3e:	68fb      	ldr	r3, [r7, #12]
 8011d40:	3304      	adds	r3, #4
 8011d42:	4618      	mov	r0, r3
 8011d44:	68b9      	ldr	r1, [r7, #8]
 8011d46:	687a      	ldr	r2, [r7, #4]
 8011d48:	f7ff f93c 	bl	8010fc4 <_SendPacket>
#if (SEGGER_SYSVIEW_USE_STATIC_BUFFER == 1)
  SEGGER_SYSVIEW_UNLOCK();
 8011d4c:	697b      	ldr	r3, [r7, #20]
 8011d4e:	f383 8811 	msr	BASEPRI, r3
#endif
  return 0;
 8011d52:	2300      	movs	r3, #0
}
 8011d54:	4618      	mov	r0, r3
 8011d56:	3718      	adds	r7, #24
 8011d58:	46bd      	mov	sp, r7
 8011d5a:	bd80      	pop	{r7, pc}

08011d5c <SEGGER_SYSVIEW_EncodeU32>:
*  Return value
*    Pointer to the byte following the value, i.e. the first free
*    byte in the payload and the next position to store payload
*    content.
*/
U8* SEGGER_SYSVIEW_EncodeU32(U8* pPayload, U32 Value) {
 8011d5c:	b480      	push	{r7}
 8011d5e:	b085      	sub	sp, #20
 8011d60:	af00      	add	r7, sp, #0
 8011d62:	6078      	str	r0, [r7, #4]
 8011d64:	6039      	str	r1, [r7, #0]
  ENCODE_U32(pPayload, Value);
 8011d66:	687b      	ldr	r3, [r7, #4]
 8011d68:	60fb      	str	r3, [r7, #12]
 8011d6a:	683b      	ldr	r3, [r7, #0]
 8011d6c:	60bb      	str	r3, [r7, #8]
 8011d6e:	e00b      	b.n	8011d88 <SEGGER_SYSVIEW_EncodeU32+0x2c>
 8011d70:	68fb      	ldr	r3, [r7, #12]
 8011d72:	1c5a      	adds	r2, r3, #1
 8011d74:	60fa      	str	r2, [r7, #12]
 8011d76:	68ba      	ldr	r2, [r7, #8]
 8011d78:	b2d2      	uxtb	r2, r2
 8011d7a:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011d7e:	b2d2      	uxtb	r2, r2
 8011d80:	701a      	strb	r2, [r3, #0]
 8011d82:	68bb      	ldr	r3, [r7, #8]
 8011d84:	09db      	lsrs	r3, r3, #7
 8011d86:	60bb      	str	r3, [r7, #8]
 8011d88:	68bb      	ldr	r3, [r7, #8]
 8011d8a:	2b7f      	cmp	r3, #127	; 0x7f
 8011d8c:	d8f0      	bhi.n	8011d70 <SEGGER_SYSVIEW_EncodeU32+0x14>
 8011d8e:	68fb      	ldr	r3, [r7, #12]
 8011d90:	1c5a      	adds	r2, r3, #1
 8011d92:	60fa      	str	r2, [r7, #12]
 8011d94:	68ba      	ldr	r2, [r7, #8]
 8011d96:	b2d2      	uxtb	r2, r2
 8011d98:	701a      	strb	r2, [r3, #0]
 8011d9a:	68fb      	ldr	r3, [r7, #12]
 8011d9c:	607b      	str	r3, [r7, #4]
  return pPayload;
 8011d9e:	687b      	ldr	r3, [r7, #4]
}
 8011da0:	4618      	mov	r0, r3
 8011da2:	3714      	adds	r7, #20
 8011da4:	46bd      	mov	sp, r7
 8011da6:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011daa:	4770      	bx	lr

08011dac <SEGGER_SYSVIEW_ShrinkId>:
*     SEGGER_SYSVIEW_ID_BASE: Lowest Id reported by the application.
*       (i.e. 0x20000000 when all Ids are an address in this RAM)
*     SEGGER_SYSVIEW_ID_SHIFT: Number of bits to shift the Id to
*       save bandwidth. (i.e. 2 when Ids are 4 byte aligned)
*/
U32 SEGGER_SYSVIEW_ShrinkId(U32 Id) {
 8011dac:	b480      	push	{r7}
 8011dae:	b083      	sub	sp, #12
 8011db0:	af00      	add	r7, sp, #0
 8011db2:	6078      	str	r0, [r7, #4]
  return SHRINK_ID(Id);
 8011db4:	4b05      	ldr	r3, [pc, #20]	; (8011dcc <SEGGER_SYSVIEW_ShrinkId+0x20>)
 8011db6:	691b      	ldr	r3, [r3, #16]
 8011db8:	687a      	ldr	r2, [r7, #4]
 8011dba:	1ad3      	subs	r3, r2, r3
 8011dbc:	089b      	lsrs	r3, r3, #2
}
 8011dbe:	4618      	mov	r0, r3
 8011dc0:	370c      	adds	r7, #12
 8011dc2:	46bd      	mov	sp, r7
 8011dc4:	f85d 7b04 	ldr.w	r7, [sp], #4
 8011dc8:	4770      	bx	lr
 8011dca:	bf00      	nop
 8011dcc:	2000cd14 	.word	0x2000cd14

08011dd0 <SEGGER_SYSVIEW_SendModule>:
*    Sends the information of a registered module to the host.
*
*  Parameters
*    ModuleId   - Id of the requested module.
*/
void SEGGER_SYSVIEW_SendModule(U8 ModuleId) {
 8011dd0:	b580      	push	{r7, lr}
 8011dd2:	b08c      	sub	sp, #48	; 0x30
 8011dd4:	af00      	add	r7, sp, #0
 8011dd6:	4603      	mov	r3, r0
 8011dd8:	71fb      	strb	r3, [r7, #7]
  SEGGER_SYSVIEW_MODULE* pModule;
  U32 n;

  if (_pFirstModule != 0) {
 8011dda:	4b3a      	ldr	r3, [pc, #232]	; (8011ec4 <SEGGER_SYSVIEW_SendModule+0xf4>)
 8011ddc:	681b      	ldr	r3, [r3, #0]
 8011dde:	2b00      	cmp	r3, #0
 8011de0:	d06c      	beq.n	8011ebc <SEGGER_SYSVIEW_SendModule+0xec>
    pModule = _pFirstModule;
 8011de2:	4b38      	ldr	r3, [pc, #224]	; (8011ec4 <SEGGER_SYSVIEW_SendModule+0xf4>)
 8011de4:	681b      	ldr	r3, [r3, #0]
 8011de6:	62fb      	str	r3, [r7, #44]	; 0x2c
    for (n = 0; n < ModuleId; n++) {
 8011de8:	2300      	movs	r3, #0
 8011dea:	62bb      	str	r3, [r7, #40]	; 0x28
 8011dec:	e009      	b.n	8011e02 <SEGGER_SYSVIEW_SendModule+0x32>
      pModule = pModule->pNext;
 8011dee:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011df0:	691b      	ldr	r3, [r3, #16]
 8011df2:	62fb      	str	r3, [r7, #44]	; 0x2c
      if (pModule == 0) {
 8011df4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011df6:	2b00      	cmp	r3, #0
 8011df8:	d100      	bne.n	8011dfc <SEGGER_SYSVIEW_SendModule+0x2c>
        break;
 8011dfa:	e006      	b.n	8011e0a <SEGGER_SYSVIEW_SendModule+0x3a>
  SEGGER_SYSVIEW_MODULE* pModule;
  U32 n;

  if (_pFirstModule != 0) {
    pModule = _pFirstModule;
    for (n = 0; n < ModuleId; n++) {
 8011dfc:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011dfe:	3301      	adds	r3, #1
 8011e00:	62bb      	str	r3, [r7, #40]	; 0x28
 8011e02:	79fa      	ldrb	r2, [r7, #7]
 8011e04:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8011e06:	429a      	cmp	r2, r3
 8011e08:	d8f1      	bhi.n	8011dee <SEGGER_SYSVIEW_SendModule+0x1e>
      pModule = pModule->pNext;
      if (pModule == 0) {
        break;
      }
    }
    if (pModule != 0) {
 8011e0a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011e0c:	2b00      	cmp	r3, #0
 8011e0e:	d055      	beq.n	8011ebc <SEGGER_SYSVIEW_SendModule+0xec>
      U8* pPayload;
      U8* pPayloadStart;
      RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + 1 + SEGGER_SYSVIEW_MAX_STRING_LEN);
 8011e10:	f3ef 8311 	mrs	r3, BASEPRI
 8011e14:	f04f 0120 	mov.w	r1, #32
 8011e18:	f381 8811 	msr	BASEPRI, r1
 8011e1c:	617b      	str	r3, [r7, #20]
 8011e1e:	482a      	ldr	r0, [pc, #168]	; (8011ec8 <SEGGER_SYSVIEW_SendModule+0xf8>)
 8011e20:	f7fe fffc 	bl	8010e1c <_PreparePacket>
 8011e24:	6138      	str	r0, [r7, #16]
      //
      pPayload = pPayloadStart;
 8011e26:	693b      	ldr	r3, [r7, #16]
 8011e28:	60fb      	str	r3, [r7, #12]
      //
      // Send module description
      // Send event offset and number of events
      //
      ENCODE_U32(pPayload, ModuleId);
 8011e2a:	68fb      	ldr	r3, [r7, #12]
 8011e2c:	627b      	str	r3, [r7, #36]	; 0x24
 8011e2e:	79fb      	ldrb	r3, [r7, #7]
 8011e30:	623b      	str	r3, [r7, #32]
 8011e32:	e00b      	b.n	8011e4c <SEGGER_SYSVIEW_SendModule+0x7c>
 8011e34:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011e36:	1c5a      	adds	r2, r3, #1
 8011e38:	627a      	str	r2, [r7, #36]	; 0x24
 8011e3a:	6a3a      	ldr	r2, [r7, #32]
 8011e3c:	b2d2      	uxtb	r2, r2
 8011e3e:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011e42:	b2d2      	uxtb	r2, r2
 8011e44:	701a      	strb	r2, [r3, #0]
 8011e46:	6a3b      	ldr	r3, [r7, #32]
 8011e48:	09db      	lsrs	r3, r3, #7
 8011e4a:	623b      	str	r3, [r7, #32]
 8011e4c:	6a3b      	ldr	r3, [r7, #32]
 8011e4e:	2b7f      	cmp	r3, #127	; 0x7f
 8011e50:	d8f0      	bhi.n	8011e34 <SEGGER_SYSVIEW_SendModule+0x64>
 8011e52:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011e54:	1c5a      	adds	r2, r3, #1
 8011e56:	627a      	str	r2, [r7, #36]	; 0x24
 8011e58:	6a3a      	ldr	r2, [r7, #32]
 8011e5a:	b2d2      	uxtb	r2, r2
 8011e5c:	701a      	strb	r2, [r3, #0]
 8011e5e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011e60:	60fb      	str	r3, [r7, #12]
      ENCODE_U32(pPayload, (pModule->EventOffset));
 8011e62:	68fb      	ldr	r3, [r7, #12]
 8011e64:	61fb      	str	r3, [r7, #28]
 8011e66:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011e68:	689b      	ldr	r3, [r3, #8]
 8011e6a:	61bb      	str	r3, [r7, #24]
 8011e6c:	e00b      	b.n	8011e86 <SEGGER_SYSVIEW_SendModule+0xb6>
 8011e6e:	69fb      	ldr	r3, [r7, #28]
 8011e70:	1c5a      	adds	r2, r3, #1
 8011e72:	61fa      	str	r2, [r7, #28]
 8011e74:	69ba      	ldr	r2, [r7, #24]
 8011e76:	b2d2      	uxtb	r2, r2
 8011e78:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011e7c:	b2d2      	uxtb	r2, r2
 8011e7e:	701a      	strb	r2, [r3, #0]
 8011e80:	69bb      	ldr	r3, [r7, #24]
 8011e82:	09db      	lsrs	r3, r3, #7
 8011e84:	61bb      	str	r3, [r7, #24]
 8011e86:	69bb      	ldr	r3, [r7, #24]
 8011e88:	2b7f      	cmp	r3, #127	; 0x7f
 8011e8a:	d8f0      	bhi.n	8011e6e <SEGGER_SYSVIEW_SendModule+0x9e>
 8011e8c:	69fb      	ldr	r3, [r7, #28]
 8011e8e:	1c5a      	adds	r2, r3, #1
 8011e90:	61fa      	str	r2, [r7, #28]
 8011e92:	69ba      	ldr	r2, [r7, #24]
 8011e94:	b2d2      	uxtb	r2, r2
 8011e96:	701a      	strb	r2, [r3, #0]
 8011e98:	69fb      	ldr	r3, [r7, #28]
 8011e9a:	60fb      	str	r3, [r7, #12]
      pPayload = _EncodeStr(pPayload, pModule->sModule, SEGGER_SYSVIEW_MAX_STRING_LEN);
 8011e9c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8011e9e:	681b      	ldr	r3, [r3, #0]
 8011ea0:	68f8      	ldr	r0, [r7, #12]
 8011ea2:	4619      	mov	r1, r3
 8011ea4:	2280      	movs	r2, #128	; 0x80
 8011ea6:	f7fe ff6b 	bl	8010d80 <_EncodeStr>
 8011eaa:	60f8      	str	r0, [r7, #12]
      _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_MODULEDESC);
 8011eac:	6938      	ldr	r0, [r7, #16]
 8011eae:	68f9      	ldr	r1, [r7, #12]
 8011eb0:	2216      	movs	r2, #22
 8011eb2:	f7ff f887 	bl	8010fc4 <_SendPacket>
      RECORD_END();
 8011eb6:	697b      	ldr	r3, [r7, #20]
 8011eb8:	f383 8811 	msr	BASEPRI, r3
    }
  }
}
 8011ebc:	3730      	adds	r7, #48	; 0x30
 8011ebe:	46bd      	mov	sp, r7
 8011ec0:	bd80      	pop	{r7, pc}
 8011ec2:	bf00      	nop
 8011ec4:	2000cd3c 	.word	0x2000cd3c
 8011ec8:	2000cd44 	.word	0x2000cd44

08011ecc <SEGGER_SYSVIEW_SendModuleDescription>:
*
*  Function description
*    Triggers a send of the registered module descriptions.
*
*/
void SEGGER_SYSVIEW_SendModuleDescription(void) {
 8011ecc:	b580      	push	{r7, lr}
 8011ece:	b082      	sub	sp, #8
 8011ed0:	af00      	add	r7, sp, #0
  SEGGER_SYSVIEW_MODULE* pModule;

  if (_pFirstModule != 0) {
 8011ed2:	4b0b      	ldr	r3, [pc, #44]	; (8011f00 <SEGGER_SYSVIEW_SendModuleDescription+0x34>)
 8011ed4:	681b      	ldr	r3, [r3, #0]
 8011ed6:	2b00      	cmp	r3, #0
 8011ed8:	d00f      	beq.n	8011efa <SEGGER_SYSVIEW_SendModuleDescription+0x2e>
    pModule = _pFirstModule;
 8011eda:	4b09      	ldr	r3, [pc, #36]	; (8011f00 <SEGGER_SYSVIEW_SendModuleDescription+0x34>)
 8011edc:	681b      	ldr	r3, [r3, #0]
 8011ede:	607b      	str	r3, [r7, #4]
    do {
      if (pModule->pfSendModuleDesc) {
 8011ee0:	687b      	ldr	r3, [r7, #4]
 8011ee2:	68db      	ldr	r3, [r3, #12]
 8011ee4:	2b00      	cmp	r3, #0
 8011ee6:	d002      	beq.n	8011eee <SEGGER_SYSVIEW_SendModuleDescription+0x22>
        pModule->pfSendModuleDesc();
 8011ee8:	687b      	ldr	r3, [r7, #4]
 8011eea:	68db      	ldr	r3, [r3, #12]
 8011eec:	4798      	blx	r3
      }
      pModule = pModule->pNext;
 8011eee:	687b      	ldr	r3, [r7, #4]
 8011ef0:	691b      	ldr	r3, [r3, #16]
 8011ef2:	607b      	str	r3, [r7, #4]
    } while (pModule);
 8011ef4:	687b      	ldr	r3, [r7, #4]
 8011ef6:	2b00      	cmp	r3, #0
 8011ef8:	d1f2      	bne.n	8011ee0 <SEGGER_SYSVIEW_SendModuleDescription+0x14>
  }
}
 8011efa:	3708      	adds	r7, #8
 8011efc:	46bd      	mov	sp, r7
 8011efe:	bd80      	pop	{r7, pc}
 8011f00:	2000cd3c 	.word	0x2000cd3c

08011f04 <SEGGER_SYSVIEW_SendNumModules>:
*       SEGGER_SYSVIEW_SendNumModules()
*
*  Function description
*    Send the number of registered modules to the host.
*/
void SEGGER_SYSVIEW_SendNumModules(void) {
 8011f04:	b580      	push	{r7, lr}
 8011f06:	b086      	sub	sp, #24
 8011f08:	af00      	add	r7, sp, #0
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2*SEGGER_SYSVIEW_QUANTA_U32);
 8011f0a:	f3ef 8311 	mrs	r3, BASEPRI
 8011f0e:	f04f 0120 	mov.w	r1, #32
 8011f12:	f381 8811 	msr	BASEPRI, r1
 8011f16:	60fb      	str	r3, [r7, #12]
 8011f18:	4816      	ldr	r0, [pc, #88]	; (8011f74 <SEGGER_SYSVIEW_SendNumModules+0x70>)
 8011f1a:	f7fe ff7f 	bl	8010e1c <_PreparePacket>
 8011f1e:	60b8      	str	r0, [r7, #8]
  pPayload = pPayloadStart;
 8011f20:	68bb      	ldr	r3, [r7, #8]
 8011f22:	607b      	str	r3, [r7, #4]
  ENCODE_U32(pPayload, _NumModules);
 8011f24:	687b      	ldr	r3, [r7, #4]
 8011f26:	617b      	str	r3, [r7, #20]
 8011f28:	4b13      	ldr	r3, [pc, #76]	; (8011f78 <SEGGER_SYSVIEW_SendNumModules+0x74>)
 8011f2a:	781b      	ldrb	r3, [r3, #0]
 8011f2c:	613b      	str	r3, [r7, #16]
 8011f2e:	e00b      	b.n	8011f48 <SEGGER_SYSVIEW_SendNumModules+0x44>
 8011f30:	697b      	ldr	r3, [r7, #20]
 8011f32:	1c5a      	adds	r2, r3, #1
 8011f34:	617a      	str	r2, [r7, #20]
 8011f36:	693a      	ldr	r2, [r7, #16]
 8011f38:	b2d2      	uxtb	r2, r2
 8011f3a:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011f3e:	b2d2      	uxtb	r2, r2
 8011f40:	701a      	strb	r2, [r3, #0]
 8011f42:	693b      	ldr	r3, [r7, #16]
 8011f44:	09db      	lsrs	r3, r3, #7
 8011f46:	613b      	str	r3, [r7, #16]
 8011f48:	693b      	ldr	r3, [r7, #16]
 8011f4a:	2b7f      	cmp	r3, #127	; 0x7f
 8011f4c:	d8f0      	bhi.n	8011f30 <SEGGER_SYSVIEW_SendNumModules+0x2c>
 8011f4e:	697b      	ldr	r3, [r7, #20]
 8011f50:	1c5a      	adds	r2, r3, #1
 8011f52:	617a      	str	r2, [r7, #20]
 8011f54:	693a      	ldr	r2, [r7, #16]
 8011f56:	b2d2      	uxtb	r2, r2
 8011f58:	701a      	strb	r2, [r3, #0]
 8011f5a:	697b      	ldr	r3, [r7, #20]
 8011f5c:	607b      	str	r3, [r7, #4]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_NUMMODULES);
 8011f5e:	68b8      	ldr	r0, [r7, #8]
 8011f60:	6879      	ldr	r1, [r7, #4]
 8011f62:	221b      	movs	r2, #27
 8011f64:	f7ff f82e 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8011f68:	68fb      	ldr	r3, [r7, #12]
 8011f6a:	f383 8811 	msr	BASEPRI, r3
}
 8011f6e:	3718      	adds	r7, #24
 8011f70:	46bd      	mov	sp, r7
 8011f72:	bd80      	pop	{r7, pc}
 8011f74:	2000cd44 	.word	0x2000cd44
 8011f78:	2000cd40 	.word	0x2000cd40

08011f7c <SEGGER_SYSVIEW_Warn>:
*    Print a warning string to the host.
*
*  Parameters
*    s        - String to sent.
*/
void SEGGER_SYSVIEW_Warn(const char* s) {
 8011f7c:	b580      	push	{r7, lr}
 8011f7e:	b08a      	sub	sp, #40	; 0x28
 8011f80:	af00      	add	r7, sp, #0
 8011f82:	6078      	str	r0, [r7, #4]
  U8* pPayload;
  U8* pPayloadStart;
  RECORD_START(SEGGER_SYSVIEW_INFO_SIZE + 2 * SEGGER_SYSVIEW_QUANTA_U32 + SEGGER_SYSVIEW_MAX_STRING_LEN);
 8011f84:	f3ef 8311 	mrs	r3, BASEPRI
 8011f88:	f04f 0120 	mov.w	r1, #32
 8011f8c:	f381 8811 	msr	BASEPRI, r1
 8011f90:	617b      	str	r3, [r7, #20]
 8011f92:	4826      	ldr	r0, [pc, #152]	; (801202c <SEGGER_SYSVIEW_Warn+0xb0>)
 8011f94:	f7fe ff42 	bl	8010e1c <_PreparePacket>
 8011f98:	6138      	str	r0, [r7, #16]
  //
  pPayload = _EncodeStr(pPayloadStart, s, SEGGER_SYSVIEW_MAX_STRING_LEN);
 8011f9a:	6938      	ldr	r0, [r7, #16]
 8011f9c:	6879      	ldr	r1, [r7, #4]
 8011f9e:	2280      	movs	r2, #128	; 0x80
 8011fa0:	f7fe feee 	bl	8010d80 <_EncodeStr>
 8011fa4:	60f8      	str	r0, [r7, #12]
  ENCODE_U32(pPayload, SEGGER_SYSVIEW_WARNING);
 8011fa6:	68fb      	ldr	r3, [r7, #12]
 8011fa8:	627b      	str	r3, [r7, #36]	; 0x24
 8011faa:	2301      	movs	r3, #1
 8011fac:	623b      	str	r3, [r7, #32]
 8011fae:	e00b      	b.n	8011fc8 <SEGGER_SYSVIEW_Warn+0x4c>
 8011fb0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011fb2:	1c5a      	adds	r2, r3, #1
 8011fb4:	627a      	str	r2, [r7, #36]	; 0x24
 8011fb6:	6a3a      	ldr	r2, [r7, #32]
 8011fb8:	b2d2      	uxtb	r2, r2
 8011fba:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011fbe:	b2d2      	uxtb	r2, r2
 8011fc0:	701a      	strb	r2, [r3, #0]
 8011fc2:	6a3b      	ldr	r3, [r7, #32]
 8011fc4:	09db      	lsrs	r3, r3, #7
 8011fc6:	623b      	str	r3, [r7, #32]
 8011fc8:	6a3b      	ldr	r3, [r7, #32]
 8011fca:	2b7f      	cmp	r3, #127	; 0x7f
 8011fcc:	d8f0      	bhi.n	8011fb0 <SEGGER_SYSVIEW_Warn+0x34>
 8011fce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011fd0:	1c5a      	adds	r2, r3, #1
 8011fd2:	627a      	str	r2, [r7, #36]	; 0x24
 8011fd4:	6a3a      	ldr	r2, [r7, #32]
 8011fd6:	b2d2      	uxtb	r2, r2
 8011fd8:	701a      	strb	r2, [r3, #0]
 8011fda:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8011fdc:	60fb      	str	r3, [r7, #12]
  ENCODE_U32(pPayload, 0);
 8011fde:	68fb      	ldr	r3, [r7, #12]
 8011fe0:	61fb      	str	r3, [r7, #28]
 8011fe2:	2300      	movs	r3, #0
 8011fe4:	61bb      	str	r3, [r7, #24]
 8011fe6:	e00b      	b.n	8012000 <SEGGER_SYSVIEW_Warn+0x84>
 8011fe8:	69fb      	ldr	r3, [r7, #28]
 8011fea:	1c5a      	adds	r2, r3, #1
 8011fec:	61fa      	str	r2, [r7, #28]
 8011fee:	69ba      	ldr	r2, [r7, #24]
 8011ff0:	b2d2      	uxtb	r2, r2
 8011ff2:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8011ff6:	b2d2      	uxtb	r2, r2
 8011ff8:	701a      	strb	r2, [r3, #0]
 8011ffa:	69bb      	ldr	r3, [r7, #24]
 8011ffc:	09db      	lsrs	r3, r3, #7
 8011ffe:	61bb      	str	r3, [r7, #24]
 8012000:	69bb      	ldr	r3, [r7, #24]
 8012002:	2b7f      	cmp	r3, #127	; 0x7f
 8012004:	d8f0      	bhi.n	8011fe8 <SEGGER_SYSVIEW_Warn+0x6c>
 8012006:	69fb      	ldr	r3, [r7, #28]
 8012008:	1c5a      	adds	r2, r3, #1
 801200a:	61fa      	str	r2, [r7, #28]
 801200c:	69ba      	ldr	r2, [r7, #24]
 801200e:	b2d2      	uxtb	r2, r2
 8012010:	701a      	strb	r2, [r3, #0]
 8012012:	69fb      	ldr	r3, [r7, #28]
 8012014:	60fb      	str	r3, [r7, #12]
  _SendPacket(pPayloadStart, pPayload, SYSVIEW_EVTID_PRINT_FORMATTED);
 8012016:	6938      	ldr	r0, [r7, #16]
 8012018:	68f9      	ldr	r1, [r7, #12]
 801201a:	221a      	movs	r2, #26
 801201c:	f7fe ffd2 	bl	8010fc4 <_SendPacket>
  RECORD_END();
 8012020:	697b      	ldr	r3, [r7, #20]
 8012022:	f383 8811 	msr	BASEPRI, r3
}
 8012026:	3728      	adds	r7, #40	; 0x28
 8012028:	46bd      	mov	sp, r7
 801202a:	bd80      	pop	{r7, pc}
 801202c:	2000cd44 	.word	0x2000cd44

08012030 <_cbSendTaskList>:
*  Function description
*    This function is part of the link between FreeRTOS and SYSVIEW.
*    Called from SystemView when asked by the host, it uses SYSVIEW
*    functions to send the entire task list to the host.
*/
static void _cbSendTaskList(void) {
 8012030:	b5f0      	push	{r4, r5, r6, r7, lr}
 8012032:	b085      	sub	sp, #20
 8012034:	af02      	add	r7, sp, #8
  unsigned n;

  for (n = 0; n < _NumTasks; n++) {
 8012036:	2300      	movs	r3, #0
 8012038:	607b      	str	r3, [r7, #4]
 801203a:	e033      	b.n	80120a4 <_cbSendTaskList+0x74>
#if INCLUDE_uxTaskGetStackHighWaterMark // Report Task Stack High Watermark
    _aTasks[n].uStackHighWaterMark = uxTaskGetStackHighWaterMark((TaskHandle_t)_aTasks[n].xHandle);
#endif
    SYSVIEW_SendTaskInfo((U32)_aTasks[n].xHandle, _aTasks[n].pcTaskName, (unsigned)_aTasks[n].uxCurrentPriority, (U32)_aTasks[n].pxStack, (unsigned)_aTasks[n].uStackHighWaterMark);
 801203c:	491d      	ldr	r1, [pc, #116]	; (80120b4 <_cbSendTaskList+0x84>)
 801203e:	687a      	ldr	r2, [r7, #4]
 8012040:	4613      	mov	r3, r2
 8012042:	009b      	lsls	r3, r3, #2
 8012044:	4413      	add	r3, r2
 8012046:	009b      	lsls	r3, r3, #2
 8012048:	440b      	add	r3, r1
 801204a:	6818      	ldr	r0, [r3, #0]
 801204c:	4919      	ldr	r1, [pc, #100]	; (80120b4 <_cbSendTaskList+0x84>)
 801204e:	687a      	ldr	r2, [r7, #4]
 8012050:	4613      	mov	r3, r2
 8012052:	009b      	lsls	r3, r3, #2
 8012054:	4413      	add	r3, r2
 8012056:	009b      	lsls	r3, r3, #2
 8012058:	440b      	add	r3, r1
 801205a:	685e      	ldr	r6, [r3, #4]
 801205c:	4915      	ldr	r1, [pc, #84]	; (80120b4 <_cbSendTaskList+0x84>)
 801205e:	687a      	ldr	r2, [r7, #4]
 8012060:	4613      	mov	r3, r2
 8012062:	009b      	lsls	r3, r3, #2
 8012064:	4413      	add	r3, r2
 8012066:	009b      	lsls	r3, r3, #2
 8012068:	440b      	add	r3, r1
 801206a:	3308      	adds	r3, #8
 801206c:	681d      	ldr	r5, [r3, #0]
 801206e:	4911      	ldr	r1, [pc, #68]	; (80120b4 <_cbSendTaskList+0x84>)
 8012070:	687a      	ldr	r2, [r7, #4]
 8012072:	4613      	mov	r3, r2
 8012074:	009b      	lsls	r3, r3, #2
 8012076:	4413      	add	r3, r2
 8012078:	009b      	lsls	r3, r3, #2
 801207a:	440b      	add	r3, r1
 801207c:	3308      	adds	r3, #8
 801207e:	685c      	ldr	r4, [r3, #4]
 8012080:	490c      	ldr	r1, [pc, #48]	; (80120b4 <_cbSendTaskList+0x84>)
 8012082:	687a      	ldr	r2, [r7, #4]
 8012084:	4613      	mov	r3, r2
 8012086:	009b      	lsls	r3, r3, #2
 8012088:	4413      	add	r3, r2
 801208a:	009b      	lsls	r3, r3, #2
 801208c:	440b      	add	r3, r1
 801208e:	3310      	adds	r3, #16
 8012090:	681b      	ldr	r3, [r3, #0]
 8012092:	9300      	str	r3, [sp, #0]
 8012094:	4631      	mov	r1, r6
 8012096:	462a      	mov	r2, r5
 8012098:	4623      	mov	r3, r4
 801209a:	f000 f8a9 	bl	80121f0 <SYSVIEW_SendTaskInfo>
*    functions to send the entire task list to the host.
*/
static void _cbSendTaskList(void) {
  unsigned n;

  for (n = 0; n < _NumTasks; n++) {
 801209e:	687b      	ldr	r3, [r7, #4]
 80120a0:	3301      	adds	r3, #1
 80120a2:	607b      	str	r3, [r7, #4]
 80120a4:	4b04      	ldr	r3, [pc, #16]	; (80120b8 <_cbSendTaskList+0x88>)
 80120a6:	681b      	ldr	r3, [r3, #0]
 80120a8:	687a      	ldr	r2, [r7, #4]
 80120aa:	429a      	cmp	r2, r3
 80120ac:	d3c6      	bcc.n	801203c <_cbSendTaskList+0xc>
#if INCLUDE_uxTaskGetStackHighWaterMark // Report Task Stack High Watermark
    _aTasks[n].uStackHighWaterMark = uxTaskGetStackHighWaterMark((TaskHandle_t)_aTasks[n].xHandle);
#endif
    SYSVIEW_SendTaskInfo((U32)_aTasks[n].xHandle, _aTasks[n].pcTaskName, (unsigned)_aTasks[n].uxCurrentPriority, (U32)_aTasks[n].pxStack, (unsigned)_aTasks[n].uStackHighWaterMark);
  }
}
 80120ae:	370c      	adds	r7, #12
 80120b0:	46bd      	mov	sp, r7
 80120b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80120b4:	2000ce28 	.word	0x2000ce28
 80120b8:	2000cec8 	.word	0x2000cec8

080120bc <_cbGetTime>:
*  Function description
*    This function is part of the link between FreeRTOS and SYSVIEW.
*    Called from SystemView when asked by the host, returns the
*    current system time in micro seconds.
*/
static U64 _cbGetTime(void) {
 80120bc:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 80120c0:	b082      	sub	sp, #8
 80120c2:	af00      	add	r7, sp, #0
  U64 Time;

  Time = xTaskGetTickCountFromISR();
 80120c4:	f7f3 fa6e 	bl	80055a4 <xTaskGetTickCountFromISR>
 80120c8:	4603      	mov	r3, r0
 80120ca:	461a      	mov	r2, r3
 80120cc:	f04f 0300 	mov.w	r3, #0
 80120d0:	e9c7 2300 	strd	r2, r3, [r7]
  Time *= portTICK_PERIOD_MS;
  Time *= 1000;
 80120d4:	e9d7 0100 	ldrd	r0, r1, [r7]
 80120d8:	4602      	mov	r2, r0
 80120da:	460b      	mov	r3, r1
 80120dc:	ea4f 0b83 	mov.w	fp, r3, lsl #2
 80120e0:	ea4b 7b92 	orr.w	fp, fp, r2, lsr #30
 80120e4:	ea4f 0a82 	mov.w	sl, r2, lsl #2
 80120e8:	4652      	mov	r2, sl
 80120ea:	465b      	mov	r3, fp
 80120ec:	015d      	lsls	r5, r3, #5
 80120ee:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
 80120f2:	0154      	lsls	r4, r2, #5
 80120f4:	1aa4      	subs	r4, r4, r2
 80120f6:	eb65 0503 	sbc.w	r5, r5, r3
 80120fa:	1824      	adds	r4, r4, r0
 80120fc:	eb45 0501 	adc.w	r5, r5, r1
 8012100:	ea4f 09c5 	mov.w	r9, r5, lsl #3
 8012104:	ea49 7954 	orr.w	r9, r9, r4, lsr #29
 8012108:	ea4f 08c4 	mov.w	r8, r4, lsl #3
 801210c:	4644      	mov	r4, r8
 801210e:	464d      	mov	r5, r9
 8012110:	e9c7 4500 	strd	r4, r5, [r7]
  return Time;
 8012114:	e9d7 2300 	ldrd	r2, r3, [r7]
}
 8012118:	4610      	mov	r0, r2
 801211a:	4619      	mov	r1, r3
 801211c:	3708      	adds	r7, #8
 801211e:	46bd      	mov	sp, r7
 8012120:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}

08012124 <SYSVIEW_AddTask>:
*       SYSVIEW_AddTask()
*
*  Function description
*    Add a task to the internal list and record its information.
*/
void SYSVIEW_AddTask(U32 xHandle, const char* pcTaskName, unsigned uxCurrentPriority, U32  pxStack, unsigned uStackHighWaterMark) {
 8012124:	b580      	push	{r7, lr}
 8012126:	b086      	sub	sp, #24
 8012128:	af02      	add	r7, sp, #8
 801212a:	60f8      	str	r0, [r7, #12]
 801212c:	60b9      	str	r1, [r7, #8]
 801212e:	607a      	str	r2, [r7, #4]
 8012130:	603b      	str	r3, [r7, #0]
  
  if (memcmp(pcTaskName, "IDLE", 5) == 0) {
 8012132:	68b8      	ldr	r0, [r7, #8]
 8012134:	492a      	ldr	r1, [pc, #168]	; (80121e0 <SYSVIEW_AddTask+0xbc>)
 8012136:	2205      	movs	r2, #5
 8012138:	f000 f8f4 	bl	8012324 <memcmp>
 801213c:	4603      	mov	r3, r0
 801213e:	2b00      	cmp	r3, #0
 8012140:	d100      	bne.n	8012144 <SYSVIEW_AddTask+0x20>
    return;
 8012142:	e049      	b.n	80121d8 <SYSVIEW_AddTask+0xb4>
  }
  
  if (_NumTasks >= SYSVIEW_FREERTOS_MAX_NOF_TASKS) {
 8012144:	4b27      	ldr	r3, [pc, #156]	; (80121e4 <SYSVIEW_AddTask+0xc0>)
 8012146:	681b      	ldr	r3, [r3, #0]
 8012148:	2b07      	cmp	r3, #7
 801214a:	d903      	bls.n	8012154 <SYSVIEW_AddTask+0x30>
    SEGGER_SYSVIEW_Warn("SYSTEMVIEW: Could not record task information. Maximum number of tasks reached.");
 801214c:	4826      	ldr	r0, [pc, #152]	; (80121e8 <SYSVIEW_AddTask+0xc4>)
 801214e:	f7ff ff15 	bl	8011f7c <SEGGER_SYSVIEW_Warn>
    return;
 8012152:	e041      	b.n	80121d8 <SYSVIEW_AddTask+0xb4>
  }

  _aTasks[_NumTasks].xHandle = xHandle;
 8012154:	4b23      	ldr	r3, [pc, #140]	; (80121e4 <SYSVIEW_AddTask+0xc0>)
 8012156:	681a      	ldr	r2, [r3, #0]
 8012158:	4924      	ldr	r1, [pc, #144]	; (80121ec <SYSVIEW_AddTask+0xc8>)
 801215a:	4613      	mov	r3, r2
 801215c:	009b      	lsls	r3, r3, #2
 801215e:	4413      	add	r3, r2
 8012160:	009b      	lsls	r3, r3, #2
 8012162:	440b      	add	r3, r1
 8012164:	68fa      	ldr	r2, [r7, #12]
 8012166:	601a      	str	r2, [r3, #0]
  _aTasks[_NumTasks].pcTaskName = pcTaskName;
 8012168:	4b1e      	ldr	r3, [pc, #120]	; (80121e4 <SYSVIEW_AddTask+0xc0>)
 801216a:	681a      	ldr	r2, [r3, #0]
 801216c:	491f      	ldr	r1, [pc, #124]	; (80121ec <SYSVIEW_AddTask+0xc8>)
 801216e:	4613      	mov	r3, r2
 8012170:	009b      	lsls	r3, r3, #2
 8012172:	4413      	add	r3, r2
 8012174:	009b      	lsls	r3, r3, #2
 8012176:	440b      	add	r3, r1
 8012178:	68ba      	ldr	r2, [r7, #8]
 801217a:	605a      	str	r2, [r3, #4]
  _aTasks[_NumTasks].uxCurrentPriority = uxCurrentPriority;
 801217c:	4b19      	ldr	r3, [pc, #100]	; (80121e4 <SYSVIEW_AddTask+0xc0>)
 801217e:	681a      	ldr	r2, [r3, #0]
 8012180:	491a      	ldr	r1, [pc, #104]	; (80121ec <SYSVIEW_AddTask+0xc8>)
 8012182:	4613      	mov	r3, r2
 8012184:	009b      	lsls	r3, r3, #2
 8012186:	4413      	add	r3, r2
 8012188:	009b      	lsls	r3, r3, #2
 801218a:	440b      	add	r3, r1
 801218c:	3308      	adds	r3, #8
 801218e:	687a      	ldr	r2, [r7, #4]
 8012190:	601a      	str	r2, [r3, #0]
  _aTasks[_NumTasks].pxStack = pxStack;
 8012192:	4b14      	ldr	r3, [pc, #80]	; (80121e4 <SYSVIEW_AddTask+0xc0>)
 8012194:	681a      	ldr	r2, [r3, #0]
 8012196:	4915      	ldr	r1, [pc, #84]	; (80121ec <SYSVIEW_AddTask+0xc8>)
 8012198:	4613      	mov	r3, r2
 801219a:	009b      	lsls	r3, r3, #2
 801219c:	4413      	add	r3, r2
 801219e:	009b      	lsls	r3, r3, #2
 80121a0:	440b      	add	r3, r1
 80121a2:	3308      	adds	r3, #8
 80121a4:	683a      	ldr	r2, [r7, #0]
 80121a6:	605a      	str	r2, [r3, #4]
  _aTasks[_NumTasks].uStackHighWaterMark = uStackHighWaterMark;
 80121a8:	4b0e      	ldr	r3, [pc, #56]	; (80121e4 <SYSVIEW_AddTask+0xc0>)
 80121aa:	681a      	ldr	r2, [r3, #0]
 80121ac:	490f      	ldr	r1, [pc, #60]	; (80121ec <SYSVIEW_AddTask+0xc8>)
 80121ae:	4613      	mov	r3, r2
 80121b0:	009b      	lsls	r3, r3, #2
 80121b2:	4413      	add	r3, r2
 80121b4:	009b      	lsls	r3, r3, #2
 80121b6:	440b      	add	r3, r1
 80121b8:	3310      	adds	r3, #16
 80121ba:	69ba      	ldr	r2, [r7, #24]
 80121bc:	601a      	str	r2, [r3, #0]

  _NumTasks++;
 80121be:	4b09      	ldr	r3, [pc, #36]	; (80121e4 <SYSVIEW_AddTask+0xc0>)
 80121c0:	681b      	ldr	r3, [r3, #0]
 80121c2:	3301      	adds	r3, #1
 80121c4:	4a07      	ldr	r2, [pc, #28]	; (80121e4 <SYSVIEW_AddTask+0xc0>)
 80121c6:	6013      	str	r3, [r2, #0]

  SYSVIEW_SendTaskInfo(xHandle, pcTaskName,uxCurrentPriority, pxStack, uStackHighWaterMark);
 80121c8:	69bb      	ldr	r3, [r7, #24]
 80121ca:	9300      	str	r3, [sp, #0]
 80121cc:	68f8      	ldr	r0, [r7, #12]
 80121ce:	68b9      	ldr	r1, [r7, #8]
 80121d0:	687a      	ldr	r2, [r7, #4]
 80121d2:	683b      	ldr	r3, [r7, #0]
 80121d4:	f000 f80c 	bl	80121f0 <SYSVIEW_SendTaskInfo>

}
 80121d8:	3710      	adds	r7, #16
 80121da:	46bd      	mov	sp, r7
 80121dc:	bd80      	pop	{r7, pc}
 80121de:	bf00      	nop
 80121e0:	080129a8 	.word	0x080129a8
 80121e4:	2000cec8 	.word	0x2000cec8
 80121e8:	080129b0 	.word	0x080129b0
 80121ec:	2000ce28 	.word	0x2000ce28

080121f0 <SYSVIEW_SendTaskInfo>:
*       SYSVIEW_SendTaskInfo()
*
*  Function description
*    Record task information.
*/
void SYSVIEW_SendTaskInfo(U32 TaskID, const char* sName, unsigned Prio, U32 StackBase, unsigned StackSize) {
 80121f0:	b580      	push	{r7, lr}
 80121f2:	b08a      	sub	sp, #40	; 0x28
 80121f4:	af00      	add	r7, sp, #0
 80121f6:	60f8      	str	r0, [r7, #12]
 80121f8:	60b9      	str	r1, [r7, #8]
 80121fa:	607a      	str	r2, [r7, #4]
 80121fc:	603b      	str	r3, [r7, #0]
  SEGGER_SYSVIEW_TASKINFO TaskInfo;

  memset(&TaskInfo, 0, sizeof(TaskInfo)); // Fill all elements with 0 to allow extending the structure in future version without breaking the code
 80121fe:	f107 0314 	add.w	r3, r7, #20
 8012202:	4618      	mov	r0, r3
 8012204:	2100      	movs	r1, #0
 8012206:	2214      	movs	r2, #20
 8012208:	f7fe f84e 	bl	80102a8 <memset>
  TaskInfo.TaskID     = TaskID;
 801220c:	68fb      	ldr	r3, [r7, #12]
 801220e:	617b      	str	r3, [r7, #20]
  TaskInfo.sName      = sName;
 8012210:	68bb      	ldr	r3, [r7, #8]
 8012212:	61bb      	str	r3, [r7, #24]
  TaskInfo.Prio       = Prio;
 8012214:	687b      	ldr	r3, [r7, #4]
 8012216:	61fb      	str	r3, [r7, #28]
  TaskInfo.StackBase  = StackBase;
 8012218:	683b      	ldr	r3, [r7, #0]
 801221a:	623b      	str	r3, [r7, #32]
  TaskInfo.StackSize  = StackSize;
 801221c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 801221e:	627b      	str	r3, [r7, #36]	; 0x24
  SEGGER_SYSVIEW_SendTaskInfo(&TaskInfo);
 8012220:	f107 0314 	add.w	r3, r7, #20
 8012224:	4618      	mov	r0, r3
 8012226:	f7ff fa81 	bl	801172c <SEGGER_SYSVIEW_SendTaskInfo>
}
 801222a:	3728      	adds	r7, #40	; 0x28
 801222c:	46bd      	mov	sp, r7
 801222e:	bd80      	pop	{r7, pc}

08012230 <SYSVIEW_RecordU32x4>:
*       SYSVIEW_RecordU32x4()
*
*  Function description
*    Record an event with 4 parameters
*/
void SYSVIEW_RecordU32x4(unsigned Id, U32 Para0, U32 Para1, U32 Para2, U32 Para3) {
 8012230:	b580      	push	{r7, lr}
 8012232:	b08e      	sub	sp, #56	; 0x38
 8012234:	af00      	add	r7, sp, #0
 8012236:	60f8      	str	r0, [r7, #12]
 8012238:	60b9      	str	r1, [r7, #8]
 801223a:	607a      	str	r2, [r7, #4]
 801223c:	603b      	str	r3, [r7, #0]
      U8  aPacket[SEGGER_SYSVIEW_INFO_SIZE + 4 * SEGGER_SYSVIEW_QUANTA_U32];
      U8* pPayload;
      //
      pPayload = SEGGER_SYSVIEW_PREPARE_PACKET(aPacket);                // Prepare the packet for SystemView
 801223e:	f107 0314 	add.w	r3, r7, #20
 8012242:	3304      	adds	r3, #4
 8012244:	637b      	str	r3, [r7, #52]	; 0x34
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para0);             // Add the first parameter to the packet
 8012246:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8012248:	68b9      	ldr	r1, [r7, #8]
 801224a:	f7ff fd87 	bl	8011d5c <SEGGER_SYSVIEW_EncodeU32>
 801224e:	6378      	str	r0, [r7, #52]	; 0x34
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para1);             // Add the second parameter to the packet
 8012250:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8012252:	6879      	ldr	r1, [r7, #4]
 8012254:	f7ff fd82 	bl	8011d5c <SEGGER_SYSVIEW_EncodeU32>
 8012258:	6378      	str	r0, [r7, #52]	; 0x34
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para2);             // Add the third parameter to the packet
 801225a:	6b78      	ldr	r0, [r7, #52]	; 0x34
 801225c:	6839      	ldr	r1, [r7, #0]
 801225e:	f7ff fd7d 	bl	8011d5c <SEGGER_SYSVIEW_EncodeU32>
 8012262:	6378      	str	r0, [r7, #52]	; 0x34
      pPayload = SEGGER_SYSVIEW_EncodeU32(pPayload, Para3);             // Add the fourth parameter to the packet
 8012264:	6b78      	ldr	r0, [r7, #52]	; 0x34
 8012266:	6c39      	ldr	r1, [r7, #64]	; 0x40
 8012268:	f7ff fd78 	bl	8011d5c <SEGGER_SYSVIEW_EncodeU32>
 801226c:	6378      	str	r0, [r7, #52]	; 0x34
      //
      SEGGER_SYSVIEW_SendPacket(&aPacket[0], pPayload, Id);             // Send the packet
 801226e:	f107 0314 	add.w	r3, r7, #20
 8012272:	4618      	mov	r0, r3
 8012274:	6b79      	ldr	r1, [r7, #52]	; 0x34
 8012276:	68fa      	ldr	r2, [r7, #12]
 8012278:	f7ff fd54 	bl	8011d24 <SEGGER_SYSVIEW_SendPacket>
}
 801227c:	3738      	adds	r7, #56	; 0x38
 801227e:	46bd      	mov	sp, r7
 8012280:	bd80      	pop	{r7, pc}
 8012282:	bf00      	nop

08012284 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 8012284:	f8df d034 	ldr.w	sp, [pc, #52]	; 80122bc <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 8012288:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 801228a:	e003      	b.n	8012294 <LoopCopyDataInit>

0801228c <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 801228c:	4b0c      	ldr	r3, [pc, #48]	; (80122c0 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 801228e:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 8012290:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 8012292:	3104      	adds	r1, #4

08012294 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 8012294:	480b      	ldr	r0, [pc, #44]	; (80122c4 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 8012296:	4b0c      	ldr	r3, [pc, #48]	; (80122c8 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8012298:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 801229a:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 801229c:	d3f6      	bcc.n	801228c <CopyDataInit>
  ldr  r2, =_sbss
 801229e:	4a0b      	ldr	r2, [pc, #44]	; (80122cc <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80122a0:	e002      	b.n	80122a8 <LoopFillZerobss>

080122a2 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80122a2:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80122a4:	f842 3b04 	str.w	r3, [r2], #4

080122a8 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80122a8:	4b09      	ldr	r3, [pc, #36]	; (80122d0 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 80122aa:	429a      	cmp	r2, r3
  bcc  FillZerobss
 80122ac:	d3f9      	bcc.n	80122a2 <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 80122ae:	f7fe fa7f 	bl	80107b0 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80122b2:	f000 f811 	bl	80122d8 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 80122b6:	f7fc ff6d 	bl	800f194 <main>
  bx  lr    
 80122ba:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 80122bc:	20080000 	.word	0x20080000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 80122c0:	08012ba4 	.word	0x08012ba4
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80122c4:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 80122c8:	2000bb70 	.word	0x2000bb70
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 80122cc:	2000bb70 	.word	0x2000bb70
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80122d0:	2000d0b0 	.word	0x2000d0b0

080122d4 <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 80122d4:	e7fe      	b.n	80122d4 <ADC_IRQHandler>
	...

080122d8 <__libc_init_array>:
 80122d8:	b570      	push	{r4, r5, r6, lr}
 80122da:	4b0e      	ldr	r3, [pc, #56]	; (8012314 <__libc_init_array+0x3c>)
 80122dc:	2500      	movs	r5, #0
 80122de:	4c0e      	ldr	r4, [pc, #56]	; (8012318 <__libc_init_array+0x40>)
 80122e0:	461e      	mov	r6, r3
 80122e2:	1ae4      	subs	r4, r4, r3
 80122e4:	10a4      	asrs	r4, r4, #2
 80122e6:	42a5      	cmp	r5, r4
 80122e8:	d004      	beq.n	80122f4 <__libc_init_array+0x1c>
 80122ea:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80122ee:	3501      	adds	r5, #1
 80122f0:	4798      	blx	r3
 80122f2:	e7f8      	b.n	80122e6 <__libc_init_array+0xe>
 80122f4:	f000 f89c 	bl	8012430 <_init>
 80122f8:	4c08      	ldr	r4, [pc, #32]	; (801231c <__libc_init_array+0x44>)
 80122fa:	4b09      	ldr	r3, [pc, #36]	; (8012320 <__libc_init_array+0x48>)
 80122fc:	2500      	movs	r5, #0
 80122fe:	1ae4      	subs	r4, r4, r3
 8012300:	461e      	mov	r6, r3
 8012302:	10a4      	asrs	r4, r4, #2
 8012304:	42a5      	cmp	r5, r4
 8012306:	d004      	beq.n	8012312 <__libc_init_array+0x3a>
 8012308:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 801230c:	3501      	adds	r5, #1
 801230e:	4798      	blx	r3
 8012310:	e7f8      	b.n	8012304 <__libc_init_array+0x2c>
 8012312:	bd70      	pop	{r4, r5, r6, pc}
 8012314:	08012b9c 	.word	0x08012b9c
 8012318:	08012b9c 	.word	0x08012b9c
 801231c:	08012ba0 	.word	0x08012ba0
 8012320:	08012b9c 	.word	0x08012b9c

08012324 <memcmp>:
 8012324:	b510      	push	{r4, lr}
 8012326:	440a      	add	r2, r1
 8012328:	1e44      	subs	r4, r0, #1
 801232a:	4291      	cmp	r1, r2
 801232c:	d008      	beq.n	8012340 <memcmp+0x1c>
 801232e:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 8012332:	7808      	ldrb	r0, [r1, #0]
 8012334:	4283      	cmp	r3, r0
 8012336:	d001      	beq.n	801233c <memcmp+0x18>
 8012338:	1a18      	subs	r0, r3, r0
 801233a:	bd10      	pop	{r4, pc}
 801233c:	3101      	adds	r1, #1
 801233e:	e7f4      	b.n	801232a <memcmp+0x6>
 8012340:	2000      	movs	r0, #0
 8012342:	bd10      	pop	{r4, pc}

08012344 <memmove>:
 8012344:	4281      	cmp	r1, r0
 8012346:	eb01 0302 	add.w	r3, r1, r2
 801234a:	b510      	push	{r4, lr}
 801234c:	d301      	bcc.n	8012352 <memmove+0xe>
 801234e:	1e42      	subs	r2, r0, #1
 8012350:	e00b      	b.n	801236a <memmove+0x26>
 8012352:	4298      	cmp	r0, r3
 8012354:	d2fb      	bcs.n	801234e <memmove+0xa>
 8012356:	1881      	adds	r1, r0, r2
 8012358:	1ad2      	subs	r2, r2, r3
 801235a:	42d3      	cmn	r3, r2
 801235c:	d004      	beq.n	8012368 <memmove+0x24>
 801235e:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8012362:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8012366:	e7f8      	b.n	801235a <memmove+0x16>
 8012368:	bd10      	pop	{r4, pc}
 801236a:	4299      	cmp	r1, r3
 801236c:	d004      	beq.n	8012378 <memmove+0x34>
 801236e:	f811 4b01 	ldrb.w	r4, [r1], #1
 8012372:	f802 4f01 	strb.w	r4, [r2, #1]!
 8012376:	e7f8      	b.n	801236a <memmove+0x26>
 8012378:	bd10      	pop	{r4, pc}
	...

0801237c <strcasecmp>:
 801237c:	4b0d      	ldr	r3, [pc, #52]	; (80123b4 <strcasecmp+0x38>)
 801237e:	b530      	push	{r4, r5, lr}
 8012380:	681d      	ldr	r5, [r3, #0]
 8012382:	f810 3b01 	ldrb.w	r3, [r0], #1
 8012386:	18ea      	adds	r2, r5, r3
 8012388:	7852      	ldrb	r2, [r2, #1]
 801238a:	f002 0203 	and.w	r2, r2, #3
 801238e:	2a01      	cmp	r2, #1
 8012390:	f811 2b01 	ldrb.w	r2, [r1], #1
 8012394:	eb05 0402 	add.w	r4, r5, r2
 8012398:	bf08      	it	eq
 801239a:	3320      	addeq	r3, #32
 801239c:	7864      	ldrb	r4, [r4, #1]
 801239e:	f004 0403 	and.w	r4, r4, #3
 80123a2:	2c01      	cmp	r4, #1
 80123a4:	bf08      	it	eq
 80123a6:	3220      	addeq	r2, #32
 80123a8:	1a9b      	subs	r3, r3, r2
 80123aa:	d101      	bne.n	80123b0 <strcasecmp+0x34>
 80123ac:	2a00      	cmp	r2, #0
 80123ae:	d1e8      	bne.n	8012382 <strcasecmp+0x6>
 80123b0:	4618      	mov	r0, r3
 80123b2:	bd30      	pop	{r4, r5, pc}
 80123b4:	2000bb6c 	.word	0x2000bb6c

080123b8 <strcpy>:
 80123b8:	4603      	mov	r3, r0
 80123ba:	f811 2b01 	ldrb.w	r2, [r1], #1
 80123be:	f803 2b01 	strb.w	r2, [r3], #1
 80123c2:	2a00      	cmp	r2, #0
 80123c4:	d1f9      	bne.n	80123ba <strcpy+0x2>
 80123c6:	4770      	bx	lr

080123c8 <strlen>:
 80123c8:	4603      	mov	r3, r0
 80123ca:	f813 2b01 	ldrb.w	r2, [r3], #1
 80123ce:	2a00      	cmp	r2, #0
 80123d0:	d1fb      	bne.n	80123ca <strlen+0x2>
 80123d2:	1a18      	subs	r0, r3, r0
 80123d4:	3801      	subs	r0, #1
 80123d6:	4770      	bx	lr

080123d8 <strncmp>:
 80123d8:	b570      	push	{r4, r5, r6, lr}
 80123da:	b1a2      	cbz	r2, 8012406 <strncmp+0x2e>
 80123dc:	1e45      	subs	r5, r0, #1
 80123de:	3901      	subs	r1, #1
 80123e0:	786b      	ldrb	r3, [r5, #1]
 80123e2:	1c6e      	adds	r6, r5, #1
 80123e4:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80123e8:	42a3      	cmp	r3, r4
 80123ea:	d106      	bne.n	80123fa <strncmp+0x22>
 80123ec:	f06f 0401 	mvn.w	r4, #1
 80123f0:	1b64      	subs	r4, r4, r5
 80123f2:	4414      	add	r4, r2
 80123f4:	42e0      	cmn	r0, r4
 80123f6:	d102      	bne.n	80123fe <strncmp+0x26>
 80123f8:	461c      	mov	r4, r3
 80123fa:	1b18      	subs	r0, r3, r4
 80123fc:	bd70      	pop	{r4, r5, r6, pc}
 80123fe:	4635      	mov	r5, r6
 8012400:	2b00      	cmp	r3, #0
 8012402:	d1ed      	bne.n	80123e0 <strncmp+0x8>
 8012404:	e7f8      	b.n	80123f8 <strncmp+0x20>
 8012406:	4610      	mov	r0, r2
 8012408:	bd70      	pop	{r4, r5, r6, pc}

0801240a <strncpy>:
 801240a:	4603      	mov	r3, r0
 801240c:	b510      	push	{r4, lr}
 801240e:	b132      	cbz	r2, 801241e <strncpy+0x14>
 8012410:	f811 4b01 	ldrb.w	r4, [r1], #1
 8012414:	3a01      	subs	r2, #1
 8012416:	f803 4b01 	strb.w	r4, [r3], #1
 801241a:	2c00      	cmp	r4, #0
 801241c:	d1f7      	bne.n	801240e <strncpy+0x4>
 801241e:	441a      	add	r2, r3
 8012420:	4293      	cmp	r3, r2
 8012422:	d003      	beq.n	801242c <strncpy+0x22>
 8012424:	2100      	movs	r1, #0
 8012426:	f803 1b01 	strb.w	r1, [r3], #1
 801242a:	e7f9      	b.n	8012420 <strncpy+0x16>
 801242c:	bd10      	pop	{r4, pc}
	...

08012430 <_init>:
 8012430:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8012432:	bf00      	nop
 8012434:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8012436:	bc08      	pop	{r3}
 8012438:	469e      	mov	lr, r3
 801243a:	4770      	bx	lr

0801243c <_fini>:
 801243c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 801243e:	bf00      	nop
 8012440:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8012442:	bc08      	pop	{r3}
 8012444:	469e      	mov	lr, r3
 8012446:	4770      	bx	lr
